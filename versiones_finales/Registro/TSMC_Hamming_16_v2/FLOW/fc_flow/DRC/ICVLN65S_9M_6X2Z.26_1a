// #!TSMC
//***************************************************************************************
//* ICV DRC COMMAND FILE - ICVLN65S_9M_6X2Z.26_1a 11/19/2021
//* FOR TSMC 65NM/55NM CMOS LOGIC/RF G/GP/LP/LPG/ULP 1P9M PROCESS WITH 6X2Z METAL OPTION (WLCSP sealring support version)
//* DESIGN RULE DOCUMENT:      T-N65-CL-DR-001    VER 2.6_1
//*                            T-N55-CL-DR-006    VER 1.1
//*                            T-N65-CM-DR-012    VER 2.1
//* DRC COMMAND FILE DOCUMENT: T-N65-CL-DR-001-J1 VER 2.6_1a
//***************************************************************************************
//
//****************************************************************************************************************
// TSMC has developed this deck using Synopsys proprietary PXL formats.
// The deck is to be used only in IC Validator tools.
//****************************************************************************************************************
//* Tech File Ver: v2.6_1a


//**************************************
// FOR ICV Density Report (default ON)
//**************************************
//#define ICV_REPORT_DENSITY   // Turn off to disable *.density report generation


//**************************************
//FOR in-design flow (default OFF)
//**************************************
#define SNPSINDESIGN


#ifndef SELECTABLE_VIOLATION_NAMES
	#define SELECTABLE_VIOLATION_NAMES
#endif
#ifndef SELECTABLE_VIOLATION_COMMENTS
	#define SELECTABLE_VIOLATION_COMMENTS
#endif

#include <icv.rh>

#ifdef VERSION_LT
#if VERSION_LT(2021, 6, 2, 3)
#error This PXL runset was generated to run with ICV version 2021.06-SP2-3 and newer.
#endif
#endif


//  OPTION SETUP
//================
/* SWITCH DEFINITION START  */


#define GUIDELINE_RES                     /* Turn on to check OD/PO resistor guidelines */ 
#define DISCONNECT_AFTER_RESISTOR         /* Turn on to break connection after resistor for Latch-Up rule check. */ 
#define DEFINE_PAD_BY_TEXT              /* Turn on to recognize IO PAD by following text for Latch-Up rules  */ 
#define GUIDELINE_LUP                     /* Turn on to check Latch-up prevention guidelines */ 
#define GUIDELINE_ESD                     /* Turn on to check ESD protection guidelines */ 
#define NW_SUGGESTED                      /* Turn on to not only check NW.S.3 and NW.S.4 but also additionally check SUGGESTED.NW.S.3__NW.S.4. If it turns OFF, DRC only checks NW.S.3 and NW.S.4. These rules are Nwell space check for NW1V and NW2V (low and high voltage NWs). */ 
#define DATATYPE_WARNING                  /* Turn on to flag NW/OD/PO/CO warning datatype */ 
#define MIXED_SCHEME                    /* Turn on to allow datatype 0 for M(y,z,r,u)/VIA(y,z,r,u) and datatype 1 for DM(y,z,r,u). Turn off this switch and use datatype 40 for Mz/VIAz and datatype 41 for DMz... We assume customer's layout follows the new scheme.  If the customer has some layout with the old scheme (for instance, using an old library cells) please enable this switch so that we read in datatype 0 as well. */ 
//#define CHECK_LOW_DENSITY                 /* Turn on to check OD/PO/Metal local low density.  */ 
#define FRONT_END                         /* Turn on to check Front-End rules */ 
#define BACK_END                          /* Turn on to check Back-End rules */ 
#define FULL_CHIP                         /* Turn on for chip level design */ 
//#define WLCSP_2_MASK                    /* Turn on for new far-back-end process WLCSP 2-MASK, setup CB2 and Cu_PPI connection without PM1. */ 
//#define GP                              /* Turn on for General-purpose Plus(GP) process */ 
//#define LPG                             /* Turn on for Triple-gate-oxide (LPG) process  */ 
#define LP                              /* Turn on for Low-Power(LP) and Ultra Low-Power(ULP) process */ 
//#define HALF_NODE                       /* Turn on for N55 process */ 
//#define _28K_AP                          /* Turn on for 28K thicknees of AP */ 
//#define WLCSP_SEALRING                    /* Turn on if using WLCSP SEALRING structure */ 
//#define ChipWindowUsed                  /* Turn on to specify chip boundary directly by following variables   */ 
XLB : double = 0.0;                  /* x-coordinate of left-bottom corner for user defined chip window  */ 
YLB : double = 0.0;                  /* y-coordinate of left-bottom corner for user defined chip window  */ 
XRT : double = 1000.0;               /* x-coordinate of right-top corner for user defined chip window   */ 
YRT : double = 1000.0;               /* y-coordinate of right-top corner for user defined chip window */ 
PAD_TEXT : const list of string = { "*" };    /* Pin name of PAD */ 
VDD_TEXT : const list of string = { "[V][dD][dD]*" };    /* Pin name of VDD */ 
VSS_TEXT : const list of string = { "[V][S][S]*" };    /* Pin name of VSS  */ 

//  OPTION SETUP OF DFM RULES
//===============================
#define DFM                             /* Turn on to check DFM rules */ 
//#define DFM_ONLY                        /* Turn on to check DFM rules only */ 
#ifdef HALF_NODE 
   CELLSFOR1NMGRID : const string = "_NULL_CELL_NAME_";    /* Specify Cells for 1nm grid. */ 
#endif
CELLSFORRRULEREQUIRED : const string = "_NULL_CELL_NAME_";    /* include cell in Action-Required rules check  */ 
CELLSFORRRULERECOMMENDED : const string = "_NULL_CELL_NAME_";    /* include cell in Recommendations check */ 
CELLSFORRRULEANALOG : const string = "_NULL_CELL_NAME_";    /* include cell in Analog rules check (default is empty) */ 
CELLSFORRRULEGUIDELINE : const string = "_NULL_CELL_NAME_";    /* include cell in Guidleline check */ 
EXCLCELLSFORRRULEREQUIRED : const string = "*";    /* exclude cell from Action-Required rules check */ 
EXCLCELLSFORRRULERECOMMENDED : const string = "*";    /* exclude cell from Recommendations check */ 
EXCLCELLSFORRRULEANALOG : const string = "*";    /* exclude cell from Analog rules check */ 
EXCLCELLSFORRRULEGUIDELINE : const string = "*";    /* exclude cell from Guidleline check */ 

// select by DFM category
#define Required                          /*  Not checked if DFM is OFF. If turning on DFM, and turn on this switch, then DFM action-Required rules will be checked */ 
#define Recommended                       /* Not checked if DFM is OFF. If turning on DFM, and turn on this switch, then DFM recommendation rules will be checked */ 
#define Analog                            /* Not checked if DFM is OFF. If turning on DFM, and turn on this switch (or setting), then Analog Recommendations will be checkeds(must select by layer RRuleAnalog or cell CELLSFORRRULEANALOG) */ 
#define Guideline                         /* Not checked if DFM is OFF. If turning on DFM, and turn on this switch, then DFM Guideline rules will be checked */ 

// select by DFM Grouping
//#define First_priority                  /* Not checked if DFM is OFF. If turning on DFM, and turn on this switch, then DFM First priority rules will be checked  */ 
//#define Systematic                      /* Not checked if DFM is OFF. If turning on DFM, and turn on this switch, then DFM Systematic rules will be checked */ 
//#define Defect                          /* Not checked if DFM is OFF. If turning on DFM, and turn on this switch, then DFM Defect rules will be checked */ 
//#define d_SPICE                           /* Not checked if DFM is OFF. If turning on DFM, and turn on this switch, then DFM SPICE rules will be checked */

// select by each DFM rule respectively
// Action-required rules    
//#define _POS2_                          /* Systematic(Litho/OPC/Others) and SPICE related  */ 
//#define _POEX2_                         /* Systematic(Others) and SPICE related  */ 
//#define _POS5_                          /* Systematic(Litho/OPC) and SPICE related */ 

// Recommendations    
//#define _OPCR1_                         /* Systematic(Litho/OPC) related  */ 
//#define _DNWEN1_                        /* Systematic(Others) related  */ 
//#define _ODW2_                          /* SPICE related */ 
//#define _NWRODS3_                       /* SPICE related */ 
//#define _NWRODR1_                       /* SPICE related  */ 
//#define _NWRSTIEN2_                     /* SPICE related */ 
//#define _NWRSTIR1_                      /* SPICE related */ 
//#define _ODS1_                          /* Defect related */ 
//#define _ODS6_                          /* Systematic(Others) related  */ 
//#define _POS1_                          /* Defect related */ 
//#define _POS4_1_                        /* SPICE related */ 
//#define _POS11_                         /* Systematic(Litho/OPC) related */ 
//#define _POS13_                         /* Systematic(Litho/OPC) related */ 
//#define _POS14_                         /* Systematic(Others) and SPICE related */ 
//#define _POEN1_                         /* Systematic(Others) and SPICE related */ 
//#define _POEN2_                         /* Systematic(Others) and SPICE related */ 
//#define _POEN3_                         /* Systematic(Others) and SPICE related */ 
//#define _RES2_                          /* SPICE related */ 
//#define _RES8_                          /* SPICE related */ 
//#define _RES9_                          /* SPICE related */ 
//#define _COEN1_                         /* Systematic(Litho/OPC) and SPICE related */ 
//#define _COEN3_                         /* Systematic(Litho/OPC) and SPICE related */ 
//#define _COS3_                          /* 1st priority, Systematic(Others) and Defect related */ 
//#define _M1S1_                          /* Defect related */ 
//#define _M1S7_                          /* Systematic(Others) related */ 
//#define _M1EN1_M1EN2_                   /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
//#define _VIA1EN1_VIA1EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
//#define _M2S1_                          /* Defect related */ 
//#define _M2S7_                          /* Systematic(Others) related */ 
//#define _M2EN1_M2EN2_                   /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
//#define _VIA2EN1_VIA2EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
//#define _M3S1_                          /* Defect related */ 
//#define _M3S7_                          /* Systematic(Others) related */ 
//#define _M3EN1_M3EN2_                   /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
//#define _VIA3EN1_VIA3EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
//#define _M4S1_                          /* Defect related */ 
//#define _M4S7_                          /* Systematic(Others) related */ 
//#define _M4EN1_M4EN2_                   /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
//#define _VIA4EN1_VIA4EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
//#define _M5S1_                          /* Defect related */ 
//#define _M5S7_                          /* Systematic(Others) related */ 
//#define _M5EN1_M5EN2_                   /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
//#define _VIA5EN1_VIA5EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
//#define _M6S1_                          /* Defect related */ 
//#define _M6S7_                          /* Systematic(Others) related */ 
//#define _M6EN1_M6EN2_                   /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
//#define _VIA6EN1_VIA6EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
//#define _M7S1_                          /* Defect related */ 
//#define _M7S7_                          /* Systematic(Others) related */ 
//#define _M7EN1_M7EN2_                   /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
//#define _VIAxR8_                        /* Systematic(CMP) related */ 
//#define _DTCDDN1_                       /* Systematic(Others) related */ 

// Analog Recommendations 
//#define _POS5m_                         /* SPICE related */ 
//#define _POS6m_                         /* SPICE related */ 
//#define _RES5m_                         /* SPICE related    */ 
//#define _BJTR2_                         /* SPICE related */ 
//#define _ANR17_                         /* Electrical Performance related */ 
//#define _ANR20_                         /* Electrical Performance related */ 
//#define _ANR47_                         /* Guidelines related */ 

// Guidelines
//#define _OPCR2_                         /* Systematic(Litho/OPC) related */ 
//#define _NWR1_                          /* Systematic(Other) and SPICE related */ 
//#define _DNWR6_                         /* Systematic(Other) and SPICE related */ 
//#define _NWRODR3_NWRSTIR3_              /* SPICE related */ 
//#define _COS6_                          /* SPICE related   */ 
//#define _COR5_                          /* 1st priority, Defect and SPICE related  */ 
//#define _VIA1R9_                        /* 1st priority, Defect and SPICE related     */ 
//#define _VIA2R9_                        /* 1st priority, Defect and SPICE related     */ 
//#define _VIA3R9_                        /* 1st priority, Defect and SPICE related     */ 
//#define _VIA4R9_                        /* 1st priority, Defect and SPICE related     */ 
//#define _VIA5R9_                        /* 1st priority, Defect and SPICE related     */ 
//#define _VIA6R9_                        /* 1st priority, Defect and SPICE related     */ 
//#define _VIA7R5_                        /* 1st priority, Defect and SPICE related */ 
//#define _VIA8R5_                        /* 1st priority, Defect and SPICE related */ 
//#define AU_WireBond                     /* Turn on when using AU WireBond, turn off when using CU WireBond, and if not using wire-bond, keep the switch off */ 

/* SWITCH DEFINITION END  */

//RULES VALUE VARIABLES
//=======================
METAL_LOW_DEN_WINDOW_SIZE : double = 75; 
METAL_LOW_DEN_WINDOW_STEP : double = 37.5; 
METAL_HIGH_DEN_WINDOW_SIZE : double = 100; 
METAL_HIGH_DEN_WINDOW_STEP : double = 50; 
GRID : double = 0.005; 

/* Needed for conditional variable declarations */
M1_DN_6 : double = 0.0; 
M2_DN_6 : double = 0.0; 
M3_DN_6 : double = 0.0; 
M4_DN_6 : double = 0.0; 
M5_DN_6 : double = 0.0; 
M1_THICKNESS : double = 0.0; 
M2_THICKNESS : double = 0.0; 
V1_THICKNESS : double = 0.0; 
M3_THICKNESS : double = 0.0; 
V2_THICKNESS : double = 0.0; 
M4_THICKNESS : double = 0.0; 
V3_THICKNESS : double = 0.0; 
M5_THICKNESS : double = 0.0; 
V4_THICKNESS : double = 0.0; 
M6_THICKNESS : double = 0.0; 
V5_THICKNESS : double = 0.0; 
M7_THICKNESS : double = 0.0; 
V6_THICKNESS : double = 0.0; 
M8_THICKNESS : double = 0.0; 
V7_THICKNESS : double = 0.0; 
M9_THICKNESS : double = 0.0; 
V8_THICKNESS : double = 0.0; 
AP_THICKNESS : double = 0.0; 
RV_THICKNESS : double = 0.0; 
OFFSETX : double = 0.001; 
DNW_S_1 : double = 3.5; 
DNW_S_2 : double = 2.5; 
DNW_W_1 : double = 3.0; 
DNW_S_3 : double = 1.65; 
DNW_S_4 : double = 1.0; 
DNW_S_5 : double = 1.2; 
DNW_EN_3 : double = 0.56; 
DNW_O_1 : double = 0.4; 
OD_W_1 : double = 0.08; 
OD_W_2 : double = 0.12; 
OD_W_3 : double = 0.40; 
OD_W_4 : double = 0.18; 
OD_S_1 : double = 0.11; 
OD_S_1_R : double = 0.14; 
OD_S_2 : double = 0.18; 
OD_S_3_L : double = 0.2; 
OD_S_3_W : double = 0.15; 
OD_S_3 : double = 0.13; 
OD_S_3_1 : double = 0.125; 
OD_S_4 : double = 0.18; 
OD_S_5 : double = 0.18; 
OD_S_6_R : double = 0.35; 
OD_A_1 : double = 0.054; 
OD_A_2 : double = 0.085; 
OD_L_1 : double = 0.5; 
OD_L_1_W : double = 0.15; 
OD_L_2 : double = 25.0; 
OD_L_2_W : double = 0.15; 
OD_DN_1L : double = 0.25; 
OD_DN_1H : double = 0.75; 
OD_DN_2L : double = 0.2; 
OD_DN_2L_W : double = 150; 
OD_DN_2L_S : double = 75; 
OD_DN_2L_E : double = 37.5; 
OD_DN_2H : double = 0.9; 
OD_DN_2H_CORE : double = 0.8; 
OD_DN_2H_W : double = 150; 
OD_DN_2H_S : double = 75; 
OD_DN_2H_E : double = 37.5; 
OD_DN_3L : double = 0.2; 
OD_DN_3L_W : double = 150; 
OD_DN_3L_S : double = 75; 
OD_DN_3L_E : double = 37.5; 
OD_DN_3H : double = 0.9; 
OD_DN_3H_CORE : double = 0.8; 
OD_DN_3H_W : double = 150; 
OD_DN_3H_S : double = 75; 
OD_DN_3H_E : double = 37.5; 
NW_W_1 : double = 0.47; 
NW_W_2 : double = 1.80; 
NW_S_1 : double = 0.47; 
NW_S_2 : double = 1.00; 
NW_S_3 : double = 1.20; 
NW_S_4 : double = 1.20; 
NW_S_5 : double = 0.16; 
NW_S_6 : double = 0.16; 
NW_S_7 : double = 0.31; 
NW_EN_1 : double = 0.16; 
NW_EN_1_5V : double = 0.17; 
NW_EN_2 : double = 0.16; 
NW_EN_2_5V : double = 0.8; 
NW_EN_3 : double = 0.31; 
NW_A_1 : double = 0.64; 
NW_A_2 : double = 0.64; 
NW_A_3 : double = 1.0; 
NW_A_3_L : double = 0.8; 
NW_A_4 : double = 1.0; 
NW_A_4_L : double = 0.8; 
NWROD_W_1 : double = 1.8; 
NWROD_S_1 : double = 1.2; 
NWROD_S_2 : double = 0.3; 
NWROD_EN_1 : double = 1.0; 
NWROD_EN_2 : double = 0.3; 
NWROD_O_1 : double = 0.4; 
NWRSTI_EN_1 : double = 0.4; 
NWRSTI_EN_2 : double = 0.3; 
NWRSTI_EN_3 : double = 0.3; 
NWRSTI_EX_1 : double = 0.3; 
NT_N_W_1 : double = 0.47; 
NT_N_S_1 : double = 0.47; 
NT_N_S_2 : double = 0.38; 
NT_N_S_3 : double = 1.20; 
NT_N_EX_1 : double = 0.35; 
NT_N_A_1 : double = 0.64; 
NT_N_A_2 : double = 0.64; 
NT_N_A_3 : double = 1.0; 
NT_N_A_3_L : double = 0.8; 
NT_N_A_4 : double = 1.0; 
NT_N_A_4_L : double = 0.8; 
NT_N_W_2 : double = 0.20; 
NT_N_W_2_1 : double = 0.30; 
NT_N_W_2_2 : double = 0.20; 
NT_N_W_2_2_E : double = 1.0; 
NT_N_W_2_2_M : double = 0.5; 
NT_N_W_2_3 : double = 0.2; 
NT_N_W_3 : double = 1.20; 
NT_N_W_4 : double = 0.8; 
NT_N_W_5 : double = 0.5; 
NT_N_EN_1_L : double = 0.26; 
NT_N_EN_1_H : double = 0.285; 
OD2_W_1 : double = 0.47; 
OD2_W_2 : double = 0.47; 
OD2_W_3 : double = 0.47; 
OD2_S_1 : double = 0.47; 
OD2_S_2 : double = 0.27; 
OD2_S_3 : double = 0.34; 
OD2_S_4 : double = 0.47; 
OD2_S_5 : double = 0.47; 
OD2_S_6 : double = 0.47; 
OD2_S_7 : double = 0.47; 
OD2_S_8 : double = 0.47; 
OD2_EN_1 : double = 0.34; 
OD2_EX_1 : double = 0.47; 
OD2_EX_2 : double = 0.47; 
OD2_EX_3 : double = 0.27; 
OD2_O_1 : double = 0.47; 
OD25_33_W_1 : double = 0.5; 
OD25_33_W_2 : double = 0.4; 
OD25_18_W_1 : double = 0.26; 
PO_W_1 : double = 0.06; 
PO_W_2 : double = 0.28; 
PO_W_3 : double = 0.38; 
PO_W_4 : double = 0.20; 
PO_W_5 : double = 0.19; 
PO_W_5_F : double = 0.08; 
PO_S_1 : double = 0.12; 
PO_S_2 : double = 0.13; 
PO_S_2_1 : double = 0.15; 
PO_S_2_1_W : double = 0.09; 
PO_S_3 : double = 0.25; 
PO_S_4 : double = 0.05; 
PO_S_4_1 : double = 0.15; 
PO_S_4_1_A : double = 0.0121; 
PO_S_5 : double = 0.10; 
PO_S_5_W : double = 0.15; 
PO_S_6 : double = 0.10; 
PO_S_6_W : double = 0.15; 
PO_S_7 : double = 0.18; 
PO_S_7_L : double = 0.18; 
PO_S_7_W : double = 0.13; 
PO_S_9 : double = 0.25; 
PO_S_10 : double = 0.14; 
PO_S_10_Q : double = 0.09; 
PO_S_10_E : double = 0.035; 
PO_EX_1 : double = 0.14; 
PO_EX_2 : double = 0.115; 
PO_EX_3 : double = 0.16; 
PO_EX_3_W : double = 0.15; 
PO_EX_3_S : double = 0.10; 
PO_L_1 : double = 25.0; 
PO_L_1_W : double = 0.13; 
PO_A_1 : double = 0.042; 
PO_A_1_1 : double = 0.051; 
PO_A_2 : double = 0.094; 
PO_DN_1_L : double = 0.14; 
PO_DN_1_H : double = 0.40; 
PO_DN_2 : double = 0.001; 
PO_DN_2_W : double = 20; 
PO_DN_2_S : double = 10; 
PO_DN_2_E : double = 5; 
PO_DN_3 : double = 0.14; 
PO_R_6_U : double = 0.425; 
PO_R_6_V : double = 0.11; 
PO_R_6_W : double = 0.255; 
PO_R_6_X : double = 0.065; 
PO_S_15 : double = 1.0; 
PO_S_15_L : double = 0.08; 
PO_S_15_A : double = 630; 
PO_S_15_DN : double = 0.7; 
PO_S_16 : double = 0.19; 
VTH_N_W_1 : double = 0.18; 
VTH_N_S_1 : double = 0.18; 
VTH_N_S_2 : double = 0.16; 
VTH_N_S_2_1 : double = 0.185; 
VTH_N_S_3 : double = 0.22; 
VTH_N_EN_1 : double = 0.185; 
VTH_N_EN_2 : double = 0.16; 
VTH_N_A_1 : double = 0.27; 
VTH_N_A_2 : double = 0.27; 
VTH_N_S_1_W : double = 0.4; 
VTH_P_W_1 : double = 0.18; 
VTH_P_S_1 : double = 0.18; 
VTH_P_S_2 : double = 0.16; 
VTH_P_S_2_1 : double = 0.185; 
VTH_P_S_3 : double = 0.22; 
VTH_P_EN_1 : double = 0.185; 
VTH_P_EN_2 : double = 0.16; 
VTH_P_A_1 : double = 0.27; 
VTH_P_A_2 : double = 0.27; 
VTH_P_S_1_W : double = 0.4; 
VTL_N_W_1 : double = 0.18; 
VTL_N_S_1 : double = 0.18; 
VTL_N_S_2 : double = 0.16; 
VTL_N_S_2_1 : double = 0.185; 
VTL_N_S_3 : double = 0.22; 
VTL_N_EN_1 : double = 0.185; 
VTL_N_EN_2 : double = 0.16; 
VTL_N_A_1 : double = 0.27; 
VTL_N_A_2 : double = 0.27; 
VTL_N_S_1_W : double = 0.4; 
VTL_P_W_1 : double = 0.18; 
VTL_P_S_1 : double = 0.18; 
VTL_P_S_2 : double = 0.16; 
VTL_P_S_2_1 : double = 0.185; 
VTL_P_S_3 : double = 0.22; 
VTL_P_EN_1 : double = 0.185; 
VTL_P_EN_2 : double = 0.16; 
VTL_P_A_1 : double = 0.27; 
VTL_P_A_2 : double = 0.27; 
VTL_P_S_1_W : double = 0.4; 
MVTL_EN_1 : double = 0.05; 
MVTL_S_1 : double = 0.05; 
PP_W_1 : double = 0.18; 
PP_S_1 : double = 0.18; 
PP_S_2 : double = 0.13; 
PP_S_4 : double = 0.02; 
PP_S_5 : double = 0.32; 
PP_S_6 : double = 0.32; 
PP_S_6_J : double = 0.16; 
PP_S_7 : double = 0.20; 
PP_EN_1 : double = 0.15; 
PP_EX_1 : double = 0.13; 
PP_EX_2 : double = 0.02; 
PP_EX_3 : double = 0.20; 
PP_EX_4 : double = 0.32; 
PP_O_1 : double = 0.13; 
PP_A_1 : double = 0.122; 
PP_A_2 : double = 0.122; 
PP_A_3 : double = 0.04; 
PP_R_1 : double = 0.16; 
NP_W_1 : double = 0.18; 
NP_S_1 : double = 0.18; 
NP_S_2 : double = 0.13; 
NP_EX_1 : double = 0.13; 
NP_S_4 : double = 0.02; 
NP_S_5 : double = 0.32; 
NP_S_6 : double = 0.32; 
NP_S_6_J : double = 0.16; 
NP_S_7 : double = 0.20; 
NP_EX_2 : double = 0.02; 
NP_EX_3 : double = 0.20; 
NP_EX_4 : double = 0.32; 
NP_O_1 : double = 0.13; 
NP_A_1 : double = 0.122; 
NP_A_2 : double = 0.122; 
NP_A_3 : double = 0.04; 
NP_R_1 : double = 0.16; 
DCO_W_1 : double = 0.4; 
DCO_S_1 : double = 0.4; 
DCO_S_2 : double = 0.055; 
DCO_S_3 : double = 0.185; 
DCO_S_4 : double = 0.16; 
DCO_S_5 : double = 0.18; 
DCO_S_6 : double = 0.4; 
DCO_EN_1 : double = 0.185; 
DCO_EN_2 : double = 0.16; 
DCO_EX_1 : double = 0.18; 
DCO_EX_2 : double = 0.18; 
DCO_EX_3 : double = 0.055; 
DCO_A_1 : double = 1.2; 
DCO_A_2 : double = 1.2; 
DCO_O_1 : double = 0.18; 
DCO_R_5 : double = 0.2; 
LDN_EX_1 : double = 0.18; 
LDN_O_1 : double = 0.18; 
LDP_EX_1 : double = 0.18; 
LDP_O_2 : double = 0.18; 
VT_S_1 : double = 0.18; 
VT_EX_2 : double = 0.18; 
RPO_W_1 : double = 0.43; 
RPO_S_1 : double = 0.43; 
RPO_S_2 : double = 0.22; 
RPO_S_3 : double = 0.22; 
RPO_S_4 : double = 0.38; 
RPO_S_5 : double = 0.30; 
RPO_EX_1 : double = 0.22; 
RPO_EX_2 : double = 0.22; 
RPO_EX_1_1 : double = 0.30; 
RPO_EX_1_1_W : double = 10.0; 
RPO_A_1 : double = 1.00; 
RPO_A_2 : double = 1.00; 
RES_8 : double = 0.16; 
RES_11 : double = 0.13; 
VAR_W_1 : double = 0.20; 
VAR_W_2 : double = 0.20; 
VAR_W_3 : double = 0.40; 
VAR_W_4 : double = 0.40; 
VAR_S_1 : double = 0.13; 
VAR_EN_1 : double = 0.16; 
VAR_R_4 : double = 0.16; 
VAR_R_5_1 : double = 0.19; 
VAR_R_5_2 : double = 0.13; 
HVD_N_W_1 : double = 0.47; 
HVD_N_W_2 : double = 0.6; 
HVD_N_S_1 : double = 0.47; 
HVD_N_S_2 : double = 1.37; 
HVD_N_S_3 : double = 1.6; 
HVD_N_S_4 : double = 0.3; 
HVD_N_S_5 : double = 0.6; 
HVD_N_S_6 : double = 3.0; 
HVD_N_EX_1 : double = 0.24; 
HVD_N_O_1 : double = 0.3; 
HVD_N_L_1 : double = 0.85; 
HVD_N_A_1 : double = 0.64; 
HVD_N_A_2 : double = 0.64; 
HVD_P_W_1 : double = 0.47; 
HVD_P_W_2 : double = 0.6; 
HVD_P_S_1 : double = 0.47; 
HVD_P_S_2 : double = 1.2; 
HVD_P_S_4 : double = 0.24; 
HVD_P_S_5 : double = 0.48; 
HVD_P_EX_1 : double = 0.24; 
HVD_P_EN_1 : double = 1.6; 
HVD_P_O_1 : double = 0.25; 
HVD_P_L_1 : double = 0.6; 
HVD_P_A_1 : double = 0.64; 
HVD_P_A_2 : double = 0.64; 

// VALUE OF VARIABLE FOR GUARD RING RULES
//=================
GR_R_7 : double = 2; 
GR_R_8 : double = 4; 
GR_R_9 : double = 28; 
GR_R_10 : double = 2; 
GR_R_11 : double = 2; 
GR_R_12 : double = 65; 
GR_R_13 : double = 10; 
BV_W_1 : double = 10; 
BV_W_2 : double = 50; 
BV_R_1 : double = 64; 

// VARIABLE OF RULE VALUE for N55LP HVD
//-------------------------
HVD_N_W_1_N55LP : double = 0.47; 
HVD_N_W_2_N55LP : double = 1; 
HVD_N_S_1_N55LP : double = 0.47; 
HVD_N_S_2_N55LP : double = 1.6; 
HVD_N_S_3_N55LP : double = 1.6; 
HVD_N_S_4_N55LP : double = 0.3; 
HVD_N_S_5_N55LP : double = 0.6; 
HVD_N_S_6_N55LP : double = 3.0; 
HVD_N_EX_1_N55LP : double = 0.24; 
HVD_N_O_1_N55LP : double = 0.2; 
HVD_N_L_1_N55LP : double = 0.52; 
HVD_N_A_1_N55LP : double = 0.64; 
HVD_N_A_2_N55LP : double = 0.64; 
HVD_N_W_3_N55LP : double = 0.12; 
HVD_N_S_7_N55LP : double = 0.13; 
HVD_N_EX_2_N55LP : double = 0.14; 
HVD_N_S_8_N55LP : double = 0.34; 
HVD_N_S_9_N55LP : double = 0.37; 
HVD_P_W_1_N55LP : double = 0.47; 
HVD_P_W_2_N55LP : double = 1; 
HVD_P_S_1_N55LP : double = 0.47; 
HVD_P_S_2_N55LP : double = 1.6; 
HVD_P_S_4_N55LP : double = 0.3; 
HVD_P_S_5_N55LP : double = 0.6; 
HVD_P_EX_1_N55LP : double = 0.24; 
HVD_P_EN_1_N55LP : double = 1.6; 
HVD_P_O_1_N55LP : double = 0.15; 
HVD_P_L_1_N55LP : double = 0.5; 
HVD_P_A_1_N55LP : double = 0.64; 
HVD_P_A_2_N55LP : double = 0.64; 
HVD_P_EN_2_N55LP : double = 0.4; 
HVD_P_W_3_N55LP : double = 0.12; 
HVD_P_S_6_N55LP : double = 0.13; 
HVD_P_EX_2_N55LP : double = 0.14; 
HVD_P_S_7_N55LP : double = 0.34; 
HVD_P_S_8_N55LP : double = 0.37; 
HVD_DPW_W_1_N55LP : double = 0.5; 
HVD_DPW_S_1_N55LP : double = 0.5; 
HVD_DPW_S_2_N55LP : double = 4; 
HVD_DPW_S_3_N55LP : double = 0.75; 
BV_W_1_N55LP : double = 50; 
BV_W_2_N55LP : double = 20; 
BV_R_1_N55LP : double = 32; 

// VALUE OF VARIABLE FOR GUARD RING RULES
//=================
GR_R_8_N55LP : double = 2; 
GR_R_9_N55LP : double = 4; 
GR_R_10_N55LP : double = 28; 
GR_R_11_N55LP : double = 2; 
GR_R_12_N55LP : double = 2; 
GR_R_13_N55LP : double = 65; 
CO_W_1 : double = 0.09; 
CO_W_2 : double = 0.09; 
CO_S_1 : double = 0.11; 
CO_S_2 : double = 0.14; 
CO_S_2_N : double = 0.15; 
CO_S_2_1 : double = 0.14; 
CO_S_2_2 : double = 0.12; 
CO_S_4 : double = 0.07; 
CO_S_5 : double = 0.09; 
CO_S_6 : double = 0.06; 
CO_S_3 : double = 0.055; 
CO_EN_1 : double = 0.015; 
CO_EN_1_1 : double = 0.03; 
CO_EN_1_R : double = 0.04; 
CO_EN_2 : double = 0.01; 
CO_EN_3 : double = 0.04; 
CO_EN_4 : double = 0.03; 
M1_W_1 : double = 0.09; 
M1_W_2 : double = 0.19; 
M1_W_3 : double = 12.0; 
M1_S_1 : double = 0.09; 
#ifdef HALF_NODE 
   M1_S_2 : double = 0.11; 
   M1_S_2_W : double = 0.22;         /* N55  */ 
   M1_S_2_L : double = 0.42;         /* N55 */ 
   M1_S_2_1 : double = 0.16; 
   M1_S_2_1_W : double = 0.465;      /* N55   */ 
   M1_S_2_1_L : double = 0.465;      /* N55 */ 
   M1_S_2_2 : double = 0.1;          /* N55 */ 
   M1_S_2_2_W : double = 0.2;        /* N55   */ 
   M1_S_2_2_L : double = 0.42;       /* N55 */ 
   M1_S_2_3 : double = 0.12;         /* N55 */ 
   M1_S_2_3_W : double = 0.42;       /* N55   */ 
   M1_S_2_3_L : double = 0.465;      /* N55 */ 
   M1_S_3 : double = 0.50; 
   M1_S_3_W : double = 1.65;         /* N55 */ 
   M1_S_3_L : double = 1.65;         /* N55 */ 
   M1_S_4 : double = 1.50; 
   M1_S_4_W : double = 4.95;         /* N55 */ 
   M1_S_4_L : double = 4.95;         /* N55 */ 
#else
   M1_S_2 : double = 0.11; 
   M1_S_2_W : double = 0.20; 
   M1_S_2_L : double = 0.38; 
   M1_S_2_1 : double = 0.16; 
   M1_S_2_1_W : double = 0.42; 
   M1_S_2_1_L : double = 0.42; 
   M1_S_3 : double = 0.50; 
   M1_S_3_W : double = 1.5; 
   M1_S_3_L : double = 1.5; 
   M1_S_4 : double = 1.50; 
   M1_S_4_W : double = 4.5; 
   M1_S_4_L : double = 4.5; 
#endif
M1_S_6 : double = 0.19; 
M1_S_5 : double = 0.11; 
M1_S_5_Q : double = 0.11; 
M1_S_5_E : double = 0.035; 
M1_EN_2 : double = 0.04; 
M1_EN_3 : double = 0.025; 
M1_EN_4 : double = 0.04; 
M1_EN_4_W : double = 1.0; 
M1_A_1 : double = 0.042; 
M1_A_2 : double = 0.2; 
M1_EN_1 : double = 0; 
M1_DN_1L : double = 0.1; 
M1_DN_1L_W : double = METAL_LOW_DEN_WINDOW_SIZE; 
M1_DN_1L_S : double = METAL_LOW_DEN_WINDOW_STEP; 
M1_DN_1L_E : double = M1_DN_1L_W / 4; 
M1_DN_1H : double = 0.8; 
M1_DN_1H_W : double = METAL_HIGH_DEN_WINDOW_SIZE; 
M1_DN_1H_S : double = METAL_HIGH_DEN_WINDOW_STEP; 
M1_DN_1H_E : double = M1_DN_1H_W / 4; 
M1_DN_2 : double = 0.9; 
M1_DN_2_W : double = 20; 
M1_DN_2_S : double = 10; 
M1_DN_2_E : double = 5; 
M1_DN_4 : double = 0.4; 
M1_DN_4_W : double = 250; 
VIA1_W_1 : double = 0.10; 
VIA1_W_2 : double = 0.10; 
VIA1_S_1 : double = 0.10; 
VIA1_S_2 : double = 0.13; 
VIA1_S_2_S : double = 0.14; 
VIA1_S_3 : double = 0.13; 
VIA1_EN_2 : double = 0.04; 
VIA1_EN_3 : double = 0.03; 
#ifdef HALF_NODE 
   VIA1_R_2_S1 : double = 0.22;      /* N55 */ 
   VIA1_R_2_S2 : double = 0.275;     /* N55 */ 
   VIA1_R_2_W : double = 0.33;       /* N55 */ 
   VIA1_R_3_S1 : double = 0.22;      /* N55   */ 
   VIA1_R_3_S2 : double = 0.385;     /* N55 */ 
   VIA1_R_3_W : double = 0.77;       /* N55 */ 
   VIA1_R_4_W : double = 0.33;       /* N55  */ 
   VIA1_R_4_D : double = 0.8; 
   VIA1_R_5_W : double = 2.2;        /* N55 */ 
   VIA1_R_5_D : double = 2.0; 
   VIA1_R_6_W : double = 3.3;        /* N55 */ 
   VIA1_R_6_L : double = 11.0;       /* N55 */ 
   VIA1_R_6_D : double = 5.0; 
#else
   VIA1_R_2_S1 : double = 0.20; 
   VIA1_R_2_S2 : double = 0.25; 
   VIA1_R_2_W : double = 0.30; 
   VIA1_R_3_S1 : double = 0.20; 
   VIA1_R_3_S2 : double = 0.35; 
   VIA1_R_3_W : double = 0.70; 
   VIA1_R_4_W : double = 0.3; 
   VIA1_R_4_D : double = 0.8; 
   VIA1_R_5_W : double = 2.0; 
   VIA1_R_5_D : double = 2.0; 
   VIA1_R_6_W : double = 3.0; 
   VIA1_R_6_L : double = 10.0; 
   VIA1_R_6_D : double = 5.0; 
#endif
VIA1_R_11_L : double = 1.0; 
VIA1_R_11_W : double = 0.3; 
VIA1_R_11_A : double = 5.0; 
VIA1_R_11_L2 : double = 5.0; 
M2_W_1 : double = 0.10; 
M2_S_1 : double = 0.10; 
M2_A_1 : double = 0.052; 
M2_A_2 : double = 0.20; 
M2_W_3 : double = 12.0; 
#ifdef HALF_NODE 
   M2_S_2 : double = 0.12; 
   M2_S_2_W : double = 0.22;         /* N55  */ 
   M2_S_2_L : double = 0.42;         /* N55 */ 
   M2_S_2_1 : double = 0.16; 
   M2_S_2_1_W : double = 0.44;       /* N55 */ 
   M2_S_2_1_L : double = 0.44;       /* N55  */ 
   M2_S_2_2 : double = 0.11;         /* N55 */ 
   M2_S_2_2_W : double = 0.2;        /* N55 */ 
   M2_S_2_2_L : double = 0.42;       /* N55 */ 
   M2_S_2_3 : double = 0.13;         /* N55 */ 
   M2_S_2_3_W : double = 0.4;        /* N55 */ 
   M2_S_2_3_L : double = 0.44;       /* N55 */ 
   M2_S_3 : double = 0.50; 
   M2_S_3_W : double = 1.65;         /* N55 */ 
   M2_S_3_L : double = 1.65;         /* N55 */ 
   M2_S_4 : double = 1.50; 
   M2_S_4_W : double = 4.95;         /* N55 */ 
   M2_S_4_L : double = 4.95;         /* N55 */ 
#else
   M2_S_2 : double = 0.12; 
   M2_S_2_W : double = 0.20; 
   M2_S_2_L : double = 0.38; 
   M2_S_2_1 : double = 0.16; 
   M2_S_2_1_W : double = 0.4; 
   M2_S_2_1_L : double = 0.4; 
   M2_S_3 : double = 0.50; 
   M2_S_3_W : double = 1.50; 
   M2_S_3_L : double = 1.50; 
   M2_S_4 : double = 1.50; 
   M2_S_4_W : double = 4.50; 
   M2_S_4_L : double = 4.50; 
#endif
M2_S_5 : double = 0.12; 
M2_S_5_Q : double = 0.12; 
M2_S_5_E : double = 0.035; 
M2_EN_2 : double = 0.04; 
M2_EN_3 : double = 0.03; 
M2_W_2 : double = 0.19; 
M2_S_6 : double = 0.19; 
M2_DN_1L : double = 0.1; 
M2_DN_1L_W : double = METAL_LOW_DEN_WINDOW_SIZE; 
M2_DN_1L_S : double = METAL_LOW_DEN_WINDOW_STEP; 
M2_DN_1L_E : double = M2_DN_1L_W / 4; 
M2_DN_1H : double = 0.8; 
M2_DN_1H_W : double = METAL_HIGH_DEN_WINDOW_SIZE; 
M2_DN_1H_S : double = METAL_HIGH_DEN_WINDOW_STEP; 
M2_DN_1H_E : double = M2_DN_1H_W / 4; 
M2_DN_2 : double = 0.9; 
M2_DN_2_W : double = 20; 
M2_DN_2_S : double = 10; 
M2_DN_2_E : double = 5; 
M2_DN_4 : double = 0.4; 
M2_DN_4_W : double = 250; 
VIA2_W_1 : double = 0.10; 
VIA2_W_2 : double = 0.10; 
VIA2_S_1 : double = 0.10; 
VIA2_S_2 : double = 0.13; 
VIA2_S_2_S : double = 0.14; 
VIA2_S_3 : double = 0.13; 
VIA2_EN_2 : double = 0.04; 
VIA2_EN_3 : double = 0.03; 
#ifdef HALF_NODE 
   VIA2_R_2_S1 : double = 0.22;      /* N55 */ 
   VIA2_R_2_S2 : double = 0.275;     /* N55 */ 
   VIA2_R_2_W : double = 0.33;       /* N55 */ 
   VIA2_R_3_S1 : double = 0.22;      /* N55   */ 
   VIA2_R_3_S2 : double = 0.385;     /* N55 */ 
   VIA2_R_3_W : double = 0.77;       /* N55 */ 
   VIA2_R_4_W : double = 0.33;       /* N55  */ 
   VIA2_R_4_D : double = 0.8; 
   VIA2_R_5_W : double = 2.2;        /* N55 */ 
   VIA2_R_5_D : double = 2.0; 
   VIA2_R_6_W : double = 3.3;        /* N55 */ 
   VIA2_R_6_L : double = 11.0;       /* N55 */ 
   VIA2_R_6_D : double = 5.0; 
#else
   VIA2_R_2_S1 : double = 0.20; 
   VIA2_R_2_S2 : double = 0.25; 
   VIA2_R_2_W : double = 0.30; 
   VIA2_R_3_S1 : double = 0.20; 
   VIA2_R_3_S2 : double = 0.35; 
   VIA2_R_3_W : double = 0.70; 
   VIA2_R_4_W : double = 0.3; 
   VIA2_R_4_D : double = 0.8; 
   VIA2_R_5_W : double = 2.0; 
   VIA2_R_5_D : double = 2.0; 
   VIA2_R_6_W : double = 3.0; 
   VIA2_R_6_L : double = 10.0; 
   VIA2_R_6_D : double = 5.0; 
#endif
VIA2_R_11_L : double = 1.0; 
VIA2_R_11_W : double = 0.3; 
VIA2_R_11_A : double = 5.0; 
VIA2_R_11_L2 : double = 5.0; 
M3_W_1 : double = 0.10; 
M3_S_1 : double = 0.10; 
M3_A_1 : double = 0.052; 
M3_A_2 : double = 0.20; 
M3_W_3 : double = 12.0; 
#ifdef HALF_NODE 
   M3_S_2 : double = 0.12; 
   M3_S_2_W : double = 0.22;         /* N55  */ 
   M3_S_2_L : double = 0.42;         /* N55 */ 
   M3_S_2_1 : double = 0.16; 
   M3_S_2_1_W : double = 0.44;       /* N55 */ 
   M3_S_2_1_L : double = 0.44;       /* N55  */ 
   M3_S_2_2 : double = 0.11;         /* N55 */ 
   M3_S_2_2_W : double = 0.2;        /* N55 */ 
   M3_S_2_2_L : double = 0.42;       /* N55 */ 
   M3_S_2_3 : double = 0.13;         /* N55 */ 
   M3_S_2_3_W : double = 0.4;        /* N55 */ 
   M3_S_2_3_L : double = 0.44;       /* N55 */ 
   M3_S_3 : double = 0.50; 
   M3_S_3_W : double = 1.65;         /* N55 */ 
   M3_S_3_L : double = 1.65;         /* N55 */ 
   M3_S_4 : double = 1.50; 
   M3_S_4_W : double = 4.95;         /* N55 */ 
   M3_S_4_L : double = 4.95;         /* N55 */ 
#else
   M3_S_2 : double = 0.12; 
   M3_S_2_W : double = 0.20; 
   M3_S_2_L : double = 0.38; 
   M3_S_2_1 : double = 0.16; 
   M3_S_2_1_W : double = 0.4; 
   M3_S_2_1_L : double = 0.4; 
   M3_S_3 : double = 0.50; 
   M3_S_3_W : double = 1.50; 
   M3_S_3_L : double = 1.50; 
   M3_S_4 : double = 1.50; 
   M3_S_4_W : double = 4.50; 
   M3_S_4_L : double = 4.50; 
#endif
M3_S_5 : double = 0.12; 
M3_S_5_Q : double = 0.12; 
M3_S_5_E : double = 0.035; 
M3_EN_2 : double = 0.04; 
M3_EN_3 : double = 0.03; 
M3_W_2 : double = 0.19; 
M3_S_6 : double = 0.19; 
M3_DN_1L : double = 0.1; 
M3_DN_1L_W : double = METAL_LOW_DEN_WINDOW_SIZE; 
M3_DN_1L_S : double = METAL_LOW_DEN_WINDOW_STEP; 
M3_DN_1L_E : double = M3_DN_1L_W / 4; 
M3_DN_1H : double = 0.8; 
M3_DN_1H_W : double = METAL_HIGH_DEN_WINDOW_SIZE; 
M3_DN_1H_S : double = METAL_HIGH_DEN_WINDOW_STEP; 
M3_DN_1H_E : double = M3_DN_1H_W / 4; 
M3_DN_2 : double = 0.9; 
M3_DN_2_W : double = 20; 
M3_DN_2_S : double = 10; 
M3_DN_2_E : double = 5; 
M3_DN_4 : double = 0.4; 
M3_DN_4_W : double = 250; 
VIA3_W_1 : double = 0.10; 
VIA3_W_2 : double = 0.10; 
VIA3_S_1 : double = 0.10; 
VIA3_S_2 : double = 0.13; 
VIA3_S_2_S : double = 0.14; 
VIA3_S_3 : double = 0.13; 
VIA3_EN_2 : double = 0.04; 
VIA3_EN_3 : double = 0.03; 
#ifdef HALF_NODE 
   VIA3_R_2_S1 : double = 0.22;      /* N55 */ 
   VIA3_R_2_S2 : double = 0.275;     /* N55 */ 
   VIA3_R_2_W : double = 0.33;       /* N55 */ 
   VIA3_R_3_S1 : double = 0.22;      /* N55   */ 
   VIA3_R_3_S2 : double = 0.385;     /* N55 */ 
   VIA3_R_3_W : double = 0.77;       /* N55 */ 
   VIA3_R_4_W : double = 0.33;       /* N55  */ 
   VIA3_R_4_D : double = 0.8; 
   VIA3_R_5_W : double = 2.2;        /* N55 */ 
   VIA3_R_5_D : double = 2.0; 
   VIA3_R_6_W : double = 3.3;        /* N55 */ 
   VIA3_R_6_L : double = 11.0;       /* N55 */ 
   VIA3_R_6_D : double = 5.0; 
#else
   VIA3_R_2_S1 : double = 0.20; 
   VIA3_R_2_S2 : double = 0.25; 
   VIA3_R_2_W : double = 0.30; 
   VIA3_R_3_S1 : double = 0.20; 
   VIA3_R_3_S2 : double = 0.35; 
   VIA3_R_3_W : double = 0.70; 
   VIA3_R_4_W : double = 0.3; 
   VIA3_R_4_D : double = 0.8; 
   VIA3_R_5_W : double = 2.0; 
   VIA3_R_5_D : double = 2.0; 
   VIA3_R_6_W : double = 3.0; 
   VIA3_R_6_L : double = 10.0; 
   VIA3_R_6_D : double = 5.0; 
#endif
VIA3_R_11_L : double = 1.0; 
VIA3_R_11_W : double = 0.3; 
VIA3_R_11_A : double = 5.0; 
VIA3_R_11_L2 : double = 5.0; 
M4_W_1 : double = 0.10; 
M4_S_1 : double = 0.10; 
M4_A_1 : double = 0.052; 
M4_A_2 : double = 0.20; 
M4_W_3 : double = 12.0; 
#ifdef HALF_NODE 
   M4_S_2 : double = 0.12; 
   M4_S_2_W : double = 0.22;         /* N55  */ 
   M4_S_2_L : double = 0.42;         /* N55 */ 
   M4_S_2_1 : double = 0.16; 
   M4_S_2_1_W : double = 0.44;       /* N55 */ 
   M4_S_2_1_L : double = 0.44;       /* N55  */ 
   M4_S_2_2 : double = 0.11;         /* N55 */ 
   M4_S_2_2_W : double = 0.2;        /* N55 */ 
   M4_S_2_2_L : double = 0.42;       /* N55 */ 
   M4_S_2_3 : double = 0.13;         /* N55 */ 
   M4_S_2_3_W : double = 0.4;        /* N55 */ 
   M4_S_2_3_L : double = 0.44;       /* N55 */ 
   M4_S_3 : double = 0.50; 
   M4_S_3_W : double = 1.65;         /* N55 */ 
   M4_S_3_L : double = 1.65;         /* N55 */ 
   M4_S_4 : double = 1.50; 
   M4_S_4_W : double = 4.95;         /* N55 */ 
   M4_S_4_L : double = 4.95;         /* N55 */ 
#else
   M4_S_2 : double = 0.12; 
   M4_S_2_W : double = 0.20; 
   M4_S_2_L : double = 0.38; 
   M4_S_2_1 : double = 0.16; 
   M4_S_2_1_W : double = 0.4; 
   M4_S_2_1_L : double = 0.4; 
   M4_S_3 : double = 0.50; 
   M4_S_3_W : double = 1.50; 
   M4_S_3_L : double = 1.50; 
   M4_S_4 : double = 1.50; 
   M4_S_4_W : double = 4.50; 
   M4_S_4_L : double = 4.50; 
#endif
M4_S_5 : double = 0.12; 
M4_S_5_Q : double = 0.12; 
M4_S_5_E : double = 0.035; 
M4_EN_2 : double = 0.04; 
M4_EN_3 : double = 0.03; 
M4_W_2 : double = 0.19; 
M4_S_6 : double = 0.19; 
M4_DN_1L : double = 0.1; 
M4_DN_1L_W : double = METAL_LOW_DEN_WINDOW_SIZE; 
M4_DN_1L_S : double = METAL_LOW_DEN_WINDOW_STEP; 
M4_DN_1L_E : double = M4_DN_1L_W / 4; 
M4_DN_1H : double = 0.8; 
M4_DN_1H_W : double = METAL_HIGH_DEN_WINDOW_SIZE; 
M4_DN_1H_S : double = METAL_HIGH_DEN_WINDOW_STEP; 
M4_DN_1H_E : double = M4_DN_1H_W / 4; 
M4_DN_2 : double = 0.9; 
M4_DN_2_W : double = 20; 
M4_DN_2_S : double = 10; 
M4_DN_2_E : double = 5; 
M4_DN_4 : double = 0.4; 
M4_DN_4_W : double = 250; 
VIA4_W_1 : double = 0.10; 
VIA4_W_2 : double = 0.10; 
VIA4_S_1 : double = 0.10; 
VIA4_S_2 : double = 0.13; 
VIA4_S_2_S : double = 0.14; 
VIA4_S_3 : double = 0.13; 
VIA4_EN_2 : double = 0.04; 
VIA4_EN_3 : double = 0.03; 
#ifdef HALF_NODE 
   VIA4_R_2_S1 : double = 0.22;      /* N55 */ 
   VIA4_R_2_S2 : double = 0.275;     /* N55 */ 
   VIA4_R_2_W : double = 0.33;       /* N55 */ 
   VIA4_R_3_S1 : double = 0.22;      /* N55   */ 
   VIA4_R_3_S2 : double = 0.385;     /* N55 */ 
   VIA4_R_3_W : double = 0.77;       /* N55 */ 
   VIA4_R_4_W : double = 0.33;       /* N55  */ 
   VIA4_R_4_D : double = 0.8; 
   VIA4_R_5_W : double = 2.2;        /* N55 */ 
   VIA4_R_5_D : double = 2.0; 
   VIA4_R_6_W : double = 3.3;        /* N55 */ 
   VIA4_R_6_L : double = 11.0;       /* N55 */ 
   VIA4_R_6_D : double = 5.0; 
#else
   VIA4_R_2_S1 : double = 0.20; 
   VIA4_R_2_S2 : double = 0.25; 
   VIA4_R_2_W : double = 0.30; 
   VIA4_R_3_S1 : double = 0.20; 
   VIA4_R_3_S2 : double = 0.35; 
   VIA4_R_3_W : double = 0.70; 
   VIA4_R_4_W : double = 0.3; 
   VIA4_R_4_D : double = 0.8; 
   VIA4_R_5_W : double = 2.0; 
   VIA4_R_5_D : double = 2.0; 
   VIA4_R_6_W : double = 3.0; 
   VIA4_R_6_L : double = 10.0; 
   VIA4_R_6_D : double = 5.0; 
#endif
VIA4_R_11_L : double = 1.0; 
VIA4_R_11_W : double = 0.3; 
VIA4_R_11_A : double = 5.0; 
VIA4_R_11_L2 : double = 5.0; 
M5_W_1 : double = 0.10; 
M5_S_1 : double = 0.10; 
M5_A_1 : double = 0.052; 
M5_A_2 : double = 0.20; 
M5_W_3 : double = 12.0; 
#ifdef HALF_NODE 
   M5_S_2 : double = 0.12; 
   M5_S_2_W : double = 0.22;         /* N55  */ 
   M5_S_2_L : double = 0.42;         /* N55 */ 
   M5_S_2_1 : double = 0.16; 
   M5_S_2_1_W : double = 0.44;       /* N55 */ 
   M5_S_2_1_L : double = 0.44;       /* N55  */ 
   M5_S_2_2 : double = 0.11;         /* N55 */ 
   M5_S_2_2_W : double = 0.2;        /* N55 */ 
   M5_S_2_2_L : double = 0.42;       /* N55 */ 
   M5_S_2_3 : double = 0.13;         /* N55 */ 
   M5_S_2_3_W : double = 0.4;        /* N55 */ 
   M5_S_2_3_L : double = 0.44;       /* N55 */ 
   M5_S_3 : double = 0.50; 
   M5_S_3_W : double = 1.65;         /* N55 */ 
   M5_S_3_L : double = 1.65;         /* N55 */ 
   M5_S_4 : double = 1.50; 
   M5_S_4_W : double = 4.95;         /* N55 */ 
   M5_S_4_L : double = 4.95;         /* N55 */ 
#else
   M5_S_2 : double = 0.12; 
   M5_S_2_W : double = 0.20; 
   M5_S_2_L : double = 0.38; 
   M5_S_2_1 : double = 0.16; 
   M5_S_2_1_W : double = 0.4; 
   M5_S_2_1_L : double = 0.4; 
   M5_S_3 : double = 0.50; 
   M5_S_3_W : double = 1.50; 
   M5_S_3_L : double = 1.50; 
   M5_S_4 : double = 1.50; 
   M5_S_4_W : double = 4.50; 
   M5_S_4_L : double = 4.50; 
#endif
M5_S_5 : double = 0.12; 
M5_S_5_Q : double = 0.12; 
M5_S_5_E : double = 0.035; 
M5_EN_2 : double = 0.04; 
M5_EN_3 : double = 0.03; 
M5_W_2 : double = 0.19; 
M5_S_6 : double = 0.19; 
M5_DN_1L : double = 0.1; 
M5_DN_1L_W : double = METAL_LOW_DEN_WINDOW_SIZE; 
M5_DN_1L_S : double = METAL_LOW_DEN_WINDOW_STEP; 
M5_DN_1L_E : double = M5_DN_1L_W / 4; 
M5_DN_1H : double = 0.8; 
M5_DN_1H_W : double = METAL_HIGH_DEN_WINDOW_SIZE; 
M5_DN_1H_S : double = METAL_HIGH_DEN_WINDOW_STEP; 
M5_DN_1H_E : double = M5_DN_1H_W / 4; 
M5_DN_2 : double = 0.9; 
M5_DN_2_W : double = 20; 
M5_DN_2_S : double = 10; 
M5_DN_2_E : double = 5; 
M5_DN_4 : double = 0.4; 
M5_DN_4_W : double = 250; 
VIA5_W_1 : double = 0.10; 
VIA5_W_2 : double = 0.10; 
VIA5_S_1 : double = 0.10; 
VIA5_S_2 : double = 0.13; 
VIA5_S_2_S : double = 0.14; 
VIA5_S_3 : double = 0.13; 
VIA5_EN_2 : double = 0.04; 
VIA5_EN_3 : double = 0.03; 
#ifdef HALF_NODE 
   VIA5_R_2_S1 : double = 0.22;      /* N55 */ 
   VIA5_R_2_S2 : double = 0.275;     /* N55 */ 
   VIA5_R_2_W : double = 0.33;       /* N55 */ 
   VIA5_R_3_S1 : double = 0.22;      /* N55   */ 
   VIA5_R_3_S2 : double = 0.385;     /* N55 */ 
   VIA5_R_3_W : double = 0.77;       /* N55 */ 
   VIA5_R_4_W : double = 0.33;       /* N55  */ 
   VIA5_R_4_D : double = 0.8; 
   VIA5_R_5_W : double = 2.2;        /* N55 */ 
   VIA5_R_5_D : double = 2.0; 
   VIA5_R_6_W : double = 3.3;        /* N55 */ 
   VIA5_R_6_L : double = 11.0;       /* N55 */ 
   VIA5_R_6_D : double = 5.0; 
#else
   VIA5_R_2_S1 : double = 0.20; 
   VIA5_R_2_S2 : double = 0.25; 
   VIA5_R_2_W : double = 0.30; 
   VIA5_R_3_S1 : double = 0.20; 
   VIA5_R_3_S2 : double = 0.35; 
   VIA5_R_3_W : double = 0.70; 
   VIA5_R_4_W : double = 0.3; 
   VIA5_R_4_D : double = 0.8; 
   VIA5_R_5_W : double = 2.0; 
   VIA5_R_5_D : double = 2.0; 
   VIA5_R_6_W : double = 3.0; 
   VIA5_R_6_L : double = 10.0; 
   VIA5_R_6_D : double = 5.0; 
#endif
VIA5_R_11_L : double = 1.0; 
VIA5_R_11_W : double = 0.3; 
VIA5_R_11_A : double = 5.0; 
VIA5_R_11_L2 : double = 5.0; 
M6_W_1 : double = 0.10; 
M6_S_1 : double = 0.10; 
M6_A_1 : double = 0.052; 
M6_A_2 : double = 0.20; 
M6_W_3 : double = 12.0; 
#ifdef HALF_NODE 
   M6_S_2 : double = 0.12; 
   M6_S_2_W : double = 0.22;         /* N55  */ 
   M6_S_2_L : double = 0.42;         /* N55 */ 
   M6_S_2_1 : double = 0.16; 
   M6_S_2_1_W : double = 0.44;       /* N55 */ 
   M6_S_2_1_L : double = 0.44;       /* N55  */ 
   M6_S_2_2 : double = 0.11;         /* N55 */ 
   M6_S_2_2_W : double = 0.2;        /* N55 */ 
   M6_S_2_2_L : double = 0.42;       /* N55 */ 
   M6_S_2_3 : double = 0.13;         /* N55 */ 
   M6_S_2_3_W : double = 0.4;        /* N55 */ 
   M6_S_2_3_L : double = 0.44;       /* N55 */ 
   M6_S_3 : double = 0.50; 
   M6_S_3_W : double = 1.65;         /* N55 */ 
   M6_S_3_L : double = 1.65;         /* N55 */ 
   M6_S_4 : double = 1.50; 
   M6_S_4_W : double = 4.95;         /* N55 */ 
   M6_S_4_L : double = 4.95;         /* N55 */ 
#else
   M6_S_2 : double = 0.12; 
   M6_S_2_W : double = 0.20; 
   M6_S_2_L : double = 0.38; 
   M6_S_2_1 : double = 0.16; 
   M6_S_2_1_W : double = 0.4; 
   M6_S_2_1_L : double = 0.4; 
   M6_S_3 : double = 0.50; 
   M6_S_3_W : double = 1.50; 
   M6_S_3_L : double = 1.50; 
   M6_S_4 : double = 1.50; 
   M6_S_4_W : double = 4.50; 
   M6_S_4_L : double = 4.50; 
#endif
M6_S_5 : double = 0.12; 
M6_S_5_Q : double = 0.12; 
M6_S_5_E : double = 0.035; 
M6_EN_2 : double = 0.04; 
M6_EN_3 : double = 0.03; 
M6_W_2 : double = 0.19; 
M6_S_6 : double = 0.19; 
M6_DN_1L : double = 0.1; 
M6_DN_1L_W : double = METAL_LOW_DEN_WINDOW_SIZE; 
M6_DN_1L_S : double = METAL_LOW_DEN_WINDOW_STEP; 
M6_DN_1L_E : double = M6_DN_1L_W / 4; 
M6_DN_1H : double = 0.8; 
M6_DN_1H_W : double = METAL_HIGH_DEN_WINDOW_SIZE; 
M6_DN_1H_S : double = METAL_HIGH_DEN_WINDOW_STEP; 
M6_DN_1H_E : double = M6_DN_1H_W / 4; 
M6_DN_2 : double = 0.9; 
M6_DN_2_W : double = 20; 
M6_DN_2_S : double = 10; 
M6_DN_2_E : double = 5; 
M6_DN_4 : double = 0.4; 
M6_DN_4_W : double = 250; 
VIA6_W_1 : double = 0.10; 
VIA6_W_2 : double = 0.10; 
VIA6_S_1 : double = 0.10; 
VIA6_S_2 : double = 0.13; 
VIA6_S_2_S : double = 0.14; 
VIA6_S_3 : double = 0.13; 
VIA6_EN_2 : double = 0.04; 
VIA6_EN_3 : double = 0.03; 
#ifdef HALF_NODE 
   VIA6_R_2_S1 : double = 0.22;      /* N55 */ 
   VIA6_R_2_S2 : double = 0.275;     /* N55 */ 
   VIA6_R_2_W : double = 0.33;       /* N55 */ 
   VIA6_R_3_S1 : double = 0.22;      /* N55   */ 
   VIA6_R_3_S2 : double = 0.385;     /* N55 */ 
   VIA6_R_3_W : double = 0.77;       /* N55 */ 
   VIA6_R_4_W : double = 0.33;       /* N55  */ 
   VIA6_R_4_D : double = 0.8; 
   VIA6_R_5_W : double = 2.2;        /* N55 */ 
   VIA6_R_5_D : double = 2.0; 
   VIA6_R_6_W : double = 3.3;        /* N55 */ 
   VIA6_R_6_L : double = 11.0;       /* N55 */ 
   VIA6_R_6_D : double = 5.0; 
#else
   VIA6_R_2_S1 : double = 0.20; 
   VIA6_R_2_S2 : double = 0.25; 
   VIA6_R_2_W : double = 0.30; 
   VIA6_R_3_S1 : double = 0.20; 
   VIA6_R_3_S2 : double = 0.35; 
   VIA6_R_3_W : double = 0.70; 
   VIA6_R_4_W : double = 0.3; 
   VIA6_R_4_D : double = 0.8; 
   VIA6_R_5_W : double = 2.0; 
   VIA6_R_5_D : double = 2.0; 
   VIA6_R_6_W : double = 3.0; 
   VIA6_R_6_L : double = 10.0; 
   VIA6_R_6_D : double = 5.0; 
#endif
VIA6_R_11_L : double = 1.0; 
VIA6_R_11_W : double = 0.3; 
VIA6_R_11_A : double = 5.0; 
VIA6_R_11_L2 : double = 5.0; 
M7_W_1 : double = 0.10; 
M7_S_1 : double = 0.10; 
M7_A_1 : double = 0.052; 
M7_A_2 : double = 0.20; 
M7_W_3 : double = 12.0; 
#ifdef HALF_NODE 
   M7_S_2 : double = 0.12; 
   M7_S_2_W : double = 0.22;         /* N55  */ 
   M7_S_2_L : double = 0.42;         /* N55 */ 
   M7_S_2_1 : double = 0.16; 
   M7_S_2_1_W : double = 0.44;       /* N55 */ 
   M7_S_2_1_L : double = 0.44;       /* N55  */ 
   M7_S_2_2 : double = 0.11;         /* N55 */ 
   M7_S_2_2_W : double = 0.2;        /* N55 */ 
   M7_S_2_2_L : double = 0.42;       /* N55 */ 
   M7_S_2_3 : double = 0.13;         /* N55 */ 
   M7_S_2_3_W : double = 0.4;        /* N55 */ 
   M7_S_2_3_L : double = 0.44;       /* N55 */ 
   M7_S_3 : double = 0.50; 
   M7_S_3_W : double = 1.65;         /* N55 */ 
   M7_S_3_L : double = 1.65;         /* N55 */ 
   M7_S_4 : double = 1.50; 
   M7_S_4_W : double = 4.95;         /* N55 */ 
   M7_S_4_L : double = 4.95;         /* N55 */ 
#else
   M7_S_2 : double = 0.12; 
   M7_S_2_W : double = 0.20; 
   M7_S_2_L : double = 0.38; 
   M7_S_2_1 : double = 0.16; 
   M7_S_2_1_W : double = 0.4; 
   M7_S_2_1_L : double = 0.4; 
   M7_S_3 : double = 0.50; 
   M7_S_3_W : double = 1.50; 
   M7_S_3_L : double = 1.50; 
   M7_S_4 : double = 1.50; 
   M7_S_4_W : double = 4.50; 
   M7_S_4_L : double = 4.50; 
#endif
M7_S_5 : double = 0.12; 
M7_S_5_Q : double = 0.12; 
M7_S_5_E : double = 0.035; 
M7_EN_2 : double = 0.04; 
M7_EN_3 : double = 0.03; 
M7_W_2 : double = 0.19; 
M7_S_6 : double = 0.19; 
M7_DN_1L : double = 0.1; 
M7_DN_1L_W : double = METAL_LOW_DEN_WINDOW_SIZE; 
M7_DN_1L_S : double = METAL_LOW_DEN_WINDOW_STEP; 
M7_DN_1L_E : double = M7_DN_1L_W / 4; 
M7_DN_1H : double = 0.8; 
M7_DN_1H_W : double = METAL_HIGH_DEN_WINDOW_SIZE; 
M7_DN_1H_S : double = METAL_HIGH_DEN_WINDOW_STEP; 
M7_DN_1H_E : double = M7_DN_1H_W / 4; 
M7_DN_2 : double = 0.9; 
M7_DN_2_W : double = 20; 
M7_DN_2_S : double = 10; 
M7_DN_2_E : double = 5; 
M7_DN_4 : double = 0.4; 
M7_DN_4_W : double = 250; 
VIA7_W_1 : double = 0.36; 
VIA7_W_2 : double = 0.36; 
VIA7_S_1 : double = 0.34; 
VIA7_S_2 : double = 0.54; 
VIA7_S_2_S : double = 0.56; 
VIA7_EN_1 : double = 0.02; 
VIA7_EN_2 : double = 0.08; 
#ifdef HALF_NODE 
   VIA7_R_2_S : double = 1.87;       /* N55  */ 
   VIA7_R_2_W : double = 1.98;       /* N55 */ 
   VIA7_R_3_W : double = 3.3;        /* N55 */ 
   VIA7_R_3_L : double = 11.0;       /* N55 */ 
   VIA7_R_3_D : double = 5.0; 
#else
   VIA7_R_2_S : double = 1.7; 
   VIA7_R_2_W : double = 1.8; 
   VIA7_R_3_W : double = 3.0; 
   VIA7_R_3_L : double = 10.0; 
   VIA7_R_3_D : double = 5.0; 
#endif
VIA7_EN_3 : double = 0.24; 
VIA7_EN_4 : double = 0.20; 
VIA7_S_3 : double = 0.30; 
VIA7_S_4 : double = 0.54; 
VIA7_S_5 : double = 0.54; 
M8_W_1 : double = 0.4; 
M8_W_2 : double = 12.0; 
M8_S_1 : double = 0.4; 
#ifdef HALF_NODE 
   M8_S_2 : double = 0.5; 
   M8_S_2_W : double = 1.65;         /* N55  */ 
   M8_S_2_L : double = 1.65;         /* N55 */ 
   M8_S_3 : double = 1.5; 
   M8_S_3_W : double = 4.95;         /* N55 */ 
   M8_S_3_L : double = 4.95;         /* N55 */ 
#else
   M8_S_2 : double = 0.5; 
   M8_S_2_W : double = 1.5; 
   M8_S_2_L : double = 1.5; 
   M8_S_3 : double = 1.5; 
   M8_S_3_W : double = 4.5; 
   M8_S_3_L : double = 4.5; 
#endif
M8_EN_1 : double = 0.02; 
M8_EN_2 : double = 0.08; 
M8_A_1 : double = 0.565; 
M8_A_2 : double = 0.565; 
M8_DN_1L : double = 0.2; 
M8_DN_1L_W : double = METAL_LOW_DEN_WINDOW_SIZE; 
M8_DN_1L_S : double = METAL_LOW_DEN_WINDOW_STEP; 
M8_DN_1L_E : double = M8_DN_1L_W / 4; 
M8_DN_1H : double = 0.8; 
M8_DN_1H_W : double = METAL_HIGH_DEN_WINDOW_SIZE; 
M8_DN_1H_S : double = METAL_HIGH_DEN_WINDOW_STEP; 
M8_DN_1H_E : double = M8_DN_1H_W / 4; 
M8_DN_2 : double = 0.9; 
M8_DN_2_W : double = 20; 
M8_DN_2_S : double = 10; 
M8_DN_2_E : double = 5; 
M8_DN_4 : double = 0.4; 
M8_DN_4_W : double = 250; 
M8_EN_3 : double = 0.1; 
M8_DN_5L : double = 0.5; 
M8_DN_5L_W : double = 200; 
M8_DN_5L_S : double = 100; 
M8_DN_5L_E : double = 2500; 
M8_DN_5H : double = 0.8; 
M8_DN_5H_W : double = 100; 
M8_DN_5H_S : double = 50; 
M8_DN_5H_E : double = 2500; 
M8_W_4 : double = 0.84; 
M8_S_4 : double = 0.84; 
VIA8_W_1 : double = 0.36; 
VIA8_W_2 : double = 0.36; 
VIA8_S_1 : double = 0.34; 
VIA8_S_2 : double = 0.54; 
VIA8_S_2_S : double = 0.56; 
VIA8_EN_1 : double = 0.02; 
VIA8_EN_2 : double = 0.08; 
#ifdef HALF_NODE 
   VIA8_R_2_S : double = 1.87;       /* N55  */ 
   VIA8_R_2_W : double = 1.98;       /* N55 */ 
   VIA8_R_3_W : double = 3.3;        /* N55 */ 
   VIA8_R_3_L : double = 11.0;       /* N55 */ 
   VIA8_R_3_D : double = 5.0; 
#else
   VIA8_R_2_S : double = 1.7; 
   VIA8_R_2_W : double = 1.8; 
   VIA8_R_3_W : double = 3.0; 
   VIA8_R_3_L : double = 10.0; 
   VIA8_R_3_D : double = 5.0; 
#endif
M9_W_1 : double = 0.4; 
M9_W_2 : double = 12.0; 
M9_S_1 : double = 0.4; 
#ifdef HALF_NODE 
   M9_S_2 : double = 0.5; 
   M9_S_2_W : double = 1.65;         /* N55  */ 
   M9_S_2_L : double = 1.65;         /* N55 */ 
   M9_S_3 : double = 1.5; 
   M9_S_3_W : double = 4.95;         /* N55 */ 
   M9_S_3_L : double = 4.95;         /* N55 */ 
#else
   M9_S_2 : double = 0.5; 
   M9_S_2_W : double = 1.5; 
   M9_S_2_L : double = 1.5; 
   M9_S_3 : double = 1.5; 
   M9_S_3_W : double = 4.5; 
   M9_S_3_L : double = 4.5; 
#endif
M9_EN_1 : double = 0.02; 
M9_EN_2 : double = 0.08; 
M9_A_1 : double = 0.565; 
M9_A_2 : double = 0.565; 
M9_DN_1L : double = 0.2; 
M9_DN_1L_W : double = METAL_LOW_DEN_WINDOW_SIZE; 
M9_DN_1L_S : double = METAL_LOW_DEN_WINDOW_STEP; 
M9_DN_1L_E : double = M9_DN_1L_W / 4; 
M9_DN_1H : double = 0.8; 
M9_DN_1H_W : double = METAL_HIGH_DEN_WINDOW_SIZE; 
M9_DN_1H_S : double = METAL_HIGH_DEN_WINDOW_STEP; 
M9_DN_1H_E : double = M9_DN_1H_W / 4; 
M9_DN_2 : double = 0.9; 
M9_DN_2_W : double = 20; 
M9_DN_2_S : double = 10; 
M9_DN_2_E : double = 5; 
M9_DN_4 : double = 0.4; 
M9_DN_4_W : double = 250; 
CTM_A_1 : double = 1000000; 
CTM_W_1 : double = 2.0; 
CTM_W_2 : double = 100; 
CTM_S_1 : double = 0.8; 
CTM_EN_1 : double = 0.4; 
CBM_W_1 : double = 2.8; 
CBM_W_2 : double = 210; 
CBM_EN_2 : double = 10; 
CBM_S_3 : double = 0.5; 
CBM_S_1 : double = 2.0; 
CBM_S_1_A : double = 40000; 
CBM_S_2 : double = 2.6; 
CBM_S_2_A : double = 40000; 
MX_DN_5 : double = 0.8; 
MX_DN_5_W : double = 50; 
MX_DN_5_S : double = 25; 
MOM_S_1 : double = 0.1; 
MOM_S_2 : double = 0.12; 
MOM_A_1 : double = 7.01E7; 
MOM_S_3 : double = 0.13; 
MOM_S_4 : double = 0.13; 
MOM_A_2 : double = 1.72E5; 
LOGO_S_1 : double = 10.0; 
CSR_R_2 : double = 2.5; 
CSR_S_1 : double = 0.36; 
CSR_EN_1 : double = 0.53; 
CSR_S_2 : double = 0.35; 
CSR_EN_2 : double = 0.525; 
CSR_S_3 : double = 0.34; 
CSR_EN_3 : double = 0.61; 
CSR_S_4 : double = 0.56; 
CSR_EN_4 : double = 0.61; 
CSR_S_5 : double = 0.89; 
CSR_EN_9 : double = 0.345; 
CSR_R_3_X : double = 16; 
CSR_R_3_Y : double = 9; 
CSR_R_3_Z : double = 4; 
CSR_R_3_R : double = 4; 
CSR_W_1 : double = 10.0; 
CSR_W_2_1 : double = 6.0; 
CSR_W_2_2 : double = 10.0; 
CSR_L_1_1 : double = 20.0; 
CSR_L_1_2 : double = 25.0; 
#ifdef WLCSP_SEALRING 
   CSR_EN_5_1 : double = 5.0; 
   CSR_EN_5_2 : double = 9.0; 
#else
   CSR_EN_5_1 : double = 4.0; 
   CSR_EN_5_2 : double = 8.0; 
#endif
CSR_EN_6_A : double = 28.0; 
CSR_EN_6_B : double = 29.0; 
CSR_EN_6_1_L1 : double = 19.0; 
CSR_EN_6_1_L2 : double = 20.0; 
CSR_EN_6_2_L1 : double = 19.2; 
CSR_EN_6_2_L2 : double = 20.3; 
CSR_EN_7_X : double = 0.52; 
CSR_EN_7_Y : double = 0.47; 
CSR_EN_7_Z : double = 0.58; 
CSR_EN_7_R : double = 0.345; 
CSR_EN_8 : double = 0.25; 
SR_EN_1 : double = 0.5; 
SR_S_1 : double = 10; 
AP_W_4 : double = 8.0; 
AP_W_5 : double = 1.5; 
AP_W_6 : double = 1.5; 
#ifdef HALF_NODE 
   AP_S_5 : double = 4; 
   PM_W_5 : double = 5.5; 
   PM_W_6 : double = 10.5; 
#else
   AP_S_5 : double = 3.6; 
   PM_W_5 : double = 5.9; 
   PM_W_6 : double = 10.9; 
#endif
CB_W_7 : double = 2.0; 
AP_EN_3 : double = 1.0; 
AP_EN_3_W : double = 4.5; 
WLCSP_TOL : double = 0.02; 
DOD_W_1 : double = 0.5; 
DOD_S_1 : double = 0.4; 
DOD_S_2 : double = 0.34; 
DOD_S_3 : double = 0.3; 
DOD_S_5 : double = 0.3; 
DOD_S_6 : double = 1.2; 
DOD_S_7 : double = 1.2; 
DOD_S_7_1 : double = 5; 
DOD_S_8 : double = 0.6; 
DOD_S_10 : double = 1.2; 
DOD_EN_1 : double = 0.3; 
DOD_EN_2 : double = 0.6; 
DPO_W_1 : double = 0.4; 
DPO_S_1 : double = 0.3; 
DPO_S_2 : double = 0.2; 
DPO_S_3 : double = 0.5; 
DPO_S_5 : double = 1.2; 
DPO_S_6 : double = 1.2; 
DPO_S_6_1 : double = 5; 
DPO_S_9 : double = 1.2; 
DPO_EN_1 : double = 0.6; 
DM1_W_2 : double = 3.0; 
#ifdef HALF_NODE 
   DM1_S_3 : double = 1.5; 
   DM1_S_3_L : double = 4.95; 
   DM1_S_3_W : double = 4.95; 
   DM1_S_3_1 : double = 0.5; 
   DM1_S_3_1_L : double = 1.65; 
   DM1_S_3_1_W : double = 1.65; 
#else
   DM1_S_3 : double = 1.5; 
   DM1_S_3_L : double = 4.5; 
   DM1_S_3_W : double = 4.5; 
   DM1_S_3_1 : double = 0.5; 
   DM1_S_3_1_L : double = 1.5; 
   DM1_S_3_1_W : double = 1.5; 
#endif
DM1_S_4 : double = 5.0; 
DM1_S_5 : double = 5.0; 
DM1_S_5_1 : double = 5.0; 
DM1_S_8 : double = 2.5; 
DM1_EN_1 : double = 2.5; 
DM2_W_2 : double = 3.0; 
#ifdef HALF_NODE 
   DM2_S_3 : double = 1.5; 
   DM2_S_3_L : double = 4.95; 
   DM2_S_3_W : double = 4.95; 
   DM2_S_3_1 : double = 0.5; 
   DM2_S_3_1_L : double = 1.65; 
   DM2_S_3_1_W : double = 1.65; 
#else
   DM2_S_3 : double = 1.5; 
   DM2_S_3_L : double = 4.5; 
   DM2_S_3_W : double = 4.5; 
   DM2_S_3_1 : double = 0.5; 
   DM2_S_3_1_L : double = 1.5; 
   DM2_S_3_1_W : double = 1.5; 
#endif
DM2_S_4 : double = 5.0; 
DM2_S_5 : double = 5.0; 
DM2_S_5_1 : double = 5.0; 
DM2_S_8 : double = 2.5; 
DM2_EN_1 : double = 2.5; 
DM3_W_2 : double = 3.0; 
#ifdef HALF_NODE 
   DM3_S_3 : double = 1.5; 
   DM3_S_3_L : double = 4.95; 
   DM3_S_3_W : double = 4.95; 
   DM3_S_3_1 : double = 0.5; 
   DM3_S_3_1_L : double = 1.65; 
   DM3_S_3_1_W : double = 1.65; 
#else
   DM3_S_3 : double = 1.5; 
   DM3_S_3_L : double = 4.5; 
   DM3_S_3_W : double = 4.5; 
   DM3_S_3_1 : double = 0.5; 
   DM3_S_3_1_L : double = 1.5; 
   DM3_S_3_1_W : double = 1.5; 
#endif
DM3_S_4 : double = 5.0; 
DM3_S_5 : double = 5.0; 
DM3_S_5_1 : double = 5.0; 
DM3_S_8 : double = 2.5; 
DM3_EN_1 : double = 2.5; 
DM4_W_2 : double = 3.0; 
#ifdef HALF_NODE 
   DM4_S_3 : double = 1.5; 
   DM4_S_3_L : double = 4.95; 
   DM4_S_3_W : double = 4.95; 
   DM4_S_3_1 : double = 0.5; 
   DM4_S_3_1_L : double = 1.65; 
   DM4_S_3_1_W : double = 1.65; 
#else
   DM4_S_3 : double = 1.5; 
   DM4_S_3_L : double = 4.5; 
   DM4_S_3_W : double = 4.5; 
   DM4_S_3_1 : double = 0.5; 
   DM4_S_3_1_L : double = 1.5; 
   DM4_S_3_1_W : double = 1.5; 
#endif
DM4_S_4 : double = 5.0; 
DM4_S_5 : double = 5.0; 
DM4_S_5_1 : double = 5.0; 
DM4_S_8 : double = 2.5; 
DM4_EN_1 : double = 2.5; 
DM5_W_2 : double = 3.0; 
#ifdef HALF_NODE 
   DM5_S_3 : double = 1.5; 
   DM5_S_3_L : double = 4.95; 
   DM5_S_3_W : double = 4.95; 
   DM5_S_3_1 : double = 0.5; 
   DM5_S_3_1_L : double = 1.65; 
   DM5_S_3_1_W : double = 1.65; 
#else
   DM5_S_3 : double = 1.5; 
   DM5_S_3_L : double = 4.5; 
   DM5_S_3_W : double = 4.5; 
   DM5_S_3_1 : double = 0.5; 
   DM5_S_3_1_L : double = 1.5; 
   DM5_S_3_1_W : double = 1.5; 
#endif
DM5_S_4 : double = 5.0; 
DM5_S_5 : double = 5.0; 
DM5_S_5_1 : double = 5.0; 
DM5_S_8 : double = 2.5; 
DM5_EN_1 : double = 2.5; 
DM6_W_2 : double = 3.0; 
#ifdef HALF_NODE 
   DM6_S_3 : double = 1.5; 
   DM6_S_3_L : double = 4.95; 
   DM6_S_3_W : double = 4.95; 
   DM6_S_3_1 : double = 0.5; 
   DM6_S_3_1_L : double = 1.65; 
   DM6_S_3_1_W : double = 1.65; 
#else
   DM6_S_3 : double = 1.5; 
   DM6_S_3_L : double = 4.5; 
   DM6_S_3_W : double = 4.5; 
   DM6_S_3_1 : double = 0.5; 
   DM6_S_3_1_L : double = 1.5; 
   DM6_S_3_1_W : double = 1.5; 
#endif
DM6_S_4 : double = 5.0; 
DM6_S_5 : double = 5.0; 
DM6_S_5_1 : double = 5.0; 
DM6_S_8 : double = 2.5; 
DM6_EN_1 : double = 2.5; 
DM7_W_2 : double = 3.0; 
#ifdef HALF_NODE 
   DM7_S_3 : double = 1.5; 
   DM7_S_3_L : double = 4.95; 
   DM7_S_3_W : double = 4.95; 
   DM7_S_3_1 : double = 0.5; 
   DM7_S_3_1_L : double = 1.65; 
   DM7_S_3_1_W : double = 1.65; 
#else
   DM7_S_3 : double = 1.5; 
   DM7_S_3_L : double = 4.5; 
   DM7_S_3_W : double = 4.5; 
   DM7_S_3_1 : double = 0.5; 
   DM7_S_3_1_L : double = 1.5; 
   DM7_S_3_1_W : double = 1.5; 
#endif
DM7_S_4 : double = 5.0; 
DM7_S_5 : double = 5.0; 
DM7_S_5_1 : double = 5.0; 
DM7_S_8 : double = 2.5; 
DM7_S_9 : double = 1.5; 
DM7_EN_1 : double = 2.5; 
DM8_W_2 : double = 3.0; 
#ifdef HALF_NODE 
   DM8_S_3 : double = 1.5; 
   DM8_S_3_L : double = 4.95; 
   DM8_S_3_W : double = 4.95; 
   DM8_S_3_1 : double = 0.5; 
   DM8_S_3_1_L : double = 1.65; 
   DM8_S_3_1_W : double = 1.65; 
#else
   DM8_S_3 : double = 1.5; 
   DM8_S_3_L : double = 4.5; 
   DM8_S_3_W : double = 4.5; 
   DM8_S_3_1 : double = 0.5; 
   DM8_S_3_1_L : double = 1.5; 
   DM8_S_3_1_W : double = 1.5; 
#endif
DM8_S_4 : double = 5.0; 
DM8_S_5 : double = 5.0; 
DM8_S_5_1 : double = 5.0; 
DM8_S_8 : double = 2.5; 
DM8_EN_1 : double = 2.5; 
DM9_W_2 : double = 3.0; 
#ifdef HALF_NODE 
   DM9_S_3 : double = 1.5; 
   DM9_S_3_L : double = 4.95; 
   DM9_S_3_W : double = 4.95; 
   DM9_S_3_1 : double = 0.5; 
   DM9_S_3_1_L : double = 1.65; 
   DM9_S_3_1_W : double = 1.65; 
#else
   DM9_S_3 : double = 1.5; 
   DM9_S_3_L : double = 4.5; 
   DM9_S_3_W : double = 4.5; 
   DM9_S_3_1 : double = 0.5; 
   DM9_S_3_1_L : double = 1.5; 
   DM9_S_3_1_W : double = 1.5; 
#endif
DM9_S_4 : double = 5.0; 
DM9_S_5 : double = 5.0; 
DM9_S_5_1 : double = 5.0; 
DM9_S_8 : double = 2.5; 
DM9_EN_1 : double = 2.5; 
DM1_W_1 : double = 0.3; 
DM1_S_1 : double = 0.3; 
DM1_S_2 : double = 0.3; 
DM1_A_1 : double = 0.24; 
DM1_A_2 : double = 80.0; 
DM1_S_10 : double = 0.4; 
DM2_W_1 : double = 0.3; 
DM2_S_1 : double = 0.3; 
DM2_S_2 : double = 0.3; 
DM2_A_1 : double = 0.24; 
DM2_A_2 : double = 80.0; 
DM2_S_10 : double = 0.4; 
DM3_W_1 : double = 0.3; 
DM3_S_1 : double = 0.3; 
DM3_S_2 : double = 0.3; 
DM3_A_1 : double = 0.24; 
DM3_A_2 : double = 80.0; 
DM3_S_10 : double = 0.4; 
DM4_W_1 : double = 0.3; 
DM4_S_1 : double = 0.3; 
DM4_S_2 : double = 0.3; 
DM4_A_1 : double = 0.24; 
DM4_A_2 : double = 80.0; 
DM4_S_10 : double = 0.4; 
DM5_W_1 : double = 0.3; 
DM5_S_1 : double = 0.3; 
DM5_S_2 : double = 0.3; 
DM5_A_1 : double = 0.24; 
DM5_A_2 : double = 80.0; 
DM5_S_10 : double = 0.4; 
DM6_W_1 : double = 0.3; 
DM6_S_1 : double = 0.3; 
DM6_S_2 : double = 0.3; 
DM6_A_1 : double = 0.24; 
DM6_A_2 : double = 80.0; 
DM6_S_10 : double = 0.4; 
DM7_W_1 : double = 0.3; 
DM7_S_1 : double = 0.3; 
DM7_S_2 : double = 0.3; 
DM7_A_1 : double = 0.24; 
DM7_A_2 : double = 80.0; 
DM7_S_10 : double = 0.4; 
DM8_W_1 : double = 0.4; 
DM8_S_1 : double = 0.4; 
DM8_S_2 : double = 0.6; 
DM8_A_1 : double = 0.565; 
DM8_A_2 : double = 160.0; 
DM9_W_1 : double = 0.4; 
DM9_S_1 : double = 0.4; 
DM9_S_2 : double = 0.6; 
DM9_A_1 : double = 0.565; 
DM9_A_2 : double = 160.0; 
FU_W_1 : double = 1; 
FU_S_1_1 : double = 2; 
FU_S_4 : double = 27; 
FU_EN_1 : double = 8; 
FU_EN_1_1 : double = 2.2; 
FU_EN_2 : double = 13; 
FU_EN_3 : double = 0.8; 
FU_W_2 : double = 15.2;              /* short-length AP fuse */ 
FU_L_1 : double = 10.8;              /* short-length AP fuse */ 
#ifdef HALF_NODE 
   FU_L_1_1 : double = 6.6;          /* N55 short-length AP fuse */ 
   FU_S_1 : double = 4.18;           /* N55 short-length AP fuse */ 
#else
   FU_L_1_1 : double = 6;            /* short-length AP fuse */ 
   FU_S_1 : double = 3.8;            /* short-length AP fuse */ 
#endif
FU_S_2 : double = 7.8;               /* short-length AP fuse */ 
FU_S_3 : double = 7.6;               /* short-length AP fuse */ 
FU_A_1_L : double = 0.8;             /* short-length AP fuse */ 
FU_A_1_W : double = 1.2;             /* short-length AP fuse */ 
PR_W_1_VX : double = 0.1; 
PR_W_1_VY : double = 0.2; 
PR_W_1_VZ : double = 0.36; 
PR_W_1_VR : double = 0.29; 
PR_S_1 : double = 1.0; 
PR_S_2 : double = 3.2; 
PR_S_3 : double = 0.5; 
PR_EN_1_VX : double = 0.6; 
PR_EN_1_VY : double = 0.52; 
PR_EN_1_VZ : double = 0.52; 
PR_EN_1_VR : double = 0.52; 
PR_EX_2 : double = 12; 
#ifdef HALF_NODE 
   LW_W_1_MIN : double = 11; 
   LW_W_1_MAX : double = 22; 
   LW_L_1_MIN : double = 33; 
   LW_L_1_MAX : double = 55; 
   LW_EN_1 : double = 13.2; 
   LW_EN_2 : double = 33; 
#else
   LW_W_1_MIN : double = 10; 
   LW_W_1_MAX : double = 20; 
   LW_L_1_MIN : double = 30; 
   LW_L_1_MAX : double = 50; 
   LW_EN_1 : double = 12; 
   LW_EN_2 : double = 30; 
#endif
LW_S_1 : double = 5; 
LW_S_2 : double = 15; 
RV_W_1 : double = 3; 
RV_S_1 : double = 3; 
RV_S_3 : double = 6; 
RV_EN_1 : double = 1.5; 
AP_W_1 : double = 3; 
AP_W_2 : double = 35.0; 
AP_W_3 : double = 3; 
AP_S_1 : double = 2; 
AP_S_2 : double = 5; 
AP_S_3 : double = 5; 
AP_EN_1 : double = 1.5; 
AP_EN_2 : double = 1.0; 
TOL : double = 0.01; 
AP_DN_1_L : double = 0.1; 
AP_DN_1_H : double = 0.7; 
LUP_2 : double = 15.0; 
LUP_2_S : double = 5.0; 
LUP_3_W : double = 0.2; 
LUP_3_1_1 : double = 2; 
LUP_3_1_2 : double = 3; 
LUP_3_2_1 : double = 2.3; 
LUP_3_2_2 : double = 4; 
LUP_3_3_1 : double = 2.6; 
LUP_3_3_2 : double = 5; 
LUP_3_4_1 : double = 4; 
LUP_3_4_2 : double = 8; 
LUP_3_5_1 : double = 10; 
LUP_3_5_2 : double = 15; 
LUP_4 : double = 0.12; 
LUP_5_1_1 : double = 2; 
LUP_5_1_2 : double = 3; 
LUP_5_2_1 : double = 2.3; 
LUP_5_2_2 : double = 4; 
LUP_5_3_1 : double = 2.6; 
LUP_5_3_2 : double = 5; 
LUP_5_4_1 : double = 4; 
LUP_5_4_2 : double = 8; 
LUP_5_5_1 : double = 10; 
LUP_5_5_2 : double = 15; 
LUP_6 : double = 30.0; 
LUP_6_SRAM : double = 40.0; 
LUP_10 : double = 75.0; 
LUP_10E : double = 3.0; 
LUP_13 : double = 15.0; 
LUP_14 : double = 0.2; 
ESD_3G_MIN : double = 15.0; 
ESD_3G_MAX : double = 60.0; 
ESD_6G : double = 2.0; 
ESD_7G : double = 2.4; 
ESD_16G : double = 360; 
ESD_17G : double = 360; 
ESD_18G_33V : double = 0.4; 
ESD_18G_25V : double = 0.35; 
ESD_18G_18V : double = 0.2; 
ESD_18G_10V : double = 0.1; 
ESD_20G : double = 0.06; 
ESD_21G : double = 1; 
ESD_22G : double = 1.0; 
ESD_23G : double = 0.22; 
ESD_28G : double = 0.06; 
ESD_30G : double = 1; 
ESD_32G : double = 0.22; 
ESD_33G : double = 0.25; 
ESD_37G : double = 900; 
ESD_48G : double = 0.45; 
ESD_49G : double = 1; 
ESD_50G : double = 1.0; 
ESD_51G : double = 0.22; 
ESD_56G : double = 1; 
ESD_57G : double = 0.22; 
ESD_58G : double = 360; 
ESD_59G : double = 360; 
ESD_60G : double = 0.44; 
ESD_61G_MIN : double = 15; 
ESD_61G_MAX : double = 60; 
ESD_63G : double = 0.86; 
ESD_64G : double = 1.95; 
ESD_65G : double = 0.1; 
ESD_66G : double = 0.22; 
SRAM_WARN_1 : double = 8388608; 
SRAM_W_1 : double = 0.28; 
SRAM_S_1 : double = 0.28; 
SRAM_S_2 : double = 0.12; 
SRAM_EN_1 : double = 0.12; 
SRAM_EX_1 : double = 0.28; 
SRAM_O_1 : double = 0.28; 
SRAM_A_1 : double = 0.6; 
WLD_R_1 : double = 0.05; 
WLD_R_2 : double = 0.043; 
WLD_R_3 : double = 0.14;             /* min. */ 
WLD_R_7 : double = 200; 
BIG_AREA : double = 4000000; 
#ifdef FULL_CHIP 
   #define CHECK_LOW_DENSITY 
#endif
#ifndef DFM_ONLY 
   #ifdef FRONT_END 
      NW_A_2PRE : double = ( ( NW_A_2 + ( NW_S_1 * NW_S_1 * 3.142 ) ) / ( 2 * NW_S_1 ) ) * ( ( NW_A_2 + ( NW_S_1 * NW_S_1 * 3.142 ) ) / ( 2 * NW_S_1 ) ) / 3.141; 
      NW_A_4PRE : double = ( ( NW_A_4 + ( NW_S_1 * NW_S_1 * 3.142 ) ) / ( 2 * NW_S_1 ) ) * ( ( NW_A_4 + ( NW_S_1 * NW_S_1 * 3.142 ) ) / ( 2 * NW_S_1 ) ) / 3.141; 
      NT_N_A_2PRE : double = ( ( NT_N_A_2 + ( NT_N_S_1 * NT_N_S_1 * 3.142 ) ) / ( 2 * NT_N_S_1 ) ) * ( ( NT_N_A_2 + ( NT_N_S_1 * NT_N_S_1 * 3.142 ) ) / ( 2 * NT_N_S_1 ) ) / 3.141; 
      NT_N_A_4PRE : double = ( ( NT_N_A_4 + ( NT_N_S_1 * NT_N_S_1 * 3.142 ) ) / ( 2 * NT_N_S_1 ) ) * ( ( NT_N_A_4 + ( NT_N_S_1 * NT_N_S_1 * 3.142 ) ) / ( 2 * NT_N_S_1 ) ) / 3.141; 
      OD_A_2PRE : double = ( ( OD_A_2 + ( OD_S_1 * OD_S_1 * 3.142 ) ) / ( 2 * OD_S_1 ) ) * ( ( OD_A_2 + ( OD_S_1 * OD_S_1 * 3.142 ) ) / ( 2 * OD_S_1 ) ) / 3.141; 
      PO_A_2PRE : double = ( ( PO_A_2 + ( PO_S_1 * PO_S_1 * 3.142 ) ) / ( 2 * PO_S_1 ) ) * ( ( PO_A_2 + ( PO_S_1 * PO_S_1 * 3.142 ) ) / ( 2 * PO_S_1 ) ) / 3.141; 
      VTH_N_A_2PRE : double = ( ( VTH_N_A_2 + ( VTH_N_S_1 * VTH_N_S_1 * 3.142 ) ) / ( 2 * VTH_N_S_1 ) ) * ( ( VTH_N_A_2 + ( VTH_N_S_1 * VTH_N_S_1 * 3.142 ) ) / ( 2 * VTH_N_S_1 ) ) / 3.141; 
      VTH_P_A_2PRE : double = ( ( VTH_P_A_2 + ( VTH_P_S_1 * VTH_P_S_1 * 3.142 ) ) / ( 2 * VTH_P_S_1 ) ) * ( ( VTH_P_A_2 + ( VTH_P_S_1 * VTH_P_S_1 * 3.142 ) ) / ( 2 * VTH_P_S_1 ) ) / 3.141; 
      VTL_N_A_2PRE : double = ( ( VTL_N_A_2 + ( VTL_N_S_1 * VTL_N_S_1 * 3.142 ) ) / ( 2 * VTL_N_S_1 ) ) * ( ( VTL_N_A_2 + ( VTL_N_S_1 * VTL_N_S_1 * 3.142 ) ) / ( 2 * VTL_N_S_1 ) ) / 3.141; 
      VTL_P_A_2PRE : double = ( ( VTL_P_A_2 + ( VTL_P_S_1 * VTL_P_S_1 * 3.142 ) ) / ( 2 * VTL_P_S_1 ) ) * ( ( VTL_P_A_2 + ( VTL_P_S_1 * VTL_P_S_1 * 3.142 ) ) / ( 2 * VTL_P_S_1 ) ) / 3.141; 
      PP_A_2PRE : double = ( ( PP_A_2 + ( PP_S_1 * PP_S_1 * 3.142 ) ) / ( 2 * PP_S_1 ) ) * ( ( PP_A_2 + ( PP_S_1 * PP_S_1 * 3.142 ) ) / ( 2 * PP_S_1 ) ) / 3.141; 
      NP_A_2PRE : double = ( ( NP_A_2 + ( NP_S_1 * NP_S_1 * 3.142 ) ) / ( 2 * NP_S_1 ) ) * ( ( NP_A_2 + ( NP_S_1 * NP_S_1 * 3.142 ) ) / ( 2 * NP_S_1 ) ) / 3.141; 
      
      // NP.R.2 is checked by PP.R.2
      // NP.R.3 is checked by OD.R.1
      // NP.R.4 is checked by PP.EN.1
      
      //LOGICAL OPERATION RULE
      //======================
      NLDDN1V_SU : double = 0.085; 
      NLDDN1V_SD : double = 0.17; 
      NLDDN2V_SU : double = 0.085; 
      NLDDN2V_SD : double = 0.17; 
      VTLN_SU : double = 0.085; 
      VTLN_SD : double = 0.17; 
      PLDDP1V_SU : double = 0.085; 
      PLDDP1V_SD : double = 0.17; 
      PLDDP2V_SU : double = 0.085; 
      PLDDP2V_SD : double = 0.17; 
      VTLP_SU : double = 0.085; 
      VTLP_SD : double = 0.17; 
      #ifdef LPG 
         DCO_A_2PRE : double = ( ( DCO_A_2 + ( DCO_S_1 * DCO_S_1 * 3.142 ) ) / ( 2 * DCO_S_1 ) ) * ( ( DCO_A_2 + ( DCO_S_1 * DCO_S_1 * 3.142 ) ) / ( 2 * DCO_S_1 ) ) / 3.141; 
      #endif
      RPO_A_2PRE : double = ( ( RPO_A_2 + ( RPO_S_1 * RPO_S_1 * 3.142 ) ) / ( 2 * RPO_S_1 ) ) * ( ( RPO_A_2 + ( RPO_S_1 * RPO_S_1 * 3.142 ) ) / ( 2 * RPO_S_1 ) ) / 3.141; 
      #ifndef HALF_NODE 
         #ifdef LP 
            
            //<VAR.R.2>  is checked by VAR.R.2.a
            //<VAR.R.3>  is checked by VAR.R.6.a
            //<VAR.R.5>  is checked by VAR.R.5.a
            VAR_R_6_1 : double = 0.19; 
            VAR_R_6_2 : double = 0.13; 
         #endif
      #endif
   #endif
   #ifdef BACK_END 
      M1_A_2PRE : double = ( ( M1_A_2 + ( M1_S_1 * M1_S_1 * 3.142 ) ) / ( 2 * M1_S_1 ) ) * ( ( M1_A_2 + ( M1_S_1 * M1_S_1 * 3.142 ) ) / ( 2 * M1_S_1 ) ) / 3.141; 
      #ifdef HALF_NODE 
         VIA1_R_2_S2_S1 : double = ( VIA1_R_2_S2 - VIA1_R_2_S1 - OFFSETX ) / 2; 
      #else
         VIA1_R_2_S2_S1 : double = ( VIA1_R_2_S2 - VIA1_R_2_S1 ) / 2; 
      #endif
      M2_A_2PRE : double = ( ( M2_A_2 + ( M2_S_1 * M2_S_1 * 3.142 ) ) / ( 2 * M2_S_1 ) ) * ( ( M2_A_2 + ( M2_S_1 * M2_S_1 * 3.142 ) ) / ( 2 * M2_S_1 ) ) / 3.141; 
      #ifdef HALF_NODE 
         VIA2_R_2_S2_S1 : double = ( VIA2_R_2_S2 - VIA2_R_2_S1 - OFFSETX ) / 2; 
      #else
         VIA2_R_2_S2_S1 : double = ( VIA2_R_2_S2 - VIA2_R_2_S1 ) / 2; 
      #endif
      M3_A_2PRE : double = ( ( M3_A_2 + ( M3_S_1 * M3_S_1 * 3.142 ) ) / ( 2 * M3_S_1 ) ) * ( ( M3_A_2 + ( M3_S_1 * M3_S_1 * 3.142 ) ) / ( 2 * M3_S_1 ) ) / 3.141; 
      M1_DN_6 = 0.15; 
      #ifdef HALF_NODE 
         VIA3_R_2_S2_S1 : double = ( VIA3_R_2_S2 - VIA3_R_2_S1 - OFFSETX ) / 2; 
      #else
         VIA3_R_2_S2_S1 : double = ( VIA3_R_2_S2 - VIA3_R_2_S1 ) / 2; 
      #endif
      M4_A_2PRE : double = ( ( M4_A_2 + ( M4_S_1 * M4_S_1 * 3.142 ) ) / ( 2 * M4_S_1 ) ) * ( ( M4_A_2 + ( M4_S_1 * M4_S_1 * 3.142 ) ) / ( 2 * M4_S_1 ) ) / 3.141; 
      M2_DN_6 = 0.15; 
      #ifdef HALF_NODE 
         VIA4_R_2_S2_S1 : double = ( VIA4_R_2_S2 - VIA4_R_2_S1 - OFFSETX ) / 2; 
      #else
         VIA4_R_2_S2_S1 : double = ( VIA4_R_2_S2 - VIA4_R_2_S1 ) / 2; 
      #endif
      M5_A_2PRE : double = ( ( M5_A_2 + ( M5_S_1 * M5_S_1 * 3.142 ) ) / ( 2 * M5_S_1 ) ) * ( ( M5_A_2 + ( M5_S_1 * M5_S_1 * 3.142 ) ) / ( 2 * M5_S_1 ) ) / 3.141; 
      M3_DN_6 = 0.15; 
      #ifdef HALF_NODE 
         VIA5_R_2_S2_S1 : double = ( VIA5_R_2_S2 - VIA5_R_2_S1 - OFFSETX ) / 2; 
      #else
         VIA5_R_2_S2_S1 : double = ( VIA5_R_2_S2 - VIA5_R_2_S1 ) / 2; 
      #endif
      M6_A_2PRE : double = ( ( M6_A_2 + ( M6_S_1 * M6_S_1 * 3.142 ) ) / ( 2 * M6_S_1 ) ) * ( ( M6_A_2 + ( M6_S_1 * M6_S_1 * 3.142 ) ) / ( 2 * M6_S_1 ) ) / 3.141; 
      M4_DN_6 = 0.15; 
      #ifdef HALF_NODE 
         VIA6_R_2_S2_S1 : double = ( VIA6_R_2_S2 - VIA6_R_2_S1 - OFFSETX ) / 2; 
      #else
         VIA6_R_2_S2_S1 : double = ( VIA6_R_2_S2 - VIA6_R_2_S1 ) / 2; 
      #endif
      M7_A_2PRE : double = ( ( M7_A_2 + ( M7_S_1 * M7_S_1 * 3.142 ) ) / ( 2 * M7_S_1 ) ) * ( ( M7_A_2 + ( M7_S_1 * M7_S_1 * 3.142 ) ) / ( 2 * M7_S_1 ) ) / 3.141; 
      M5_DN_6 = 0.15; 
      M8_A_2PRE : double = ( ( M8_A_2 + ( M8_S_1 * M8_S_1 * 3.142 ) ) / ( 2 * M8_S_1 ) ) * ( ( M8_A_2 + ( M8_S_1 * M8_S_1 * 3.142 ) ) / ( 2 * M8_S_1 ) ) / 3.141; 
      M9_A_2PRE : double = ( ( M9_A_2 + ( M9_S_1 * M9_S_1 * 3.142 ) ) / ( 2 * M9_S_1 ) ) * ( ( M9_A_2 + ( M9_S_1 * M9_S_1 * 3.142 ) ) / ( 2 * M9_S_1 ) ) / 3.141; 
      #ifdef HALF_NODE 
         M1_THICKNESS = 0.16; 
      #else
         M1_THICKNESS = 0.18; 
      #endif
      #ifdef HALF_NODE 
         M2_THICKNESS = 0.2; 
      #else
         M2_THICKNESS = 0.22; 
      #endif
      V1_THICKNESS = 0.175; 
      #ifdef HALF_NODE 
         M3_THICKNESS = 0.2; 
      #else
         M3_THICKNESS = 0.22; 
      #endif
      V2_THICKNESS = 0.175; 
      #ifdef HALF_NODE 
         M4_THICKNESS = 0.2; 
      #else
         M4_THICKNESS = 0.22; 
      #endif
      V3_THICKNESS = 0.175; 
      #ifdef HALF_NODE 
         M5_THICKNESS = 0.2; 
      #else
         M5_THICKNESS = 0.22; 
      #endif
      V4_THICKNESS = 0.175; 
      #ifdef HALF_NODE 
         M6_THICKNESS = 0.2; 
      #else
         M6_THICKNESS = 0.22; 
      #endif
      V5_THICKNESS = 0.175; 
      #ifdef HALF_NODE 
         M7_THICKNESS = 0.2; 
      #else
         M7_THICKNESS = 0.22; 
      #endif
      V6_THICKNESS = 0.175; 
      M8_THICKNESS = 0.9; 
      V7_THICKNESS = 0.595; 
      M9_THICKNESS = 0.9; 
      V8_THICKNESS = 0.595; 
      #ifdef _28K_AP 
         AP_THICKNESS = 2.8; 
      #else
         AP_THICKNESS = 1.45; 
      #endif
      RV_THICKNESS = 0.8; 
      IND_W_1 : double = 0.4; 
      IND_W_2 : double = 0.6; 
      IND_W_3 : double = 0.8; 
      IND_W_4 : double = 12; 
      IND_W_5 : double = 12; 
      IND_W_6 : double = 30; 
      IND_S_1 : double = 0.4; 
      IND_S_2 : double = 0.6; 
      IND_S_3 : double = 0.8; 
      IND_S_4 : double = 1.0; 
      IND_S_5 : double = 2.0; 
      IND_MD_DN_10 : double = 0.15; 
      IND_MD_DN_10W : double = 15; 
      IND_MD_DN_10R : double = 5; 
      IND_MD_R_17 : double = 0.2; 
      IND_MD_R_17_N : double = 100; 
      IND_MD_W_1 : double = 0.4; 
      IND_MD_W_2 : double = 0.6; 
      IND_MD_W_3 : double = 0.8; 
      IND_MD_W_4 : double = 12; 
      IND_MD_S_1 : double = 0.4; 
      IND_MD_S_2 : double = 0.6; 
      IND_MD_S_3 : double = 0.8; 
      IND_MD_S_4 : double = 1.0; 
      IND_MD_S_5 : double = 2.0; 
   #endif
   #ifdef FRONT_END 
      ESDIMP_W_1 : double = 0.6; 
      ESDIMP_S_1 : double = 0.6; 
      ESDIMP_S_2 : double = 0.6; 
      ESDIMP_EN_1 : double = 0.4; 
      ESDIMP_A_1 : double = 1.0; 
      ESDIMP_A_2 : double = 1.0; 
   #endif
#endif
#ifdef DFM 
   #ifdef Required 
      #define _POS2_                      /* Systematic(Litho/OPC/Others) and SPICE related  */ 
      #define _POEX2_                     /* Systematic(Others) and SPICE related  */ 
      #define _POS5_                      /* Systematic(Litho/OPC) and SPICE related */ 
   #endif
   #ifdef Recommended 
      
      // Start of recommended DFM rules  
      #define _OPCR1_                     /* Systematic(Litho/OPC) related  */ 
      #define _DNWEN1_                    /* Systematic(Others) related  */ 
      #define _ODW2_                      /* SPICE related */ 
      #define _ODS1_                      /* Defect related */ 
      #define _ODS6_                      /* Systematic(Others) related  */ 
      #define _NWRODS3_                   /* SPICE related */ 
      #define _NWRODR1_                   /* SPICE related  */ 
      #define _NWRSTIEN2_                 /* SPICE related */ 
      #define _NWRSTIR1_                  /* SPICE related */ 
      #define _POS1_                      /* Defect related */ 
      #define _POS4_1_                    /* SPICE related */ 
      #define _POS11_                     /* Systematic(Litho/OPC) related */ 
      #define _POS13_                     /* Systematic(Litho/OPC) related  */ 
      #define _POS14_                     /* Systematic(Others) and SPICE related */ 
      #define _POEN1_                     /* Systematic(Others) and SPICE related */ 
      #define _POEN2_                     /* Systematic(Others) and SPICE related */ 
      #define _POEN3_                     /* Systematic(Others) and SPICE related */ 
      #define _RES2_                      /* SPICE related */ 
      #define _RES8_                      /* SPICE related */ 
      #define _RES9_                      /* SPICE related */ 
      #define _COEN1_                     /* Systematic(Litho/OPC) and SPICE related */ 
      #define _COEN3_                     /* Systematic(Litho/OPC) and SPICE related */ 
      #define _COS3_                      /* 1st priority, Systematic(Others) and Defect related */ 
      #define _M1S1_                      /* Defect related */ 
      #define _M1S7_                      /* Systematic(Others) related */ 
      #define _M1EN1_M1EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIA1EN1_VIA1EN2_           /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _M2S1_                      /* Defect related */ 
      #define _M2S7_                      /* Systematic(Others) related */ 
      #define _M2EN1_M2EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIA2EN1_VIA2EN2_           /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _M3S1_                      /* Defect related */ 
      #define _M3S7_                      /* Systematic(Others) related */ 
      #define _M3EN1_M3EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIA3EN1_VIA3EN2_           /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _M4S1_                      /* Defect related */ 
      #define _M4S7_                      /* Systematic(Others) related */ 
      #define _M4EN1_M4EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIA4EN1_VIA4EN2_           /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _M5S1_                      /* Defect related */ 
      #define _M5S7_                      /* Systematic(Others) related */ 
      #define _M5EN1_M5EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIA5EN1_VIA5EN2_           /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _M6S1_                      /* Defect related */ 
      #define _M6S7_                      /* Systematic(Others) related */ 
      #define _M6EN1_M6EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIA6EN1_VIA6EN2_           /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _M7S1_                      /* Defect related */ 
      #define _M7S7_                      /* Systematic(Others) related */ 
      #define _M7EN1_M7EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIAxR8_                    /* Systematic(CMP) related */ 
      #define _DTCDDN1_                   /* Systematic(Others) related */ 
   #endif
   #ifdef Guideline 
      #define _OPCR2_                     /* Systematic(Litho/OPC) related */ 
      #define _NWR1_                      /* Systematic(Other) and SPICE related */ 
      #define _DNWR6_                     /* Systematic(Other) and SPICE related */ 
      #define _NWRODR3_NWRSTIR3_          /* SPICE related */ 
      #define _COS6_                      /* SPICE related   */ 
      #define _COR5_                      /* 1st priority, Defect and SPICE related  */ 
      #define _VIA1R9_                    /* 1st priority, Defect and SPICE related                        */ 
      #define _VIA2R9_                    /* 1st priority, Defect and SPICE related                        */ 
      #define _VIA3R9_                    /* 1st priority, Defect and SPICE related                        */ 
      #define _VIA4R9_                    /* 1st priority, Defect and SPICE related                        */ 
      #define _VIA5R9_                    /* 1st priority, Defect and SPICE related                        */ 
      #define _VIA6R9_                    /* 1st priority, Defect and SPICE related                        */ 
      #define _VIA7R5_                    /* 1st priority, Defect and SPICE related */ 
      #define _VIA8R5_                    /* 1st priority, Defect and SPICE related */ 
   #endif
   #ifdef Analog 
      
      // Start of Analog DFM rules 
      #define _POS5m_ 
      #define _POS6m_ 
      #define _RES5m_ 
      #define _BJTR2_ 
      #define _ANR17_ 
      #define _ANR20_ 
      #define _ANR47_ 
   #endif
   #ifdef First_priority 
      #define _COS3_                      /* 1st priority, Systematic(Others) and Defect related */ 
      #define _COR5_                      /* 1st priority, Defect and SPICE related */ 
      #define _M1EN1_M1EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIA1EN1_VIA1EN2_           /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _M2EN1_M2EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIA1R9_                    /* 1st priority, Defect and SPICE related */ 
      #define _VIA2EN1_VIA2EN2_           /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _M3EN1_M3EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIA2R9_                    /* 1st priority, Defect and SPICE related */ 
      #define _VIA3EN1_VIA3EN2_           /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _M4EN1_M4EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIA3R9_                    /* 1st priority, Defect and SPICE related */ 
      #define _VIA4EN1_VIA4EN2_           /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _M5EN1_M5EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIA4R9_                    /* 1st priority, Defect and SPICE related */ 
      #define _VIA5EN1_VIA5EN2_           /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _M6EN1_M6EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIA5R9_                    /* 1st priority, Defect and SPICE related */ 
      #define _VIA6EN1_VIA6EN2_           /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _M7EN1_M7EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIA6R9_                    /* 1st priority, Defect and SPICE related */ 
      #define _VIA7R5_                    /* 1st priority, Defect and SPICE related */ 
      #define _VIA8R5_                    /* 1st priority, Defect and SPICE related */ 
   #endif
   #ifdef Systematic 
      #define _OPCR2_                     /* Systematic(Litho/OPC) related */ 
      #define _NWR1_                      /* Systematic(Other) and SPICE related */ 
      #define _DNWR6_                     /* Systematic(Other) and SPICE related */ 
      #define _POS2_                      /* Systematic(Litho/OPC/Others) and SPICE related  */ 
      #define _POEX2_                     /* Systematic(Others) and SPICE related  */ 
      #define _POS5_                      /* Systematic(Litho/OPC) and SPICE related */ 
      #define _POS14_                     /* Systematic(Others) and SPICE related */ 
      #define _POEN1_                     /* Systematic(Others) and SPICE related */ 
      #define _POEN2_                     /* Systematic(Others) and SPICE related */ 
      #define _POEN3_                     /* Systematic(Others) and SPICE related */ 
      #define _OPCR1_                     /* Systematic(Litho/OPC) related  */ 
      #define _ODS6_                      /* Systematic(Others) related  */ 
      #define _DNWEN1_                    /* Systematic(Others) related  */ 
      #define _POS11_                     /* Systematic(Litho/OPC) related */ 
      #define _POS13_                     /* Systematic(Litho/OPC) related  */ 
      #define _COEN3_                     /* Systematic(Litho/OPC) and SPICE related */ 
      #define _COS3_                      /* 1st priority, Systematic(Others) and Defect related */ 
      #define _COEN1_                     /* Systematic(Litho/OPC) and SPICE related */ 
      #define _M1S7_                      /* Systematic(Others) related */ 
      #define _M1EN1_M1EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIA1EN1_VIA1EN2_           /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _M2S7_                      /* Systematic(Others) related */ 
      #define _M2EN1_M2EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIA2EN1_VIA2EN2_           /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _M3S7_                      /* Systematic(Others) related */ 
      #define _M3EN1_M3EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIA3EN1_VIA3EN2_           /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _M4S7_                      /* Systematic(Others) related */ 
      #define _M4EN1_M4EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIA4EN1_VIA4EN2_           /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _M5S7_                      /* Systematic(Others) related */ 
      #define _M5EN1_M5EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIA5EN1_VIA5EN2_           /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _M6S7_                      /* Systematic(Others) related */ 
      #define _M6EN1_M6EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIA6EN1_VIA6EN2_           /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _M7S7_                      /* Systematic(Others) related */ 
      #define _M7EN1_M7EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIAxR8_                    /* Systematic(CMP) related */ 
      #define _DTCDDN1_                   /* Systematic(Others) related */ 
   #endif
   #ifdef Defect 
      #define _ODS1_                      /* Defect related */ 
      #define _COS3_                      /* 1st priority, Systematic(Others) and Defect related */ 
      #define _POS1_                      /* Defect related */ 
      #define _M1S1_                      /* Defect related */ 
      #define _COR5_                      /* 1st priority, Defect and SPICE related  */ 
      #define _VIA1R9_                    /* 1st priority, Defect and SPICE related */ 
      #define _M2S1_                      /* Defect related */ 
      #define _VIA2R9_                    /* 1st priority, Defect and SPICE related */ 
      #define _M3S1_                      /* Defect related */ 
      #define _VIA3R9_                    /* 1st priority, Defect and SPICE related */ 
      #define _M4S1_                      /* Defect related */ 
      #define _VIA4R9_                    /* 1st priority, Defect and SPICE related */ 
      #define _M5S1_                      /* Defect related */ 
      #define _VIA5R9_                    /* 1st priority, Defect and SPICE related */ 
      #define _M6S1_                      /* Defect related */ 
      #define _VIA6R9_                    /* 1st priority, Defect and SPICE related */ 
      #define _M7S1_                      /* Defect related */ 
      #define _VIA7R5_                    /* 1st priority, Defect and SPICE related */ 
      #define _VIA8R5_                    /* 1st priority, Defect and SPICE related */ 
   #endif
   #ifdef d_SPICE
      #define _POS2_                      /* Systematic(Litho/OPC/Others) and SPICE related  */ 
      #define _POEX2_                     /* Systematic(Others) and SPICE related  */ 
      #define _POS5_                      /* Systematic(Litho/OPC) and SPICE related */ 
      #define _POS14_                     /* Systematic(Others) and SPICE related */ 
      #define _POEN1_                     /* Systematic(Others) and SPICE related */ 
      #define _POEN2_                     /* Systematic(Others) and SPICE related */ 
      #define _POEN3_                     /* Systematic(Others) and SPICE related */ 
      #define _RES5m_                     /* SPICE related */ 
      #define _ODW2_                      /* SPICE related */ 
      #define _NWRODS3_                   /* SPICE related */ 
      #define _NWRODR1_                   /* SPICE related  */ 
      #define _NWRSTIEN2_                 /* SPICE related */ 
      #define _NWRSTIR1_                  /* SPICE related */ 
      #define _POS4_1_                    /* SPICE related */ 
      #define _RES2_                      /* SPICE related */ 
      #define _RES8_                      /* SPICE related */ 
      #define _RES9_                      /* SPICE related */ 
      #define _COEN3_                     /* Systematic(Litho/OPC) and SPICE related */ 
      #define _COEN1_                     /* Systematic(Litho/OPC) and SPICE related */ 
      #define _M1EN1_M1EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIA1EN1_VIA1EN2_           /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _M2EN1_M2EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIA2EN1_VIA2EN2_           /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _M3EN1_M3EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIA3EN1_VIA3EN2_           /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _M4EN1_M4EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIA4EN1_VIA4EN2_           /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _M5EN1_M5EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIA5EN1_VIA5EN2_           /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _M6EN1_M6EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _VIA6EN1_VIA6EN2_           /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _M7EN1_M7EN2_               /* 1st priority, Systematic(Litho/OPC) and SPICE related */ 
      #define _NWR1_                      /* Systematic(Other) and SPICE related */ 
      #define _DNWR6_                     /* Systematic(Other) and SPICE related */ 
      #define _NWRODR3_NWRSTIR3_          /* SPICE related */ 
      #define _COS6_                      /* SPICE related   */ 
      #define _COR5_                      /* 1st priority, Defect and SPICE related  */ 
      #define _VIA1R9_                    /* 1st priority, Defect and SPICE related                        */ 
      #define _VIA2R9_                    /* 1st priority, Defect and SPICE related                        */ 
      #define _VIA3R9_                    /* 1st priority, Defect and SPICE related                        */ 
      #define _VIA4R9_                    /* 1st priority, Defect and SPICE related                        */ 
      #define _VIA5R9_                    /* 1st priority, Defect and SPICE related                        */ 
      #define _VIA6R9_                    /* 1st priority, Defect and SPICE related                        */ 
      #define _VIA7R5_                    /* 1st priority, Defect and SPICE related */ 
      #define _VIA8R5_                    /* 1st priority, Defect and SPICE related */ 
   #endif
#endif


/*Library Setup*/

library( 
    cell         = "TOPCELLNAME",
    format       = GDSII,
    library_name = "GDSFILENAME"
);
error_options( 
    error_limit_per_check   = 10000    /* MAXIMUM RESULTS limited from 'ALL' */
);
gds_options( 
    box            = CONVERT_TO_RECT,
    duplicate_cell = DROP
);
resolution_options( 
    internal_resolution = 0.001
);
layout_drawn_options( 
    self_intersect        = true,
    self_intersect_action = FILL
);
layout_grid_options( 
    check_45   = {},
    check_90   = {}
);
text_options( 
    colon_text     = REGULAR_TEXT,
    promote_text   = "*",
    semicolon_text = REGULAR_TEXT
);
run_options( 
    uppercase = true
);
#ifdef OVERRIDE_FILE
#include "override_file.rs"
#endif

CONNECT_DB : connect_database = NULL_CONNECT_DATABASE;
_den_con : constraint of double;
_den_polygon_area_clip : boolean;
_den_print : boolean;
_den_print_only : boolean;
_gden_con : constraint of double;
_gden_gcon : constraint of double;
_gden_absolute : boolean;
_gden_corner : boolean;
_gden_corner_value : double;
_gden_polygon_area_clip : boolean;
_gden_print : boolean;
_gden_print_only : boolean;

/* Begin of Equation Code-Based Functions definitions */

#define dblnp(value) (((value) > 0.0) ? 0.0 : 1.0)

#define dblnz(value) ((((value) < 0.0) || ((value) > 0.0)) ? 1.0 : 0.0)

#define dblz(value) ((((value) < 0.0) || ((value) > 0.0)) ? 0.0 : 1.0)
size_inside_wrapper : published function (
    layer1           : polygon_layer,
    bounding         : polygon_layer,
    distance         : double,
    increment        : double = 0.0,
    corner_extension : corner_extension_e = INTERSECTION,
    radial_sectors   : integer = 0
)
    returning size_inside_wrapper_result : polygon_layer
{
    size_pl : polygon_layer;

    if (dblge(increment, distance) || dbleq(increment, 0.0)) {
        size_pl  = size(layer1, distance, clip_acute = BISECTOR, corner_extension = corner_extension, radial_sectors   = radial_sectors);
        size_inside_wrapper_result = and(size_pl, bounding);
    }
    else {
        size_pl  = size(layer1, increment, clip_acute = BISECTOR, corner_extension = corner_extension, radial_sectors   = radial_sectors);
        size_inside_wrapper_result =
            size_inside(size_pl,
                        bounding,
                        distance         = distance - increment,
                        increment        = increment,
                        output_type      = OVERSIZE,
                        corner_extension = corner_extension,
                        radial_sectors   = radial_sectors);
    }
}
inv_cell_name : inline function (
    cellname : string
)
    returning result : string
{
    result = "!" + cellname;
}

double_constraint_contains_bk : published function (
    con : constraint of double,
    val : double
)
    returning result : boolean
{
    cat = con.category();

    result = false;

    if (cat == CONSTRAINT_EQ) {
        result = dbleq(val, con.lo());
    }
    elif (cat == CONSTRAINT_NE) {
        result = dblne(val, con.lo());
    }
    elif (cat == CONSTRAINT_GE) {
        result = dblge(val, con.lo());
    }
    elif (cat == CONSTRAINT_GT) {
        result = dblgt(val, con.lo());
    }
    elif (cat == CONSTRAINT_LE) {
        result = dblle(val, con.hi());
    }
    elif (cat == CONSTRAINT_LT) {
        result = dbllt(val, con.hi());
    }
    elif (cat == CONSTRAINT_GELE) {
        result = (dblge(val, con.lo()) && dblle(val, con.hi()));
    }
    elif (cat == CONSTRAINT_GELT) {
        result = (dblge(val, con.lo()) && dbllt(val, con.hi()));
    }
    elif (cat == CONSTRAINT_GTLE) {
        result = (dblgt(val, con.lo()) && dblle(val, con.hi()));
    }
    elif (cat == CONSTRAINT_GTLT) {
        result = (dblgt(val, con.lo()) && dbllt(val, con.hi()));
    }
}




double_constraint_contains : published function (
    con : constraint of double,
    val : double
)
    returning result : boolean
{
    cat = con.category();

    result = false;

    if (cat == CONSTRAINT_EQ) {
        result = dbleq(val - con.lo(), 0);
    }
    elif (cat == CONSTRAINT_NE) {
        result = dblne(val - con.lo(), 0);
    }
    elif (cat == CONSTRAINT_GE) {
        result = dblge(val - con.lo(), 0);
    }
    elif (cat == CONSTRAINT_GT) {
        result = dblgt(val - con.lo(), 0);
    }
    elif (cat == CONSTRAINT_LE) {
        result = dblle(val - con.hi(), 0);
    }
    elif (cat == CONSTRAINT_LT) {
        result = dbllt(val - con.hi(), 0);
    }
    elif (cat == CONSTRAINT_GELE) {
        result = (dblge(val - con.lo(), 0) && dblle(val - con.hi(), 0));
    }
    elif (cat == CONSTRAINT_GELT) {
        result = (dblge(val - con.lo(), 0) && dbllt(val - con.hi(), 0));
    }
    elif (cat == CONSTRAINT_GTLE) {
        result = (dblgt(val - con.lo(), 0) && dblle(val - con.hi(), 0));
    }
    elif (cat == CONSTRAINT_GTLT) {
        result = (dblgt(val - con.lo(), 0) && dbllt(val - con.hi(), 0));
    }
}

nar_funcs_e : newtype enum of {
    UNKNOWN,
    NAR_SAVE_NET_5,
    NAR_SAVE_NET_6,
    NAR_SAVE_NET_9,
    NAR_SAVE_NET_15,
    NAR_SAVE_NET_16,
    NAR_SAVE_NET_17,
    NAR_SAVE_NET_18,
    NAR_SAVE_NET_19,
    NAR_SAVE_NET_20,
    NAR_SAVE_NET_21,
    NARACC_SAVE_NET_22
};
nar_void_func_s : newtype struct of {
    func : function (void) returning void;
};
nar_void_func_h : newtype hash of nar_funcs_e to nar_void_func_s;
nar_constrained_area_s : newtype struct of {
    area    : constraint of double = > 0;
    layer1  : string               = "";
    factor1 : double               = 1.0;
    layer2  : string               = "";
    factor2 : double               = 1.0;
};
nar_constrained_areas_h : newtype hash of string to nar_constrained_area_s;

net_area_ratio : published function (
    cdb_in            : connect_database,
    con               : constraint of double,
    layer_groups      : layer_groups_h,
    denominator_start : integer,
    denominator_end   : integer,
    constrained_areas : nar_constrained_areas_h = { },
    func_enum         : nar_funcs_e             = UNKNOWN,
    expr_is_default   : boolean                 = false
)
    returning net_area_ratio_result : polygon_layer
{
    nar_funcs   : nar_void_func_h = { };
    nar_func    : function (void) returning void;
    con2any     : list of polygon_layer = { };
    not_con2any : list of polygon_layer = { };
    n_layer_0   : polygon_layer;

    /* Declare and register equation code function. */
    nar_save_net_5 : function (void) returning void
    {
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");
        areaL5 = ns_net_area("layer5");
        areaL6 = ns_net_area("layer6");
        areaL7 = ns_net_area("layer7");
        areaL8 = ns_net_area("layer8");
        areaL9 = ns_net_area("layer9");
        areaL10 = ns_net_area("layer10");

        ratio = dblz(areaL2) * dblz(areaL3) * dblz(areaL4) * dblz(areaL5) * dblz(areaL6) * dblz(areaL7) * dblz(areaL8) * dblz(areaL9) + dblz(areaL10);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_5] = { nar_save_net_5 };
 
    /* Declare and register equation code function. */
    nar_save_net_6 : function (void) returning void
    {
        countL1 = ns_net_data_count("layer1");
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");
        areaL5 = ns_net_area("layer5");
        areaL6 = ns_net_area("layer6");
        areaL7 = ns_net_area("layer7");
        areaL8 = ns_net_area("layer8");
        areaL9 = ns_net_area("layer9");

        ratio = dblnp( countL1 - 1 ) * dblz(areaL2) * dblz(areaL3) * dblz(areaL4) * dblz(areaL5) * dblz(areaL6) * dblz(areaL7) * dblz(areaL8) * dblz(areaL9);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_6] = { nar_save_net_6 };
 
    /* Declare and register equation code function. */
    nar_save_net_9 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");
        areaL2 = ns_net_area("layer2");

        con_eq_zero : boolean = ((con.category() == CONSTRAINT_EQ) && dbleq(con.lo(), 0));
        if (( areaL1 > 0) || con_eq_zero) {
            ratio = ( areaL1 > 0 ) ? areaL2 / areaL1 : 0;

            if (double_constraint_contains(con, ratio)) {
                ns_save_net({"ratio"}, {ratio});
            }
        }
    }
    nar_funcs[NAR_SAVE_NET_9] = { nar_save_net_9 };
 
    /* Declare and register equation code function. */
    nar_save_net_15 : function (void) returning void
    {
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");
        areaL5 = ns_net_area("layer5");

        ratio = dblnz(areaL2) + dblnz(areaL3) + dblnz(areaL4) + dblnz(areaL5);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_15] = { nar_save_net_15 };
 
    /* Declare and register equation code function. */
    nar_save_net_16 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");
        areaL2 = ns_net_area("layer2");

        ratio = dblnz(areaL1) * dblnz(areaL2);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_16] = { nar_save_net_16 };
 
    /* Declare and register equation code function. */
    nar_save_net_17 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");
        areaL5 = ns_net_area("layer5");

        ratio = dblnz(areaL1) * dblz(areaL5) * ( dblnz(areaL2) + dblnz(areaL3) + dblnz(areaL4) );

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_17] = { nar_save_net_17 };
 
    /* Declare and register equation code function. */
    nar_save_net_18 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");
        areaL5 = ns_net_area("layer5");

        ratio = dblnz(areaL1) * ( dblnz(areaL2) + dblnz(areaL3) + dblnz(areaL4) + dblnz(areaL5) );

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_18] = { nar_save_net_18 };
 
    /* Declare and register equation code function. */
    nar_save_net_19 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");

        ratio = ( areaL1 ) / GRID; 

        if (double_constraint_contains(con, ratio) && !isinf(ratio) && !isnan(ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_19] = { nar_save_net_19 };
 
    /* Declare and register equation code function. */
    nar_save_net_20 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");

        ratio = ( areaL1 / 2 ) / GRID; 

        if (double_constraint_contains(con, ratio) && !isinf(ratio) && !isnan(ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_20] = { nar_save_net_20 };
 
    /* Declare and register equation code function. */
    nar_save_net_21 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");

        ratio = areaL1 / GRID; 

        if (double_constraint_contains(con, ratio) && !isinf(ratio) && !isnan(ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_21] = { nar_save_net_21 };

    /* Lookup the net_function to use in this num/den instance. */
    nar_func = nar_funcs[func_enum].func;

    n_layer_0 = layer_groups["layer1"][0];

    if (expr_is_default && (layer_groups.size() > 1)) {
        d_layers : list of polygon_layer = { };

        for (i = denominator_start to denominator_end) {
            d_layers.push_back(layer_groups["layer" + i][0]);
        }

        if ((con.category() == CONSTRAINT_EQ) && !((con.lo() > 0.0) || (con.lo() < 0.0))) {
            not_con2any = d_layers;
        }
        else {
            con2any = d_layers;
        }
    }

    net_area_ratio_result = net_select(
        connect_sequence     = cdb_in,
        net_function         = nar_func,
        layer_groups         = layer_groups,
        connected_to_all     = { n_layer_0 },
        connected_to_any     = con2any,
        not_connected_to_any = not_con2any,
        output_from_layers   = { n_layer_0 }
    );
}

full_neighborhood : list of window_offset_e = {
    UPPER_LEFT, UP, UPPER_RIGHT,
    LEFT, RIGHT,
    LOWER_LEFT, DOWN, LOWER_RIGHT
};

adjacent_neighborhood : list of window_offset_e = {
    UP, LEFT, RIGHT, DOWN
};

corner_neighborhood : list of window_offset_e = {
    UPPER_LEFT, UPPER_RIGHT,
    LOWER_LEFT, LOWER_RIGHT
};

net_area_ratio : published function (
    cdb_in            : connect_database,
    con               : constraint of double,
    layer_groups      : layer_groups_h,
    denominator_start : integer,
    denominator_end   : integer,
    constrained_areas : nar_constrained_areas_h = { },
    func_enum         : nar_funcs_e             = UNKNOWN,
    expr_is_default   : boolean                 = false
)
    returning void
{
    nar_funcs   : nar_void_func_h = { };
    nar_func    : function (void) returning void;
    con2any     : list of polygon_layer = { };
    not_con2any : list of polygon_layer = { };
    n_layer_0   : polygon_layer;

    /* Declare and register equation code function. */
    nar_save_net_5 : function (void) returning void
    {
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");
        areaL5 = ns_net_area("layer5");
        areaL6 = ns_net_area("layer6");
        areaL7 = ns_net_area("layer7");
        areaL8 = ns_net_area("layer8");
        areaL9 = ns_net_area("layer9");
        areaL10 = ns_net_area("layer10");

        ratio = dblz(areaL2) * dblz(areaL3) * dblz(areaL4) * dblz(areaL5) * dblz(areaL6) * dblz(areaL7) * dblz(areaL8) * dblz(areaL9) + dblz(areaL10);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_5] = { nar_save_net_5 };
 
    /* Declare and register equation code function. */
    nar_save_net_6 : function (void) returning void
    {
        countL1 = ns_net_data_count("layer1");
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");
        areaL5 = ns_net_area("layer5");
        areaL6 = ns_net_area("layer6");
        areaL7 = ns_net_area("layer7");
        areaL8 = ns_net_area("layer8");
        areaL9 = ns_net_area("layer9");

        ratio = dblnp( countL1 - 1 ) * dblz(areaL2) * dblz(areaL3) * dblz(areaL4) * dblz(areaL5) * dblz(areaL6) * dblz(areaL7) * dblz(areaL8) * dblz(areaL9);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_6] = { nar_save_net_6 };
 
    /* Declare and register equation code function. */
    nar_save_net_9 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");
        areaL2 = ns_net_area("layer2");

        con_eq_zero : boolean = ((con.category() == CONSTRAINT_EQ) && dbleq(con.lo(), 0));
        if (( areaL1 > 0) || con_eq_zero) {
            ratio = ( areaL1 > 0 ) ? areaL2 / areaL1 : 0;

            if (double_constraint_contains(con, ratio)) {
                ns_save_net({"ratio"}, {ratio});
            }
        }
    }
    nar_funcs[NAR_SAVE_NET_9] = { nar_save_net_9 };
 
    /* Declare and register equation code function. */
    nar_save_net_15 : function (void) returning void
    {
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");
        areaL5 = ns_net_area("layer5");

        ratio = dblnz(areaL2) + dblnz(areaL3) + dblnz(areaL4) + dblnz(areaL5);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_15] = { nar_save_net_15 };
 
    /* Declare and register equation code function. */
    nar_save_net_16 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");
        areaL2 = ns_net_area("layer2");

        ratio = dblnz(areaL1) * dblnz(areaL2);

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_16] = { nar_save_net_16 };
 
    /* Declare and register equation code function. */
    nar_save_net_17 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");
        areaL5 = ns_net_area("layer5");

        ratio = dblnz(areaL1) * dblz(areaL5) * ( dblnz(areaL2) + dblnz(areaL3) + dblnz(areaL4) );

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_17] = { nar_save_net_17 };
 
    /* Declare and register equation code function. */
    nar_save_net_18 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");
        areaL2 = ns_net_area("layer2");
        areaL3 = ns_net_area("layer3");
        areaL4 = ns_net_area("layer4");
        areaL5 = ns_net_area("layer5");

        ratio = dblnz(areaL1) * ( dblnz(areaL2) + dblnz(areaL3) + dblnz(areaL4) + dblnz(areaL5) );

        if (double_constraint_contains(con, ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_18] = { nar_save_net_18 };
 
    /* Declare and register equation code function. */
    nar_save_net_19 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");

        ratio = ( areaL1 ) / GRID; 

        if (double_constraint_contains(con, ratio) && !isinf(ratio) && !isnan(ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_19] = { nar_save_net_19 };
 
    /* Declare and register equation code function. */
    nar_save_net_20 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");

        ratio = ( areaL1 / 2 ) / GRID; 

        if (double_constraint_contains(con, ratio) && !isinf(ratio) && !isnan(ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_20] = { nar_save_net_20 };
 
    /* Declare and register equation code function. */
    nar_save_net_21 : function (void) returning void
    {
        areaL1 = ns_net_area("layer1");

        ratio = areaL1 / GRID; 

        if (double_constraint_contains(con, ratio) && !isinf(ratio) && !isnan(ratio)) {
            ns_save_net({"ratio"}, {ratio});
        }
    }
    nar_funcs[NAR_SAVE_NET_21] = { nar_save_net_21 };

    /* Lookup the net_function to use in this num/den instance. */
    nar_func = nar_funcs[func_enum].func;

    n_layer_0 = layer_groups["layer1"][0];

    if (expr_is_default && (layer_groups.size() > 1)) {
        d_layers : list of polygon_layer = { };

        for (i = denominator_start to denominator_end) {
            d_layers.push_back(layer_groups["layer" + i][0]);
        }

        if ((con.category() == CONSTRAINT_EQ) && !((con.lo() > 0.0) || (con.lo() < 0.0))) {
            not_con2any = d_layers;
        }
        else {
            con2any = d_layers;
        }
    }

    net_select(
        connect_sequence     = cdb_in,
        net_function         = nar_func,
        layer_groups         = layer_groups,
        connected_to_all     = { n_layer_0 },
        connected_to_any     = con2any,
        not_connected_to_any = not_con2any,
        output_from_layers   = { n_layer_0 },
        error_net_output     = ALL
    );
}

net_area_ratio_with_accumulate : published function (
    cdb_in            : connect_database,
    con               : constraint of double,
    prop_in           : property_layer,
    prop_out          : out property_layer,
    layer_groups      : layer_groups_h,
    constrained_areas : nar_constrained_areas_h = { },
    func_enum         : nar_funcs_e             = UNKNOWN
)
    returning void
{
    naracc_funcs      : nar_void_func_h = { };
    nar_func          : function (void) returning void;
    output_properties : boolean = false;
    output_polygons   : boolean = true;

    /* Declare and register equation code function. */
    naracc_save_net_22 : function (void) returning void
    {
        countL1 = nps_net_data_count("layer1");

        cur_ratio = countL1;

        new_ratio = nps_read_property("ANT_RATIO") + cur_ratio;

        if (output_properties) {
            nps_save_property("ANT_RATIO", new_ratio);
        }

        if (double_constraint_contains(con, new_ratio) && output_polygons) {
            nps_save_polygon(error_names = { "countL1", "cur_ratio", "new_ratio" },
                             values      = { countL1, cur_ratio, new_ratio }
            );
        }
    }
    naracc_funcs[NARACC_SAVE_NET_22] = { naracc_save_net_22 };

    /* Lookup the net_function to use in this num/den instance. */
    nar_func = naracc_funcs[func_enum].func;

    net_polygon_select(
        connect_sequence     = cdb_in,
        in_property_layer    = prop_in,
        out_property_layer   = prop_out,
        net_polygon_function = nar_func,
        layer_groups         = layer_groups,
        output_from_layers   = { }
    );
}

/* Declare and register equation code function. */
den_save_window_1 : function (void) returning void
{
    areaL1 = den_polygon_area("layer1", clip = _den_polygon_area_clip);
    areaL2 = den_polygon_area("layer2", clip = _den_polygon_area_clip);
    
    ratio = areaL1 / areaL2;

    if (double_constraint_contains(_den_con, ratio) && !isinf(ratio) && !isnan(ratio)) {
        if (!_den_print_only) {
            den_save_window(error_names = { "ratio", "areaL1", "areaL2" },
                            values      = { ratio, areaL1, areaL2 }
            );
        }
    
        if (_den_print || _den_print_only) {
            den_window_statistics(
                which_file  = 0,
                error_names = { "ratio", "areaL1", "areaL2" },
                values      = { ratio, areaL1, areaL2 }
            );
        }
    }
}


/* Declare and register equation code function. */
den_save_window_2 : function (void) returning void
{
    areaL1 = den_polygon_area("layer1", clip = _den_polygon_area_clip);
    areaL2 = den_polygon_area("layer2", clip = _den_polygon_area_clip);
    areaL3 = den_polygon_area("layer3", clip = _den_polygon_area_clip);
    
    ratio = dblz(areaL1) + areaL2 / areaL3;

    if (double_constraint_contains(_den_con, ratio) && !isinf(ratio) && !isnan(ratio)) {
        if (!_den_print_only) {
            den_save_window(error_names = { "ratio", "areaL1", "areaL2", "areaL3" },
                            values      = { ratio, areaL1, areaL2, areaL3 }
            );
        }
    
        if (_den_print || _den_print_only) {
            den_window_statistics(
                which_file  = 0,
                error_names = { "ratio", "areaL1", "areaL2", "areaL3" },
                values      = { ratio, areaL1, areaL2, areaL3 }
            );
        }
    }
}


/* Declare and register equation code function. */
den_save_window_3 : function (void) returning void
{
    areaL1 = den_polygon_area("layer1", clip = _den_polygon_area_clip);
    areaL2 = den_polygon_area("layer2", clip = _den_polygon_area_clip);
    areaL3 = den_polygon_area("layer3", clip = _den_polygon_area_clip);
    
    ratio = dblnz(areaL1) * areaL2 / areaL3;

    if (double_constraint_contains(_den_con, ratio) && !isinf(ratio) && !isnan(ratio)) {
        if (!_den_print_only) {
            den_save_window(error_names = { "ratio", "areaL1", "areaL2", "areaL3" },
                            values      = { ratio, areaL1, areaL2, areaL3 }
            );
        }
    
        if (_den_print || _den_print_only) {
            den_window_statistics(
                which_file  = 0,
                error_names = { "ratio", "areaL1", "areaL2", "areaL3" },
                values      = { ratio, areaL1, areaL2, areaL3 }
            );
        }
    }
}


/* Declare and register equation code function. */
den_save_window_4 : function (void) returning void
{
    areaL1 = den_polygon_area("layer1", clip = _den_polygon_area_clip);
    areaW = den_window_area();
    
    ratio = areaL1 / areaW;

    if (double_constraint_contains(_den_con, ratio)) {
        if (!_den_print_only) {
            den_save_window(error_names = { "ratio", "areaL1", "areaW" },
                            values      = { ratio, areaL1, areaW }
            );
        }
    
        if (_den_print || _den_print_only) {
            den_window_statistics(
                which_file  = 0,
                error_names = { "ratio", "areaL1", "areaW" },
                values      = { ratio, areaL1, areaW }
            );
        }
    }

    den_generate_next_step(ratio, _den_con, RATIO);
}


/* Declare and register equation code function. */
den_save_window_8 : function (void) returning void
{
    areaL1 = den_polygon_area("layer1", clip = _den_polygon_area_clip);
    areaL2 = den_polygon_area("layer2", clip = _den_polygon_area_clip);
    areaL3 = den_polygon_area("layer3", clip = _den_polygon_area_clip);
    areaW = den_window_area();
    
    ratio = dblz(dblnp( areaL1 / areaW - MX_DN_5 )) * dblz(dblnp( areaL2 / areaW - MX_DN_5 )) * dblz(dblnp( areaL3 / areaW - MX_DN_5 )); 

    if (double_constraint_contains(_den_con, ratio) && !isinf(ratio) && !isnan(ratio)) {
        if (!_den_print_only) {
            den_save_window(error_names = { "ratio", "areaL1", "areaL2", "areaL3", "areaW" },
                            values      = { ratio, areaL1, areaL2, areaL3, areaW }
            );
        }
    
        if (_den_print || _den_print_only) {
            den_window_statistics(
                which_file  = 0,
                error_names = { "ratio", "areaL1", "areaL2", "areaL3", "areaW" },
                values      = { ratio, areaL1, areaL2, areaL3, areaW }
            );
        }
    }
}


/* Declare and register equation code function. */
den_save_window_10 : function (void) returning void
{
    areaL1 = den_polygon_area("layer1", clip = _den_polygon_area_clip);
    areaL2 = den_polygon_area("layer2", clip = _den_polygon_area_clip);
    areaL3 = den_polygon_area("layer3", clip = _den_polygon_area_clip);
    
    ratio = dblnp( areaL2 - M8_DN_5L_E ) * dblnz( areaL2 - M8_DN_5L_E ) + areaL1 / areaL2 + dblz(areaL3); 

    if (double_constraint_contains(_den_con, ratio) && !isinf(ratio) && !isnan(ratio)) {
        if (!_den_print_only) {
            den_save_window(error_names = { "ratio", "areaL1", "areaL2", "areaL3" },
                            values      = { ratio, areaL1, areaL2, areaL3 }
            );
        }
    
        if (_den_print || _den_print_only) {
            den_window_statistics(
                which_file  = 0,
                error_names = { "ratio", "areaL1", "areaL2", "areaL3" },
                values      = { ratio, areaL1, areaL2, areaL3 }
            );
        }
    }
}


/* Declare and register equation code function. */
den_save_window_11 : function (void) returning void
{
    areaL1 = den_polygon_area("layer1", clip = _den_polygon_area_clip);
    areaL2 = den_polygon_area("layer2", clip = _den_polygon_area_clip);
    
    ratio = dblz( dblnp( areaL2 - M8_DN_5H_E ) * dblnz( areaL2 - M8_DN_5H_E ) ) * areaL1 / areaL2; 

    if (double_constraint_contains(_den_con, ratio) && !isinf(ratio) && !isnan(ratio)) {
        if (!_den_print_only) {
            den_save_window(error_names = { "ratio", "areaL1", "areaL2" },
                            values      = { ratio, areaL1, areaL2 }
            );
        }
    
        if (_den_print || _den_print_only) {
            den_window_statistics(
                which_file  = 0,
                error_names = { "ratio", "areaL1", "areaL2" },
                values      = { ratio, areaL1, areaL2 }
            );
        }
    }
}


/* Declare and register equation code function. */
den_save_window_14 : function (void) returning void
{
    areaL1 = den_polygon_area("layer1", clip = _den_polygon_area_clip);
    
    ratio = 1E4 * areaL1;

    if (double_constraint_contains(_den_con, ratio)) {
        if (!_den_print_only) {
            den_save_window(error_names = { "ratio", "areaL1" },
                            values      = { ratio, areaL1 }
            );
        }
    
        if (_den_print || _den_print_only) {
            den_window_statistics(
                which_file  = 0,
                error_names = { "ratio", "areaL1" },
                values      = { ratio, areaL1 }
            );
        }
    }
}


/* Declare and register equation code function. */
den_save_window_23 : function (void) returning void
{
    areaL1 = den_polygon_area("layer1", clip = _den_polygon_area_clip);
    
    ratio = areaL1;

    if (double_constraint_contains(_den_con, ratio)) {
        if (!_den_print_only) {
            den_save_window(error_names = { "ratio", "areaL1" },
                            values      = { ratio, areaL1 }
            );
        }
    
        if (_den_print || _den_print_only) {
            den_window_statistics(
                which_file  = 0,
                error_names = { "ratio", "areaL1" },
                values      = { ratio, areaL1 }
            );
        }
    }
}


dfm_property_func_12 : function (void) returning void
{
    primary_data = df_get_current_data();
    elayer10_set = df_edge_layer(primary_data, "layer10");
    elayer11_set = df_edge_layer(primary_data, "layer11");
    elayer2_set = df_edge_layer(primary_data, "layer2");
    elayer3_set = df_edge_layer(primary_data, "layer3");
    elayer4_set = df_edge_layer(primary_data, "layer4");
    elayer5_set = df_edge_layer(primary_data, "layer5");
    elayer6_set = df_edge_layer(primary_data, "layer6");
    elayer7_set = df_edge_layer(primary_data, "layer7");
    elayer8_set = df_edge_layer(primary_data, "layer8");
    elayer9_set = df_edge_layer(primary_data, "layer9");
    lengthL10 = df_edge_sum_length(elayer10_set);
    lengthL11 = df_edge_sum_length(elayer11_set);
    lengthL2 = df_edge_sum_length(elayer2_set);
    lengthL3 = df_edge_sum_length(elayer3_set);
    lengthL4 = df_edge_sum_length(elayer4_set);
    lengthL5 = df_edge_sum_length(elayer5_set);
    lengthL6 = df_edge_sum_length(elayer6_set);
    lengthL7 = df_edge_sum_length(elayer7_set);
    lengthL8 = df_edge_sum_length(elayer8_set);
    lengthL9 = df_edge_sum_length(elayer9_set);

    SIDEWALL_AREA = ( lengthL2 * M1_THICKNESS + lengthL3 * M2_THICKNESS + lengthL4 * M3_THICKNESS + lengthL5 * M4_THICKNESS + lengthL6 * M5_THICKNESS + lengthL7 * M6_THICKNESS + lengthL8 * M7_THICKNESS + lengthL9 * M8_THICKNESS + lengthL10 * M9_THICKNESS + lengthL11 * AP_THICKNESS ) / 2; 

    if (double_constraint_contains(> MOM_A_1, SIDEWALL_AREA)) { 
        df_save_properties(primary_data, { { "Sidewall_Area", SIDEWALL_AREA } }); 
        df_save_data(primary_data);
    }
}

dfm_property_func_12_rdb : function (void) returning void
{
    primary_data = df_get_current_data();
    layer1_set = df_polygon_layer(primary_data, "");

    if (df_get_polygon_sum_double_property(layer1_set, "Sidewall_Area", SIDEWALL_AREA)) { 
        df_fnote(0, "Sidewall_Area = " + SIDEWALL_AREA + "\n"); 
    }
}

dfm_property_func_13 : function (void) returning void
{
    primary_data = df_get_current_data();
    elayer10_set = df_edge_layer(primary_data, "layer10");
    elayer12_set = df_edge_layer(primary_data, "layer12");
    elayer14_set = df_edge_layer(primary_data, "layer14");
    elayer16_set = df_edge_layer(primary_data, "layer16");
    elayer18_set = df_edge_layer(primary_data, "layer18");
    elayer20_set = df_edge_layer(primary_data, "layer20");
    elayer2_set = df_edge_layer(primary_data, "layer2");
    elayer4_set = df_edge_layer(primary_data, "layer4");
    elayer6_set = df_edge_layer(primary_data, "layer6");
    elayer8_set = df_edge_layer(primary_data, "layer8");
    player11_set = df_polygon_layer(primary_data, "layer11");
    player13_set = df_polygon_layer(primary_data, "layer13");
    player15_set = df_polygon_layer(primary_data, "layer15");
    player17_set = df_polygon_layer(primary_data, "layer17");
    player19_set = df_polygon_layer(primary_data, "layer19");
    player3_set = df_polygon_layer(primary_data, "layer3");
    player5_set = df_polygon_layer(primary_data, "layer5");
    player7_set = df_polygon_layer(primary_data, "layer7");
    player9_set = df_polygon_layer(primary_data, "layer9");
    lengthL10 = df_edge_sum_length(elayer10_set);
    lengthL12 = df_edge_sum_length(elayer12_set);
    lengthL14 = df_edge_sum_length(elayer14_set);
    lengthL16 = df_edge_sum_length(elayer16_set);
    lengthL18 = df_edge_sum_length(elayer18_set);
    lengthL2 = df_edge_sum_length(elayer2_set);
    lengthL20 = df_edge_sum_length(elayer20_set);
    lengthL4 = df_edge_sum_length(elayer4_set);
    lengthL6 = df_edge_sum_length(elayer6_set);
    lengthL8 = df_edge_sum_length(elayer8_set);
    perimeterL11 = df_polygon_sum_perimeter(player11_set);
    perimeterL13 = df_polygon_sum_perimeter(player13_set);
    perimeterL15 = df_polygon_sum_perimeter(player15_set);
    perimeterL17 = df_polygon_sum_perimeter(player17_set);
    perimeterL19 = df_polygon_sum_perimeter(player19_set);
    perimeterL3 = df_polygon_sum_perimeter(player3_set);
    perimeterL5 = df_polygon_sum_perimeter(player5_set);
    perimeterL7 = df_polygon_sum_perimeter(player7_set);
    perimeterL9 = df_polygon_sum_perimeter(player9_set);

    SIDEWALL_AREA = ( lengthL2 * M1_THICKNESS ) / 2 + ( lengthL4 * M2_THICKNESS ) / 2 + ( lengthL6 * M3_THICKNESS ) / 2 + ( lengthL8 * M4_THICKNESS ) / 2 + ( lengthL10 * M5_THICKNESS ) / 2 + ( lengthL12 * M6_THICKNESS ) / 2 + ( lengthL14 * M7_THICKNESS ) / 2 + ( lengthL16 * M8_THICKNESS ) / 2 + ( lengthL18 * M9_THICKNESS ) / 2 + ( perimeterL3 * V1_THICKNESS ) / 4 + ( perimeterL5 * V2_THICKNESS ) / 4 + ( perimeterL7 * V3_THICKNESS ) / 4 + ( perimeterL9 * V4_THICKNESS ) / 4 + ( perimeterL11 * V5_THICKNESS ) / 4 + ( perimeterL13 * V6_THICKNESS ) / 4 + ( perimeterL15 * V7_THICKNESS ) / 4 + ( perimeterL17 * V8_THICKNESS ) / 4 + ( perimeterL19 * RV_THICKNESS ) / 4 + ( lengthL20 * AP_THICKNESS ) / 2; 

    if (double_constraint_contains(> MOM_A_2, SIDEWALL_AREA)) { 
        df_save_properties(primary_data, { { "Sidewall_Area", SIDEWALL_AREA } }); 
        df_save_data(primary_data);
    }
}

dfm_property_func_13_rdb : function (void) returning void
{
    primary_data = df_get_current_data();
    layer1_set = df_polygon_layer(primary_data, "");

    if (df_get_polygon_sum_double_property(layer1_set, "Sidewall_Area", SIDEWALL_AREA)) { 
        df_fnote(0, "Sidewall_Area = " + SIDEWALL_AREA + "\n"); 
    }
}

/* Declare and register equation code function. */
gden_save_window_7 : function (void) returning void
{
    neighborhood : list of window_offset_e;
    ratio_center : double = 0.0;
    max_gradient : double = 0.0;
    abs_ratio_center : double;
    abs_ratio_neighbor : double;

    areaL1_center = gden_polygon_area("layer1", CENTER, clip = _gden_polygon_area_clip);
    areaL2_center = gden_polygon_area("layer2", CENTER, clip = _gden_polygon_area_clip);

    if (dblne(areaL2_center, 0)) {
        ratio_center = areaL1_center / areaL2_center;
        abs_ratio_center = abs(ratio_center);
    
        neighborhood = (_gden_corner) ? full_neighborhood : adjacent_neighborhood;
    
        foreach (neighbor in neighborhood) {
            if (gden_window_valid(neighbor)) {
                areaL1_neighbor = gden_polygon_area("layer1", neighbor, clip = _gden_polygon_area_clip);
                areaL2_neighbor = gden_polygon_area("layer2", neighbor, clip = _gden_polygon_area_clip);
    
                if (dblne(areaL2_neighbor, 0)) {
                    ratio_neighbor = areaL1_neighbor / areaL2_neighbor;
                    abs_ratio_neighbor = abs(ratio_neighbor);
        
                    gradient = (dbleq(abs_ratio_center, abs_ratio_neighbor))
                                 ? 0
                                 : (_gden_absolute)
                                     ? abs(abs_ratio_center - abs_ratio_neighbor)
                                     : abs(abs_ratio_center - abs_ratio_neighbor) / max(abs_ratio_center, abs_ratio_neighbor);
        
                    if (dblne(_gden_corner_value, -1.0) && corner_neighborhood.contains(neighbor)) {
                        gradient = gradient * _gden_corner_value;
                    }
        
                    max_gradient = max(max_gradient, gradient);
                }
            }
        }
    
        if (double_constraint_contains(_gden_con, ratio_center) && !isinf(ratio_center) && !isnan(ratio_center) &&
            double_constraint_contains(_gden_gcon, max_gradient) && !isinf(max_gradient) && !isnan(max_gradient)) {
            if (!_gden_print_only) {
                gden_save_window(error_names = { "ratio_center", "areaL1_center", "areaL2_center", "Unsigned Gradient" },
                                 values      = { ratio_center, areaL1_center, areaL2_center, max_gradient },
                                 offset      = CENTER
                );
            }
    
            if (_gden_print || _gden_print_only) {
                gden_window_statistics(
                    which_file  = 0,
                    error_names = { "ratio_center", "areaL1_center", "areaL2_center", "Unsigned Gradient" },
                    values      = { ratio_center, areaL1_center, areaL2_center, max_gradient },
                    offset      = CENTER
                );
            }
        }
    }
}

/* End of Equation Code-Based Functions definitions */

// DRAWN LAYER DEFINITIONS
//------------------------
/* deep-nwell */
DNWI                    = assign({ { 1 } }, layer_intent = { LAYER_INTENT_BASE }); 
/* nwell technology */
NWI                     = assign({ { 3, [0, 255] } }, layer_intent = { LAYER_INTENT_BASE }); 
NWI_OTHERS              = assign({ { 3, [1, 255] } }); 
/* define 1.8V thick gate oxides */
OD_18I                  = assign({ { 16 } }, layer_intent = { LAYER_INTENT_BASE }); 
/* define 2.5V thick gate oxides */
OD_25I                  = assign({ { 18, <= 2 }, { 18, >= 5 } }, layer_intent = { LAYER_INTENT_BASE }); 
/* define 2.5V thick gate oxides overdrive 3.3v */
OD25_33                 = assign({ { 18, 3 } }); 
/* define 2.5V thick gate oxides underdrive 1.8v */
OD25_18                 = assign({ { 18, 4 } }); 
/* define 3.3V thick gate oxides */
OD_33I                  = assign({ { 15 } }, layer_intent = { LAYER_INTENT_BASE }); 
/* decoupling capacitor device region */
OD_DECAP                = assign({ { 118 } }); 
/* P+ S/D imlant */
PPI                     = assign({ { 25 } }, layer_intent = { LAYER_INTENT_BASE }); 
/* N+ S/D imlant */
NPI                     = assign({ { 26 } }, layer_intent = { LAYER_INTENT_BASE }); 
/* Define connect for M1 to S/D and Gate */
COI                     = assign({ { 30, [0, 10] }, { 30, [12, 255] } }, grid_check = { resolution = 0.001 }, layer_intent = { LAYER_INTENT_BASE }); 
/* rule pushed contact in SRAM cell */
CO_PUSH                 = assign({ { 30, 11 } }); 
COI_SRAM                = assign({ { 30, [11, 13] } }); 
COI_OTHERS              = assign({ { 30, [1, 10] }, { 30, [12, 255] } }); 
/* Passivation opening for Bond Pad */
CBI                     = assign({ { 76 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Passivation-2 opening for Bond Pad */
CB2I                    = assign({ { 86 } }); 
/* Silicided Block Layer */
RPOI                    = assign({ { 29 } }); 
/* Native NMOS blocked implant */
NT_NI                   = assign({ { 11, <= 19 }, { 11, >= 21 } }, layer_intent = { LAYER_INTENT_BASE }); 
/* connected NMOS capacitors within same NT_N region */
NCAP_NTNI               = assign({ { 11, 20 } }); 
/* Al fuse window */
FWALI                   = assign({ { 95, 20 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Cu fuse window */
FWCUI                   = assign({ { 95, 0 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Poly fuse implant layer     */
POFUSE                  = assign({ { 156, 0 } }); 
/* Dummy layer to cover poly fuse link region.    */
FUSELINK                = assign({ { 156, 1 } }); 
/* Polymide window */
PMI                     = assign({ { 5, 0 }, { 5, >= 3 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* polyimide 1 window for WLCSP */
PM1I                    = assign({ { 5, 1 } }); 
/* polyimide 2 window for WLCSP */
PM2I                    = assign({ { 5, 2 } }); 
/* SEALRING Layer to cover seal ring area */
SEALRINGI               = assign({ { 162 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* High Vt NMOS Implant */
VTH_NI                  = assign({ { 67 } }, layer_intent = { LAYER_INTENT_BASE }); 
/* High Vt PMOS Implant */
VTH_PI                  = assign({ { 68 } }, layer_intent = { LAYER_INTENT_BASE }); 
/* Low Vt NMOS Implant */
VTL_NI                  = assign({ { 12 } }, layer_intent = { LAYER_INTENT_BASE }); 
/* Low Vt PMOS Implant */
VTL_PI                  = assign({ { 13 } }, layer_intent = { LAYER_INTENT_BASE }); 
/* Ultra High Vt NMOS Implant */
UHVT_NI                 = assign({ { 93 } }); 
/* Ultra High Vt PMOS Implant */
UHVT_PI                 = assign({ { 94 } }); 
/* CBD For solder Bump and RDL layer  */
CBDI                    = assign({ { 169 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* UBM For solder Bump and RDL layer  */
UBMI                    = assign({ { 170 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Form P+OD/POLY resistor & N+OD/POLY resistor with RPO */
RH                      = assign({ { 117 } }); 
/* Layer for DRC and logic operation to form ESD implant */
ESD3                    = assign({ { 147 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* For both MOS and junction type varactor */
VARI                    = assign({ { 143 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* ALRDL */
API                     = assign({ { 74, <= 9 }, { 74, >= 11 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Cu_PPI interconnection between Polymide1 and Polymide2 for WLCSP */
CU_PPII                 = assign({ { 74, 10 } }); 
/* MIM Capacitor Bottom Metal */
CBMI                    = assign({ { 88 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* MIM Capacitor Top Metal */
CTMI                    = assign({ { 77 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Via hole between AP and top metal  */
RVI                     = assign({ { 85, 0 } }); 
/* Dual Core oxide layer used to cover G core device */
DCOI                    = assign({ { 90 } }, layer_intent = { LAYER_INTENT_BASE }); 
/* Define P-HVMOS drain side where sustains high voltage */
HVD_P                   = assign({ { 91, 2 } }); 
/* Define N-HVMOS drain side where sustains high voltage (NW approach) */
HVD_N_NW                = assign({ { 91, 3 } }); 
SRM_ULL                 = assign({ { 50, 68 } }); 
/* BJT dummy layer */
BJTDMY                  = assign({ { 110 } }); 
/* NWEL resistor dummy layer */
NWDMY                   = assign({ { 114 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* dummy layer to cover od/poly resistor wi/wo silicide */
RPDMY                   = assign({ { 115 } }); 
/* dummy layer to cover fuse window and protection ring structure */
PMDMY                   = assign({ { 106 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* cover IO ESD area */
SDI                     = assign({ { 122 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
ESD1DMY                 = assign({ { 145 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
ESD2DMY                 = assign({ { 146 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* for SRAM process to exclude OD area */
RODMY                   = assign({ { 49 } }); 
/* Alignment Mark Rule for Laser Repair */
LMARK                   = assign({ { 109 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Layer to cover SRAM Cell */
SRM                     = assign({ { 50, 0 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Layer to cover chip corner areas */
CSRDMY                  = assign({ { 166 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Dummy layer to cover CDU pattern on assembly isolation. */
CDUDMY                  = assign({ { 165, 0 }, { 165, >= 2 } }); 
/* Dummy layer to cover TCD pattern. */
TCDDMY                  = assign({ { 165, 1 } }); 
/* Dummy layer for product labels and LOGO */
LOGO                    = assign({ { 158 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Dummy layer for inductor */
INDDMY                  = assign({ { 144, [0, 14] } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Dummy layer for inductor center tap */
IND_CTAP                = assign({ { 144, 34 } }); 
/* Dummy layer for MIM capacitor */
CTMDMY                  = assign({ { 148, 0 }, { 148, 10 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Dummy layer for 1.0fF/um2 MIM capacitor */
CTMDMY_10               = assign({ { 148, 110 } }); 
/* Dummy layer for 1.5fF/um2 MIM capacitor */
CTMDMY_15               = assign({ { 148, 115 } }); 
/* Dummy layer for 2.0fF/um2 MIM capacitor */
CTMDMY_20               = assign({ { 148, 120 } }); 
CTMDMY_21               = assign({ { 148, 21 } }); 
/* Dummy layer for M1 MOM region */
MOMDMY_1                = assign({ { 155, 1 } }); 
/* Dummy layer for M2 MOM region */
MOMDMY_2                = assign({ { 155, 2 } }); 
/* Dummy layer for M3 MOM region */
MOMDMY_3                = assign({ { 155, 3 } }); 
/* Dummy layer for M4 MOM region */
MOMDMY_4                = assign({ { 155, 4 } }); 
/* Dummy layer for M5 MOM region */
MOMDMY_5                = assign({ { 155, 5 } }); 
/* Dummy layer for M6 MOM region */
MOMDMY_6                = assign({ { 155, 6 } }); 
/* Dummy layer for M7 MOM region */
MOMDMY_7                = assign({ { 155, 7 } }); 
/* Dummy layer for M8 MOM region */
MOMDMY_8                = assign({ { 155, 8 } }); 
/* Dummy layer for M9 MOM region */
MOMDMY_9                = assign({ { 155, 9 } }); 
/* Dummy layer for AP MOM region */
MOMDMY_AP               = assign({ { 155, 20 } }); 
/* Dummy layer for RTMOM  */
RTMOMDMY                = assign({ { 155, 21 } }); 
MOMDMY                  = assign({ { 155, 0 } }); 
/* Dummy layer for 2T MOM region */
MOMDMY_2T               = assign({ { 155, 27 } }); 
/* Dummy layer for FMOM region */
MOMDMY_100              = assign({ { 155, 100 } }); 
MOMDMY_ALL              = assign({ { 155, [1, 9] }, { 155, [20, 21] } }); 
/* For RF circuit */
RFDMY                   = assign({ { 161 } }); 
/* For CUP purpose */
WBDMY                   = assign({ { 157 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Dummy layer for diode */
DIODMY                  = assign({ { 119 } }); 
/* SRAM DRC violations waive layer		 */
SRAMDMY                 = assign({ { 186, 0 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* SRAM periphrial region for 0.525 um2, 0.62um2, 0.974um2, 1.158um2 */
SRAMDMY_4               = assign({ { 186, 4 } }); 
/* SRAM periphrial region for 0.499 um2  */
SRAMDMY_5               = assign({ { 186, 5 } }); 
/* pass gate region in sram cell */
SRAMDMY_1               = assign({ { 186, 1 } }); 
/* dummy layer to define 1T-MIM region */
RAM1TDMY                = assign({ { 160, 0 } }); 
OD1TI                   = assign({ { 27 } }); 
/* 1T-MIM Cell CLDD */
CLDDI                   = assign({ { 92 } }); 
CROWNI                  = assign({ { 102 } }); 
P3I                     = assign({ { 103 } }); 
SNCTI                   = assign({ { 101 } }); 
/* DRC dummy layer to waive Latch-Up rules for verified IP. */
LUPWDMY                 = assign({ { 255, 1 } }); 
/* DRC dummy layer to check Area Array IO LUP rules. */
LUPWDMY_2               = assign({ { 255, 18 } }); 
/* DRC dummy layer to identify VDD PAD for Latch-Up rules. */
VDDDMY                  = assign({ { 255, 4 } }); 
/* DRC dummy layer to identify VSS PAD for Latch-Up rules. */
VSSDMY                  = assign({ { 255, 5 } }); 
/* DEFINE matching dummy layer for cover the diffential pair region */
MATCHING                = assign({ { 255, 10 } }); 
/* Metal1 layer */
M1I                     = assign({ { 31, 0 }, { 31, 7 } }, layer_intent = { LAYER_INTENT_METAL }); 
/* Metal1 layer (drawing metal) */
M1_REAL                 = assign({ { 31, 0 } }); 
DM1_O                   = assign({ { 31, 7 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* dummy Metal1 */
DUM1                    = assign({ { 31, 1 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
NOUSEM1                 = assign({ { 31, 20 }, { 31, 21 }, { 31, 40 }, { 31, 41 }, { 31, 60 }, { 31, 61 }, { 31, 80 }, { 31, 81 } }); 
NOTUSEM1                = assign({ { 31, [161, 165] } }); 
DM1EXCL                 = assign({ { 150, 1 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal2 layer */
M2I                     = assign({ { 32, 0 }, { 32, 7 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal2 layer (drawing metal) */
M2_REAL                 = assign({ { 32, 0 } }); 
DM2_O                   = assign({ { 32, 7 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* dummy Metal2 */
DUM2                    = assign({ { 32, 1 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
NOUSEM2                 = assign({ { 32, 20 }, { 32, 21 }, { 32, 40 }, { 32, 41 }, { 32, 60 }, { 32, 61 }, { 32, 80 }, { 32, 81 } }); 
NOTUSEM2                = assign({ { 32, [161, 165] } }); 
DM2EXCL                 = assign({ { 150, 2 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal3 layer */
M3I                     = assign({ { 33, 0 }, { 33, 7 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal3 layer (drawing metal) */
M3_REAL                 = assign({ { 33, 0 } }); 
DM3_O                   = assign({ { 33, 7 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* dummy Metal3 */
DUM3                    = assign({ { 33, 1 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
NOUSEM3                 = assign({ { 33, 20 }, { 33, 21 }, { 33, 40 }, { 33, 41 }, { 33, 60 }, { 33, 61 }, { 33, 80 }, { 33, 81 } }); 
NOTUSEM3                = assign({ { 33, [161, 165] } }); 
DM3EXCL                 = assign({ { 150, 3 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal4 layer */
M4I                     = assign({ { 34, 0 }, { 34, 7 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal4 layer (drawing metal) */
M4_REAL                 = assign({ { 34, 0 } }); 
DM4_O                   = assign({ { 34, 7 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* dummy Metal4 */
DUM4                    = assign({ { 34, 1 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
NOUSEM4                 = assign({ { 34, 20 }, { 34, 21 }, { 34, 40 }, { 34, 41 }, { 34, 60 }, { 34, 61 }, { 34, 80 }, { 34, 81 } }); 
NOTUSEM4                = assign({ { 34, [161, 165] } }); 
DM4EXCL                 = assign({ { 150, 4 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal5 layer */
M5I                     = assign({ { 35, 0 }, { 35, 7 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal5 layer (drawing metal) */
M5_REAL                 = assign({ { 35, 0 } }); 
DM5_O                   = assign({ { 35, 7 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* dummy Metal5 */
DUM5                    = assign({ { 35, 1 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
NOUSEM5                 = assign({ { 35, 20 }, { 35, 21 }, { 35, 40 }, { 35, 41 }, { 35, 60 }, { 35, 61 }, { 35, 80 }, { 35, 81 } }); 
NOTUSEM5                = assign({ { 35, [161, 165] } }); 
DM5EXCL                 = assign({ { 150, 5 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal6 layer */
M6I                     = assign({ { 36, 0 }, { 36, 7 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal6 layer (drawing metal) */
M6_REAL                 = assign({ { 36, 0 } }); 
DM6_O                   = assign({ { 36, 7 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* dummy Metal6 */
DUM6                    = assign({ { 36, 1 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
NOUSEM6                 = assign({ { 36, 20 }, { 36, 21 }, { 36, 40 }, { 36, 41 }, { 36, 60 }, { 36, 61 }, { 36, 80 }, { 36, 81 } }); 
NOTUSEM6                = assign({ { 36, [161, 165] } }); 
DM6EXCL                 = assign({ { 150, 6 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal7 layer */
M7I                     = assign({ { 37, 0 }, { 37, 7 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal7 layer (drawing metal) */
M7_REAL                 = assign({ { 37, 0 } }); 
DM7_O                   = assign({ { 37, 7 } }, layer_intent = { LAYER_INTENT_FILL }); 
/* dummy Metal7 */
DUM7                    = assign({ { 37, 1 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
NOUSEM7                 = assign({ { 37, 20 }, { 37, 21 }, { 37, 40 }, { 37, 41 }, { 37, 60 }, { 37, 61 }, { 37, 80 }, { 37, 81 } }); 
NOTUSEM7                = assign({ { 37, [161, 165] } }); 
DM7EXCL                 = assign({ { 150, 7 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal8 layer */
M8_OLD                  = assign({ { 38, 0 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal8 layer */
M8_NEW                  = assign({ { 38, 40 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
DUM8_OLD                = assign({ { 38, 1 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
DUM8_NEW                = assign({ { 38, 41 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
NOUSEM8_NEW             = assign({ { 38, 0 }, { 38, 1 } }); 
NOUSEM8_OLD             = assign({ { 38, 7 }, { 38, 20 }, { 38, 21 }, { 38, 60 }, { 38, 61 }, { 38, 80 }, { 38, 81 } }); 
NOTUSEM8                = assign({ { 38, [161, 165] } }); 
DM8EXCL                 = assign({ { 150, 8 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal9 layer */
M9_OLD                  = assign({ { 39, 0 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Metal9 layer */
M9_NEW                  = assign({ { 39, 40 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
DUM9_OLD                = assign({ { 39, 1 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
DUM9_NEW                = assign({ { 39, 41 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
NOUSEM9_NEW             = assign({ { 39, 0 }, { 39, 1 } }); 
NOUSEM9_OLD             = assign({ { 39, 7 }, { 39, 20 }, { 39, 21 }, { 39, 60 }, { 39, 61 }, { 39, 80 }, { 39, 81 } }); 
NOTUSEM9                = assign({ { 39, [161, 165] } }); 
DM9EXCL                 = assign({ { 150, 9 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
VIA1I                   = assign({ { 51, 0 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
NOUSEV1                 = assign({ { 51, 20 }, { 51, 40 }, { 51, 80 } }); 
VIA2I                   = assign({ { 52, 0 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
NOUSEV2                 = assign({ { 52, 20 }, { 52, 40 }, { 52, 80 } }); 
VIA3I                   = assign({ { 53, 0 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
NOUSEV3                 = assign({ { 53, 20 }, { 53, 40 }, { 53, 80 } }); 
VIA4I                   = assign({ { 54, 0 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
NOUSEV4                 = assign({ { 54, 20 }, { 54, 40 }, { 54, 80 } }); 
VIA5I                   = assign({ { 55, 0 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
NOUSEV5                 = assign({ { 55, 20 }, { 55, 40 }, { 55, 80 } }); 
VIA6I                   = assign({ { 56, 0 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
NOUSEV6                 = assign({ { 56, 20 }, { 56, 40 }, { 56, 80 } }); 
VIA7_OLD                = assign({ { 57, 0 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
VIA7_NEW                = assign({ { 57, 40 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
NOUSEV7_NEW             = assign({ { 57, 0 } }); 
NOUSEV7_OLD             = assign({ { 57, 20 }, { 57, 80 } }); 
VIA8_OLD                = assign({ { 58, 0 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
VIA8_NEW                = assign({ { 58, 40 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
NOUSEV8_NEW             = assign({ { 58, 0 } }); 
NOUSEV8_OLD             = assign({ { 58, 20 }, { 58, 80 } }); 
ODI                     = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, layer_intent = { LAYER_INTENT_BASE }); 
ODI_RFDRAIN             = assign({ { 6, 3 } }); 
ODI_SRAM                = assign({ { 6, 11 }, { 6, 12 }, { 6, 13 } }); 
ODI_OTHERS              = assign({ { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }); 
DOD                     = assign({ { 6, 1 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
NOTUSEOD                = assign({ { 6, [161, 165] } }); 
POI                     = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, grid_check = { resolution = 0.001 }, layer_intent = { LAYER_INTENT_BASE }); 
POI_SRAM                = assign({ { 17, 11 }, { 17, 12 }, { 17, 13 } }); 
POI_OTHERS              = assign({ { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }); 
DPO                     = assign({ { 17, 1 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* Used to generate poly logical operation in N65LP LVT process */
MVTLI                   = assign({ { 17, 51 } }); 
NOTUSEPO                = assign({ { 17, [161, 165] } }); 
ODBLK                   = assign({ { 150, 20 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
POBLK                   = assign({ { 150, 21 } }, layer_intent = { LAYER_INTENT_METAL, LAYER_INTENT_VIA, LAYER_INTENT_INTERCONNECT }); 
/* marker layer for DFM action-required rules */
RRULEREQUIRED           = assign({ { 182, 1 } }); 
/* marker layer for DFM recommendations */
RRULERECOMMENDED        = assign({ { 182, 2 } }); 
/* marker layer for analog rules and recommendations */
RRULEANALOG             = assign({ { 182, 3 } }); 
/* marker layer for DFM guidelines */
RRULEGUIDELINE          = assign({ { 182, 4 } }); 
/* marker layer for excluding DFM action-required rules */
EXCLUDERRULEREQUIRED    = assign({ { 182, 11 } }); 
/* marker layer for excluding DFM recommendations */
EXCLUDERRULERECOMMENDED = assign({ { 182, 12 } }); 
/* marker layer for excluding analog rules and recommendations */
EXCLUDERRULEANALOG      = assign({ { 182, 13 } }); 
/* marker layer for excluding DFM guidelines */
EXCLUDERRULEGUIDELINE   = assign({ { 182, 14 } }); 
RMDMY1                  = assign({ { 116, 1 } }); 
RMDMY2                  = assign({ { 116, 2 } }); 
RMDMY3                  = assign({ { 116, 3 } }); 
RMDMY4                  = assign({ { 116, 4 } }); 
RMDMY5                  = assign({ { 116, 5 } }); 
RMDMY6                  = assign({ { 116, 6 } }); 
RMDMY7                  = assign({ { 116, 7 } }); 
RMDMY8                  = assign({ { 116, 8 } }); 
RMDMY9                  = assign({ { 116, 9 } }); 
RMDMYAP                 = assign({ { 116, 16 } }); 
/* metal coil within INDDMY_MD for DRC checking purpose.         */
INDDMY_COIL             = assign({ { 144, 36 } }); 
/* inductor region for medium metal density inductor.   */
INDDMY_MD               = assign({ { 144, 37 } }); 
/* metal coil within INDDMY_MD for DRC checking purpose.         */
INDDMY_HD               = assign({ { 144, 38 } }); 
/* A drawing layer for ESD implant  */
ESDIMP                  = assign({ { 189, 0 } }); 
text_131                 = assign_text({ { 131 } });
text_132                 = assign_text({ { 132 } });
text_133                 = assign_text({ { 133 } });
text_134                 = assign_text({ { 134 } });
text_135                 = assign_text({ { 135 } });
text_136                 = assign_text({ { 136 } });
text_137                 = assign_text({ { 137 } });
text_138                 = assign_text({ { 138 } });
text_139                 = assign_text({ { 139 } });
text_126                 = assign_text({ { 126 } });
#ifndef DFM_ONLY 
   #ifdef HALF_NODE 
      aLAYER_1                 = assign({ { 1 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_2                 = assign({ { 3, [0, 255] } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_3                 = assign({ { 16 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_4                 = assign({ { 18, <= 2 }, { 18, >= 5 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_5                 = assign({ { 18, 3 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_6                 = assign({ { 18, 4 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_7                 = assign({ { 15 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_8                 = assign({ { 118 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_9                 = assign({ { 25 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_10                = assign({ { 26 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_11                = assign({ { 76 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_12                = assign({ { 29 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_13                = assign({ { 11, <= 19 }, { 11, >= 21 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_14                = assign({ { 11, 20 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_15                = assign({ { 95, 20 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_16                = assign({ { 95, 0 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_17                = assign({ { 156, 0 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_18                = assign({ { 156, 1 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_19                = assign({ { 162 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_20                = assign({ { 67 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_21                = assign({ { 68 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_22                = assign({ { 12 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_23                = assign({ { 13 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      layer_patch_93                = assign({ { 93 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      layer_patch_94                = assign({ { 94 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_26                = assign({ { 117 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_27                = assign({ { 147 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_28                = assign({ { 143 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_29                = assign({ { 74, <= 9 }, { 74, >= 11 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_30                = assign({ { 88 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_31                = assign({ { 77 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_32                = assign({ { 85, 0 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_33                = assign({ { 90 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_34                = assign({ { 91, 2 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_35                = assign({ { 91, 3 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_36                = assign({ { 50, 68 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_37                = assign({ { 110 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_38                = assign({ { 114 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_39                = assign({ { 115 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_40                = assign({ { 106 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      layer_patch_122                = assign({ { 122 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_42                = assign({ { 145 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_43                = assign({ { 146 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_44                = assign({ { 49 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_45                = assign({ { 50, 0 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_46                = assign({ { 165, 0 }, { 165, >= 2 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_47                = assign({ { 165, 1 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_48                = assign({ { 158 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_49                = assign({ { 144, [0, 14] } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_50                = assign({ { 148, 0 }, { 148, 10 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_51                = assign({ { 148, 110 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_52                = assign({ { 148, 115 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_53                = assign({ { 148, 120 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_54                = assign({ { 148, 21 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_55                = assign({ { 155, 1 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_56                = assign({ { 155, 2 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_57                = assign({ { 155, 3 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_58                = assign({ { 155, 4 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_59                = assign({ { 155, 5 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_60                = assign({ { 155, 6 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_61                = assign({ { 155, 7 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_62                = assign({ { 155, 8 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_63                = assign({ { 155, 9 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_64                = assign({ { 155, 20 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_65                = assign({ { 155, 21 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_66                = assign({ { 155, 0 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_67                = assign({ { 155, 27 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_68                = assign({ { 155, 100 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_69                = assign({ { 161 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_70                = assign({ { 157 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_71                = assign({ { 119 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_72                = assign({ { 186, 0 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_73                = assign({ { 186, 4 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_74                = assign({ { 186, 5 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_75                = assign({ { 186, 1 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_76                = assign({ { 27 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_77                = assign({ { 92 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_78                = assign({ { 102 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_79                = assign({ { 103 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_80                = assign({ { 101 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_81                = assign({ { 255, 1 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_82                = assign({ { 255, 18 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_83                = assign({ { 255, 4 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_84                = assign({ { 255, 5 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_85                = assign({ { 255, 10 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_86                = assign({ { 31, 0 }, { 31, 7 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_87                = assign({ { 31, 0 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_88                = assign({ { 31, 7 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_89                = assign({ { 31, 1 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_90                = assign({ { 32, 0 }, { 32, 7 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_91                = assign({ { 32, 0 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_92                = assign({ { 32, 7 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_93                = assign({ { 32, 1 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_94                = assign({ { 33, 0 }, { 33, 7 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_95                = assign({ { 33, 0 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_96                = assign({ { 33, 7 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_97                = assign({ { 33, 1 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_98                = assign({ { 34, 0 }, { 34, 7 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_99                = assign({ { 34, 0 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_100               = assign({ { 34, 7 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_101               = assign({ { 34, 1 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_102               = assign({ { 35, 0 }, { 35, 7 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_103               = assign({ { 35, 0 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_104               = assign({ { 35, 7 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_105               = assign({ { 35, 1 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_106               = assign({ { 36, 0 }, { 36, 7 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_107               = assign({ { 36, 0 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_108               = assign({ { 36, 7 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_109               = assign({ { 36, 1 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_110               = assign({ { 37, 0 }, { 37, 7 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_111               = assign({ { 37, 0 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_112               = assign({ { 37, 7 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_113               = assign({ { 37, 1 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_114               = assign({ { 38, 0 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_115               = assign({ { 38, 40 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_116               = assign({ { 38, 1 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_117               = assign({ { 38, 41 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_118               = assign({ { 39, 0 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_119               = assign({ { 39, 40 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_120               = assign({ { 39, 1 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_121               = assign({ { 39, 41 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_122               = assign({ { 51, 0 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_123               = assign({ { 52, 0 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_124               = assign({ { 53, 0 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_125               = assign({ { 54, 0 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_126               = assign({ { 55, 0 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_127               = assign({ { 56, 0 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_128               = assign({ { 57, 0 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_129               = assign({ { 57, 40 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_130               = assign({ { 58, 0 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_131               = assign({ { 58, 40 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_132               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_133               = assign({ { 6, 1 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_134               = assign({ { 17, 1 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_135               = assign({ { 17, 51 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_136               = assign({ { 116, 1 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_137               = assign({ { 116, 2 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_138               = assign({ { 116, 3 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_139               = assign({ { 116, 4 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_140               = assign({ { 116, 5 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_141               = assign({ { 116, 6 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_142               = assign({ { 116, 7 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_143               = assign({ { 116, 8 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_144               = assign({ { 116, 9 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_145               = assign({ { 116, 16 } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_146               = assign({ { 30, [0, 10] }, { 30, [12, 255] } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
      aLAYER_147               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select_cells = { "*", inv_cell_name(CELLSFOR1NMGRID) }); 
   #endif
   #ifdef FRONT_END 
      aLAYER_148               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select = { cells = { CELLSFORRRULEANALOG } }); 
      aLAYER_149               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEANALOG) }); 
      aLAYER_150               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select = { cells = { CELLSFORRRULEANALOG } }); 
      aLAYER_151               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEANALOG) }); 
      aLAYER_152               = assign({ { 3, [0, 255] } }, select = { cells = { CELLSFORRRULEANALOG } }); 
      aLAYER_153               = assign({ { 3, [0, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEANALOG) }); 
   #endif
#endif
#ifdef DFM 
   #ifdef _POS2_ 
      #ifdef GP 
         aLAYER_154               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select = { cells = { CELLSFORRRULEREQUIRED } }); 
         aLAYER_155               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEREQUIRED) }); 
      #else
         #ifdef LP 
            aLAYER_156               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select = { cells = { CELLSFORRRULEREQUIRED } }); 
            aLAYER_157               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEREQUIRED) }); 
         #else
            #ifdef LPG 
               aLAYER_158               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select = { cells = { CELLSFORRRULEREQUIRED } }); 
               aLAYER_159               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEREQUIRED) }); 
            #endif
         #endif
      #endif
   #endif
   #ifdef _POEX2_ 
      aLAYER_160               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select = { cells = { CELLSFORRRULEREQUIRED } }); 
      aLAYER_161               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEREQUIRED) }); 
   #endif
   #ifdef _POS5_ 
      aLAYER_162               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select = { cells = { CELLSFORRRULEREQUIRED } }); 
      aLAYER_163               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEREQUIRED) }); 
   #endif
   #ifdef _POS14_ 
      aLAYER_164               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_165               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _POEN1_ 
      aLAYER_166               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_167               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _POEN2_ 
      aLAYER_168               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_169               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _POEN3_ 
      aLAYER_170               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_171               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _OPCR1_ 
      aLAYER_172               = assign({ { 25 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_173               = assign({ { 25 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
      aLAYER_174               = assign({ { 26 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_175               = assign({ { 26 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
      aLAYER_176               = assign({ { 67 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_177               = assign({ { 67 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
      aLAYER_178               = assign({ { 68 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_179               = assign({ { 68 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
      aLAYER_180               = assign({ { 12 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_181               = assign({ { 12 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
      aLAYER_182               = assign({ { 13 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_183               = assign({ { 13 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
      aLAYER_184               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_185               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
      aLAYER_186               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_187               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
      aLAYER_188               = assign({ { 31, 0 }, { 31, 7 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_189               = assign({ { 31, 0 }, { 31, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
      aLAYER_190               = assign({ { 32, 0 }, { 32, 7 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_191               = assign({ { 32, 0 }, { 32, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
      aLAYER_192               = assign({ { 33, 0 }, { 33, 7 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_193               = assign({ { 33, 0 }, { 33, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
      aLAYER_194               = assign({ { 34, 0 }, { 34, 7 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_195               = assign({ { 34, 0 }, { 34, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
      aLAYER_196               = assign({ { 35, 0 }, { 35, 7 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_197               = assign({ { 35, 0 }, { 35, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
      aLAYER_198               = assign({ { 36, 0 }, { 36, 7 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_199               = assign({ { 36, 0 }, { 36, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
      aLAYER_200               = assign({ { 37, 0 }, { 37, 7 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_201               = assign({ { 37, 0 }, { 37, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _ODS6_ 
      aLAYER_202               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_203               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _DNWEN1_ 
      aLAYER_204               = assign({ { 1 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_205               = assign({ { 1 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _POS11_ 
      aLAYER_206               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_207               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
      aLAYER_208               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_209               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _POS13_ 
      aLAYER_210               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_211               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
      aLAYER_212               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_213               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _NWRODS3_ 
      aLAYER_214               = assign({ { 3, [0, 255] } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_215               = assign({ { 3, [0, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _NWRODR1_ 
      aLAYER_216               = assign({ { 3, [0, 255] } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_217               = assign({ { 3, [0, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _NWRSTIEN2_ 
      aLAYER_218               = assign({ { 3, [0, 255] } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_219               = assign({ { 3, [0, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _NWRSTIR1_ 
      aLAYER_220               = assign({ { 3, [0, 255] } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_221               = assign({ { 3, [0, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _ODW2_ 
      aLAYER_222               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_223               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
      aLAYER_224               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_225               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _POS4_1_ 
      aLAYER_226               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_227               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _RES2_ 
      aLAYER_228               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_229               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
      aLAYER_230               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_231               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _RES8_ 
      aLAYER_232               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_233               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _RES9_ 
      aLAYER_234               = assign({ { 117 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_235               = assign({ { 117 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _COEN1_ 
      aLAYER_236               = assign({ { 30, [0, 10] }, { 30, [12, 255] } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_237               = assign({ { 30, [0, 10] }, { 30, [12, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _COEN3_ 
      aLAYER_238               = assign({ { 30, [0, 10] }, { 30, [12, 255] } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_239               = assign({ { 30, [0, 10] }, { 30, [12, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _COS3_ 
      aLAYER_240               = assign({ { 30, [0, 10] }, { 30, [12, 255] } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_241               = assign({ { 30, [0, 10] }, { 30, [12, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _ODS1_ 
      aLAYER_242               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_243               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _POS1_ 
      aLAYER_244               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_245               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _M1S1_ 
      aLAYER_246               = assign({ { 31, 0 }, { 31, 7 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_247               = assign({ { 31, 0 }, { 31, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _M1EN1_M1EN2_ 
      aLAYER_248               = assign({ { 30, [0, 10] }, { 30, [12, 255] } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_249               = assign({ { 30, [0, 10] }, { 30, [12, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _M1S7_ 
      aLAYER_250               = assign({ { 31, 0 }, { 31, 7 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_251               = assign({ { 31, 0 }, { 31, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
      aLAYER_252               = assign({ { 31, 1 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_253               = assign({ { 31, 1 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _VIA1EN1_VIA1EN2_ 
      aLAYER_254               = assign({ { 51, 0 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_255               = assign({ { 51, 0 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _M2EN1_M2EN2_ 
      aLAYER_256               = assign({ { 51, 0 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_257               = assign({ { 51, 0 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _M2S1_ 
      aLAYER_258               = assign({ { 32, 0 }, { 32, 7 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_259               = assign({ { 32, 0 }, { 32, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _M2S7_ 
      aLAYER_260               = assign({ { 32, 0 }, { 32, 7 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_261               = assign({ { 32, 0 }, { 32, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
      aLAYER_262               = assign({ { 32, 1 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_263               = assign({ { 32, 1 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _VIA2EN1_VIA2EN2_ 
      aLAYER_264               = assign({ { 52, 0 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_265               = assign({ { 52, 0 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _M3EN1_M3EN2_ 
      aLAYER_266               = assign({ { 52, 0 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_267               = assign({ { 52, 0 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _M3S1_ 
      aLAYER_268               = assign({ { 33, 0 }, { 33, 7 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_269               = assign({ { 33, 0 }, { 33, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _M3S7_ 
      aLAYER_270               = assign({ { 33, 0 }, { 33, 7 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_271               = assign({ { 33, 0 }, { 33, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
      aLAYER_272               = assign({ { 33, 1 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_273               = assign({ { 33, 1 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _VIA3EN1_VIA3EN2_ 
      aLAYER_274               = assign({ { 53, 0 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_275               = assign({ { 53, 0 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _M4EN1_M4EN2_ 
      aLAYER_276               = assign({ { 53, 0 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_277               = assign({ { 53, 0 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _M4S1_ 
      aLAYER_278               = assign({ { 34, 0 }, { 34, 7 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_279               = assign({ { 34, 0 }, { 34, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _M4S7_ 
      aLAYER_280               = assign({ { 34, 0 }, { 34, 7 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_281               = assign({ { 34, 0 }, { 34, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
      aLAYER_282               = assign({ { 34, 1 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_283               = assign({ { 34, 1 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _VIA4EN1_VIA4EN2_ 
      aLAYER_284               = assign({ { 54, 0 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_285               = assign({ { 54, 0 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _M5EN1_M5EN2_ 
      aLAYER_286               = assign({ { 54, 0 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_287               = assign({ { 54, 0 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _M5S1_ 
      aLAYER_288               = assign({ { 35, 0 }, { 35, 7 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_289               = assign({ { 35, 0 }, { 35, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _M5S7_ 
      aLAYER_290               = assign({ { 35, 0 }, { 35, 7 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_291               = assign({ { 35, 0 }, { 35, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
      aLAYER_292               = assign({ { 35, 1 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_293               = assign({ { 35, 1 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _VIA5EN1_VIA5EN2_ 
      aLAYER_294               = assign({ { 55, 0 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_295               = assign({ { 55, 0 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _M6EN1_M6EN2_ 
      aLAYER_296               = assign({ { 55, 0 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_297               = assign({ { 55, 0 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _M6S1_ 
      aLAYER_298               = assign({ { 36, 0 }, { 36, 7 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_299               = assign({ { 36, 0 }, { 36, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _M6S7_ 
      aLAYER_300               = assign({ { 36, 0 }, { 36, 7 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_301               = assign({ { 36, 0 }, { 36, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
      aLAYER_302               = assign({ { 36, 1 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_303               = assign({ { 36, 1 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _VIA6EN1_VIA6EN2_ 
      aLAYER_304               = assign({ { 56, 0 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_305               = assign({ { 56, 0 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _M7EN1_M7EN2_ 
      aLAYER_306               = assign({ { 56, 0 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_307               = assign({ { 56, 0 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _M7S1_ 
      aLAYER_308               = assign({ { 37, 0 }, { 37, 7 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_309               = assign({ { 37, 0 }, { 37, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _M7S7_ 
      aLAYER_310               = assign({ { 37, 0 }, { 37, 7 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_311               = assign({ { 37, 0 }, { 37, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
      aLAYER_312               = assign({ { 37, 1 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_313               = assign({ { 37, 1 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _VIAxR8_ 
      aLAYER_314               = assign({ { 52, 0 } }, select = { cells = { CELLSFORRRULERECOMMENDED } }); 
      aLAYER_315               = assign({ { 52, 0 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULERECOMMENDED) }); 
   #endif
   #ifdef _OPCR2_ 
      aLAYER_316               = assign({ { 25 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_317               = assign({ { 25 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
      aLAYER_318               = assign({ { 26 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_319               = assign({ { 26 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
      aLAYER_320               = assign({ { 67 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_321               = assign({ { 67 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
      aLAYER_322               = assign({ { 68 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_323               = assign({ { 68 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
      aLAYER_324               = assign({ { 12 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_325               = assign({ { 12 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
      aLAYER_326               = assign({ { 13 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_327               = assign({ { 13 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
      aLAYER_328               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_329               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
      aLAYER_330               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_331               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
      aLAYER_332               = assign({ { 31, 0 }, { 31, 7 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_333               = assign({ { 31, 0 }, { 31, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
      aLAYER_334               = assign({ { 32, 0 }, { 32, 7 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_335               = assign({ { 32, 0 }, { 32, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
      aLAYER_336               = assign({ { 33, 0 }, { 33, 7 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_337               = assign({ { 33, 0 }, { 33, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
      aLAYER_338               = assign({ { 34, 0 }, { 34, 7 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_339               = assign({ { 34, 0 }, { 34, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
      aLAYER_340               = assign({ { 35, 0 }, { 35, 7 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_341               = assign({ { 35, 0 }, { 35, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
      aLAYER_342               = assign({ { 36, 0 }, { 36, 7 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_343               = assign({ { 36, 0 }, { 36, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
      aLAYER_344               = assign({ { 37, 0 }, { 37, 7 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_345               = assign({ { 37, 0 }, { 37, 7 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
   #endif
   #ifdef _NWR1_ 
      aLAYER_346               = assign({ { 3, [0, 255] } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_347               = assign({ { 3, [0, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
   #endif
   #ifdef _DNWR6_ 
      aLAYER_348               = assign({ { 1 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_349               = assign({ { 1 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
   #endif
   #ifdef _NWRODR3_NWRSTIR3_ 
      aLAYER_350               = assign({ { 114 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_351               = assign({ { 114 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
   #endif
   #ifdef _COS6_ 
      aLAYER_352               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_353               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
   #endif
   #ifdef _COR5_ 
      aLAYER_354               = assign({ { 30, [0, 10] }, { 30, [12, 255] } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_355               = assign({ { 30, [0, 10] }, { 30, [12, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
   #endif
   #ifdef _VIA1R9_ 
      aLAYER_356               = assign({ { 51, 0 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_357               = assign({ { 51, 0 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
   #endif
   #ifdef _VIA2R9_ 
      aLAYER_358               = assign({ { 52, 0 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_359               = assign({ { 52, 0 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
   #endif
   #ifdef _VIA3R9_ 
      aLAYER_360               = assign({ { 53, 0 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_361               = assign({ { 53, 0 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
   #endif
   #ifdef _VIA4R9_ 
      aLAYER_362               = assign({ { 54, 0 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_363               = assign({ { 54, 0 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
   #endif
   #ifdef _VIA5R9_ 
      aLAYER_364               = assign({ { 55, 0 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_365               = assign({ { 55, 0 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
   #endif
   #ifdef _VIA6R9_ 
      aLAYER_366               = assign({ { 56, 0 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
      aLAYER_367               = assign({ { 56, 0 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
   #endif
   #ifdef _VIA7R5_ 
      #ifdef MIXED_SCHEME 
         aLAYER_368               = assign({ { 57, 0 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
         aLAYER_369               = assign({ { 57, 0 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
         aLAYER_370               = assign({ { 57, 40 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
         aLAYER_371               = assign({ { 57, 40 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
      #else
         aLAYER_372               = assign({ { 57, 40 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
         aLAYER_373               = assign({ { 57, 40 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
      #endif
   #endif
   #ifdef _VIA8R5_ 
      #ifdef MIXED_SCHEME 
         aLAYER_374               = assign({ { 58, 0 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
         aLAYER_375               = assign({ { 58, 0 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
         aLAYER_376               = assign({ { 58, 40 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
         aLAYER_377               = assign({ { 58, 40 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
      #else
         aLAYER_378               = assign({ { 58, 40 } }, select = { cells = { CELLSFORRRULEGUIDELINE } }); 
         aLAYER_379               = assign({ { 58, 40 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEGUIDELINE) }); 
      #endif
   #endif
   #ifdef _POS5m_ 
      aLAYER_380               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select = { cells = { CELLSFORRRULEANALOG } }); 
      aLAYER_381               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEANALOG) }); 
   #endif
   #ifdef _POS6m_ 
      aLAYER_382               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select = { cells = { CELLSFORRRULEANALOG } }); 
      aLAYER_383               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEANALOG) }); 
   #endif
   #ifdef _RES5m_ 
      aLAYER_384               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select = { cells = { CELLSFORRRULEANALOG } }); 
      aLAYER_385               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEANALOG) }); 
      aLAYER_386               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select = { cells = { CELLSFORRRULEANALOG } }); 
      aLAYER_387               = assign({ { 6, 0 }, { 6, 2 }, { 6, [4, 160] }, { 6, [166, 255] }, { 7 }, { 8 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEANALOG) }); 
   #endif
   #ifdef _ANR17_ 
      aLAYER_388               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select = { cells = { CELLSFORRRULEANALOG } }); 
      aLAYER_389               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEANALOG) }); 
   #endif
   #ifdef _ANR20_ 
      aLAYER_390               = assign({ { 143 } }, select = { cells = { CELLSFORRRULEANALOG } }); 
      aLAYER_391               = assign({ { 143 } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEANALOG) }); 
   #endif
   #ifdef _ANR47_ 
      aLAYER_392               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select = { cells = { CELLSFORRRULEANALOG } }); 
      aLAYER_393               = assign({ { 17, 0 }, { 17, [2, 50] }, { 17, [52, 160] }, { 17, [166, 255] } }, select_cells = { "*", inv_cell_name(EXCLCELLSFORRRULEANALOG) }); 
   #endif
#endif

//
// ENVIRONMENT SETUP
//------------------
/* For 0.005um layout grid   */
/* For layout grid check. default grid value is resolution size */
/* inside SRAM periphrial regions only */
/* inside SRAM periphrial regions only */
#ifndef DFM_ONLY 
   #ifdef FRONT_END 
      #ifdef HALF_NODE 
         #ifdef LP 
            violation_name_unselect( { "rDPO_W_1" } );
            violation_name_unselect( { "rDPO_S_1" } );
            violation_name_unselect( { "rDPO_S_2" } );
            violation_name_unselect( { "rDPO_S_3" } );
         #endif
      #else
         #ifdef LP 
            violation_name_unselect( { "rVAR_R_2" } );
            violation_name_unselect( { "rVAR_R_3" } );
            violation_name_unselect( { "rVAR_R_5" } );
         #endif
      #endif
   #endif
#endif
#ifdef HALF_NODE 
   
                                    // Please note that only N55 process could use this variable.
#endif /* end of #ifdef HALF_NODE  */ 

//-------- Patch definition --------

#pragma ICV patch_insert patch_assigns

#pragma ICV patch_insert patch_unselects


#ifdef SNPSINDESIGN

	#ifdef USE_ICC2
		NDM_BOUNDARY = assign({ {NDM_SYSTEM_LAYER_BOUNDARY}}, ndm = {views = {DESIGN_VIEW}});
	#endif
	
	#ifndef	  EXTENDED_LAYERS
  	/* Layer 255 used for cells, to get just top level boundary layer, */
	 	MW_BOUNDARY = assign({{255}});
	#else
		/* Layer 4095 used for cells, to get just top level boundary layer, */
		MW_BOUNDARY = assign({{4095}});
	#endif
	
	topcell = get_top_cell();
	MW_BOUNDARY = copy_by_cells(MW_BOUNDARY, topcell, CELL_LEVEL);

#endif

CHIPWINDOW = empty_layer();
EMPTYI = empty_layer();


#ifdef ChipWindowUsed 
   CHIPWINDOW = CHIPWINDOW or polygons( { { { XLB, YLB }, { XRT, YRT } } } ); 
#endif
SRAM_EXCLUDE = copy( SRAMDMY ); 
NWEL = NWI not_inside SRAM_EXCLUDE; 

// EXCLUDE UNCHECKED REGIONS
//--------------------------
DNW = DNWI not_inside SRAM_EXCLUDE; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NWEL }, DNW }} );    /* For DNW.S.2 check only, not for electrical connection. */ 
NPODI = NPI and ODI; 
NONWRI = not_cutting( NWI, NWDMY ); 
NSTPI = NPODI and NONWRI;                /* Break the connection at NWR   */ 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSTPI }, NWI }} ); 
PPODI = PPI and ODI; 
PACTI = PPODI and NWI; 
PSDI = PACTI not POI;                    /* PMOS source/drain */ 

// For poly and od resistors identify
RPDMYI = not_interacting( RPDMY, RPOI ); 
RPO_RPDMY = RPOI or RPDMYI; 
PSDC = PSDI not RPO_RPDMY;               /* PMOS source/drain for connection */ 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSTPI }, PSDC }} );    /* For butted pickup */ 
PSTPI = PPODI not NWI; 
#ifdef ChipWindowUsed 
   gCHIP = copy( CHIPWINDOW ); 
#endif
DNWI_EXTENT = layer_extent( DNWI ); 
NWI_EXTENT = layer_extent( NWI ); 
OD_18I_EXTENT = layer_extent( OD_18I ); 
OD_25I_EXTENT = layer_extent( OD_25I ); 
OD_33I_EXTENT = layer_extent( OD_33I ); 
OD_DECAP_EXTENT = layer_extent( OD_DECAP ); 
PPI_EXTENT = layer_extent( PPI ); 
NPI_EXTENT = layer_extent( NPI ); 
CBI_EXTENT = layer_extent( CBI ); 
CB2I_EXTENT = layer_extent( CB2I ); 
RPOI_EXTENT = layer_extent( RPOI ); 
NT_NI_EXTENT = layer_extent( NT_NI ); 
FWALI_EXTENT = layer_extent( FWALI ); 
FWCUI_EXTENT = layer_extent( FWCUI ); 
POFUSE_EXTENT = layer_extent( POFUSE ); 
FUSELINK_EXTENT = layer_extent( FUSELINK ); 
PMI_EXTENT = layer_extent( PMI ); 
PM1I_EXTENT = layer_extent( PM1I ); 
PM2I_EXTENT = layer_extent( PM2I ); 
VTH_NI_EXTENT = layer_extent( VTH_NI ); 
VTH_PI_EXTENT = layer_extent( VTH_PI ); 
VTL_NI_EXTENT = layer_extent( VTL_NI ); 
VTL_PI_EXTENT = layer_extent( VTL_PI ); 
UHVT_NI_EXTENT = layer_extent( UHVT_NI ); 
UHVT_PI_EXTENT = layer_extent( UHVT_PI ); 
CBDI_EXTENT = layer_extent( CBDI ); 
UBMI_EXTENT = layer_extent( UBMI ); 
RH_EXTENT = layer_extent( RH ); 
ESD3_EXTENT = layer_extent( ESD3 ); 
VARI_EXTENT = layer_extent( VARI ); 
API_EXTENT = layer_extent( API ); 
CU_PPII_EXTENT = layer_extent( CU_PPII ); 
CBMI_EXTENT = layer_extent( CBMI ); 
CTMI_EXTENT = layer_extent( CTMI ); 
RVI_EXTENT = layer_extent( RVI ); 
DCOI_EXTENT = layer_extent( DCOI ); 
HVD_P_EXTENT = layer_extent( HVD_P ); 
HVD_N_NW_EXTENT = layer_extent( HVD_N_NW ); 
SRM_ULL_EXTENT = layer_extent( SRM_ULL ); 
BJTDMY_EXTENT = layer_extent( BJTDMY ); 
RODMY_EXTENT = layer_extent( RODMY ); 
LMARK_EXTENT = layer_extent( LMARK ); 
SRM_EXTENT = layer_extent( SRM ); 
TCDDMY_EXTENT = layer_extent( TCDDMY ); 
SRAMDMY_EXTENT = layer_extent( SRAMDMY ); 
SRAMDMY_4_EXTENT = layer_extent( SRAMDMY_4 ); 
SRAMDMY_5_EXTENT = layer_extent( SRAMDMY_5 ); 
SRAMDMY_1_EXTENT = layer_extent( SRAMDMY_1 ); 
OD1TI_EXTENT = layer_extent( OD1TI ); 
CLDDI_EXTENT = layer_extent( CLDDI ); 
CROWNI_EXTENT = layer_extent( CROWNI ); 
P3I_EXTENT = layer_extent( P3I ); 
SNCTI_EXTENT = layer_extent( SNCTI ); 
LUPWDMY_EXTENT = layer_extent( LUPWDMY ); 
LUPWDMY_2_EXTENT = layer_extent( LUPWDMY_2 ); 
VDDDMY_EXTENT = layer_extent( VDDDMY ); 
VSSDMY_EXTENT = layer_extent( VSSDMY ); 
MATCHING_EXTENT = layer_extent( MATCHING ); 
M1I_EXTENT = layer_extent( M1I ); 
M1_REAL_EXTENT = layer_extent( M1_REAL ); 
DM1_O_EXTENT = layer_extent( DM1_O ); 
DUM1_EXTENT = layer_extent( DUM1 ); 
M2I_EXTENT = layer_extent( M2I ); 
M2_REAL_EXTENT = layer_extent( M2_REAL ); 
DM2_O_EXTENT = layer_extent( DM2_O ); 
DUM2_EXTENT = layer_extent( DUM2 ); 
M3I_EXTENT = layer_extent( M3I ); 
M3_REAL_EXTENT = layer_extent( M3_REAL ); 
DM3_O_EXTENT = layer_extent( DM3_O ); 
DUM3_EXTENT = layer_extent( DUM3 ); 
M4I_EXTENT = layer_extent( M4I ); 
M4_REAL_EXTENT = layer_extent( M4_REAL ); 
DM4_O_EXTENT = layer_extent( DM4_O ); 
DUM4_EXTENT = layer_extent( DUM4 ); 
M5I_EXTENT = layer_extent( M5I ); 
M5_REAL_EXTENT = layer_extent( M5_REAL ); 
DM5_O_EXTENT = layer_extent( DM5_O ); 
DUM5_EXTENT = layer_extent( DUM5 ); 
M6I_EXTENT = layer_extent( M6I ); 
M6_REAL_EXTENT = layer_extent( M6_REAL ); 
DM6_O_EXTENT = layer_extent( DM6_O ); 
DUM6_EXTENT = layer_extent( DUM6 ); 
M7I_EXTENT = layer_extent( M7I ); 
M7_REAL_EXTENT = layer_extent( M7_REAL ); 
DM7_O_EXTENT = layer_extent( DM7_O ); 
DUM7_EXTENT = layer_extent( DUM7 ); 
M8_OLD_EXTENT = layer_extent( M8_OLD ); 
M8_NEW_EXTENT = layer_extent( M8_NEW ); 
DUM8_OLD_EXTENT = layer_extent( DUM8_OLD ); 
DUM8_NEW_EXTENT = layer_extent( DUM8_NEW ); 
M9_OLD_EXTENT = layer_extent( M9_OLD ); 
M9_NEW_EXTENT = layer_extent( M9_NEW ); 
DUM9_OLD_EXTENT = layer_extent( DUM9_OLD ); 
DUM9_NEW_EXTENT = layer_extent( DUM9_NEW ); 
ODI_EXTENT = layer_extent( ODI ); 
DOD_EXTENT = layer_extent( DOD ); 
POI_EXTENT = layer_extent( POI ); 
DPO_EXTENT = layer_extent( DPO ); 
MVTLI_EXTENT = layer_extent( MVTLI ); 
RMDMY1_EXTENT = layer_extent( RMDMY1 ); 
RMDMY2_EXTENT = layer_extent( RMDMY2 ); 
RMDMY3_EXTENT = layer_extent( RMDMY3 ); 
RMDMY4_EXTENT = layer_extent( RMDMY4 ); 
RMDMY5_EXTENT = layer_extent( RMDMY5 ); 
RMDMY6_EXTENT = layer_extent( RMDMY6 ); 
RMDMY7_EXTENT = layer_extent( RMDMY7 ); 
RMDMY8_EXTENT = layer_extent( RMDMY8 ); 
RMDMY9_EXTENT = layer_extent( RMDMY9 ); 
RMDMYAP_EXTENT = layer_extent( RMDMYAP ); 
gLAYER_107 = DNWI_EXTENT or NWI_EXTENT; 
gLAYER_106 = gLAYER_107 or OD_18I_EXTENT; 
gLAYER_105 = gLAYER_106 or OD_25I_EXTENT; 
gLAYER_104 = gLAYER_105 or OD_33I_EXTENT; 
gLAYER_103 = gLAYER_104 or OD_DECAP_EXTENT; 
gLAYER_102 = gLAYER_103 or PPI_EXTENT; 
gLAYER_101 = gLAYER_102 or NPI_EXTENT; 
gLAYER_100 = gLAYER_101 or CBI_EXTENT; 
gLAYER_99 = gLAYER_100 or CB2I_EXTENT; 
gLAYER_98 = gLAYER_99 or RPOI_EXTENT; 
gLAYER_97 = gLAYER_98 or NT_NI_EXTENT; 
gLAYER_96 = gLAYER_97 or FWALI_EXTENT; 
gLAYER_95 = gLAYER_96 or FWCUI_EXTENT; 
gLAYER_94 = gLAYER_95 or POFUSE_EXTENT; 
gLAYER_93 = gLAYER_94 or FUSELINK_EXTENT; 
gLAYER_92 = gLAYER_93 or PMI_EXTENT; 
gLAYER_91 = gLAYER_92 or PM1I_EXTENT; 
gLAYER_90 = gLAYER_91 or PM2I_EXTENT; 
gLAYER_89 = gLAYER_90 or VTH_NI_EXTENT; 
gLAYER_88 = gLAYER_89 or VTH_PI_EXTENT; 
gLAYER_87 = gLAYER_88 or VTL_NI_EXTENT; 
gLAYER_86 = gLAYER_87 or VTL_PI_EXTENT; 
gLAYER_85 = gLAYER_86 or UHVT_NI_EXTENT; 
gLAYER_84 = gLAYER_85 or UHVT_PI_EXTENT; 
gLAYER_83 = gLAYER_84 or CBDI_EXTENT; 
gLAYER_82 = gLAYER_83 or UBMI_EXTENT; 
gLAYER_81 = gLAYER_82 or RH_EXTENT; 
gLAYER_80 = gLAYER_81 or ESD3_EXTENT; 
gLAYER_79 = gLAYER_80 or VARI_EXTENT; 
gLAYER_78 = gLAYER_79 or API_EXTENT; 
gLAYER_77 = gLAYER_78 or CU_PPII_EXTENT; 
gLAYER_76 = gLAYER_77 or CBMI_EXTENT; 
gLAYER_75 = gLAYER_76 or CTMI_EXTENT; 
gLAYER_74 = gLAYER_75 or RVI_EXTENT; 
gLAYER_73 = gLAYER_74 or DCOI_EXTENT; 
gLAYER_72 = gLAYER_73 or HVD_P_EXTENT; 
gLAYER_71 = gLAYER_72 or HVD_N_NW_EXTENT; 
gLAYER_70 = gLAYER_71 or SRM_ULL_EXTENT; 
gLAYER_69 = gLAYER_70 or BJTDMY_EXTENT; 
gLAYER_68 = gLAYER_69 or RODMY_EXTENT; 
gLAYER_67 = gLAYER_68 or LMARK_EXTENT; 
gLAYER_66 = gLAYER_67 or SRM_EXTENT; 
gLAYER_65 = gLAYER_66 or TCDDMY_EXTENT; 
gLAYER_64 = gLAYER_65 or SRAMDMY_EXTENT; 
gLAYER_63 = gLAYER_64 or SRAMDMY_4_EXTENT; 
gLAYER_62 = gLAYER_63 or SRAMDMY_5_EXTENT; 
gLAYER_61 = gLAYER_62 or SRAMDMY_1_EXTENT; 
gLAYER_60 = gLAYER_61 or OD1TI_EXTENT; 
gLAYER_59 = gLAYER_60 or CLDDI_EXTENT; 
gLAYER_58 = gLAYER_59 or CROWNI_EXTENT; 
gLAYER_57 = gLAYER_58 or P3I_EXTENT; 
gLAYER_56 = gLAYER_57 or SNCTI_EXTENT; 
gLAYER_55 = gLAYER_56 or LUPWDMY_EXTENT; 
gLAYER_54 = gLAYER_55 or LUPWDMY_2_EXTENT; 
gLAYER_53 = gLAYER_54 or VDDDMY_EXTENT; 
gLAYER_52 = gLAYER_53 or VSSDMY_EXTENT; 
gLAYER_51 = gLAYER_52 or MATCHING_EXTENT; 
gLAYER_50 = gLAYER_51 or M1I_EXTENT; 
gLAYER_49 = gLAYER_50 or M1_REAL_EXTENT; 
gLAYER_48 = gLAYER_49 or DM1_O_EXTENT; 
gLAYER_47 = gLAYER_48 or DUM1_EXTENT; 
gLAYER_46 = gLAYER_47 or M2I_EXTENT; 
gLAYER_45 = gLAYER_46 or M2_REAL_EXTENT; 
gLAYER_44 = gLAYER_45 or DM2_O_EXTENT; 
gLAYER_43 = gLAYER_44 or DUM2_EXTENT; 
gLAYER_42 = gLAYER_43 or M3I_EXTENT; 
gLAYER_41 = gLAYER_42 or M3_REAL_EXTENT; 
gLAYER_40 = gLAYER_41 or DM3_O_EXTENT; 
gLAYER_39 = gLAYER_40 or DUM3_EXTENT; 
gLAYER_38 = gLAYER_39 or M4I_EXTENT; 
gLAYER_37 = gLAYER_38 or M4_REAL_EXTENT; 
gLAYER_36 = gLAYER_37 or DM4_O_EXTENT; 
gLAYER_35 = gLAYER_36 or DUM4_EXTENT; 
gLAYER_34 = gLAYER_35 or M5I_EXTENT; 
gLAYER_33 = gLAYER_34 or M5_REAL_EXTENT; 
gLAYER_32 = gLAYER_33 or DM5_O_EXTENT; 
gLAYER_31 = gLAYER_32 or DUM5_EXTENT; 
gLAYER_30 = gLAYER_31 or M6I_EXTENT; 
gLAYER_29 = gLAYER_30 or M6_REAL_EXTENT; 
gLAYER_28 = gLAYER_29 or DM6_O_EXTENT; 
gLAYER_27 = gLAYER_28 or DUM6_EXTENT; 
gLAYER_26 = gLAYER_27 or M7I_EXTENT; 
gLAYER_25 = gLAYER_26 or M7_REAL_EXTENT; 
gLAYER_24 = gLAYER_25 or DM7_O_EXTENT; 
gLAYER_23 = gLAYER_24 or DUM7_EXTENT; 
gLAYER_22 = gLAYER_23 or M8_OLD_EXTENT; 
gLAYER_21 = gLAYER_22 or M8_NEW_EXTENT; 
gLAYER_20 = gLAYER_21 or DUM8_OLD_EXTENT; 
gLAYER_19 = gLAYER_20 or DUM8_NEW_EXTENT; 
gLAYER_18 = gLAYER_19 or M9_OLD_EXTENT; 
gLAYER_17 = gLAYER_18 or M9_NEW_EXTENT; 
gLAYER_16 = gLAYER_17 or DUM9_OLD_EXTENT; 
gLAYER_15 = gLAYER_16 or DUM9_NEW_EXTENT; 
gLAYER_14 = gLAYER_15 or ODI_EXTENT; 
gLAYER_13 = gLAYER_14 or DOD_EXTENT; 
gLAYER_12 = gLAYER_13 or POI_EXTENT; 
gLAYER_11 = gLAYER_12 or DPO_EXTENT; 
gLAYER_10 = gLAYER_11 or MVTLI_EXTENT; 
gLAYER_9 = gLAYER_10 or RMDMY1_EXTENT; 
gLAYER_8 = gLAYER_9 or RMDMY2_EXTENT; 
gLAYER_7 = gLAYER_8 or RMDMY3_EXTENT; 
gLAYER_6 = gLAYER_7 or RMDMY4_EXTENT; 
gLAYER_5 = gLAYER_6 or RMDMY5_EXTENT; 
gLAYER_4 = gLAYER_5 or RMDMY6_EXTENT; 
gLAYER_3 = gLAYER_4 or RMDMY7_EXTENT; 
gLAYER_2 = gLAYER_3 or RMDMY8_EXTENT; 
gLAYER_1 = gLAYER_2 or RMDMY9_EXTENT; 
MT_LAYERS = gLAYER_1 or RMDMYAP_EXTENT; 
#ifndef ChipWindowUsed 
   gCHIP = layer_extent( MT_LAYERS ); 

    #ifdef SNPSINDESIGN
       #ifdef USE_ICC2
           gCHIP = copy( NDM_BOUNDARY );
       #else
           gCHIP = copy( MW_BOUNDARY );
       #endif /* end of #ifdef USE_ICC2 */
    #endif /* end of #ifdef SNPSINDESIGN */

#endif
gBULK = size( gCHIP, clip_acute = NONE, distance = 1.0 );
PWELI = gBULK not NWI; 
RWI = PWELI inside DNWI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSTPI }, RWI }} );    /* For DNW connection */ 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSTPI }, PWELI }} );    /* For DNW connection */ 
NACTI = NPODI not NWI; 
NSDI = NACTI not POI;                    /* NMOS source/drain */ 
NSDC = NSDI not RPO_RPDMY;               /* NMOS source/drain for connection */ 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSTPI }, NSDC }} );    /* For butted pickup */ 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COI }, PSDC }} );    /* For butted CO */ 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COI }, NSDC }} );    /* For butted CO */ 

// Nodal NWEL connectivity checks
ILP1I = POI not RPO_RPDMY;               /* Interconnect poly */ 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COI }, ILP1I }} );    /* For butted CO */ 
gLAYER_149 = cutting( NWI, NWDMY ); 
NWRIT = gLAYER_149 not NWDMY;             /* NWR terminal   */ 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1I, ILP1I, NSTPI, PSTPI, PSDC, NSDC, NWRIT }, COI, NONE, SHIELDED_OVERLAP }} );
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M2I, M1I }, VIA1I, NONE }} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M3I, M2I }, VIA2I, NONE }} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M4I, M3I }, VIA3I, NONE }} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M5I, M4I }, VIA4I, NONE }} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6I, M5I }, VIA5I, NONE }} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M7I, M6I }, VIA6I, NONE }} ); 
#ifdef MIXED_SCHEME 
   M8I = M8_OLD or M8_NEW; 
#else
   M8I = copy( M8_NEW ); 
#endif
#ifdef MIXED_SCHEME 
   VIA7I = VIA7_OLD or VIA7_NEW; 
#else
   VIA7I = copy( VIA7_NEW ); 
#endif
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M8I, CTMI, CBMI, M7I }, VIA7I, NONE, SHIELDED_OVERLAP }} );
#ifdef MIXED_SCHEME 
   M9I = M9_OLD or M9_NEW; 
#else
   M9I = copy( M9_NEW ); 
#endif
#ifdef MIXED_SCHEME 
   VIA8I = VIA8_OLD or VIA8_NEW; 
#else
   VIA8I = copy( VIA8_NEW ); 
#endif
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M9I, M8I }, VIA8I, NONE }} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CBI }, M9I }} ); 

// APRDL
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M9I, API }, RVI, NONE }} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M9I, API }, CBI, NONE }} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M9I, API }, CBDI, NONE }} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CB2I }, API }} ); 
#ifdef WLCSP_2_MASK 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CB2I }, CU_PPII }} ); 
#else
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CB2I }, PM1I }} ); 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PM1I }, CU_PPII }} ); 
#endif
UBMN = not_interacting( UBMI, CU_PPII ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMN }, API }} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMN, M9I }, CBDI, NONE }} ); 
UBMD = interacting( UBMI, CU_PPII ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMD, CU_PPII }, PM2I, NONE }} ); 
NSTPU = NPODI and NWI; 
gLAYER_150 = size( gCHIP, clip_acute = NONE, distance = 2.0 );
EMPTYU = gCHIP not gLAYER_150; 
NWU = EMPTYU or NWI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSTPU }, NWU }} ); 
PSDU = EMPTYU or PSDI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSTPU }, PSDU }} );    /* For butted pickup */ 
PSTPU = EMPTYU or PSTPI; 
RWU = EMPTYU or RWI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSTPU }, RWU }} );    /* For DNW connection */ 
PWELU = EMPTYU or PWELI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSTPU }, PWELU }} );    /* For DNW connection */ 
NSDU = EMPTYU or NSDI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSTPU }, NSDU }} );    /* For butted pickup */ 
COU = EMPTYU or COI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COU }, PSDU }} );    /* For butted CO */ 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COU }, NSDU }} );    /* For butted CO */ 
POU = EMPTYU or POI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COU }, POU }} );    /* For butted CO */ 
M1U = EMPTYU or M1I; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1U, POU, NSTPU, PSTPU, PSDU, NSDU }, COU, NONE, SHIELDED_OVERLAP }} );
NWRUT = EMPTYU or NWRIT; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1U, NWRUT }, COU, NONE }} ); 
M2U = EMPTYU or M2I; 
VIA1U = EMPTYU or VIA1I; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M2U, M1U }, VIA1U, NONE }} ); 
M3U = EMPTYU or M3I; 
VIA2U = EMPTYU or VIA2I; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M3U, M2U }, VIA2U, NONE }} ); 
M4U = EMPTYU or M4I; 
VIA3U = EMPTYU or VIA3I; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M4U, M3U }, VIA3U, NONE }} ); 
M5U = EMPTYU or M5I; 
VIA4U = EMPTYU or VIA4I; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M5U, M4U }, VIA4U, NONE }} ); 
M6U = EMPTYU or M6I; 
VIA5U = EMPTYU or VIA5I; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6U, M5U }, VIA5U, NONE }} ); 
M7U = EMPTYU or M7I; 
VIA6U = EMPTYU or VIA6I; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M7U, M6U }, VIA6U, NONE }} ); 
M8U = EMPTYU or M8I; 
CTMU = EMPTYU or CTMI; 
CBMU = EMPTYU or CBMI; 
VIA7U = EMPTYU or VIA7I; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M8U, CTMU, CBMU, M7U }, VIA7U, NONE, SHIELDED_OVERLAP }} );
M9U = EMPTYU or M9I; 
VIA8U = EMPTYU or VIA8I; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M9U, M8U }, VIA8U, NONE }} ); 
CBU = EMPTYU or CBI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CBU }, M9U }} );    /* for wire-bond without AP-RDL. AP/CB2 are not drawn. */ 
APU = EMPTYU or API; 
RVU = EMPTYU or RVI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M9U, APU }, RVU, NONE }} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M9U, APU }, CBU, NONE }} ); 
CBDU = EMPTYU or CBDI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M9U, APU }, CBDU, NONE }} ); 
CB2U = EMPTYU or CB2I; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CB2U }, APU }} ); 
CU_PPIU = EMPTYU or CU_PPII; 
#ifdef WLCSP_2_MASK 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CB2U }, CU_PPIU }} ); 
#endif
PM1U = EMPTYU or PM1I; 
#ifndef WLCSP_2_MASK 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CB2U }, PM1U }} ); 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PM1U }, CU_PPIU }} ); 
#endif
UBMNU = EMPTYU or UBMN; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMNU }, APU }} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMNU, M9U }, CBDU, NONE }} ); 
UBMDU = EMPTYU or UBMD; 
PM2U = EMPTYU or PM2I; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMDU, CU_PPIU }, PM2U, NONE }} ); 
gLAYER_151 = size( gCHIP, clip_acute = NONE, distance = 3.0 );
EMPTYM = gCHIP not gLAYER_151; 
M2_M = EMPTYM or M2I; 
M1_M = EMPTYM or M1I; 
VIA1_M = EMPTYM or VIA1I; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M2_M, M1_M }, VIA1_M, NONE }} ); 
M3_M = EMPTYM or M3I; 
VIA2_M = EMPTYM or VIA2I; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M3_M, M2_M }, VIA2_M, NONE }} ); 
M4_M = EMPTYM or M4I; 
VIA3_M = EMPTYM or VIA3I; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M4_M, M3_M }, VIA3_M, NONE }} ); 
M5_M = EMPTYM or M5I; 
VIA4_M = EMPTYM or VIA4I; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M5_M, M4_M }, VIA4_M, NONE }} ); 
M6_M = EMPTYM or M6I; 
VIA5_M = EMPTYM or VIA5I; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M6_M, M5_M }, VIA5_M, NONE }} ); 
M7_M = EMPTYM or M7I; 
VIA6_M = EMPTYM or VIA6I; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M7_M, M6_M }, VIA6_M, NONE }} ); 
VIA7_M = EMPTYM or VIA7I; 
CBM_M = EMPTYM or CBMI; 
VCAP_M7_M = VIA7_M not CBM_M; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VCAP_M7_M }, VIA7_M }} ); 
M8_M = EMPTYM or M8I; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M8_M, M7_M }, VIA7_M, NONE }} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M8_M }, VIA7_M }} ); 
M9_M = EMPTYM or M9I; 
VIA8_M = EMPTYM or VIA8I; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M9_M, M8_M }, VIA8_M, NONE }} ); 
CB_M = EMPTYM or CBI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CB_M }, M9_M }} ); 
AP_M = EMPTYM or API; 
RV_M = EMPTYM or RVI; 

// APRDL
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M9_M, AP_M }, RV_M, NONE }} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M9_M, AP_M }, CB_M, NONE }} ); 
CBD_M = EMPTYM or CBDI; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M9_M, AP_M }, CBD_M, NONE }} ); 
CB2_M = EMPTYM or CB2I; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CB2_M }, AP_M }} ); 
CU_PPI_M = EMPTYM or CU_PPII; 
#ifdef WLCSP_2_MASK 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CB2_M }, CU_PPI_M }} ); 
#endif
PM1_M = EMPTYM or PM1I; 
#ifndef WLCSP_2_MASK 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CB2_M }, PM1_M }} ); 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PM1_M }, CU_PPI_M }} ); 
#endif
UBMN_M = EMPTYM or UBMN; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMN_M }, AP_M }} ); 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMN_M, M9_M }, CBD_M, NONE }} ); 
UBMD_M = EMPTYM or UBMD; 
PM2_M = EMPTYM or PM2I; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMD_M, CU_PPI_M }, PM2_M, NONE }} ); 
CBM = copy( CBMI ); 

// metal in silicon
M1X = M1I or DUM1; 
M2X = M2I or DUM2; 
M3X = M3I or DUM3; 
M4X = M4I or DUM4; 
M5X = M5I or DUM5; 
M6X = M6I or DUM6; 
M7X = M7I or DUM7; 
FW_AP = copy( FWALI ); 
CO = COI not SRAM_EXCLUDE; 
AP = copy( API ); 
VIA1 = VIA1I not SRAM_EXCLUDE; 
VIA2 = copy( VIA2I ); 
VIA3 = copy( VIA3I ); 
VIA4 = copy( VIA4I ); 
VIA5 = copy( VIA5I ); 
VIA6 = copy( VIA6I ); 
VIA7 = copy( VIA7I ); 
VIA8 = copy( VIA8I ); 
POLY = POI not SRAM_EXCLUDE; 
M1 = M1I not SRAM_EXCLUDE; 
M2 = copy( M2I ); 
M3 = copy( M3I ); 
M4 = copy( M4I ); 
M5 = copy( M5I ); 
M6 = copy( M6I ); 
M7 = copy( M7I ); 
M8 = copy( M8I ); 
M9 = copy( M9I ); 
#ifndef DFM_ONLY 
   #ifdef BACK_END 
      gLAYER_259 = size( CBM, clip_acute = NONE, distance = 25 ); 
      M1DN6_CBM_MERGE = size( gLAYER_259, clip_acute = NONE, distance = - 25 ); 
      M1DN6_CHECK_CBM = area( M1DN6_CBM_MERGE, >= ( 200 * 200 ) ); 
      M1DN6_M1_CHECK = M1X and M1DN6_CHECK_CBM; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1DN6_CHECK_CBM }, M1DN6_M1_CHECK }} ); 
      M1DN6_M2_CHECK = M2X and M1DN6_CHECK_CBM; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1DN6_CHECK_CBM }, M1DN6_M2_CHECK }} ); 
      M1DN6_M3_CHECK = M3X and M1DN6_CHECK_CBM; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M1DN6_CHECK_CBM }, M1DN6_M3_CHECK }} ); 
      gLAYER_276 = size( CBM, clip_acute = NONE, distance = 25 ); 
      M2DN6_CBM_MERGE = size( gLAYER_276, clip_acute = NONE, distance = - 25 ); 
      M2DN6_CHECK_CBM = area( M2DN6_CBM_MERGE, >= ( 200 * 200 ) ); 
      M2DN6_M2_CHECK = M2X and M2DN6_CHECK_CBM; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M2DN6_CHECK_CBM }, M2DN6_M2_CHECK }} ); 
      M2DN6_M3_CHECK = M3X and M2DN6_CHECK_CBM; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M2DN6_CHECK_CBM }, M2DN6_M3_CHECK }} ); 
      M2DN6_M4_CHECK = M4X and M2DN6_CHECK_CBM; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M2DN6_CHECK_CBM }, M2DN6_M4_CHECK }} ); 
      gLAYER_293 = size( CBM, clip_acute = NONE, distance = 25 ); 
      M3DN6_CBM_MERGE = size( gLAYER_293, clip_acute = NONE, distance = - 25 ); 
      M3DN6_CHECK_CBM = area( M3DN6_CBM_MERGE, >= ( 200 * 200 ) ); 
      M3DN6_M3_CHECK = M3X and M3DN6_CHECK_CBM; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M3DN6_CHECK_CBM }, M3DN6_M3_CHECK }} ); 
      M3DN6_M4_CHECK = M4X and M3DN6_CHECK_CBM; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M3DN6_CHECK_CBM }, M3DN6_M4_CHECK }} ); 
      M3DN6_M5_CHECK = M5X and M3DN6_CHECK_CBM; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M3DN6_CHECK_CBM }, M3DN6_M5_CHECK }} ); 
      gLAYER_310 = size( CBM, clip_acute = NONE, distance = 25 ); 
      M4DN6_CBM_MERGE = size( gLAYER_310, clip_acute = NONE, distance = - 25 ); 
      M4DN6_CHECK_CBM = area( M4DN6_CBM_MERGE, >= ( 200 * 200 ) ); 
      M4DN6_M4_CHECK = M4X and M4DN6_CHECK_CBM; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M4DN6_CHECK_CBM }, M4DN6_M4_CHECK }} ); 
      M4DN6_M5_CHECK = M5X and M4DN6_CHECK_CBM; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M4DN6_CHECK_CBM }, M4DN6_M5_CHECK }} ); 
      M4DN6_M6_CHECK = M6X and M4DN6_CHECK_CBM; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M4DN6_CHECK_CBM }, M4DN6_M6_CHECK }} ); 
      gLAYER_327 = size( CBM, clip_acute = NONE, distance = 25 ); 
      M5DN6_CBM_MERGE = size( gLAYER_327, clip_acute = NONE, distance = - 25 ); 
      M5DN6_CHECK_CBM = area( M5DN6_CBM_MERGE, >= ( 200 * 200 ) ); 
      M5DN6_M5_CHECK = M5X and M5DN6_CHECK_CBM; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M5DN6_CHECK_CBM }, M5DN6_M5_CHECK }} ); 
      M5DN6_M6_CHECK = M6X and M5DN6_CHECK_CBM; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M5DN6_CHECK_CBM }, M5DN6_M6_CHECK }} ); 
      M5DN6_M7_CHECK = M7X and M5DN6_CHECK_CBM; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ M5DN6_CHECK_CBM }, M5DN6_M7_CHECK }} ); 
      
      // 0.01 um checking tolerance is allowed
      REGION_A = size( INDDMY, clip_acute = NONE, distance = - 4 ); 
      REGION_B = INDDMY not REGION_A; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ REGION_B }, REGION_B }} ); 
      F_V0 = FW_AP and CO; 
      MTFS = FW_AP and AP; 
      
      // connection for metal/via under metal fuse
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ F_V0 }, MTFS }} ); 
      F_V1 = FW_AP and VIA1; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ F_V1 }, MTFS }} ); 
      F_V2 = FW_AP and VIA2; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ F_V2 }, MTFS }} ); 
      F_V3 = FW_AP and VIA3; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ F_V3 }, MTFS }} ); 
      F_V4 = FW_AP and VIA4; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ F_V4 }, MTFS }} ); 
      F_V5 = FW_AP and VIA5; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ F_V5 }, MTFS }} ); 
      F_V6 = FW_AP and VIA6; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ F_V6 }, MTFS }} ); 
      F_V7 = FW_AP and VIA7; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ F_V7 }, MTFS }} ); 
      F_V8 = FW_AP and VIA8; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ F_V8 }, MTFS }} ); 
      
      // Layer operation for metal fuse and protection ring
      //====================================================
      F_M0 = FW_AP and POLY; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ F_M0 }, MTFS }} ); 
      F_M1 = FW_AP and M1; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ F_M1 }, MTFS }} ); 
      F_M2 = FW_AP and M2; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ F_M2 }, MTFS }} ); 
      F_M3 = FW_AP and M3; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ F_M3 }, MTFS }} ); 
      F_M4 = FW_AP and M4; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ F_M4 }, MTFS }} ); 
      F_M5 = FW_AP and M5; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ F_M5 }, MTFS }} ); 
      F_M6 = FW_AP and M6; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ F_M6 }, MTFS }} ); 
      F_M7 = FW_AP and M7; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ F_M7 }, MTFS }} ); 
      F_M8 = FW_AP and M8; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ F_M8 }, MTFS }} ); 
      F_M9 = FW_AP and M9; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ F_M9 }, MTFS }} ); 
   #endif
#endif
PWEL = PWELI not SRAM_EXCLUDE; 
#ifndef DFM_ONLY 
   #ifdef FRONT_END 
      #ifdef GUIDELINE_ESD 
         NWELC = copy( NWEL ); 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NWELC }, NWELC }} ); 
         PWELC = copy( PWEL ); 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWELC }, PWELC }} ); 
      #endif
   #endif
#endif
SRAMDMY_PERI = SRAMDMY_4 or SRAMDMY_5; 
#ifndef DFM_ONLY 
   #ifdef FRONT_END 
      SRM_ALL_CELL = SRM not SRM_ULL; 
      gLAYER_744 = SRM or SRAMDMY; 
      gLAYER_743 = gLAYER_744 and COI; 
      gLAYER_742 = interacting( gLAYER_743, ODI ); 
      SRAM_BTC = interacting( gLAYER_742, POI ); 
      SRAM_BTC_ALL_CELL = SRM_ALL_CELL and SRAM_BTC; 
      CHIP_SRAM = chip_extent(); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ SRAM_BTC_ALL_CELL }, CHIP_SRAM }} ); 
      CO_PERI = COI not_outside SRAMDMY_PERI; 
      
      // SRAM WORD LINE DECODER CHECKS
      //-------------
      OD_PERI = ODI and SRAMDMY_PERI; 
      COOD_PERI = CO_PERI not_outside OD_PERI; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COOD_PERI }, OD_PERI }} ); 
      gLAYER_745 = ODI and SRAMDMY_4; 
      COOD_PERI_4 = CO_PERI not_outside gLAYER_745; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ COOD_PERI_4 }, OD_PERI }} ); 
   #endif
#endif
FWI = FWALI or FWCUI; 
MATCHINGI = MATCHING not SRAM_EXCLUDE; 
#ifdef MIXED_SCHEME 
   DUM8 = DUM8_OLD or DUM8_NEW; 
#else /* the reverse of #ifdef MIXED_SCHEME  */ 
   DUM8 = copy( DUM8_NEW ); 
#endif /* end of #ifdef MIXED_SCHEME  */ 
#ifdef MIXED_SCHEME 
   NOUSEM8 = copy( NOUSEM8_OLD ); 
#else /* the reverse of #ifdef MIXED_SCHEME  */ 
   NOUSEM8 = NOUSEM8_NEW or NOUSEM8_OLD; 
#endif /* end of #ifdef MIXED_SCHEME  */ 
#ifdef MIXED_SCHEME 
   DUM9 = DUM9_OLD or DUM9_NEW; 
#else /* the reverse of #ifdef MIXED_SCHEME  */ 
   DUM9 = copy( DUM9_NEW ); 
#endif /* end of #ifdef MIXED_SCHEME  */ 
#ifdef MIXED_SCHEME 
   NOUSEM9 = copy( NOUSEM9_OLD ); 
#else /* the reverse of #ifdef MIXED_SCHEME  */ 
   NOUSEM9 = NOUSEM9_NEW or NOUSEM9_OLD; 
#endif /* end of #ifdef MIXED_SCHEME  */ 
#ifdef MIXED_SCHEME 
   NOUSEV7 = copy( NOUSEV7_OLD ); 
#else /* the reverse of #ifdef MIXED_SCHEME  */ 
   NOUSEV7 = NOUSEV7_NEW or NOUSEV7_OLD; 
#endif /* end of #ifdef MIXED_SCHEME  */ 
#ifdef MIXED_SCHEME 
   NOUSEV8 = copy( NOUSEV8_OLD ); 
#else /* the reverse of #ifdef MIXED_SCHEME  */ 
   NOUSEV8 = NOUSEV8_NEW or NOUSEV8_OLD; 
#endif /* end of #ifdef MIXED_SCHEME  */ 
ALL_OD = ODI or DOD; 
ALL_POLY = POI or DPO; 
M8X = M8I or DUM8; 
M9X = M9I or DUM9; 

// GLOBAL DERIVED LAYERS FOR RULE CHECKS
//--------------------------------------
#ifdef ChipWindowUsed 
#else /* the reverse of #ifdef ChipWindowUsed  */ 
   
#endif /* end of #ifdef ChipWindowUsed  */ 
CHIPX = copy( gCHIP ); 
OD = ODI not SRAM_EXCLUDE; 
ODS = ODI not_inside SRAM_EXCLUDE; 
OD_18 = OD_18I not SRAM_EXCLUDE; 
OD_25 = OD_25I not SRAM_EXCLUDE; 
OD_33 = OD_33I not SRAM_EXCLUDE; 
POLYS = POI not_inside SRAM_EXCLUDE; 
PP = PPI not_inside SRAM_EXCLUDE; 
gNP = NPI not_inside SRAM_EXCLUDE; 
VTHN = VTH_NI not SRAM_EXCLUDE; 
VTHNS = VTH_NI not_inside SRAM_EXCLUDE; 
VTHP = VTH_PI not SRAM_EXCLUDE; 
VTHPS = VTH_PI not_inside SRAM_EXCLUDE; 
VTLN = VTL_NI not SRAM_EXCLUDE; 
VTLNS = VTL_NI not_inside SRAM_EXCLUDE; 
VTLP = VTL_PI not SRAM_EXCLUDE; 
VTLPS = VTL_PI not_inside SRAM_EXCLUDE; 
RPO = RPOI not SRAM_EXCLUDE; 
RPOS = RPOI not_inside SRAM_EXCLUDE; 
NTN = NT_NI not SRAM_EXCLUDE; 
NTNS = NT_NI not_inside SRAM_EXCLUDE; 
NCAP_NTN = NCAP_NTNI not SRAM_EXCLUDE; 
COS = COI not_inside SRAM_EXCLUDE; 
M1S = M1I not_inside SRAM_EXCLUDE; 
VIA1S = VIA1I not_inside SRAM_EXCLUDE; 
DCO = DCOI not SRAM_EXCLUDE; 
DCOS = DCOI not_inside SRAM_EXCLUDE; 
CB = copy( CBI ); 
CB2 = copy( CB2I ); 
CBD = copy( CBDI ); 
UBM = copy( UBMI ); 
RV = copy( RVI ); 
FW = copy( FWI ); 
FW_CU = copy( FWCUI ); 
PM = copy( PMI ); 
CTM = copy( CTMI ); 
VAR = copy( VARI ); 
MVTL = copy( MVTLI ); 
gLAYER_108 = CBI or CBDI; 
ALL_PAD = gLAYER_108 or RVI; 
gLAYER_109 = interacting( UBMI, CBDI ); 
UBM_MT_WIDTH = not_interacting( gLAYER_109, CU_PPII ); 
UBM_MT = interacting( UBMI, CBDI ); 
UBM_EXC = size_inside_wrapper( UBM_MT, M9I, distance = 5, increment = M9_S_1 * 0.7 ); 
CBMT = size_inside_wrapper( CBI, M9I, distance = 5, increment = M9_S_1 * 0.7 ); 
CBMT2 = size_inside_wrapper( CBI, M8I, distance = 5, increment = M8_S_1 * 0.7 ); 
MTOP_EXC = CBMT or UBM_EXC;              /* For high-density limit rule */ 
UBM_EXC_WIDTH = size_inside_wrapper( UBM_MT_WIDTH, M9I, distance = 5, increment = M9_S_1 * 0.7 ); 
CBMT_PRE = not_interacting( CBI, CU_PPII ); 
CBMT_WIDTH = size_inside_wrapper( CBMT_PRE, M9I, distance = 5, increment = M9_S_1 * 0.7 ); 
gLAYER_110 = CBI not WBDMY; 
CBMT2_PRE = not_interacting( gLAYER_110, CU_PPII ); 
CBMT2_WIDTH = size_inside_wrapper( CBMT2_PRE, M8I, distance = 5, increment = M8_S_1 * 0.7 ); 
gLAYER_113 = CBDI or CBI; 
gLAYER_112 = gLAYER_113 and CB2I; 
gLAYER_111 = interacting( gLAYER_112, CU_PPII ); 
WLCSP_EXC_WIDTH = M9I and gLAYER_111; 
gLAYER_114 = CBMT_WIDTH or UBM_EXC_WIDTH; 
MTOP_EXC_WIDTH = gLAYER_114 or WLCSP_EXC_WIDTH;    /* For max. width rule */ 
CB_NON_CUP = not_interacting( CB, WBDMY ); 
LMARK_METAL = M9I and LMARK; 
gLAYER_1135 = donut_holes( LMARK_METAL ); 
LSLOT = outside( gLAYER_1135, LMARK_METAL );    /* L shaped oxide in L-mark metal in corner */ 
LSOLID = not_interacting( LMARK_METAL, LSLOT );    /* L solid metal */ 
LMARK_SLOT = interacting( LMARK, LSLOT ); 
LMARK_SOLID = interacting( LMARK, LSOLID ); 
IND_EXD = size( INDDMY, clip_acute = NONE, distance = 18 ); 
#ifdef AU_WireBond 
   gLAYER_115 = M8 not WBDMY; 
   M8_MAX_WIDTH_M = gLAYER_115 not IND_EXD; 
#else /* the reverse of #ifdef AU_WireBond  */ 
   gLAYER_117 = M8 not CBMT2_WIDTH; 
   gLAYER_116 = gLAYER_117 not WBDMY; 
   M8_MAX_WIDTH_M = gLAYER_116 not IND_EXD; 
#endif /* end of #ifdef AU_WireBond  */ 
gLAYER_118 = M8 not WBDMY; 
M8_MAX_WIDTH = gLAYER_118 not IND_EXD; 
gLAYER_120 = M9 not MTOP_EXC_WIDTH; 
gLAYER_119 = gLAYER_120 not LMARK; 
M9_MAX_WIDTH_M = gLAYER_119 not IND_EXD; 
gLAYER_121 = OD_18 or OD_25; 
OD2 = gLAYER_121 or OD_33; 
gLAYER_122 = OD_18I or OD_25I; 
OD2I = gLAYER_122 or OD_33I; 
IMP = NPI or PPI; 
NPOD = OD and gNP; 
PPOD = OD and PP; 
COOD = CO and OD;                        /* Diffusion contacts  */ 
COPO = CO not OD;                        /* POLY contacts + floating contacts */ 
RNWEL = interacting( NWEL, NWDMY );      /* NWEL resistor (Within OD & STI) */ 
NWRES = interacting( RNWEL, RPO );       /* NWEL resistor (Within OD) */ 
NONWR = NWEL not RNWEL;                  /* NWEL exclude resistor area (Within OD) */ 
ODWR = interacting( OD, NWRES );         /* OD area of NW resistor (Within OD) */ 
NPWR = interacting( gNP, NWRES );         /* N+ implant on NW resistor terminals (Within OD) */ 
COWR = interacting( COOD, NWRES );       /* Contact on NW resistor terminals (Within OD) */ 
RHWR = ODWR not RPO;                     /* Silicided terminal of NW resistor (Within OD) */ 
NWRES_STI = not_interacting( RNWEL, RPO );    /* NWEL resistor (Under STI) */ 
ODWR_STI = interacting( OD, NWRES_STI );    /* OD area of NW resistor (Under STI) */ 
NPWR_STI = interacting( gNP, NWRES_STI ); 
COWR_STI = interacting( COOD, NWRES_STI );    /* Contact on NW resistor terminals (Under STI) */ 
NSTP = NPOD and NONWR;                   /* NWEL tap diffusion */ 
NACT = NPOD not NWEL;                    /* NMOS device active diffusion */ 
PACT = PPOD and NWEL;                    /* PMOS device active diffusion */ 
PSTP = PPOD not NWEL;                    /* Substrate (pwell) tap diffusion */ 
NACT2 = interacting( NACT, OD2 ); 
PACT2 = interacting( PACT, OD2 ); 
DACT = NACT or PACT;                     /* NMOS/PMOS device active diffusion */ 
DSTP = NSTP or PSTP; 
GATE = POLY and OD;                      /* Gate regions for NMOS and PMOS */ 
gLAYER_123 = enclosing( DACT, GATE ); 
SD = gLAYER_123 not GATE;                 /* Source, drain areas */ 
FPO1 = POLY not OD;                      /* Field poly */ 
HV_GATE = GATE and OD2; 
LV_GATE = GATE not OD2; 
gLAYER_124 = not_interacting( POLY, CO ); 
DUMMY_GATE = interacting( GATE, gLAYER_124 ); 
RF_DUMMY_GATE = DUMMY_GATE inside RFDMY; 
GATE_NP = GATE and gNP; 
GATE_PP = GATE and PP; 
GATE_W = POLY coincident_inside_edge GATE;    /* Gate width */ 
GATE_L = GATE not_coincident_inside_edge POLY;    /* Coincident edge of interconnect POLY */ 
GATEN_W = and_edge( GATE_W, gNP, false ); 
GATEP_W = and_edge( GATE_W, PP, false ); 
HV_GATE_W = and_edge( GATE_W, OD2, false );    /* 2.5V/3.3V/1.8V MOS gates */ 
LV_GATE_W = or_edge( not_edge( GATE_W, OD2 ), coincident_inside_edge( GATE_W, OD2 ) );    /* 1.0V MOS gates */ 
_18V_GATE_W = and_edge( HV_GATE_W, OD_18, false ); 
_25V_GATE_W = and_edge( HV_GATE_W, OD_25, false ); 
_33V_GATE_W = and_edge( HV_GATE_W, OD_33, false ); 
ILP1 = POLY not RPO_RPDMY;               /* Interconnect poly */ 
gLAYER_126 = RPO not SDI; 
gLAYER_125 = gLAYER_126 not BJTDMY; 
ODPO_RES_MARK = gLAYER_125 outside INDDMY;    /* For unsilicided OD/poly resistors */ 
PORES = FPO1 and ODPO_RES_MARK;          /* POLY unsilicided resistor region */ 
PORESG = not_interacting( PORES, SDI ); 
INOD = OD not RPO_RPDMY; 
gLAYER_127 = OD outside NWDMY; 
FOD = gLAYER_127 not GATE; 
ODRES = FOD and ODPO_RES_MARK;           /* OD unsilicided resistor region */ 
gLAYER_128 = RH or RPDMY; 
ODRES_A = ODRES and gLAYER_128; 
gLAYER_129 = RH or RPDMY; 
PORES_A = PORESG and gLAYER_129; 
AYRE = ODRES or PORES;                   /* unsilicided OD/poly resitors */ 
NYRE = gNP and AYRE; 
PYRE = PP and AYRE; 
NP_PP_BTE = NPOD coincident_outside_edge PPOD; 
BUTT_PSTP = outside_touching( PSTP, NACT ); 
BUTT_NSTP = outside_touching( NSTP, PACT ); 

// For BJT Device
PP_EMOD = PACT and BJTDMY; 
NP_EMOD = NACT and BJTDMY; 
EMOD = PP_EMOD or NP_EMOD; 
RNGX = PMDMY not FW; 
SEALRING = SEALRINGI not RNGX; 
VIA_EXD = copy( SEALRINGI ); 
VIA1_EXD = VIA1 not VIA_EXD; 
VIA2_EXD = VIA2 not VIA_EXD; 
VIA3_EXD = VIA3 not VIA_EXD; 
VIA4_EXD = VIA4 not VIA_EXD; 
VIA5_EXD = VIA5 not VIA_EXD; 
VIA6_EXD = VIA6 not VIA_EXD; 
VIA7_EXD = VIA7 not VIA_EXD; 
VIA8_EXD = VIA8 not VIA_EXD; 

//For chip corner stress relief check
#ifdef FULL_CHIP 
   CHIP_CORE = size( CHIPX, clip_acute = NONE, distance = - 20 ); 
#else /* the reverse of #ifdef FULL_CHIP  */ 
   CHIP_CORE = copy( gCHIP ); 
#endif /* end of #ifdef FULL_CHIP  */ 
#ifdef WLCSP_SEALRING 
   PADH_PRE = donut_holes( ALL_PAD, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
   PADH = size( size( PADH_PRE, ( CB_W_7 / 2 + WLCSP_TOL ), clip_acute = NONE ), - ( ( CB_W_7 / 2 + WLCSP_TOL ) ), clip_acute = NONE ); 
#else /* the reverse of #ifdef WLCSP_SEALRING  */ 
   gLAYER_130 = ALL_PAD not CHIP_CORE; 
   PADH = donut_holes( gLAYER_130, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
#endif /* end of #ifdef WLCSP_SEALRING  */ 
SCORE = CHIP_CORE inside PADH;           /* chip with sealring inside pad ring */ 
CHIP_WISR = interacting( CHIPX, SCORE ); 
#ifdef WLCSP_SEALRING 
   SROD = interacting( ODI, SEALRING ); 
   SRODH = donut_holes( SROD, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
   gLAYER_131 = not_interacting( SRODH, CSRDMY ); 
   SCORE_WLCSP = size( gLAYER_131, clip_acute = NONE, distance = - 10 ); 
   SR_EDGE = CHIP_WISR not SCORE_WLCSP; 
#else /* the reverse of #ifdef WLCSP_SEALRING  */ 
   SR_EDGE = CHIP_WISR not SCORE; 
#endif /* end of #ifdef WLCSP_SEALRING  */ 
CHIP_NOSR = not_interacting( gCHIP, SR_EDGE ); 
CHIP_EDGE = CHIP_NOSR or SCORE; 
SR_EXC = vertex( SR_EDGE, angles = { 270 }, shape = TRIANGLE, shape_size = 73.87 ); 
SRCSR = SR_EDGE or SR_EXC;               /* sealring+corner+assembly isolation */ 
gLAYER_133 = CHIP_WISR not SRCSR; 
gLAYER_132 = size( gLAYER_133, clip_acute = NONE, distance = 10 );
SR_RING = CHIP_WISR not gLAYER_132; 
EMPTY_AREA = vertex( CHIP_NOSR, angles = { 90 }, shape = TRIANGLE, shape_size = 74 ); 
CHIP_CHAMFERED = gCHIP not EMPTY_AREA; 
#ifdef FULL_CHIP 
   gLAYER_136 = FWI or LMARK; 
   gLAYER_135 = gLAYER_136 or LOGO; 
   gLAYER_134 = gLAYER_135 or INDDMY; 
   DEN_EXC_LOW = gLAYER_134 or EMPTY_AREA;    /* exclude region for low density */ 
   gLAYER_140 = FWI or LMARK; 
   gLAYER_139 = gLAYER_140 or LOGO; 
   gLAYER_138 = gLAYER_139 or INDDMY; 
   gLAYER_137 = gLAYER_138 or CSRDMY; 
   DEN_EXC = gLAYER_137 or EMPTY_AREA; 
#else /* the reverse of #ifdef FULL_CHIP  */ 
   gLAYER_142 = FWI or LMARK; 
   gLAYER_141 = gLAYER_142 or LOGO; 
   DEN_EXC_LOW = gLAYER_141 or INDDMY;    /* exclude region for low density */ 
   gLAYER_145 = FWI or LMARK; 
   gLAYER_144 = gLAYER_145 or LOGO; 
   gLAYER_143 = gLAYER_144 or INDDMY; 
   DEN_EXC = gLAYER_143 or CSRDMY; 
#endif /* end of #ifdef FULL_CHIP  */ 
METAL_EXC_LOW = copy( DEN_EXC_LOW ); 
METAL_EXC = copy( DEN_EXC ); 
M1_EXC_LOW = copy( METAL_EXC_LOW ); 
M1_EXC = copy( METAL_EXC ); 
M2_EXC_LOW = copy( METAL_EXC_LOW ); 
M2_EXC = copy( METAL_EXC ); 
M3_EXC_LOW = copy( METAL_EXC_LOW ); 
M3_EXC = copy( METAL_EXC ); 
M4_EXC_LOW = copy( METAL_EXC_LOW ); 
M4_EXC = copy( METAL_EXC ); 
M5_EXC_LOW = copy( METAL_EXC_LOW ); 
M5_EXC = copy( METAL_EXC ); 
M6_EXC_LOW = copy( METAL_EXC_LOW ); 
M6_EXC = copy( METAL_EXC ); 
gLAYER_146 = size( CBM, clip_acute = NONE, distance = 1.5 ); 
M7_EXC_LOW = METAL_EXC_LOW or gLAYER_146; 
M7_EXC = copy( METAL_EXC ); 
M8_EXC_LOW = copy( METAL_EXC_LOW ); 
M8_EXC = copy( METAL_EXC ); 
M9_EXC_LOW = copy( METAL_EXC_LOW ); 
M9_EXC = copy( METAL_EXC ); 
SR_M1 = interacting( M1, SEALRING ); 
SR_M2 = interacting( M2, SEALRING ); 
SR_M3 = interacting( M3, SEALRING ); 
SR_M4 = interacting( M4, SEALRING ); 
SR_M5 = interacting( M5, SEALRING ); 
SR_M6 = interacting( M6, SEALRING ); 
SR_M7 = interacting( M7, SEALRING ); 
SR_M8 = interacting( M8, SEALRING ); 
SR_M9 = interacting( M9, SEALRING ); 
CO_BAR = interacting( CO, SEALRINGI ); 
VIA1_BAR = interacting( VIA1, SEALRINGI ); 
VIA2_BAR = interacting( VIA2, SEALRINGI ); 
VIA3_BAR = interacting( VIA3, SEALRINGI ); 
VIA4_BAR = interacting( VIA4, SEALRINGI ); 
VIA5_BAR = interacting( VIA5, SEALRINGI ); 
VIA6_BAR = interacting( VIA6, SEALRINGI ); 
VIA7_BAR = interacting( VIA7, SEALRINGI ); 
VIA8_BAR = interacting( VIA8, SEALRINGI ); 
SR_CO = interacting( CO_BAR, SEALRING ); 
SR_VIA1 = interacting( VIA1_BAR, SEALRING ); 
SR_VIA2 = interacting( VIA2_BAR, SEALRING ); 
SR_VIA3 = interacting( VIA3_BAR, SEALRING ); 
SR_VIA4 = interacting( VIA4_BAR, SEALRING ); 
SR_VIA5 = interacting( VIA5_BAR, SEALRING ); 
SR_VIA6 = interacting( VIA6_BAR, SEALRING ); 
SR_VIA7 = interacting( VIA7_BAR, SEALRING ); 
SR_VIA8 = interacting( VIA8_BAR, SEALRING ); 

// DFM 
gLAYER_148 = PMDMY or LOGO; 
gLAYER_147 = gLAYER_148 or SRCSR; 
BLOCK = gLAYER_147 or LMARK; 
CTM_M = EMPTYM or CTMI; 
VCAP_CTM7_M = VIA7_M and CTM_M; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VCAP_CTM7_M }, VIA7_M }} ); 
gLAYER_152 = VIA7_M not CTM_M; 
VCAP_CBM7_M = gLAYER_152 and CBM_M; 
CONNECT_DB = incremental_connect( CONNECT_DB, {{{ VCAP_CBM7_M }, VIA7_M }} ); 
VDD_CBI = net_select( CONNECT_DB, connected_to_any = { NSTPI }, output_from_layers = { CBI } ); 
VSS_CBI = net_select( CONNECT_DB, connected_to_any = { PSTPI }, output_from_layers = { CBI } ); 
VDD_CB2I = net_select( CONNECT_DB, connected_to_any = { NSTPI }, output_from_layers = { CB2I } ); 
VSS_CB2I = net_select( CONNECT_DB, connected_to_any = { PSTPI }, output_from_layers = { CB2I } ); 
VDD_UBMNI = net_select( CONNECT_DB, connected_to_any = { NSTPI }, output_from_layers = { UBMN } ); 
VSS_UBMNI = net_select( CONNECT_DB, connected_to_any = { PSTPI }, output_from_layers = { UBMN } ); 
VDD_UBMDI = net_select( CONNECT_DB, connected_to_any = { NSTPI }, output_from_layers = { UBMD } ); 
VSS_UBMDI = net_select( CONNECT_DB, connected_to_any = { PSTPI }, output_from_layers = { UBMD } ); 
gLAYER_155 = CBI not VDD_CBI; 
gLAYER_154 = gLAYER_155 not VSS_CBI; 
gLAYER_153 = not_interacting( gLAYER_154, VSSDMY ); 
IO_CBI = not_interacting( gLAYER_153, VDDDMY ); 
gLAYER_158 = CB2I not VDD_CB2I; 
gLAYER_157 = gLAYER_158 not VSS_CB2I; 
gLAYER_156 = not_interacting( gLAYER_157, VSSDMY ); 
IO_CB2I = not_interacting( gLAYER_156, VDDDMY ); 
gLAYER_161 = UBMN not VDD_UBMNI; 
gLAYER_160 = gLAYER_161 not VSS_UBMNI; 
gLAYER_159 = not_interacting( gLAYER_160, VSSDMY ); 
IO_UBMNI = not_interacting( gLAYER_159, VDDDMY ); 
gLAYER_164 = UBMD not VDD_UBMDI; 
gLAYER_163 = gLAYER_164 not VSS_UBMDI; 
gLAYER_162 = not_interacting( gLAYER_163, VSSDMY ); 
IO_UBMDI = not_interacting( gLAYER_162, VDDDMY ); 
#ifdef DEFINE_PAD_BY_TEXT 
   gLAYER_1136 = text_origin( text_131, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
   GND_M1I_BY_TEXT = M1I interacting gLAYER_1136; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M1I_BY_TEXT }, M1I }} ); 
   gLAYER_1137 = text_origin( text_132, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
   GND_M2I_BY_TEXT = M2I interacting gLAYER_1137; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M2I_BY_TEXT }, M2I }} ); 
   gLAYER_1138 = text_origin( text_133, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
   GND_M3I_BY_TEXT = M3I interacting gLAYER_1138; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M3I_BY_TEXT }, M3I }} ); 
   gLAYER_1139 = text_origin( text_134, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
   GND_M4I_BY_TEXT = M4I interacting gLAYER_1139; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M4I_BY_TEXT }, M4I }} ); 
   gLAYER_1140 = text_origin( text_135, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
   GND_M5I_BY_TEXT = M5I interacting gLAYER_1140; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M5I_BY_TEXT }, M5I }} ); 
   gLAYER_1141 = text_origin( text_136, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
   GND_M6I_BY_TEXT = M6I interacting gLAYER_1141; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M6I_BY_TEXT }, M6I }} ); 
   gLAYER_1142 = text_origin( text_137, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
   GND_M7I_BY_TEXT = M7I interacting gLAYER_1142; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M7I_BY_TEXT }, M7I }} ); 
   gLAYER_1143 = text_origin( text_138, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
   GND_M8I_BY_TEXT = M8I interacting gLAYER_1143; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M8I_BY_TEXT }, M8I }} ); 
   gLAYER_1144 = text_origin( text_139, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
   GND_M9I_BY_TEXT = M9I interacting gLAYER_1144; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M9I_BY_TEXT }, M9I }} ); 
   gLAYER_1145 = text_origin( text_126, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
   GND_API_BY_TEXT = API interacting gLAYER_1145; 
   CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_API_BY_TEXT }, API }} ); 
#endif /* end of #ifdef DEFINE_PAD_BY_TEXT  */ 

// guard ring hole in LUP and GR rule checking
NW_INSIDE_GUARD_RING_PRE1 = NWI not NSTPI; 
NW_INSIDE_GUARD_RING_PRE2 = NW_INSIDE_GUARD_RING_PRE1 not_coincident_outside_edge NSTPI; 
NW_INSIDE_GUARD_RING = NW_INSIDE_GUARD_RING_PRE1 not_touching NW_INSIDE_GUARD_RING_PRE2; 
PW_INSIDE_GUARD_RING_PRE1 = PWELI not PSTPI; 
PW_INSIDE_GUARD_RING_PRE2 = PW_INSIDE_GUARD_RING_PRE1 not_coincident_outside_edge PSTPI; 
PW_INSIDE_GUARD_RING = PW_INSIDE_GUARD_RING_PRE1 not_touching PW_INSIDE_GUARD_RING_PRE2; 
gLAYER_166 = donut_holes( NSTPI, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
gLAYER_165 = gLAYER_166 inside NWI; 
NTAP_GUARD_RING_HOLE = gLAYER_165 or NW_INSIDE_GUARD_RING; 
gLAYER_168 = donut_holes( PSTPI, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
gLAYER_167 = gLAYER_168 inside PWELI; 
PTAP_GUARD_RING_HOLE = gLAYER_167 or PW_INSIDE_GUARD_RING; 
#ifdef LP 
   #ifdef LPG 
      rLPG_OPTION_ERROR @= { @ "LPG.OPTION:ERROR : If LPG option is enabled, LP option should be disabled.";
          copy( CHIPX ); 
      } /* end of rule : LPG.OPTION:ERROR */
   #endif /* end of #ifdef LPG  */ 
#endif /* end of #ifdef LP  */ 
#ifdef HALF_NODE 
   #ifdef LPG 
      rLPG_N55_WARNING @= { @ "LPG.N55:WARNING : LPG is not the standard offer in N55 process";
          copy( CHIPX ); 
      } /* end of rule : LPG.N55:WARNING */
   #endif /* end of #ifdef LPG  */ 
   rMIM_N55_ERROR @= { @ "MIM.N55:ERROR : MIM is not offered in N55 process";
       copy( CTM ); 
       copy( CBM ); 
   } /* end of rule : MIM.N55:ERROR */
#endif /* end of #ifdef HALF_NODE  */ 
#ifndef DFM_ONLY 
   #ifdef HALF_NODE 
      rG_1_DNWI @= { @ "G.1:DNWi : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_1 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DNWi */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_DNWI @= { @ "G.1:DNWi : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( DNWI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DNWi */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_NWI @= { @ "G.1:NWi : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_2 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:NWi */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_NWI @= { @ "G.1:NWi : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( NWI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:NWi */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_OD_18I @= { @ "G.1:OD_18i : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_3 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:OD_18i */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_OD_18I @= { @ "G.1:OD_18i : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( OD_18I, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:OD_18i */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_OD_25I @= { @ "G.1:OD_25i : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_4 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:OD_25i */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_OD_25I @= { @ "G.1:OD_25i : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( OD_25I, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:OD_25i */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_OD25_33 @= { @ "G.1:OD25_33 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_5 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:OD25_33 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_OD25_33 @= { @ "G.1:OD25_33 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( OD25_33, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:OD25_33 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_OD25_18 @= { @ "G.1:OD25_18 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_6 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:OD25_18 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_OD25_18 @= { @ "G.1:OD25_18 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( OD25_18, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:OD25_18 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_OD_33I @= { @ "G.1:OD_33i : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_7 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:OD_33i */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_OD_33I @= { @ "G.1:OD_33i : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( OD_33I, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:OD_33i */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_OD_DECAP @= { @ "G.1:OD_DECAP : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_8 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:OD_DECAP */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_OD_DECAP @= { @ "G.1:OD_DECAP : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( OD_DECAP, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:OD_DECAP */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_PPI @= { @ "G.1:PPi : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_9 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:PPi */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_PPI @= { @ "G.1:PPi : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( PPI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:PPi */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_NPI @= { @ "G.1:NPi : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_10 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:NPi */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_NPI @= { @ "G.1:NPi : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( NPI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:NPi */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_CBI @= { @ "G.1:CBi : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_11 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:CBi */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_CBI @= { @ "G.1:CBi : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( CBI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:CBi */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_RPOI @= { @ "G.1:RPOi : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_12 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RPOi */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_RPOI @= { @ "G.1:RPOi : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( RPOI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RPOi */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_NT_NI @= { @ "G.1:NT_Ni : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_13 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:NT_Ni */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_NT_NI @= { @ "G.1:NT_Ni : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( NT_NI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:NT_Ni */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_NCAP_NTNI @= { @ "G.1:NCap_NTNi : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_14 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:NCap_NTNi */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_NCAP_NTNI @= { @ "G.1:NCap_NTNi : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( NCAP_NTNI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:NCap_NTNi */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_FWALI @= { @ "G.1:FWALi : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_15 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:FWALi */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_FWALI @= { @ "G.1:FWALi : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( FWALI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:FWALi */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_FWCUI @= { @ "G.1:FWCUi : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_16 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:FWCUi */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_FWCUI @= { @ "G.1:FWCUi : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( FWCUI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:FWCUi */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_POFUSE @= { @ "G.1:POFUSE : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_17 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:POFUSE */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_POFUSE @= { @ "G.1:POFUSE : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( POFUSE, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:POFUSE */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_FUSELINK @= { @ "G.1:FUSELINK : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_18 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:FUSELINK */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_FUSELINK @= { @ "G.1:FUSELINK : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( FUSELINK, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:FUSELINK */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_SEALRINGI @= { @ "G.1:SEALRINGi : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_19 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:SEALRINGi */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_SEALRINGI @= { @ "G.1:SEALRINGi : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( SEALRINGI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:SEALRINGi */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_VTH_NI @= { @ "G.1:VTH_Ni : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_20 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VTH_Ni */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_VTH_NI @= { @ "G.1:VTH_Ni : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( VTH_NI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VTH_Ni */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_VTH_PI @= { @ "G.1:VTH_Pi : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_21 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VTH_Pi */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_VTH_PI @= { @ "G.1:VTH_Pi : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( VTH_PI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VTH_Pi */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_VTL_NI @= { @ "G.1:VTL_Ni : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_22 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VTL_Ni */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_VTL_NI @= { @ "G.1:VTL_Ni : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( VTL_NI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VTL_Ni */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_VTL_PI @= { @ "G.1:VTL_Pi : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_23 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VTL_Pi */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_VTL_PI @= { @ "G.1:VTL_Pi : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( VTL_PI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VTL_Pi */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_UHVT_NI @= { @ "G.1:UHVT_Ni : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( layer_patch_93 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:UHVT_Ni */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_UHVT_NI @= { @ "G.1:UHVT_Ni : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( UHVT_NI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:UHVT_Ni */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_UHVT_PI @= { @ "G.1:UHVT_Pi : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( layer_patch_94 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:UHVT_Pi */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_UHVT_PI @= { @ "G.1:UHVT_Pi : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( UHVT_PI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:UHVT_Pi */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_RH @= { @ "G.1:RH : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_26 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RH */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_RH @= { @ "G.1:RH : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( RH, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RH */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_ESD3 @= { @ "G.1:ESD3 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_27 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:ESD3 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_ESD3 @= { @ "G.1:ESD3 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( ESD3, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:ESD3 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_VARI @= { @ "G.1:VARi : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_28 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VARi */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_VARI @= { @ "G.1:VARi : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( VARI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VARi */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_API @= { @ "G.1:APi : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_29 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:APi */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_API @= { @ "G.1:APi : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( API, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:APi */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_CBMI @= { @ "G.1:CBMi : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_30 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:CBMi */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_CBMI @= { @ "G.1:CBMi : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( CBMI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:CBMi */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_CTMI @= { @ "G.1:CTMi : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_31 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:CTMi */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_CTMI @= { @ "G.1:CTMi : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( CTMI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:CTMi */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_RVI @= { @ "G.1:RVi : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_32 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RVi */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_RVI @= { @ "G.1:RVi : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( RVI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RVi */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_DCOI @= { @ "G.1:DCOi : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_33 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DCOi */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_DCOI @= { @ "G.1:DCOi : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( DCOI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DCOi */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_HVD_P @= { @ "G.1:HVD_P : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_34 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:HVD_P */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_HVD_P @= { @ "G.1:HVD_P : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( HVD_P, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:HVD_P */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_HVD_N_NW @= { @ "G.1:HVD_N_nw : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_35 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:HVD_N_nw */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_HVD_N_NW @= { @ "G.1:HVD_N_nw : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( HVD_N_NW, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:HVD_N_nw */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_SRM_ULL @= { @ "G.1:SRM_ULL : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_36 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:SRM_ULL */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_SRM_ULL @= { @ "G.1:SRM_ULL : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( SRM_ULL, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:SRM_ULL */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_BJTDMY @= { @ "G.1:BJTDMY : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_37 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:BJTDMY */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_BJTDMY @= { @ "G.1:BJTDMY : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( BJTDMY, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:BJTDMY */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_NWDMY @= { @ "G.1:NWDMY : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_38 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:NWDMY */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_NWDMY @= { @ "G.1:NWDMY : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( NWDMY, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:NWDMY */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_RPDMY @= { @ "G.1:RPDMY : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_39 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RPDMY */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_RPDMY @= { @ "G.1:RPDMY : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( RPDMY, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RPDMY */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_PMDMY @= { @ "G.1:PMDMY : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_40 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:PMDMY */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_PMDMY @= { @ "G.1:PMDMY : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( PMDMY, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:PMDMY */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_SDI @= { @ "G.1:SDI : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( layer_patch_122 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:SDI */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_SDI @= { @ "G.1:SDI : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( SDI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:SDI */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_ESD1DMY @= { @ "G.1:ESD1DMY : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_42 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:ESD1DMY */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_ESD1DMY @= { @ "G.1:ESD1DMY : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( ESD1DMY, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:ESD1DMY */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_ESD2DMY @= { @ "G.1:ESD2DMY : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_43 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:ESD2DMY */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_ESD2DMY @= { @ "G.1:ESD2DMY : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( ESD2DMY, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:ESD2DMY */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_RODMY @= { @ "G.1:RODMY : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_44 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RODMY */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_RODMY @= { @ "G.1:RODMY : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( RODMY, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RODMY */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_SRM @= { @ "G.1:SRM : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_45 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:SRM */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_SRM @= { @ "G.1:SRM : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( SRM, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:SRM */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_CDUDMY @= { @ "G.1:CDUDMY : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_46 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:CDUDMY */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_CDUDMY @= { @ "G.1:CDUDMY : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( CDUDMY, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:CDUDMY */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_TCDDMY @= { @ "G.1:TCDDMY : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_47 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:TCDDMY */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_TCDDMY @= { @ "G.1:TCDDMY : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( TCDDMY, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:TCDDMY */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_LOGO @= { @ "G.1:LOGO : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_48 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:LOGO */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_LOGO @= { @ "G.1:LOGO : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( LOGO, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:LOGO */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_INDDMY @= { @ "G.1:INDDMY : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_49 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:INDDMY */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_INDDMY @= { @ "G.1:INDDMY : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( INDDMY, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:INDDMY */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_CTMDMY @= { @ "G.1:CTMDMY : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_50 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:CTMDMY */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_CTMDMY @= { @ "G.1:CTMDMY : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( CTMDMY, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:CTMDMY */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_CTMDMY_10 @= { @ "G.1:CTMDMY_10 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_51 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:CTMDMY_10 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_CTMDMY_10 @= { @ "G.1:CTMDMY_10 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( CTMDMY_10, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:CTMDMY_10 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_CTMDMY_15 @= { @ "G.1:CTMDMY_15 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_52 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:CTMDMY_15 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_CTMDMY_15 @= { @ "G.1:CTMDMY_15 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( CTMDMY_15, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:CTMDMY_15 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_CTMDMY_20 @= { @ "G.1:CTMDMY_20 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_53 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:CTMDMY_20 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_CTMDMY_20 @= { @ "G.1:CTMDMY_20 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( CTMDMY_20, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:CTMDMY_20 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_CTMDMY_21 @= { @ "G.1:CTMDMY_21 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_54 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:CTMDMY_21 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_CTMDMY_21 @= { @ "G.1:CTMDMY_21 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( CTMDMY_21, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:CTMDMY_21 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_MOMDMY_1 @= { @ "G.1:MOMDMY_1 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_55 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY_1 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_MOMDMY_1 @= { @ "G.1:MOMDMY_1 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( MOMDMY_1, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY_1 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_MOMDMY_2 @= { @ "G.1:MOMDMY_2 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_56 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY_2 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_MOMDMY_2 @= { @ "G.1:MOMDMY_2 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( MOMDMY_2, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY_2 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_MOMDMY_3 @= { @ "G.1:MOMDMY_3 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_57 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY_3 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_MOMDMY_3 @= { @ "G.1:MOMDMY_3 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( MOMDMY_3, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY_3 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_MOMDMY_4 @= { @ "G.1:MOMDMY_4 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_58 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY_4 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_MOMDMY_4 @= { @ "G.1:MOMDMY_4 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( MOMDMY_4, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY_4 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_MOMDMY_5 @= { @ "G.1:MOMDMY_5 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_59 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY_5 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_MOMDMY_5 @= { @ "G.1:MOMDMY_5 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( MOMDMY_5, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY_5 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_MOMDMY_6 @= { @ "G.1:MOMDMY_6 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_60 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY_6 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_MOMDMY_6 @= { @ "G.1:MOMDMY_6 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( MOMDMY_6, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY_6 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_MOMDMY_7 @= { @ "G.1:MOMDMY_7 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_61 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY_7 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_MOMDMY_7 @= { @ "G.1:MOMDMY_7 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( MOMDMY_7, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY_7 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_MOMDMY_8 @= { @ "G.1:MOMDMY_8 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_62 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY_8 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_MOMDMY_8 @= { @ "G.1:MOMDMY_8 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( MOMDMY_8, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY_8 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_MOMDMY_9 @= { @ "G.1:MOMDMY_9 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_63 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY_9 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_MOMDMY_9 @= { @ "G.1:MOMDMY_9 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( MOMDMY_9, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY_9 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_MOMDMY_AP @= { @ "G.1:MOMDMY_AP : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_64 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY_AP */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_MOMDMY_AP @= { @ "G.1:MOMDMY_AP : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( MOMDMY_AP, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY_AP */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_RTMOMDMY @= { @ "G.1:RTMOMDMY : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_65 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RTMOMDMY */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_RTMOMDMY @= { @ "G.1:RTMOMDMY : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( RTMOMDMY, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RTMOMDMY */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_MOMDMY @= { @ "G.1:MOMDMY : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_66 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_MOMDMY @= { @ "G.1:MOMDMY : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( MOMDMY, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_MOMDMY_2T @= { @ "G.1:MOMDMY_2T : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_67 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY_2T */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_MOMDMY_2T @= { @ "G.1:MOMDMY_2T : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( MOMDMY_2T, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY_2T */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_MOMDMY_100 @= { @ "G.1:MOMDMY_100 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_68 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY_100 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_MOMDMY_100 @= { @ "G.1:MOMDMY_100 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( MOMDMY_100, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MOMDMY_100 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_RFDMY @= { @ "G.1:RFDMY : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_69 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RFDMY */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_RFDMY @= { @ "G.1:RFDMY : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( RFDMY, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RFDMY */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_WBDMY @= { @ "G.1:WBDMY : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_70 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:WBDMY */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_WBDMY @= { @ "G.1:WBDMY : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( WBDMY, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:WBDMY */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_DIODMY @= { @ "G.1:DIODMY : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_71 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DIODMY */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_DIODMY @= { @ "G.1:DIODMY : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( DIODMY, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DIODMY */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_SRAMDMY @= { @ "G.1:SRAMDMY : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_72 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:SRAMDMY */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_SRAMDMY @= { @ "G.1:SRAMDMY : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( SRAMDMY, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:SRAMDMY */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_SRAMDMY_4 @= { @ "G.1:SRAMDMY_4 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_73 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:SRAMDMY_4 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_SRAMDMY_4 @= { @ "G.1:SRAMDMY_4 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( SRAMDMY_4, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:SRAMDMY_4 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_SRAMDMY_5 @= { @ "G.1:SRAMDMY_5 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_74 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:SRAMDMY_5 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_SRAMDMY_5 @= { @ "G.1:SRAMDMY_5 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( SRAMDMY_5, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:SRAMDMY_5 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_SRAMDMY_1 @= { @ "G.1:SRAMDMY_1 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_75 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:SRAMDMY_1 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_SRAMDMY_1 @= { @ "G.1:SRAMDMY_1 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( SRAMDMY_1, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:SRAMDMY_1 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_OD1TI @= { @ "G.1:OD1Ti : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_76 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:OD1Ti */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_OD1TI @= { @ "G.1:OD1Ti : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( OD1TI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:OD1Ti */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_CLDDI @= { @ "G.1:CLDDi : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_77 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:CLDDi */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_CLDDI @= { @ "G.1:CLDDi : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( CLDDI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:CLDDi */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_CROWNI @= { @ "G.1:CROWNi : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_78 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:CROWNi */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_CROWNI @= { @ "G.1:CROWNi : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( CROWNI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:CROWNi */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_P3I @= { @ "G.1:P3i : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_79 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:P3i */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_P3I @= { @ "G.1:P3i : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( P3I, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:P3i */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_SNCTI @= { @ "G.1:SNCTi : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_80 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:SNCTi */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_SNCTI @= { @ "G.1:SNCTi : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( SNCTI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:SNCTi */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_LUPWDMY @= { @ "G.1:LUPWDMY : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_81 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:LUPWDMY */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_LUPWDMY @= { @ "G.1:LUPWDMY : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( LUPWDMY, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:LUPWDMY */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_LUPWDMY_2 @= { @ "G.1:LUPWDMY_2 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_82 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:LUPWDMY_2 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_LUPWDMY_2 @= { @ "G.1:LUPWDMY_2 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( LUPWDMY_2, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:LUPWDMY_2 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_VDDDMY @= { @ "G.1:VDDDMY : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_83 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VDDDMY */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_VDDDMY @= { @ "G.1:VDDDMY : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( VDDDMY, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VDDDMY */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_VSSDMY @= { @ "G.1:VSSDMY : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_84 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VSSDMY */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_VSSDMY @= { @ "G.1:VSSDMY : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( VSSDMY, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VSSDMY */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_MATCHING @= { @ "G.1:MATCHING : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_85 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MATCHING */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_MATCHING @= { @ "G.1:MATCHING : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( MATCHING, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:MATCHING */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_M1I @= { @ "G.1:M1i : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_86 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M1i */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_M1I @= { @ "G.1:M1i : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( M1I, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M1i */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_M1_REAL @= { @ "G.1:M1_real : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_87 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M1_real */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_M1_REAL @= { @ "G.1:M1_real : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( M1_REAL, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M1_real */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_DM1_O @= { @ "G.1:DM1_O : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_88 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DM1_O */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_DM1_O @= { @ "G.1:DM1_O : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( DM1_O, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DM1_O */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_DUM1 @= { @ "G.1:DUM1 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_89 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DUM1 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_DUM1 @= { @ "G.1:DUM1 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( DUM1, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DUM1 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_M2I @= { @ "G.1:M2i : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_90 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M2i */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_M2I @= { @ "G.1:M2i : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( M2I, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M2i */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_M2_REAL @= { @ "G.1:M2_real : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_91 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M2_real */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_M2_REAL @= { @ "G.1:M2_real : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( M2_REAL, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M2_real */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_DM2_O @= { @ "G.1:DM2_O : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_92 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DM2_O */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_DM2_O @= { @ "G.1:DM2_O : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( DM2_O, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DM2_O */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_DUM2 @= { @ "G.1:DUM2 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_93 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DUM2 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_DUM2 @= { @ "G.1:DUM2 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( DUM2, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DUM2 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_M3I @= { @ "G.1:M3i : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_94 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M3i */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_M3I @= { @ "G.1:M3i : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( M3I, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M3i */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_M3_REAL @= { @ "G.1:M3_real : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_95 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M3_real */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_M3_REAL @= { @ "G.1:M3_real : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( M3_REAL, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M3_real */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_DM3_O @= { @ "G.1:DM3_O : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_96 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DM3_O */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_DM3_O @= { @ "G.1:DM3_O : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( DM3_O, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DM3_O */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_DUM3 @= { @ "G.1:DUM3 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_97 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DUM3 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_DUM3 @= { @ "G.1:DUM3 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( DUM3, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DUM3 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_M4I @= { @ "G.1:M4i : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_98 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M4i */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_M4I @= { @ "G.1:M4i : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( M4I, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M4i */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_M4_REAL @= { @ "G.1:M4_real : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_99 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M4_real */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_M4_REAL @= { @ "G.1:M4_real : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( M4_REAL, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M4_real */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_DM4_O @= { @ "G.1:DM4_O : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_100 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DM4_O */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_DM4_O @= { @ "G.1:DM4_O : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( DM4_O, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DM4_O */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_DUM4 @= { @ "G.1:DUM4 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_101 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DUM4 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_DUM4 @= { @ "G.1:DUM4 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( DUM4, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DUM4 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_M5I @= { @ "G.1:M5i : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_102 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M5i */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_M5I @= { @ "G.1:M5i : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( M5I, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M5i */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_M5_REAL @= { @ "G.1:M5_real : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_103 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M5_real */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_M5_REAL @= { @ "G.1:M5_real : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( M5_REAL, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M5_real */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_DM5_O @= { @ "G.1:DM5_O : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_104 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DM5_O */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_DM5_O @= { @ "G.1:DM5_O : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( DM5_O, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DM5_O */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_DUM5 @= { @ "G.1:DUM5 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_105 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DUM5 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_DUM5 @= { @ "G.1:DUM5 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( DUM5, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DUM5 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_M6I @= { @ "G.1:M6i : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_106 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M6i */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_M6I @= { @ "G.1:M6i : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( M6I, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M6i */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_M6_REAL @= { @ "G.1:M6_real : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_107 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M6_real */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_M6_REAL @= { @ "G.1:M6_real : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( M6_REAL, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M6_real */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_DM6_O @= { @ "G.1:DM6_O : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_108 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DM6_O */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_DM6_O @= { @ "G.1:DM6_O : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( DM6_O, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DM6_O */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_DUM6 @= { @ "G.1:DUM6 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_109 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DUM6 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_DUM6 @= { @ "G.1:DUM6 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( DUM6, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DUM6 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_M7I @= { @ "G.1:M7i : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_110 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M7i */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_M7I @= { @ "G.1:M7i : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( M7I, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M7i */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_M7_REAL @= { @ "G.1:M7_real : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_111 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M7_real */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_M7_REAL @= { @ "G.1:M7_real : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( M7_REAL, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M7_real */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_DM7_O @= { @ "G.1:DM7_O : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_112 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DM7_O */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_DM7_O @= { @ "G.1:DM7_O : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( DM7_O, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DM7_O */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_DUM7 @= { @ "G.1:DUM7 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_113 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DUM7 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_DUM7 @= { @ "G.1:DUM7 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( DUM7, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DUM7 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_M8_OLD @= { @ "G.1:M8_OLD : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_114 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M8_OLD */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_M8_OLD @= { @ "G.1:M8_OLD : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( M8_OLD, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M8_OLD */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_M8_NEW @= { @ "G.1:M8_NEW : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_115 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M8_NEW */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_M8_NEW @= { @ "G.1:M8_NEW : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( M8_NEW, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M8_NEW */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_DUM8_OLD @= { @ "G.1:DUM8_OLD : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_116 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DUM8_OLD */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_DUM8_OLD @= { @ "G.1:DUM8_OLD : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( DUM8_OLD, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DUM8_OLD */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_DUM8_NEW @= { @ "G.1:DUM8_NEW : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_117 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DUM8_NEW */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_DUM8_NEW @= { @ "G.1:DUM8_NEW : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( DUM8_NEW, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DUM8_NEW */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_M9_OLD @= { @ "G.1:M9_OLD : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_118 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M9_OLD */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_M9_OLD @= { @ "G.1:M9_OLD : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( M9_OLD, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M9_OLD */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_M9_NEW @= { @ "G.1:M9_NEW : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_119 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M9_NEW */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_M9_NEW @= { @ "G.1:M9_NEW : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( M9_NEW, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:M9_NEW */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_DUM9_OLD @= { @ "G.1:DUM9_OLD : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_120 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DUM9_OLD */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_DUM9_OLD @= { @ "G.1:DUM9_OLD : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( DUM9_OLD, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DUM9_OLD */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_DUM9_NEW @= { @ "G.1:DUM9_NEW : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_121 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DUM9_NEW */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_DUM9_NEW @= { @ "G.1:DUM9_NEW : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( DUM9_NEW, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DUM9_NEW */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_VIA1I @= { @ "G.1:VIA1i : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_122 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VIA1i */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_VIA1I @= { @ "G.1:VIA1i : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( VIA1I, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VIA1i */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_VIA2I @= { @ "G.1:VIA2i : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_123 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VIA2i */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_VIA2I @= { @ "G.1:VIA2i : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( VIA2I, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VIA2i */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_VIA3I @= { @ "G.1:VIA3i : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_124 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VIA3i */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_VIA3I @= { @ "G.1:VIA3i : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( VIA3I, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VIA3i */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_VIA4I @= { @ "G.1:VIA4i : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_125 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VIA4i */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_VIA4I @= { @ "G.1:VIA4i : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( VIA4I, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VIA4i */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_VIA5I @= { @ "G.1:VIA5i : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_126 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VIA5i */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_VIA5I @= { @ "G.1:VIA5i : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( VIA5I, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VIA5i */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_VIA6I @= { @ "G.1:VIA6i : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_127 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VIA6i */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_VIA6I @= { @ "G.1:VIA6i : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( VIA6I, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VIA6i */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_VIA7_OLD @= { @ "G.1:VIA7_OLD : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_128 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VIA7_OLD */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_VIA7_OLD @= { @ "G.1:VIA7_OLD : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( VIA7_OLD, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VIA7_OLD */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_VIA7_NEW @= { @ "G.1:VIA7_NEW : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_129 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VIA7_NEW */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_VIA7_NEW @= { @ "G.1:VIA7_NEW : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( VIA7_NEW, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VIA7_NEW */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_VIA8_OLD @= { @ "G.1:VIA8_OLD : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_130 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VIA8_OLD */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_VIA8_OLD @= { @ "G.1:VIA8_OLD : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( VIA8_OLD, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VIA8_OLD */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_VIA8_NEW @= { @ "G.1:VIA8_NEW : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_131 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VIA8_NEW */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_VIA8_NEW @= { @ "G.1:VIA8_NEW : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( VIA8_NEW, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:VIA8_NEW */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_ODI @= { @ "G.1:ODi : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_132 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:ODi */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_ODI @= { @ "G.1:ODi : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( ODI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:ODi */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_DOD @= { @ "G.1:DOD : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_133 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DOD */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_DOD @= { @ "G.1:DOD : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( DOD, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DOD */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_DPO @= { @ "G.1:DPO : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_134 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DPO */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_DPO @= { @ "G.1:DPO : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( DPO, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:DPO */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_MVTLI @= { @ "G.1:mVTLi : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_135 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:mVTLi */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_MVTLI @= { @ "G.1:mVTLi : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( MVTLI, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:mVTLi */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_RMDMY1 @= { @ "G.1:RMDMY1 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_136 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RMDMY1 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_RMDMY1 @= { @ "G.1:RMDMY1 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( RMDMY1, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RMDMY1 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_RMDMY2 @= { @ "G.1:RMDMY2 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_137 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RMDMY2 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_RMDMY2 @= { @ "G.1:RMDMY2 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( RMDMY2, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RMDMY2 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_RMDMY3 @= { @ "G.1:RMDMY3 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_138 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RMDMY3 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_RMDMY3 @= { @ "G.1:RMDMY3 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( RMDMY3, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RMDMY3 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_RMDMY4 @= { @ "G.1:RMDMY4 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_139 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RMDMY4 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_RMDMY4 @= { @ "G.1:RMDMY4 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( RMDMY4, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RMDMY4 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_RMDMY5 @= { @ "G.1:RMDMY5 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_140 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RMDMY5 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_RMDMY5 @= { @ "G.1:RMDMY5 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( RMDMY5, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RMDMY5 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_RMDMY6 @= { @ "G.1:RMDMY6 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_141 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RMDMY6 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_RMDMY6 @= { @ "G.1:RMDMY6 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( RMDMY6, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RMDMY6 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_RMDMY7 @= { @ "G.1:RMDMY7 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_142 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RMDMY7 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_RMDMY7 @= { @ "G.1:RMDMY7 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( RMDMY7, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RMDMY7 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_RMDMY8 @= { @ "G.1:RMDMY8 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_143 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RMDMY8 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_RMDMY8 @= { @ "G.1:RMDMY8 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( RMDMY8, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RMDMY8 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_RMDMY9 @= { @ "G.1:RMDMY9 : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_144 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RMDMY9 */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_RMDMY9 @= { @ "G.1:RMDMY9 : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( RMDMY9, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RMDMY9 */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_RMDMYAP @= { @ "G.1:RMDMYAP : grid must be an integer multiple of " + GRID + " um"; 
          X = copy( aLAYER_145 ); 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RMDMYAP */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_RMDMYAP @= { @ "G.1:RMDMYAP : grid must be an integer multiple of " + GRID + " um"; 
          off_grid_xy( RMDMYAP, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:RMDMYAP */
   #endif /* end of #ifdef HALF_NODE  */ 
   #ifdef HALF_NODE 
      rG_1_CO @= { @ "G.1:CO : 5nm grid is required for CO except CO inside layer 186;5";
          X = copy( aLAYER_146 ); 
          A = X not SRAMDMY_5; 
          off_grid_xy( A, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:CO */
      rG_1_PO @= { @ "G.1:PO : 5nm grid is required for PO except PO inside layer 186;5";
          X = copy( aLAYER_147 ); 
          A = X not SRAMDMY_5; 
          off_grid_xy( A, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:PO */
   #else /* the reverse of #ifdef HALF_NODE  */ 
      rG_1_CO @= { @ "G.1:CO : 5nm grid is required for CO except CO inside layer 186;5";
          X = COI not SRAMDMY_5; 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:CO */
      rG_1_PO @= { @ "G.1:PO : 5nm grid is required for PO except PO inside layer 186;5";
          X = POI not SRAMDMY_5; 
          off_grid_xy( X, x_resolution = 5 / 1000, y_resolution = 5 / 1000 ); 
      } /* end of rule : G.1:PO */
   #endif /* end of #ifdef HALF_NODE  */ 
   rG_2_DNWI @= { @ "G.2:DNWi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( DNWI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( DNWI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:DNWi */
   rG_2_NWI @= { @ "G.2:NWi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( NWI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( NWI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:NWi */
   rG_2_OD_18I @= { @ "G.2:OD_18i : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( OD_18I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( OD_18I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:OD_18i */
   rG_2_OD_25I @= { @ "G.2:OD_25i : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( OD_25I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( OD_25I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:OD_25i */
   rG_2_OD25_33 @= { @ "G.2:OD25_33 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( OD25_33, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( OD25_33, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:OD25_33 */
   rG_2_OD25_18 @= { @ "G.2:OD25_18 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( OD25_18, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( OD25_18, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:OD25_18 */
   rG_2_OD_33I @= { @ "G.2:OD_33i : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( OD_33I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( OD_33I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:OD_33i */
   rG_2_OD_DECAP @= { @ "G.2:OD_DECAP : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( OD_DECAP, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( OD_DECAP, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:OD_DECAP */
   rG_2_PPI @= { @ "G.2:PPi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( PPI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( PPI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:PPi */
   rG_2_NPI @= { @ "G.2:NPi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( NPI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( NPI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:NPi */
   rG_2_COI @= { @ "G.2:COi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( COI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( COI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:COi */
   rG_2_CO_PUSH @= { @ "G.2:CO_PUSH : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( CO_PUSH, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( CO_PUSH, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:CO_PUSH */
   rG_2_CBI @= { @ "G.2:CBi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( CBI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( CBI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:CBi */
   rG_2_CB2I @= { @ "G.2:CB2i : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( CB2I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( CB2I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:CB2i */
   rG_2_RPOI @= { @ "G.2:RPOi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( RPOI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( RPOI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:RPOi */
   rG_2_NT_NI @= { @ "G.2:NT_Ni : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( NT_NI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( NT_NI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:NT_Ni */
   rG_2_NCAP_NTNI @= { @ "G.2:NCap_NTNi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( NCAP_NTNI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( NCAP_NTNI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:NCap_NTNi */
   rG_2_FWALI @= { @ "G.2:FWALi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( FWALI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( FWALI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:FWALi */
   rG_2_FWCUI @= { @ "G.2:FWCUi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( FWCUI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( FWCUI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:FWCUi */
   rG_2_POFUSE @= { @ "G.2:POFUSE : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( POFUSE, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( POFUSE, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:POFUSE */
   rG_2_FUSELINK @= { @ "G.2:FUSELINK : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( FUSELINK, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( FUSELINK, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:FUSELINK */
   rG_2_PMI @= { @ "G.2:PMi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( PMI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( PMI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:PMi */
   rG_2_PM1I @= { @ "G.2:PM1i : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( PM1I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( PM1I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:PM1i */
   rG_2_PM2I @= { @ "G.2:PM2i : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( PM2I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( PM2I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:PM2i */
   rG_2_SEALRINGI @= { @ "G.2:SEALRINGi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( SEALRINGI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( SEALRINGI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:SEALRINGi */
   rG_2_VTH_NI @= { @ "G.2:VTH_Ni : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( VTH_NI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( VTH_NI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:VTH_Ni */
   rG_2_VTH_PI @= { @ "G.2:VTH_Pi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( VTH_PI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( VTH_PI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:VTH_Pi */
   rG_2_VTL_NI @= { @ "G.2:VTL_Ni : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( VTL_NI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( VTL_NI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:VTL_Ni */
   rG_2_VTL_PI @= { @ "G.2:VTL_Pi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( VTL_PI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( VTL_PI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:VTL_Pi */
   rG_2_UHVT_NI @= { @ "G.2:UHVT_Ni : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( UHVT_NI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( UHVT_NI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:UHVT_Ni */
   rG_2_UHVT_PI @= { @ "G.2:UHVT_Pi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( UHVT_PI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( UHVT_PI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:UHVT_Pi */
   rG_2_CBDI @= { @ "G.2:CBDi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( CBDI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( CBDI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:CBDi */
   rG_2_UBMI @= { @ "G.2:UBMi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( UBMI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( UBMI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:UBMi */
   rG_2_RH @= { @ "G.2:RH : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( RH, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( RH, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:RH */
   rG_2_ESD3 @= { @ "G.2:ESD3 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( ESD3, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( ESD3, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:ESD3 */
   rG_2_VARI @= { @ "G.2:VARi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( VARI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( VARI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:VARi */
   rG_2_API @= { @ "G.2:APi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( API, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( API, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:APi */
   rG_2_CU_PPII @= { @ "G.2:Cu_PPIi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( CU_PPII, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( CU_PPII, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:Cu_PPIi */
   rG_2_CBMI @= { @ "G.2:CBMi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( CBMI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( CBMI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:CBMi */
   rG_2_CTMI @= { @ "G.2:CTMi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( CTMI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( CTMI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:CTMi */
   rG_2_RVI @= { @ "G.2:RVi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( RVI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( RVI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:RVi */
   rG_2_DCOI @= { @ "G.2:DCOi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( DCOI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( DCOI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:DCOi */
   rG_2_HVD_P @= { @ "G.2:HVD_P : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( HVD_P, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( HVD_P, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:HVD_P */
   rG_2_HVD_N_NW @= { @ "G.2:HVD_N_nw : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( HVD_N_NW, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( HVD_N_NW, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:HVD_N_nw */
   rG_2_SRM_ULL @= { @ "G.2:SRM_ULL : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( SRM_ULL, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( SRM_ULL, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:SRM_ULL */
   rG_2_BJTDMY @= { @ "G.2:BJTDMY : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( BJTDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( BJTDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:BJTDMY */
   rG_2_NWDMY @= { @ "G.2:NWDMY : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( NWDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( NWDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:NWDMY */
   rG_2_RPDMY @= { @ "G.2:RPDMY : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( RPDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( RPDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:RPDMY */
   rG_2_PMDMY @= { @ "G.2:PMDMY : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( PMDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( PMDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:PMDMY */
   rG_2_SDI @= { @ "G.2:SDI : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( SDI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( SDI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:SDI */
   rG_2_ESD1DMY @= { @ "G.2:ESD1DMY : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( ESD1DMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( ESD1DMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:ESD1DMY */
   rG_2_ESD2DMY @= { @ "G.2:ESD2DMY : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( ESD2DMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( ESD2DMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:ESD2DMY */
   rG_2_RODMY @= { @ "G.2:RODMY : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( RODMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( RODMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:RODMY */
   rG_2_SRM @= { @ "G.2:SRM : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( SRM, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( SRM, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:SRM */
   rG_2_CDUDMY @= { @ "G.2:CDUDMY : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( CDUDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( CDUDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:CDUDMY */
   rG_2_TCDDMY @= { @ "G.2:TCDDMY : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( TCDDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( TCDDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:TCDDMY */
   rG_2_LOGO @= { @ "G.2:LOGO : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( LOGO, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( LOGO, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:LOGO */
   rG_2_INDDMY @= { @ "G.2:INDDMY : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( INDDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( INDDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:INDDMY */
   rG_2_CTMDMY @= { @ "G.2:CTMDMY : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( CTMDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( CTMDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:CTMDMY */
   rG_2_CTMDMY_10 @= { @ "G.2:CTMDMY_10 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( CTMDMY_10, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( CTMDMY_10, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:CTMDMY_10 */
   rG_2_CTMDMY_15 @= { @ "G.2:CTMDMY_15 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( CTMDMY_15, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( CTMDMY_15, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:CTMDMY_15 */
   rG_2_CTMDMY_20 @= { @ "G.2:CTMDMY_20 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( CTMDMY_20, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( CTMDMY_20, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:CTMDMY_20 */
   rG_2_CTMDMY_21 @= { @ "G.2:CTMDMY_21 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( CTMDMY_21, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( CTMDMY_21, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:CTMDMY_21 */
   rG_2_MOMDMY_1 @= { @ "G.2:MOMDMY_1 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( MOMDMY_1, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( MOMDMY_1, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:MOMDMY_1 */
   rG_2_MOMDMY_2 @= { @ "G.2:MOMDMY_2 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( MOMDMY_2, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( MOMDMY_2, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:MOMDMY_2 */
   rG_2_MOMDMY_3 @= { @ "G.2:MOMDMY_3 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( MOMDMY_3, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( MOMDMY_3, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:MOMDMY_3 */
   rG_2_MOMDMY_4 @= { @ "G.2:MOMDMY_4 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( MOMDMY_4, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( MOMDMY_4, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:MOMDMY_4 */
   rG_2_MOMDMY_5 @= { @ "G.2:MOMDMY_5 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( MOMDMY_5, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( MOMDMY_5, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:MOMDMY_5 */
   rG_2_MOMDMY_6 @= { @ "G.2:MOMDMY_6 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( MOMDMY_6, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( MOMDMY_6, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:MOMDMY_6 */
   rG_2_MOMDMY_7 @= { @ "G.2:MOMDMY_7 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( MOMDMY_7, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( MOMDMY_7, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:MOMDMY_7 */
   rG_2_MOMDMY_8 @= { @ "G.2:MOMDMY_8 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( MOMDMY_8, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( MOMDMY_8, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:MOMDMY_8 */
   rG_2_MOMDMY_9 @= { @ "G.2:MOMDMY_9 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( MOMDMY_9, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( MOMDMY_9, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:MOMDMY_9 */
   rG_2_MOMDMY_AP @= { @ "G.2:MOMDMY_AP : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( MOMDMY_AP, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( MOMDMY_AP, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:MOMDMY_AP */
   rG_2_RTMOMDMY @= { @ "G.2:RTMOMDMY : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( RTMOMDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( RTMOMDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:RTMOMDMY */
   rG_2_MOMDMY @= { @ "G.2:MOMDMY : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( MOMDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( MOMDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:MOMDMY */
   rG_2_MOMDMY_2T @= { @ "G.2:MOMDMY_2T : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( MOMDMY_2T, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( MOMDMY_2T, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:MOMDMY_2T */
   rG_2_MOMDMY_100 @= { @ "G.2:MOMDMY_100 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( MOMDMY_100, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( MOMDMY_100, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:MOMDMY_100 */
   rG_2_RFDMY @= { @ "G.2:RFDMY : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( RFDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( RFDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:RFDMY */
   rG_2_WBDMY @= { @ "G.2:WBDMY : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( WBDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( WBDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:WBDMY */
   rG_2_DIODMY @= { @ "G.2:DIODMY : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( DIODMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( DIODMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:DIODMY */
   rG_2_SRAMDMY @= { @ "G.2:SRAMDMY : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( SRAMDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( SRAMDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:SRAMDMY */
   rG_2_SRAMDMY_4 @= { @ "G.2:SRAMDMY_4 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( SRAMDMY_4, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( SRAMDMY_4, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:SRAMDMY_4 */
   rG_2_SRAMDMY_5 @= { @ "G.2:SRAMDMY_5 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( SRAMDMY_5, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( SRAMDMY_5, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:SRAMDMY_5 */
   rG_2_SRAMDMY_1 @= { @ "G.2:SRAMDMY_1 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( SRAMDMY_1, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( SRAMDMY_1, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:SRAMDMY_1 */
   rG_2_RAM1TDMY @= { @ "G.2:RAM1TDMY : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( RAM1TDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( RAM1TDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:RAM1TDMY */
   rG_2_OD1TI @= { @ "G.2:OD1Ti : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( OD1TI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( OD1TI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:OD1Ti */
   rG_2_CLDDI @= { @ "G.2:CLDDi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( CLDDI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( CLDDI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:CLDDi */
   rG_2_CROWNI @= { @ "G.2:CROWNi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( CROWNI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( CROWNI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:CROWNi */
   rG_2_P3I @= { @ "G.2:P3i : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( P3I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( P3I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:P3i */
   rG_2_SNCTI @= { @ "G.2:SNCTi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( SNCTI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( SNCTI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:SNCTi */
   rG_2_LUPWDMY @= { @ "G.2:LUPWDMY : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( LUPWDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( LUPWDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:LUPWDMY */
   rG_2_LUPWDMY_2 @= { @ "G.2:LUPWDMY_2 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( LUPWDMY_2, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( LUPWDMY_2, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:LUPWDMY_2 */
   rG_2_VDDDMY @= { @ "G.2:VDDDMY : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( VDDDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( VDDDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:VDDDMY */
   rG_2_VSSDMY @= { @ "G.2:VSSDMY : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( VSSDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( VSSDMY, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:VSSDMY */
   rG_2_MATCHING @= { @ "G.2:MATCHING : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( MATCHING, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( MATCHING, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:MATCHING */
   rG_2_M1I @= { @ "G.2:M1i : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( M1I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( M1I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:M1i */
   rG_2_M1_REAL @= { @ "G.2:M1_real : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( M1_REAL, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( M1_REAL, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:M1_real */
   rG_2_DM1_O @= { @ "G.2:DM1_O : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( DM1_O, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( DM1_O, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:DM1_O */
   rG_2_DUM1 @= { @ "G.2:DUM1 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( DUM1, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( DUM1, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:DUM1 */
   rG_2_M2I @= { @ "G.2:M2i : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( M2I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( M2I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:M2i */
   rG_2_M2_REAL @= { @ "G.2:M2_real : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( M2_REAL, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( M2_REAL, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:M2_real */
   rG_2_DM2_O @= { @ "G.2:DM2_O : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( DM2_O, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( DM2_O, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:DM2_O */
   rG_2_DUM2 @= { @ "G.2:DUM2 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( DUM2, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( DUM2, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:DUM2 */
   rG_2_M3I @= { @ "G.2:M3i : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( M3I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( M3I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:M3i */
   rG_2_M3_REAL @= { @ "G.2:M3_real : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( M3_REAL, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( M3_REAL, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:M3_real */
   rG_2_DM3_O @= { @ "G.2:DM3_O : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( DM3_O, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( DM3_O, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:DM3_O */
   rG_2_DUM3 @= { @ "G.2:DUM3 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( DUM3, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( DUM3, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:DUM3 */
   rG_2_M4I @= { @ "G.2:M4i : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( M4I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( M4I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:M4i */
   rG_2_M4_REAL @= { @ "G.2:M4_real : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( M4_REAL, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( M4_REAL, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:M4_real */
   rG_2_DM4_O @= { @ "G.2:DM4_O : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( DM4_O, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( DM4_O, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:DM4_O */
   rG_2_DUM4 @= { @ "G.2:DUM4 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( DUM4, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( DUM4, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:DUM4 */
   rG_2_M5I @= { @ "G.2:M5i : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( M5I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( M5I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:M5i */
   rG_2_M5_REAL @= { @ "G.2:M5_real : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( M5_REAL, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( M5_REAL, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:M5_real */
   rG_2_DM5_O @= { @ "G.2:DM5_O : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( DM5_O, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( DM5_O, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:DM5_O */
   rG_2_DUM5 @= { @ "G.2:DUM5 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( DUM5, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( DUM5, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:DUM5 */
   rG_2_M6I @= { @ "G.2:M6i : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( M6I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( M6I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:M6i */
   rG_2_M6_REAL @= { @ "G.2:M6_real : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( M6_REAL, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( M6_REAL, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:M6_real */
   rG_2_DM6_O @= { @ "G.2:DM6_O : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( DM6_O, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( DM6_O, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:DM6_O */
   rG_2_DUM6 @= { @ "G.2:DUM6 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( DUM6, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( DUM6, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:DUM6 */
   rG_2_M7I @= { @ "G.2:M7i : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( M7I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( M7I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:M7i */
   rG_2_M7_REAL @= { @ "G.2:M7_real : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( M7_REAL, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( M7_REAL, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:M7_real */
   rG_2_DM7_O @= { @ "G.2:DM7_O : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( DM7_O, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( DM7_O, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:DM7_O */
   rG_2_DUM7 @= { @ "G.2:DUM7 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( DUM7, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( DUM7, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:DUM7 */
   rG_2_M8_OLD @= { @ "G.2:M8_OLD : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( M8_OLD, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( M8_OLD, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:M8_OLD */
   rG_2_M8_NEW @= { @ "G.2:M8_NEW : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( M8_NEW, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( M8_NEW, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:M8_NEW */
   rG_2_DUM8_OLD @= { @ "G.2:DUM8_OLD : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( DUM8_OLD, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( DUM8_OLD, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:DUM8_OLD */
   rG_2_DUM8_NEW @= { @ "G.2:DUM8_NEW : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( DUM8_NEW, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( DUM8_NEW, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:DUM8_NEW */
   rG_2_M9_OLD @= { @ "G.2:M9_OLD : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( M9_OLD, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( M9_OLD, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:M9_OLD */
   rG_2_M9_NEW @= { @ "G.2:M9_NEW : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( M9_NEW, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( M9_NEW, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:M9_NEW */
   rG_2_DUM9_OLD @= { @ "G.2:DUM9_OLD : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( DUM9_OLD, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( DUM9_OLD, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:DUM9_OLD */
   rG_2_DUM9_NEW @= { @ "G.2:DUM9_NEW : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( DUM9_NEW, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( DUM9_NEW, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:DUM9_NEW */
   rG_2_VIA1I @= { @ "G.2:VIA1i : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( VIA1I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( VIA1I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:VIA1i */
   rG_2_VIA2I @= { @ "G.2:VIA2i : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( VIA2I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( VIA2I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:VIA2i */
   rG_2_VIA3I @= { @ "G.2:VIA3i : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( VIA3I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( VIA3I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:VIA3i */
   rG_2_VIA4I @= { @ "G.2:VIA4i : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( VIA4I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( VIA4I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:VIA4i */
   rG_2_VIA5I @= { @ "G.2:VIA5i : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( VIA5I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( VIA5I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:VIA5i */
   rG_2_VIA6I @= { @ "G.2:VIA6i : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( VIA6I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( VIA6I, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:VIA6i */
   rG_2_VIA7_OLD @= { @ "G.2:VIA7_OLD : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( VIA7_OLD, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( VIA7_OLD, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:VIA7_OLD */
   rG_2_VIA7_NEW @= { @ "G.2:VIA7_NEW : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( VIA7_NEW, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( VIA7_NEW, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:VIA7_NEW */
   rG_2_VIA8_OLD @= { @ "G.2:VIA8_OLD : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( VIA8_OLD, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( VIA8_OLD, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:VIA8_OLD */
   rG_2_VIA8_NEW @= { @ "G.2:VIA8_NEW : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( VIA8_NEW, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( VIA8_NEW, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:VIA8_NEW */
   rG_2_ODI @= { @ "G.2:ODi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( ODI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( ODI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:ODi */
   rG_2_DOD @= { @ "G.2:DOD : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( DOD, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( DOD, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:DOD */
   rG_2_POI @= { @ "G.2:POi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( POI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( POI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:POi */
   rG_2_DPO @= { @ "G.2:DPO : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( DPO, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( DPO, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:DPO */
   rG_2_MVTLI @= { @ "G.2:mVTLi : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( MVTLI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( MVTLI, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:mVTLi */
   rG_2_RMDMY1 @= { @ "G.2:RMDMY1 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( RMDMY1, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( RMDMY1, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:RMDMY1 */
   rG_2_RMDMY2 @= { @ "G.2:RMDMY2 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( RMDMY2, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( RMDMY2, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:RMDMY2 */
   rG_2_RMDMY3 @= { @ "G.2:RMDMY3 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( RMDMY3, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( RMDMY3, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:RMDMY3 */
   rG_2_RMDMY4 @= { @ "G.2:RMDMY4 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( RMDMY4, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( RMDMY4, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:RMDMY4 */
   rG_2_RMDMY5 @= { @ "G.2:RMDMY5 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( RMDMY5, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( RMDMY5, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:RMDMY5 */
   rG_2_RMDMY6 @= { @ "G.2:RMDMY6 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( RMDMY6, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( RMDMY6, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:RMDMY6 */
   rG_2_RMDMY7 @= { @ "G.2:RMDMY7 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( RMDMY7, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( RMDMY7, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:RMDMY7 */
   rG_2_RMDMY8 @= { @ "G.2:RMDMY8 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( RMDMY8, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( RMDMY8, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:RMDMY8 */
   rG_2_RMDMY9 @= { @ "G.2:RMDMY9 : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( RMDMY9, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( RMDMY9, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:RMDMY9 */
   rG_2_RMDMYAP @= { @ "G.2:RMDMYAP : LAYERS Shapes with acute angles between line segments are not allowed.";
       internal1_error( RMDMYAP, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { } ); 
       external1_error( RMDMYAP, < 0.1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { } ); 
   } /* end of rule : G.2:RMDMYAP */
   rG_3_DNWI @= { @ "G.3:DNWi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( DNWI, ( 0, 45 ) ); 
       angle_edge( DNWI, ( 45, 90 ) ); 
   } /* end of rule : G.3:DNWi */
   rG_3_NWI @= { @ "G.3:NWi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( NWI, ( 0, 45 ) ); 
       angle_edge( NWI, ( 45, 90 ) ); 
   } /* end of rule : G.3:NWi */
   rG_3_OD_18I @= { @ "G.3:OD_18i : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( OD_18I, ( 0, 45 ) ); 
       angle_edge( OD_18I, ( 45, 90 ) ); 
   } /* end of rule : G.3:OD_18i */
   rG_3_OD_25I @= { @ "G.3:OD_25i : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( OD_25I, ( 0, 45 ) ); 
       angle_edge( OD_25I, ( 45, 90 ) ); 
   } /* end of rule : G.3:OD_25i */
   rG_3_OD25_33 @= { @ "G.3:OD25_33 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( OD25_33, ( 0, 45 ) ); 
       angle_edge( OD25_33, ( 45, 90 ) ); 
   } /* end of rule : G.3:OD25_33 */
   rG_3_OD25_18 @= { @ "G.3:OD25_18 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( OD25_18, ( 0, 45 ) ); 
       angle_edge( OD25_18, ( 45, 90 ) ); 
   } /* end of rule : G.3:OD25_18 */
   rG_3_OD_33I @= { @ "G.3:OD_33i : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( OD_33I, ( 0, 45 ) ); 
       angle_edge( OD_33I, ( 45, 90 ) ); 
   } /* end of rule : G.3:OD_33i */
   rG_3_OD_DECAP @= { @ "G.3:OD_DECAP : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( OD_DECAP, ( 0, 45 ) ); 
       angle_edge( OD_DECAP, ( 45, 90 ) ); 
   } /* end of rule : G.3:OD_DECAP */
   rG_3_PPI @= { @ "G.3:PPi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( PPI, ( 0, 45 ) ); 
       angle_edge( PPI, ( 45, 90 ) ); 
   } /* end of rule : G.3:PPi */
   rG_3_NPI @= { @ "G.3:NPi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( NPI, ( 0, 45 ) ); 
       angle_edge( NPI, ( 45, 90 ) ); 
   } /* end of rule : G.3:NPi */
   rG_3_COI @= { @ "G.3:COi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( COI, ( 0, 45 ) ); 
       angle_edge( COI, ( 45, 90 ) ); 
   } /* end of rule : G.3:COi */
   rG_3_CO_PUSH @= { @ "G.3:CO_PUSH : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( CO_PUSH, ( 0, 45 ) ); 
       angle_edge( CO_PUSH, ( 45, 90 ) ); 
   } /* end of rule : G.3:CO_PUSH */
   rG_3_CBI @= { @ "G.3:CBi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( CBI, ( 0, 45 ) ); 
       angle_edge( CBI, ( 45, 90 ) ); 
   } /* end of rule : G.3:CBi */
   rG_3_RPOI @= { @ "G.3:RPOi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( RPOI, ( 0, 45 ) ); 
       angle_edge( RPOI, ( 45, 90 ) ); 
   } /* end of rule : G.3:RPOi */
   rG_3_NT_NI @= { @ "G.3:NT_Ni : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( NT_NI, ( 0, 45 ) ); 
       angle_edge( NT_NI, ( 45, 90 ) ); 
   } /* end of rule : G.3:NT_Ni */
   rG_3_NCAP_NTNI @= { @ "G.3:NCap_NTNi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( NCAP_NTNI, ( 0, 45 ) ); 
       angle_edge( NCAP_NTNI, ( 45, 90 ) ); 
   } /* end of rule : G.3:NCap_NTNi */
   rG_3_FWALI @= { @ "G.3:FWALi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( FWALI, ( 0, 45 ) ); 
       angle_edge( FWALI, ( 45, 90 ) ); 
   } /* end of rule : G.3:FWALi */
   rG_3_FWCUI @= { @ "G.3:FWCUi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( FWCUI, ( 0, 45 ) ); 
       angle_edge( FWCUI, ( 45, 90 ) ); 
   } /* end of rule : G.3:FWCUi */
   rG_3_POFUSE @= { @ "G.3:POFUSE : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( POFUSE, ( 0, 45 ) ); 
       angle_edge( POFUSE, ( 45, 90 ) ); 
   } /* end of rule : G.3:POFUSE */
   rG_3_FUSELINK @= { @ "G.3:FUSELINK : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( FUSELINK, ( 0, 45 ) ); 
       angle_edge( FUSELINK, ( 45, 90 ) ); 
   } /* end of rule : G.3:FUSELINK */
   rG_3_SEALRINGI @= { @ "G.3:SEALRINGi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( SEALRINGI, ( 0, 45 ) ); 
       angle_edge( SEALRINGI, ( 45, 90 ) ); 
   } /* end of rule : G.3:SEALRINGi */
   rG_3_VTH_NI @= { @ "G.3:VTH_Ni : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( VTH_NI, ( 0, 45 ) ); 
       angle_edge( VTH_NI, ( 45, 90 ) ); 
   } /* end of rule : G.3:VTH_Ni */
   rG_3_VTH_PI @= { @ "G.3:VTH_Pi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( VTH_PI, ( 0, 45 ) ); 
       angle_edge( VTH_PI, ( 45, 90 ) ); 
   } /* end of rule : G.3:VTH_Pi */
   rG_3_VTL_NI @= { @ "G.3:VTL_Ni : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( VTL_NI, ( 0, 45 ) ); 
       angle_edge( VTL_NI, ( 45, 90 ) ); 
   } /* end of rule : G.3:VTL_Ni */
   rG_3_VTL_PI @= { @ "G.3:VTL_Pi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( VTL_PI, ( 0, 45 ) ); 
       angle_edge( VTL_PI, ( 45, 90 ) ); 
   } /* end of rule : G.3:VTL_Pi */
   rG_3_UHVT_NI @= { @ "G.3:UHVT_Ni : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( UHVT_NI, ( 0, 45 ) ); 
       angle_edge( UHVT_NI, ( 45, 90 ) ); 
   } /* end of rule : G.3:UHVT_Ni */
   rG_3_UHVT_PI @= { @ "G.3:UHVT_Pi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( UHVT_PI, ( 0, 45 ) ); 
       angle_edge( UHVT_PI, ( 45, 90 ) ); 
   } /* end of rule : G.3:UHVT_Pi */
   rG_3_RH @= { @ "G.3:RH : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( RH, ( 0, 45 ) ); 
       angle_edge( RH, ( 45, 90 ) ); 
   } /* end of rule : G.3:RH */
   rG_3_ESD3 @= { @ "G.3:ESD3 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( ESD3, ( 0, 45 ) ); 
       angle_edge( ESD3, ( 45, 90 ) ); 
   } /* end of rule : G.3:ESD3 */
   rG_3_VARI @= { @ "G.3:VARi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( VARI, ( 0, 45 ) ); 
       angle_edge( VARI, ( 45, 90 ) ); 
   } /* end of rule : G.3:VARi */
   rG_3_API @= { @ "G.3:APi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( API, ( 0, 45 ) ); 
       angle_edge( API, ( 45, 90 ) ); 
   } /* end of rule : G.3:APi */
   rG_3_CBMI @= { @ "G.3:CBMi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( CBMI, ( 0, 45 ) ); 
       angle_edge( CBMI, ( 45, 90 ) ); 
   } /* end of rule : G.3:CBMi */
   rG_3_CTMI @= { @ "G.3:CTMi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( CTMI, ( 0, 45 ) ); 
       angle_edge( CTMI, ( 45, 90 ) ); 
   } /* end of rule : G.3:CTMi */
   rG_3_RVI @= { @ "G.3:RVi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( RVI, ( 0, 45 ) ); 
       angle_edge( RVI, ( 45, 90 ) ); 
   } /* end of rule : G.3:RVi */
   rG_3_DCOI @= { @ "G.3:DCOi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( DCOI, ( 0, 45 ) ); 
       angle_edge( DCOI, ( 45, 90 ) ); 
   } /* end of rule : G.3:DCOi */
   rG_3_HVD_P @= { @ "G.3:HVD_P : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( HVD_P, ( 0, 45 ) ); 
       angle_edge( HVD_P, ( 45, 90 ) ); 
   } /* end of rule : G.3:HVD_P */
   rG_3_HVD_N_NW @= { @ "G.3:HVD_N_nw : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( HVD_N_NW, ( 0, 45 ) ); 
       angle_edge( HVD_N_NW, ( 45, 90 ) ); 
   } /* end of rule : G.3:HVD_N_nw */
   rG_3_SRM_ULL @= { @ "G.3:SRM_ULL : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( SRM_ULL, ( 0, 45 ) ); 
       angle_edge( SRM_ULL, ( 45, 90 ) ); 
   } /* end of rule : G.3:SRM_ULL */
   rG_3_BJTDMY @= { @ "G.3:BJTDMY : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( BJTDMY, ( 0, 45 ) ); 
       angle_edge( BJTDMY, ( 45, 90 ) ); 
   } /* end of rule : G.3:BJTDMY */
   rG_3_NWDMY @= { @ "G.3:NWDMY : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( NWDMY, ( 0, 45 ) ); 
       angle_edge( NWDMY, ( 45, 90 ) ); 
   } /* end of rule : G.3:NWDMY */
   rG_3_RPDMY @= { @ "G.3:RPDMY : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( RPDMY, ( 0, 45 ) ); 
       angle_edge( RPDMY, ( 45, 90 ) ); 
   } /* end of rule : G.3:RPDMY */
   rG_3_SDI @= { @ "G.3:SDI : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( SDI, ( 0, 45 ) ); 
       angle_edge( SDI, ( 45, 90 ) ); 
   } /* end of rule : G.3:SDI */
   rG_3_ESD1DMY @= { @ "G.3:ESD1DMY : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( ESD1DMY, ( 0, 45 ) ); 
       angle_edge( ESD1DMY, ( 45, 90 ) ); 
   } /* end of rule : G.3:ESD1DMY */
   rG_3_ESD2DMY @= { @ "G.3:ESD2DMY : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( ESD2DMY, ( 0, 45 ) ); 
       angle_edge( ESD2DMY, ( 45, 90 ) ); 
   } /* end of rule : G.3:ESD2DMY */
   rG_3_RODMY @= { @ "G.3:RODMY : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( RODMY, ( 0, 45 ) ); 
       angle_edge( RODMY, ( 45, 90 ) ); 
   } /* end of rule : G.3:RODMY */
   rG_3_SRM @= { @ "G.3:SRM : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( SRM, ( 0, 45 ) ); 
       angle_edge( SRM, ( 45, 90 ) ); 
   } /* end of rule : G.3:SRM */
   rG_3_CDUDMY @= { @ "G.3:CDUDMY : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( CDUDMY, ( 0, 45 ) ); 
       angle_edge( CDUDMY, ( 45, 90 ) ); 
   } /* end of rule : G.3:CDUDMY */
   rG_3_TCDDMY @= { @ "G.3:TCDDMY : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( TCDDMY, ( 0, 45 ) ); 
       angle_edge( TCDDMY, ( 45, 90 ) ); 
   } /* end of rule : G.3:TCDDMY */
   rG_3_LOGO @= { @ "G.3:LOGO : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( LOGO, ( 0, 45 ) ); 
       angle_edge( LOGO, ( 45, 90 ) ); 
   } /* end of rule : G.3:LOGO */
   rG_3_INDDMY @= { @ "G.3:INDDMY : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( INDDMY, ( 0, 45 ) ); 
       angle_edge( INDDMY, ( 45, 90 ) ); 
   } /* end of rule : G.3:INDDMY */
   rG_3_CTMDMY @= { @ "G.3:CTMDMY : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( CTMDMY, ( 0, 45 ) ); 
       angle_edge( CTMDMY, ( 45, 90 ) ); 
   } /* end of rule : G.3:CTMDMY */
   rG_3_CTMDMY_10 @= { @ "G.3:CTMDMY_10 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( CTMDMY_10, ( 0, 45 ) ); 
       angle_edge( CTMDMY_10, ( 45, 90 ) ); 
   } /* end of rule : G.3:CTMDMY_10 */
   rG_3_CTMDMY_15 @= { @ "G.3:CTMDMY_15 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( CTMDMY_15, ( 0, 45 ) ); 
       angle_edge( CTMDMY_15, ( 45, 90 ) ); 
   } /* end of rule : G.3:CTMDMY_15 */
   rG_3_CTMDMY_20 @= { @ "G.3:CTMDMY_20 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( CTMDMY_20, ( 0, 45 ) ); 
       angle_edge( CTMDMY_20, ( 45, 90 ) ); 
   } /* end of rule : G.3:CTMDMY_20 */
   rG_3_CTMDMY_21 @= { @ "G.3:CTMDMY_21 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( CTMDMY_21, ( 0, 45 ) ); 
       angle_edge( CTMDMY_21, ( 45, 90 ) ); 
   } /* end of rule : G.3:CTMDMY_21 */
   rG_3_MOMDMY_1 @= { @ "G.3:MOMDMY_1 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( MOMDMY_1, ( 0, 45 ) ); 
       angle_edge( MOMDMY_1, ( 45, 90 ) ); 
   } /* end of rule : G.3:MOMDMY_1 */
   rG_3_MOMDMY_2 @= { @ "G.3:MOMDMY_2 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( MOMDMY_2, ( 0, 45 ) ); 
       angle_edge( MOMDMY_2, ( 45, 90 ) ); 
   } /* end of rule : G.3:MOMDMY_2 */
   rG_3_MOMDMY_3 @= { @ "G.3:MOMDMY_3 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( MOMDMY_3, ( 0, 45 ) ); 
       angle_edge( MOMDMY_3, ( 45, 90 ) ); 
   } /* end of rule : G.3:MOMDMY_3 */
   rG_3_MOMDMY_4 @= { @ "G.3:MOMDMY_4 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( MOMDMY_4, ( 0, 45 ) ); 
       angle_edge( MOMDMY_4, ( 45, 90 ) ); 
   } /* end of rule : G.3:MOMDMY_4 */
   rG_3_MOMDMY_5 @= { @ "G.3:MOMDMY_5 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( MOMDMY_5, ( 0, 45 ) ); 
       angle_edge( MOMDMY_5, ( 45, 90 ) ); 
   } /* end of rule : G.3:MOMDMY_5 */
   rG_3_MOMDMY_6 @= { @ "G.3:MOMDMY_6 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( MOMDMY_6, ( 0, 45 ) ); 
       angle_edge( MOMDMY_6, ( 45, 90 ) ); 
   } /* end of rule : G.3:MOMDMY_6 */
   rG_3_MOMDMY_7 @= { @ "G.3:MOMDMY_7 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( MOMDMY_7, ( 0, 45 ) ); 
       angle_edge( MOMDMY_7, ( 45, 90 ) ); 
   } /* end of rule : G.3:MOMDMY_7 */
   rG_3_MOMDMY_8 @= { @ "G.3:MOMDMY_8 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( MOMDMY_8, ( 0, 45 ) ); 
       angle_edge( MOMDMY_8, ( 45, 90 ) ); 
   } /* end of rule : G.3:MOMDMY_8 */
   rG_3_MOMDMY_9 @= { @ "G.3:MOMDMY_9 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( MOMDMY_9, ( 0, 45 ) ); 
       angle_edge( MOMDMY_9, ( 45, 90 ) ); 
   } /* end of rule : G.3:MOMDMY_9 */
   rG_3_MOMDMY_AP @= { @ "G.3:MOMDMY_AP : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( MOMDMY_AP, ( 0, 45 ) ); 
       angle_edge( MOMDMY_AP, ( 45, 90 ) ); 
   } /* end of rule : G.3:MOMDMY_AP */
   rG_3_RTMOMDMY @= { @ "G.3:RTMOMDMY : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( RTMOMDMY, ( 0, 45 ) ); 
       angle_edge( RTMOMDMY, ( 45, 90 ) ); 
   } /* end of rule : G.3:RTMOMDMY */
   rG_3_MOMDMY @= { @ "G.3:MOMDMY : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( MOMDMY, ( 0, 45 ) ); 
       angle_edge( MOMDMY, ( 45, 90 ) ); 
   } /* end of rule : G.3:MOMDMY */
   rG_3_MOMDMY_2T @= { @ "G.3:MOMDMY_2T : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( MOMDMY_2T, ( 0, 45 ) ); 
       angle_edge( MOMDMY_2T, ( 45, 90 ) ); 
   } /* end of rule : G.3:MOMDMY_2T */
   rG_3_MOMDMY_100 @= { @ "G.3:MOMDMY_100 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( MOMDMY_100, ( 0, 45 ) ); 
       angle_edge( MOMDMY_100, ( 45, 90 ) ); 
   } /* end of rule : G.3:MOMDMY_100 */
   rG_3_RFDMY @= { @ "G.3:RFDMY : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( RFDMY, ( 0, 45 ) ); 
       angle_edge( RFDMY, ( 45, 90 ) ); 
   } /* end of rule : G.3:RFDMY */
   rG_3_WBDMY @= { @ "G.3:WBDMY : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( WBDMY, ( 0, 45 ) ); 
       angle_edge( WBDMY, ( 45, 90 ) ); 
   } /* end of rule : G.3:WBDMY */
   rG_3_DIODMY @= { @ "G.3:DIODMY : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( DIODMY, ( 0, 45 ) ); 
       angle_edge( DIODMY, ( 45, 90 ) ); 
   } /* end of rule : G.3:DIODMY */
   rG_3_SRAMDMY @= { @ "G.3:SRAMDMY : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( SRAMDMY, ( 0, 45 ) ); 
       angle_edge( SRAMDMY, ( 45, 90 ) ); 
   } /* end of rule : G.3:SRAMDMY */
   rG_3_SRAMDMY_4 @= { @ "G.3:SRAMDMY_4 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( SRAMDMY_4, ( 0, 45 ) ); 
       angle_edge( SRAMDMY_4, ( 45, 90 ) ); 
   } /* end of rule : G.3:SRAMDMY_4 */
   rG_3_SRAMDMY_5 @= { @ "G.3:SRAMDMY_5 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( SRAMDMY_5, ( 0, 45 ) ); 
       angle_edge( SRAMDMY_5, ( 45, 90 ) ); 
   } /* end of rule : G.3:SRAMDMY_5 */
   rG_3_SRAMDMY_1 @= { @ "G.3:SRAMDMY_1 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( SRAMDMY_1, ( 0, 45 ) ); 
       angle_edge( SRAMDMY_1, ( 45, 90 ) ); 
   } /* end of rule : G.3:SRAMDMY_1 */
   rG_3_RAM1TDMY @= { @ "G.3:RAM1TDMY : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( RAM1TDMY, ( 0, 45 ) ); 
       angle_edge( RAM1TDMY, ( 45, 90 ) ); 
   } /* end of rule : G.3:RAM1TDMY */
   rG_3_OD1TI @= { @ "G.3:OD1Ti : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( OD1TI, ( 0, 45 ) ); 
       angle_edge( OD1TI, ( 45, 90 ) ); 
   } /* end of rule : G.3:OD1Ti */
   rG_3_CLDDI @= { @ "G.3:CLDDi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( CLDDI, ( 0, 45 ) ); 
       angle_edge( CLDDI, ( 45, 90 ) ); 
   } /* end of rule : G.3:CLDDi */
   rG_3_CROWNI @= { @ "G.3:CROWNi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( CROWNI, ( 0, 45 ) ); 
       angle_edge( CROWNI, ( 45, 90 ) ); 
   } /* end of rule : G.3:CROWNi */
   rG_3_P3I @= { @ "G.3:P3i : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( P3I, ( 0, 45 ) ); 
       angle_edge( P3I, ( 45, 90 ) ); 
   } /* end of rule : G.3:P3i */
   rG_3_SNCTI @= { @ "G.3:SNCTi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( SNCTI, ( 0, 45 ) ); 
       angle_edge( SNCTI, ( 45, 90 ) ); 
   } /* end of rule : G.3:SNCTi */
   rG_3_LUPWDMY @= { @ "G.3:LUPWDMY : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( LUPWDMY, ( 0, 45 ) ); 
       angle_edge( LUPWDMY, ( 45, 90 ) ); 
   } /* end of rule : G.3:LUPWDMY */
   rG_3_LUPWDMY_2 @= { @ "G.3:LUPWDMY_2 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( LUPWDMY_2, ( 0, 45 ) ); 
       angle_edge( LUPWDMY_2, ( 45, 90 ) ); 
   } /* end of rule : G.3:LUPWDMY_2 */
   rG_3_VDDDMY @= { @ "G.3:VDDDMY : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( VDDDMY, ( 0, 45 ) ); 
       angle_edge( VDDDMY, ( 45, 90 ) ); 
   } /* end of rule : G.3:VDDDMY */
   rG_3_VSSDMY @= { @ "G.3:VSSDMY : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( VSSDMY, ( 0, 45 ) ); 
       angle_edge( VSSDMY, ( 45, 90 ) ); 
   } /* end of rule : G.3:VSSDMY */
   rG_3_MATCHING @= { @ "G.3:MATCHING : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( MATCHING, ( 0, 45 ) ); 
       angle_edge( MATCHING, ( 45, 90 ) ); 
   } /* end of rule : G.3:MATCHING */
   rG_3_M1I @= { @ "G.3:M1i : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( M1I, ( 0, 45 ) ); 
       angle_edge( M1I, ( 45, 90 ) ); 
   } /* end of rule : G.3:M1i */
   rG_3_M1_REAL @= { @ "G.3:M1_real : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( M1_REAL, ( 0, 45 ) ); 
       angle_edge( M1_REAL, ( 45, 90 ) ); 
   } /* end of rule : G.3:M1_real */
   rG_3_DM1_O @= { @ "G.3:DM1_O : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( DM1_O, ( 0, 45 ) ); 
       angle_edge( DM1_O, ( 45, 90 ) ); 
   } /* end of rule : G.3:DM1_O */
   rG_3_DUM1 @= { @ "G.3:DUM1 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( DUM1, ( 0, 45 ) ); 
       angle_edge( DUM1, ( 45, 90 ) ); 
   } /* end of rule : G.3:DUM1 */
   rG_3_M2I @= { @ "G.3:M2i : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( M2I, ( 0, 45 ) ); 
       angle_edge( M2I, ( 45, 90 ) ); 
   } /* end of rule : G.3:M2i */
   rG_3_M2_REAL @= { @ "G.3:M2_real : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( M2_REAL, ( 0, 45 ) ); 
       angle_edge( M2_REAL, ( 45, 90 ) ); 
   } /* end of rule : G.3:M2_real */
   rG_3_DM2_O @= { @ "G.3:DM2_O : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( DM2_O, ( 0, 45 ) ); 
       angle_edge( DM2_O, ( 45, 90 ) ); 
   } /* end of rule : G.3:DM2_O */
   rG_3_DUM2 @= { @ "G.3:DUM2 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( DUM2, ( 0, 45 ) ); 
       angle_edge( DUM2, ( 45, 90 ) ); 
   } /* end of rule : G.3:DUM2 */
   rG_3_M3I @= { @ "G.3:M3i : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( M3I, ( 0, 45 ) ); 
       angle_edge( M3I, ( 45, 90 ) ); 
   } /* end of rule : G.3:M3i */
   rG_3_M3_REAL @= { @ "G.3:M3_real : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( M3_REAL, ( 0, 45 ) ); 
       angle_edge( M3_REAL, ( 45, 90 ) ); 
   } /* end of rule : G.3:M3_real */
   rG_3_DM3_O @= { @ "G.3:DM3_O : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( DM3_O, ( 0, 45 ) ); 
       angle_edge( DM3_O, ( 45, 90 ) ); 
   } /* end of rule : G.3:DM3_O */
   rG_3_DUM3 @= { @ "G.3:DUM3 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( DUM3, ( 0, 45 ) ); 
       angle_edge( DUM3, ( 45, 90 ) ); 
   } /* end of rule : G.3:DUM3 */
   rG_3_M4I @= { @ "G.3:M4i : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( M4I, ( 0, 45 ) ); 
       angle_edge( M4I, ( 45, 90 ) ); 
   } /* end of rule : G.3:M4i */
   rG_3_M4_REAL @= { @ "G.3:M4_real : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( M4_REAL, ( 0, 45 ) ); 
       angle_edge( M4_REAL, ( 45, 90 ) ); 
   } /* end of rule : G.3:M4_real */
   rG_3_DM4_O @= { @ "G.3:DM4_O : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( DM4_O, ( 0, 45 ) ); 
       angle_edge( DM4_O, ( 45, 90 ) ); 
   } /* end of rule : G.3:DM4_O */
   rG_3_DUM4 @= { @ "G.3:DUM4 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( DUM4, ( 0, 45 ) ); 
       angle_edge( DUM4, ( 45, 90 ) ); 
   } /* end of rule : G.3:DUM4 */
   rG_3_M5I @= { @ "G.3:M5i : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( M5I, ( 0, 45 ) ); 
       angle_edge( M5I, ( 45, 90 ) ); 
   } /* end of rule : G.3:M5i */
   rG_3_M5_REAL @= { @ "G.3:M5_real : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( M5_REAL, ( 0, 45 ) ); 
       angle_edge( M5_REAL, ( 45, 90 ) ); 
   } /* end of rule : G.3:M5_real */
   rG_3_DM5_O @= { @ "G.3:DM5_O : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( DM5_O, ( 0, 45 ) ); 
       angle_edge( DM5_O, ( 45, 90 ) ); 
   } /* end of rule : G.3:DM5_O */
   rG_3_DUM5 @= { @ "G.3:DUM5 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( DUM5, ( 0, 45 ) ); 
       angle_edge( DUM5, ( 45, 90 ) ); 
   } /* end of rule : G.3:DUM5 */
   rG_3_M6I @= { @ "G.3:M6i : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( M6I, ( 0, 45 ) ); 
       angle_edge( M6I, ( 45, 90 ) ); 
   } /* end of rule : G.3:M6i */
   rG_3_M6_REAL @= { @ "G.3:M6_real : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( M6_REAL, ( 0, 45 ) ); 
       angle_edge( M6_REAL, ( 45, 90 ) ); 
   } /* end of rule : G.3:M6_real */
   rG_3_DM6_O @= { @ "G.3:DM6_O : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( DM6_O, ( 0, 45 ) ); 
       angle_edge( DM6_O, ( 45, 90 ) ); 
   } /* end of rule : G.3:DM6_O */
   rG_3_DUM6 @= { @ "G.3:DUM6 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( DUM6, ( 0, 45 ) ); 
       angle_edge( DUM6, ( 45, 90 ) ); 
   } /* end of rule : G.3:DUM6 */
   rG_3_M7I @= { @ "G.3:M7i : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( M7I, ( 0, 45 ) ); 
       angle_edge( M7I, ( 45, 90 ) ); 
   } /* end of rule : G.3:M7i */
   rG_3_M7_REAL @= { @ "G.3:M7_real : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( M7_REAL, ( 0, 45 ) ); 
       angle_edge( M7_REAL, ( 45, 90 ) ); 
   } /* end of rule : G.3:M7_real */
   rG_3_DM7_O @= { @ "G.3:DM7_O : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( DM7_O, ( 0, 45 ) ); 
       angle_edge( DM7_O, ( 45, 90 ) ); 
   } /* end of rule : G.3:DM7_O */
   rG_3_DUM7 @= { @ "G.3:DUM7 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( DUM7, ( 0, 45 ) ); 
       angle_edge( DUM7, ( 45, 90 ) ); 
   } /* end of rule : G.3:DUM7 */
   rG_3_M8_OLD @= { @ "G.3:M8_OLD : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( M8_OLD, ( 0, 45 ) ); 
       angle_edge( M8_OLD, ( 45, 90 ) ); 
   } /* end of rule : G.3:M8_OLD */
   rG_3_M8_NEW @= { @ "G.3:M8_NEW : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( M8_NEW, ( 0, 45 ) ); 
       angle_edge( M8_NEW, ( 45, 90 ) ); 
   } /* end of rule : G.3:M8_NEW */
   rG_3_DUM8_OLD @= { @ "G.3:DUM8_OLD : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( DUM8_OLD, ( 0, 45 ) ); 
       angle_edge( DUM8_OLD, ( 45, 90 ) ); 
   } /* end of rule : G.3:DUM8_OLD */
   rG_3_DUM8_NEW @= { @ "G.3:DUM8_NEW : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( DUM8_NEW, ( 0, 45 ) ); 
       angle_edge( DUM8_NEW, ( 45, 90 ) ); 
   } /* end of rule : G.3:DUM8_NEW */
   rG_3_M9_OLD @= { @ "G.3:M9_OLD : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( M9_OLD, ( 0, 45 ) ); 
       angle_edge( M9_OLD, ( 45, 90 ) ); 
   } /* end of rule : G.3:M9_OLD */
   rG_3_M9_NEW @= { @ "G.3:M9_NEW : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( M9_NEW, ( 0, 45 ) ); 
       angle_edge( M9_NEW, ( 45, 90 ) ); 
   } /* end of rule : G.3:M9_NEW */
   rG_3_DUM9_OLD @= { @ "G.3:DUM9_OLD : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( DUM9_OLD, ( 0, 45 ) ); 
       angle_edge( DUM9_OLD, ( 45, 90 ) ); 
   } /* end of rule : G.3:DUM9_OLD */
   rG_3_DUM9_NEW @= { @ "G.3:DUM9_NEW : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( DUM9_NEW, ( 0, 45 ) ); 
       angle_edge( DUM9_NEW, ( 45, 90 ) ); 
   } /* end of rule : G.3:DUM9_NEW */
   rG_3_VIA1I @= { @ "G.3:VIA1i : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( VIA1I, ( 0, 45 ) ); 
       angle_edge( VIA1I, ( 45, 90 ) ); 
   } /* end of rule : G.3:VIA1i */
   rG_3_VIA2I @= { @ "G.3:VIA2i : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( VIA2I, ( 0, 45 ) ); 
       angle_edge( VIA2I, ( 45, 90 ) ); 
   } /* end of rule : G.3:VIA2i */
   rG_3_VIA3I @= { @ "G.3:VIA3i : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( VIA3I, ( 0, 45 ) ); 
       angle_edge( VIA3I, ( 45, 90 ) ); 
   } /* end of rule : G.3:VIA3i */
   rG_3_VIA4I @= { @ "G.3:VIA4i : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( VIA4I, ( 0, 45 ) ); 
       angle_edge( VIA4I, ( 45, 90 ) ); 
   } /* end of rule : G.3:VIA4i */
   rG_3_VIA5I @= { @ "G.3:VIA5i : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( VIA5I, ( 0, 45 ) ); 
       angle_edge( VIA5I, ( 45, 90 ) ); 
   } /* end of rule : G.3:VIA5i */
   rG_3_VIA6I @= { @ "G.3:VIA6i : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( VIA6I, ( 0, 45 ) ); 
       angle_edge( VIA6I, ( 45, 90 ) ); 
   } /* end of rule : G.3:VIA6i */
   rG_3_VIA7_OLD @= { @ "G.3:VIA7_OLD : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( VIA7_OLD, ( 0, 45 ) ); 
       angle_edge( VIA7_OLD, ( 45, 90 ) ); 
   } /* end of rule : G.3:VIA7_OLD */
   rG_3_VIA7_NEW @= { @ "G.3:VIA7_NEW : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( VIA7_NEW, ( 0, 45 ) ); 
       angle_edge( VIA7_NEW, ( 45, 90 ) ); 
   } /* end of rule : G.3:VIA7_NEW */
   rG_3_VIA8_OLD @= { @ "G.3:VIA8_OLD : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( VIA8_OLD, ( 0, 45 ) ); 
       angle_edge( VIA8_OLD, ( 45, 90 ) ); 
   } /* end of rule : G.3:VIA8_OLD */
   rG_3_VIA8_NEW @= { @ "G.3:VIA8_NEW : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( VIA8_NEW, ( 0, 45 ) ); 
       angle_edge( VIA8_NEW, ( 45, 90 ) ); 
   } /* end of rule : G.3:VIA8_NEW */
   rG_3_ODI @= { @ "G.3:ODi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( ODI, ( 0, 45 ) ); 
       angle_edge( ODI, ( 45, 90 ) ); 
   } /* end of rule : G.3:ODi */
   rG_3_DOD @= { @ "G.3:DOD : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( DOD, ( 0, 45 ) ); 
       angle_edge( DOD, ( 45, 90 ) ); 
   } /* end of rule : G.3:DOD */
   rG_3_POI @= { @ "G.3:POi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( POI, ( 0, 45 ) ); 
       angle_edge( POI, ( 45, 90 ) ); 
   } /* end of rule : G.3:POi */
   rG_3_DPO @= { @ "G.3:DPO : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( DPO, ( 0, 45 ) ); 
       angle_edge( DPO, ( 45, 90 ) ); 
   } /* end of rule : G.3:DPO */
   rG_3_MVTLI @= { @ "G.3:mVTLi : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( MVTLI, ( 0, 45 ) ); 
       angle_edge( MVTLI, ( 45, 90 ) ); 
   } /* end of rule : G.3:mVTLi */
   rG_3_RMDMY1 @= { @ "G.3:RMDMY1 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( RMDMY1, ( 0, 45 ) ); 
       angle_edge( RMDMY1, ( 45, 90 ) ); 
   } /* end of rule : G.3:RMDMY1 */
   rG_3_RMDMY2 @= { @ "G.3:RMDMY2 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( RMDMY2, ( 0, 45 ) ); 
       angle_edge( RMDMY2, ( 45, 90 ) ); 
   } /* end of rule : G.3:RMDMY2 */
   rG_3_RMDMY3 @= { @ "G.3:RMDMY3 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( RMDMY3, ( 0, 45 ) ); 
       angle_edge( RMDMY3, ( 45, 90 ) ); 
   } /* end of rule : G.3:RMDMY3 */
   rG_3_RMDMY4 @= { @ "G.3:RMDMY4 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( RMDMY4, ( 0, 45 ) ); 
       angle_edge( RMDMY4, ( 45, 90 ) ); 
   } /* end of rule : G.3:RMDMY4 */
   rG_3_RMDMY5 @= { @ "G.3:RMDMY5 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( RMDMY5, ( 0, 45 ) ); 
       angle_edge( RMDMY5, ( 45, 90 ) ); 
   } /* end of rule : G.3:RMDMY5 */
   rG_3_RMDMY6 @= { @ "G.3:RMDMY6 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( RMDMY6, ( 0, 45 ) ); 
       angle_edge( RMDMY6, ( 45, 90 ) ); 
   } /* end of rule : G.3:RMDMY6 */
   rG_3_RMDMY7 @= { @ "G.3:RMDMY7 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( RMDMY7, ( 0, 45 ) ); 
       angle_edge( RMDMY7, ( 45, 90 ) ); 
   } /* end of rule : G.3:RMDMY7 */
   rG_3_RMDMY8 @= { @ "G.3:RMDMY8 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( RMDMY8, ( 0, 45 ) ); 
       angle_edge( RMDMY8, ( 45, 90 ) ); 
   } /* end of rule : G.3:RMDMY8 */
   rG_3_RMDMY9 @= { @ "G.3:RMDMY9 : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( RMDMY9, ( 0, 45 ) ); 
       angle_edge( RMDMY9, ( 45, 90 ) ); 
   } /* end of rule : G.3:RMDMY9 */
   rG_3_RMDMYAP @= { @ "G.3:RMDMYAP : Shapes must be orthogonal or on a 45 degree angle.";
       angle_edge( RMDMYAP, ( 0, 45 ) ); 
       angle_edge( RMDMYAP, ( 45, 90 ) ); 
   } /* end of rule : G.3:RMDMYAP */
   rG_4_ODI @= { @ "G.4:ODi : Adjacent edges with length less than min. width is not allowed.";
       ODIA = ODI not_inside SRAM_EXCLUDE; 
       X = length_edge( ODIA, < OD_W_1 ); 
       ODI_SHORTEXP = edge_size( X, inside = 0.01, outside = 0.01 ); 
       sLAYER_1 = vertices( ODI_SHORTEXP, > 4 ); 
       ODI_SMALLJOG = sLAYER_1 not_inside SRAM_EXCLUDE; 
       and_edge( ODI, ODI_SMALLJOG, false ); 
   } /* end of rule : G.4:ODi */
   rG_4_POI @= { @ "G.4:POi : Adjacent edges with length less than min. width is not allowed.";
       POIA = POI not_inside SRAM_EXCLUDE; 
       X = length_edge( POIA, < PO_W_1 ); 
       POI_SHORTEXP = edge_size( X, inside = 0.01, outside = 0.01 ); 
       sLAYER_2 = vertices( POI_SHORTEXP, > 4 ); 
       POI_SMALLJOG = sLAYER_2 not_inside SRAM_EXCLUDE; 
       and_edge( POI, POI_SMALLJOG, false ); 
   } /* end of rule : G.4:POi */
   rG_4_VTH_NI @= { @ "G.4:VTH_Ni : Adjacent edges with length less than min. width is not allowed.";
       VTH_NIA = VTH_NI not_inside SRAM_EXCLUDE; 
       X = length_edge( VTH_NIA, < VTH_N_W_1 ); 
       VTH_NI_SHORTEXP = edge_size( X, inside = 0.01, outside = 0.01 ); 
       sLAYER_3 = vertices( VTH_NI_SHORTEXP, > 4 ); 
       VTH_NI_SMALLJOG = sLAYER_3 not_inside SRAM_EXCLUDE; 
       and_edge( VTH_NI, VTH_NI_SMALLJOG, false ); 
   } /* end of rule : G.4:VTH_Ni */
   rG_4_VTH_PI @= { @ "G.4:VTH_Pi : Adjacent edges with length less than min. width is not allowed.";
       VTH_PIA = VTH_PI not_inside SRAM_EXCLUDE; 
       X = length_edge( VTH_PIA, < VTH_P_W_1 ); 
       VTH_PI_SHORTEXP = edge_size( X, inside = 0.01, outside = 0.01 ); 
       sLAYER_4 = vertices( VTH_PI_SHORTEXP, > 4 ); 
       VTH_PI_SMALLJOG = sLAYER_4 not_inside SRAM_EXCLUDE; 
       and_edge( VTH_PI, VTH_PI_SMALLJOG, false ); 
   } /* end of rule : G.4:VTH_Pi */
   rG_4_VTL_NI @= { @ "G.4:VTL_Ni : Adjacent edges with length less than min. width is not allowed.";
       VTL_NIA = VTL_NI not_inside SRAM_EXCLUDE; 
       X = length_edge( VTL_NIA, < VTL_N_W_1 ); 
       VTL_NI_SHORTEXP = edge_size( X, inside = 0.01, outside = 0.01 ); 
       sLAYER_5 = vertices( VTL_NI_SHORTEXP, > 4 ); 
       VTL_NI_SMALLJOG = sLAYER_5 not_inside SRAM_EXCLUDE; 
       and_edge( VTL_NI, VTL_NI_SMALLJOG, false ); 
   } /* end of rule : G.4:VTL_Ni */
   rG_4_VTL_PI @= { @ "G.4:VTL_Pi : Adjacent edges with length less than min. width is not allowed.";
       VTL_PIA = VTL_PI not_inside SRAM_EXCLUDE; 
       X = length_edge( VTL_PIA, < VTL_P_W_1 ); 
       VTL_PI_SHORTEXP = edge_size( X, inside = 0.01, outside = 0.01 ); 
       sLAYER_6 = vertices( VTL_PI_SHORTEXP, > 4 ); 
       VTL_PI_SMALLJOG = sLAYER_6 not_inside SRAM_EXCLUDE; 
       and_edge( VTL_PI, VTL_PI_SMALLJOG, false ); 
   } /* end of rule : G.4:VTL_Pi */
   rG_4_PPI @= { @ "G.4:PPi : Adjacent edges with length less than min. width is not allowed.";
       PPIA = PPI not_inside SRAM_EXCLUDE; 
       X = length_edge( PPIA, < PP_W_1 ); 
       PPI_SHORTEXP = edge_size( X, inside = 0.01, outside = 0.01 ); 
       sLAYER_7 = vertices( PPI_SHORTEXP, > 4 ); 
       PPI_SMALLJOG = sLAYER_7 not_inside SRAM_EXCLUDE; 
       and_edge( PPI, PPI_SMALLJOG, false ); 
   } /* end of rule : G.4:PPi */
   rG_4_NPI @= { @ "G.4:NPi : Adjacent edges with length less than min. width is not allowed.";
       NPIA = NPI not_inside SRAM_EXCLUDE; 
       X = length_edge( NPIA, < NP_W_1 ); 
       NPI_SHORTEXP = edge_size( X, inside = 0.01, outside = 0.01 ); 
       sLAYER_8 = vertices( NPI_SHORTEXP, > 4 ); 
       NPI_SMALLJOG = sLAYER_8 not_inside SRAM_EXCLUDE; 
       and_edge( NPI, NPI_SMALLJOG, false ); 
   } /* end of rule : G.4:NPi */
   rG_4_M1I @= { @ "G.4:M1i : Adjacent edges with length less than min. width is not allowed.";
       M1IA = M1I not_inside SRAM_EXCLUDE; 
       X = length_edge( M1IA, < M1_W_1 ); 
       M1I_SHORTEXP = edge_size( X, inside = 0.01, outside = 0.01 ); 
       sLAYER_9 = vertices( M1I_SHORTEXP, > 4 ); 
       M1I_SMALLJOG = sLAYER_9 not_inside SRAM_EXCLUDE; 
       and_edge( M1I, M1I_SMALLJOG, false ); 
   } /* end of rule : G.4:M1i */
   rG_4_M2I @= { @ "G.4:M2i : Adjacent edges with length less than min. width is not allowed.";
       X = length_edge( M2I, < M2_W_1 ); 
       M2I_SHORTEXP = edge_size( X, inside = 0.01, outside = 0.01 ); 
       M2I_SMALLJOG = vertices( M2I_SHORTEXP, > 4 ); 
       and_edge( M2I, M2I_SMALLJOG, false ); 
   } /* end of rule : G.4:M2i */
   rG_4_M3I @= { @ "G.4:M3i : Adjacent edges with length less than min. width is not allowed.";
       X = length_edge( M3I, < M3_W_1 ); 
       M3I_SHORTEXP = edge_size( X, inside = 0.01, outside = 0.01 ); 
       M3I_SMALLJOG = vertices( M3I_SHORTEXP, > 4 ); 
       and_edge( M3I, M3I_SMALLJOG, false ); 
   } /* end of rule : G.4:M3i */
   rG_4_M4I @= { @ "G.4:M4i : Adjacent edges with length less than min. width is not allowed.";
       X = length_edge( M4I, < M4_W_1 ); 
       M4I_SHORTEXP = edge_size( X, inside = 0.01, outside = 0.01 ); 
       M4I_SMALLJOG = vertices( M4I_SHORTEXP, > 4 ); 
       and_edge( M4I, M4I_SMALLJOG, false ); 
   } /* end of rule : G.4:M4i */
   rG_4_M5I @= { @ "G.4:M5i : Adjacent edges with length less than min. width is not allowed.";
       X = length_edge( M5I, < M5_W_1 ); 
       M5I_SHORTEXP = edge_size( X, inside = 0.01, outside = 0.01 ); 
       M5I_SMALLJOG = vertices( M5I_SHORTEXP, > 4 ); 
       and_edge( M5I, M5I_SMALLJOG, false ); 
   } /* end of rule : G.4:M5i */
   rG_4_M6I @= { @ "G.4:M6i : Adjacent edges with length less than min. width is not allowed.";
       X = length_edge( M6I, < M6_W_1 ); 
       M6I_SHORTEXP = edge_size( X, inside = 0.01, outside = 0.01 ); 
       M6I_SMALLJOG = vertices( M6I_SHORTEXP, > 4 ); 
       and_edge( M6I, M6I_SMALLJOG, false ); 
   } /* end of rule : G.4:M6i */
   rG_4_M7I @= { @ "G.4:M7i : Adjacent edges with length less than min. width is not allowed.";
       X = length_edge( M7I, < M7_W_1 ); 
       M7I_SHORTEXP = edge_size( X, inside = 0.01, outside = 0.01 ); 
       M7I_SMALLJOG = vertices( M7I_SHORTEXP, > 4 ); 
       and_edge( M7I, M7I_SMALLJOG, false ); 
   } /* end of rule : G.4:M7i */
   
   //G.4:CO is checked by CO.W.1
   //G.4:VIAx is checked by [VIA1.W.1 ~ VIA6.W.1]
   rG_5_NOTUSEM1 @= { @ "G.5:NOTUSEM1 : Do not use NOTUSEM1 which is reserved for tsmc internal mask making";
       copy( NOTUSEM1 ); 
   } /* end of rule : G.5:NOTUSEM1 */
   rG_5_NOTUSEM2 @= { @ "G.5:NOTUSEM2 : Do not use NOTUSEM2 which is reserved for tsmc internal mask making";
       copy( NOTUSEM2 ); 
   } /* end of rule : G.5:NOTUSEM2 */
   rG_5_NOTUSEM3 @= { @ "G.5:NOTUSEM3 : Do not use NOTUSEM3 which is reserved for tsmc internal mask making";
       copy( NOTUSEM3 ); 
   } /* end of rule : G.5:NOTUSEM3 */
   rG_5_NOTUSEM4 @= { @ "G.5:NOTUSEM4 : Do not use NOTUSEM4 which is reserved for tsmc internal mask making";
       copy( NOTUSEM4 ); 
   } /* end of rule : G.5:NOTUSEM4 */
   rG_5_NOTUSEM5 @= { @ "G.5:NOTUSEM5 : Do not use NOTUSEM5 which is reserved for tsmc internal mask making";
       copy( NOTUSEM5 ); 
   } /* end of rule : G.5:NOTUSEM5 */
   rG_5_NOTUSEM6 @= { @ "G.5:NOTUSEM6 : Do not use NOTUSEM6 which is reserved for tsmc internal mask making";
       copy( NOTUSEM6 ); 
   } /* end of rule : G.5:NOTUSEM6 */
   rG_5_NOTUSEM7 @= { @ "G.5:NOTUSEM7 : Do not use NOTUSEM7 which is reserved for tsmc internal mask making";
       copy( NOTUSEM7 ); 
   } /* end of rule : G.5:NOTUSEM7 */
   rG_5_NOTUSEM8 @= { @ "G.5:NOTUSEM8 : Do not use NOTUSEM8 which is reserved for tsmc internal mask making";
       copy( NOTUSEM8 ); 
   } /* end of rule : G.5:NOTUSEM8 */
   rG_5_NOTUSEM9 @= { @ "G.5:NOTUSEM9 : Do not use NOTUSEM9 which is reserved for tsmc internal mask making";
       copy( NOTUSEM9 ); 
   } /* end of rule : G.5:NOTUSEM9 */
   rG_5_NOTUSEOD @= { @ "G.5:NOTUSEOD : Do not use NOTUSEOD which is reserved for tsmc internal mask making";
       copy( NOTUSEOD ); 
   } /* end of rule : G.5:NOTUSEOD */
   rG_5_NOTUSEPO @= { @ "G.5:NOTUSEPO : Do not use NOTUSEPO which is reserved for tsmc internal mask making";
       copy( NOTUSEPO ); 
   } /* end of rule : G.5:NOTUSEPO */
   rUSER_GUIDE_M1 @= { @ "USER_GUIDE.M1 : Metal layers with forbidden datatypes.";
       copy( NOUSEM1 ); 
   } /* end of rule : USER_GUIDE.M1 */
   rUSER_GUIDE_M2 @= { @ "USER_GUIDE.M2 : Metal layers with forbidden datatypes.";
       copy( NOUSEM2 ); 
   } /* end of rule : USER_GUIDE.M2 */
   rUSER_GUIDE_M3 @= { @ "USER_GUIDE.M3 : Metal layers with forbidden datatypes.";
       copy( NOUSEM3 ); 
   } /* end of rule : USER_GUIDE.M3 */
   rUSER_GUIDE_M4 @= { @ "USER_GUIDE.M4 : Metal layers with forbidden datatypes.";
       copy( NOUSEM4 ); 
   } /* end of rule : USER_GUIDE.M4 */
   rUSER_GUIDE_M5 @= { @ "USER_GUIDE.M5 : Metal layers with forbidden datatypes.";
       copy( NOUSEM5 ); 
   } /* end of rule : USER_GUIDE.M5 */
   rUSER_GUIDE_M6 @= { @ "USER_GUIDE.M6 : Metal layers with forbidden datatypes.";
       copy( NOUSEM6 ); 
   } /* end of rule : USER_GUIDE.M6 */
   rUSER_GUIDE_M7 @= { @ "USER_GUIDE.M7 : Metal layers with forbidden datatypes.";
       copy( NOUSEM7 ); 
   } /* end of rule : USER_GUIDE.M7 */
   rUSER_GUIDE_M8 @= { @ "USER_GUIDE.M8 : Metal layers with forbidden datatypes.";
       copy( NOUSEM8 ); 
   } /* end of rule : USER_GUIDE.M8 */
   rUSER_GUIDE_M9 @= { @ "USER_GUIDE.M9 : Metal layers with forbidden datatypes.";
       copy( NOUSEM9 ); 
   } /* end of rule : USER_GUIDE.M9 */
   rUSER_GUIDE_VIA1 @= { @ "USER_GUIDE.VIA1 : Via layers with forbidden datatypes.";
       copy( NOUSEV1 ); 
   } /* end of rule : USER_GUIDE.VIA1 */
   rUSER_GUIDE_VIA2 @= { @ "USER_GUIDE.VIA2 : Via layers with forbidden datatypes.";
       copy( NOUSEV2 ); 
   } /* end of rule : USER_GUIDE.VIA2 */
   rUSER_GUIDE_VIA3 @= { @ "USER_GUIDE.VIA3 : Via layers with forbidden datatypes.";
       copy( NOUSEV3 ); 
   } /* end of rule : USER_GUIDE.VIA3 */
   rUSER_GUIDE_VIA4 @= { @ "USER_GUIDE.VIA4 : Via layers with forbidden datatypes.";
       copy( NOUSEV4 ); 
   } /* end of rule : USER_GUIDE.VIA4 */
   rUSER_GUIDE_VIA5 @= { @ "USER_GUIDE.VIA5 : Via layers with forbidden datatypes.";
       copy( NOUSEV5 ); 
   } /* end of rule : USER_GUIDE.VIA5 */
   rUSER_GUIDE_VIA6 @= { @ "USER_GUIDE.VIA6 : Via layers with forbidden datatypes.";
       copy( NOUSEV6 ); 
   } /* end of rule : USER_GUIDE.VIA6 */
   rUSER_GUIDE_VIA7 @= { @ "USER_GUIDE.VIA7 : Via layers with forbidden datatypes.";
       copy( NOUSEV7 ); 
   } /* end of rule : USER_GUIDE.VIA7 */
   rUSER_GUIDE_VIA8 @= { @ "USER_GUIDE.VIA8 : Via layers with forbidden datatypes.";
       copy( NOUSEV8 ); 
   } /* end of rule : USER_GUIDE.VIA8 */
   rUSER_GUIDE_2 @= { @ "USER_GUIDE.2 : Dummy metal,poly,od can't be used to connect";
       interacting( DUM1, COI ); 
       interacting( DUM1, VIA1I ); 
       interacting( DUM2, VIA1I ); 
       interacting( DUM2, VIA2I ); 
       interacting( DUM3, VIA2I ); 
       interacting( DUM3, VIA3I ); 
       interacting( DUM4, VIA3I ); 
       interacting( DUM4, VIA4I ); 
       interacting( DUM5, VIA4I ); 
       interacting( DUM5, VIA5I ); 
       interacting( DUM6, VIA5I ); 
       interacting( DUM6, VIA6I ); 
       interacting( DUM7, VIA6I ); 
       interacting( DUM7, VIA7I ); 
       interacting( DUM8, VIA7I ); 
       interacting( DUM8, VIA8I ); 
       interacting( DUM9, VIA8I ); 
       interacting( DPO, COI ); 
       interacting( DOD, COI ); 
   } /* end of rule : USER_GUIDE.2 */
   #ifdef DATATYPE_WARNING 
      rNW_DATATYPE_WARNING1 @= { @ "NW_DATATYPE:WARNING1 : Extreme user care needs to be taken when using any layer other than (3;0) that default MT form considers to create NW mask. The tapeout engineer must explicitly explain that those non-default layers must be considered equivalent to NW in the MT form to ensure complete fabrication. It is strongly recommended to use NW;drawing (3;0) layer to define NW regions.";
          copy( NWI_OTHERS ); 
      } /* end of rule : NW_DATATYPE:WARNING1 */
      rOD_DATATYPE_WARNING1 @= { @ "OD_DATATYPE:WARNING1 : Extreme user care needs to be taken when using any other layer to create OD mask such as pdiff (7;0), ndiff (8;0) or any layer other than (6;0), and (6;1) that default MT form considers. The tapeout engineer must explicitly explain that those non-default layers must be considered equivalent to OD in the MT form to ensure complete fabrication.  It is strongly recommended to use only OD;drawing (6;0) and OD;dummy (6;1) layers to defined OD and DOD regions.";
          copy( ODI_OTHERS ); 
      } /* end of rule : OD_DATATYPE:WARNING1 */
      rOD_DATATYPE_WARNING2 @= { @ "OD_DATATYPE:WARNING2 : SRAM OD (6;11-13) layer are only allowed in SRAM region.";
          sLAYER_10 = SRM or SRAMDMY; 
          ODI_SRAM not sLAYER_10; 
      } /* end of rule : OD_DATATYPE:WARNING2 */
      rOD_DATATYPE_WARNING3 @= { @ "OD_DATATYPE:WARNING3 : Layer (6;3) is for recognition purpose of RF devices, please take care if this layer is adopted for non-RF designs and not for masking purpose of diffusion regions together with OD (6;0).";
          ODI_RFDRAIN not RFDMY; 
          ODI_RFDRAIN and POI; 
          ODI_RFDRAIN not ODI; 
      } /* end of rule : OD_DATATYPE:WARNING3 */
      rPO_DATATYPE_WARNING1 @= { @ "PO_DATATYPE:WARNING1 : Extreme user care needs to be taken when using any layer other than (17;0), and (17,1) that default MT form considers to create PO mask. The tapeout engineer must explicitly explain that those non-default layers must be considered equivalent to PO in the MT form to ensure complete fabrication. It is strongly recommended to use PO;drawing (17;0) and PO;dummy (17;1) layer to define PO and DPO regions.";
          copy( POI_OTHERS ); 
      } /* end of rule : PO_DATATYPE:WARNING1 */
      rPO_DATATYPE_WARNING2 @= { @ "PO_DATATYPE:WARNING2 : SRAM PO (17;11-13) layer are only allowed in SRAM region.";
          sLAYER_11 = SRM or SRAMDMY; 
          POI_SRAM not sLAYER_11; 
      } /* end of rule : PO_DATATYPE:WARNING2 */
      rCO_DATATYPE_WARNING1 @= { @ "CO_DATATYPE:WARNING1 : Extreme user care needs to be taken when using any layer other than (30;0) that default MT form considers to create CO mask. The tapeout engineer must explicitly explain that those non-default layers must be considered equivalent to CO in the MT form to ensure complete fabrication. It is strongly recommended to use CO;drawing (30;0) to define CO regions.";
          copy( COI_OTHERS ); 
      } /* end of rule : CO_DATATYPE:WARNING1 */
      rCO_DATATYPE_WARNING2 @= { @ "CO_DATATYPE:WARNING2 : SRAM CO (30;11-13) layer are only allowed in SRAM region.";
          sLAYER_12 = SRM or SRAMDMY; 
          COI_SRAM not sLAYER_12; 
      } /* end of rule : CO_DATATYPE:WARNING2 */
   #endif /* end of #ifdef DATATYPE_WARNING  */ 
   #ifdef FRONT_END 
      
      //NW CHECKS
      //=========
      NW1V = NWEL not OD2; 
      NW2V = NWEL and OD2; 
      rNW_W_1 @= { @ "NW.W.1 : Width >= " + NW_W_1 + " um"; 
          sLAYER_13 = internal1( NWEL, < NW_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          A = sLAYER_13 not_inside SRAM_EXCLUDE; 
          A outside SRAM_EXCLUDE; 
          B = cutting( A, SRAM_EXCLUDE ); 
          sLAYER_14 = interacting( NWEL, B ); 
          C = sLAYER_14 not SRAM_EXCLUDE; 
          D = internal1( C, < NW_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          interacting( B, D ); 
      } /* end of rule : NW.W.1 */
      rNW_S_1 @= { @ "NW.S.1 : Space >= " + NW_S_1 + " um"; 
          sLAYER_15 = external1( NWEL, < NW_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_15 not_inside SRAM_EXCLUDE; 
      } /* end of rule : NW.S.1 */
      rNW_S_2 @= { @ "NW.S.2 : Space of two NW1V with different potentials >= " + NW_S_2 + " um"; 
          NW1V_NODAL = stamp( NW1V, NWI, CONNECT_DB, CONNECT_DB_NW_S_2, include_touch = NONE ); 
          sLAYER_16 = external1( NW1V_NODAL, < NW_S_2, connect_sequence = CONNECT_DB_NW_S_2, connectivity = DIFFERENT_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_16 not_inside SRAM_EXCLUDE; 
      } /* end of rule : NW.S.2 */
      rNW_S_3 @= { @ "NW.S.3 : NW1V space to NW2V with different potentials >= " + NW_S_3 + " um"; 
          NW1VC = stamp( NW1V, NWI, CONNECT_DB, CONNECT_DB_NW_S_3, include_touch = NONE ); 
          NW2VC = stamp( NW2V, NWI, CONNECT_DB_NW_S_3, CONNECT_DB_NW_S_3, include_touch = NONE ); 
          sLAYER_17 = external2( NW1VC, NW2VC, < NW_S_3, connect_sequence = CONNECT_DB_NW_S_3, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
          sLAYER_17 not_inside SRAM_EXCLUDE; 
      } /* end of rule : NW.S.3 */
      rNW_S_4 @= { @ "NW.S.4 : Space of two NW2V with different potentials >= NW2V " + NW_S_4 + " um"; 
          NW2V_NODAL = stamp( NW2V, NWI, CONNECT_DB, CONNECT_DB_NW_S_4, include_touch = NONE ); 
          sLAYER_18 = external1( NW2V_NODAL, < NW_S_4, connect_sequence = CONNECT_DB_NW_S_4, connectivity = DIFFERENT_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_18 not_inside SRAM_EXCLUDE; 
      } /* end of rule : NW.S.4 */
      #ifdef NW_SUGGESTED 
         rSUGGESTED_NW_S_3__NW_S_4 @= { @ "SUGGESTED.NW.S.3__NW.S.4 : A more conservative way to check NW.S.3, NW.S.4 with "
                                                                     "varied operating voltages determination of nwels.";
             sNW1V = NWEL outside OD2; 
             sNW2V = NWEL not_outside OD2; 
             NW1VC = stamp( sNW1V, NWI, CONNECT_DB, CONNECT_DB_SUGGESTED_NW_S_3__NW_S_4, include_touch = NONE ); 
             NW2VC = stamp( sNW2V, NWI, CONNECT_DB_SUGGESTED_NW_S_3__NW_S_4, CONNECT_DB_SUGGESTED_NW_S_3__NW_S_4, include_touch = NONE ); 
             external2( NW1VC, NW2VC, < NW_S_3, connect_sequence = CONNECT_DB_SUGGESTED_NW_S_3__NW_S_4, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
             NW2V_NODAL = stamp( sNW2V, NWI, CONNECT_DB_SUGGESTED_NW_S_3__NW_S_4, CONNECT_DB_SUGGESTED_NW_S_3__NW_S_4, include_touch = NONE ); 
             external1( NW2V_NODAL, < NW_S_4, connect_sequence = CONNECT_DB_SUGGESTED_NW_S_3__NW_S_4, connectivity = DIFFERENT_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
         } /* end of rule : SUGGESTED.NW.S.3__NW.S.4 */
      #endif /* end of #ifdef NW_SUGGESTED  */ 
      rNW_S_5 @= { @ "NW.S.5 : Space to PW STRAP >= " + NW_S_5 + " um"; 
          external2( NWI, PPOD, < NW_S_5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          cutting( PPOD, NWI ); 
      } /* end of rule : NW.S.5 */
      rNW_S_6 @= { @ "NW.S.6 : Space to N+active except dummy TCD region >= " + NW_S_6 + " um"; 
          A = not_interacting( NACT, RNWEL ); 
          sLAYER_19 = external2( NWI, A, < NW_S_6, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          sLAYER_19 not_inside TCDDMY; 
          sLAYER_20 = cutting( A, NWI ); 
          sLAYER_20 not_inside TCDDMY; 
      } /* end of rule : NW.S.6 */
      rNW_S_7 @= { @ "NW.S.7 : Space to (N+active interact OD2) >= " + NW_S_7 + " um"; 
          external2( NWI, NACT2, < NW_S_7, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : NW.S.7 */
      rNW_EN_1 @= { @ "NW.EN.1 : Enclosure of NW STRAP >= " + NW_EN_1 + " um"; 
          enclose( NPOD, NONWR, < NW_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : NW.EN.1 */
      rNW_EN_2 @= { @ "NW.EN.2 : Enclosure of P+active >= " + NW_EN_2 + " um"; 
          enclose( PPOD, NONWR, < NW_EN_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : NW.EN.2 */
      rNW_EN_3 @= { @ "NW.EN.3 : ENClosure of (P+active interact with OD2) >= " + NW_EN_3 + " um"; 
          enclose( PACT2, NWI, < NW_EN_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : NW.EN.3 */
      rNW_A_1 @= { @ "NW.A.1 : Area >= " + NW_A_1 + " um2"; 
          area( NWEL, < NW_A_1 ); 
      } /* end of rule : NW.A.1 */
      rNW_A_2 @= { @ "NW.A.2 : Enclosed Area >= " + NW_A_2 + " um2"; 
          A = donut_holes( NWEL, area = < NW_A_2PRE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          B = A not NWEL; 
          sLAYER_21 = area( B, < NW_A_2 ); 
          sLAYER_21 not_inside SRAM_EXCLUDE; 
      } /* end of rule : NW.A.2 */
      rNW_A_3 @= { @ "NW.A.3 : Area (one of edge length < " + NW_A_3_L + " um) >= " + NW_A_3 + " um2"; 
          X = length_edge( NWEL, < NW_A_3_L ); 
          Y = NWEL touching X; 
          area( Y, < NW_A_3 ); 
      } /* end of rule : NW.A.3 */
      rNW_A_4 @= { @ "NW.A.4 : Enclosed Area (one of the enclosed edge length < " + NW_A_4_L + " um) >= " + NW_A_4 + " um2"; 
          A = donut_holes( NWEL, area = < NW_A_4PRE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          X = length_edge( A, < NW_A_4_L ); 
          Y = A touching X; 
          B = Y not NWI; 
          sLAYER_22 = area( B, < NW_A_4 ); 
          sLAYER_22 not_inside SRAM_EXCLUDE; 
      } /* end of rule : NW.A.4 */
      rNW_R_3 @= { @ "NW.R.3 : NW ABUT NWDMY from outside is not allowed V";
          NWI coincident_outside_edge NWDMY; 
      } /* end of rule : NW.R.3 */
      
      //NWROD CHECKS
      //=============
      rNWROD_W_1 @= { @ "NWROD.W.1 : Width >= " + NWROD_W_1 + " (NWRSTI.W.1 is checked by NWROD.W.1)"; 
          internal1( RNWEL, < NWROD_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : NWROD.W.1 */
      rNWROD_S_1 @= { @ "NWROD.S.1 : Space to NWROD or to NW >= " + NWROD_S_1 + " " 
                                    "NWRSTI.S.1  Space to NWRSTI or to NW >= " + NWROD_S_1; 
          external1( RNWEL, < NWROD_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, relational = { POINT_TOUCH } ); 
          external2( RNWEL, NWEL, < NWROD_S_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : NWROD.S.1 */
      rNWROD_S_2 @= { @ "NWROD.S.2 : Min. space to RPO >= " + NWROD_S_2 + " um"; 
          external2( NWRES, RPO, < NWROD_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          sLAYER_23 = NWRES and RPO; 
          not_interacting( sLAYER_23, NWDMY ); 
          A = and_edge( RPO, NWRES, false ); 
          vertex( A, angles = { 270 }, shape = TRIANGLE, shape_size = RPO_W_1 ); 
      } /* end of rule : NWROD.S.2 */
      rNWROD_EN_1 @= { @ "NWROD.EN.1 : Min. enclose by OD >= " + NWROD_EN_1 + " um"; 
          enclose( NWRES, ODWR, < NWROD_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          cutting( NWRES, ODWR ); 
      } /* end of rule : NWROD.EN.1 */
      rNWROD_EN_2 @= { @ "NWROD.EN.2 : Min. enclose by CO >= " + NWROD_EN_2 + " um"; 
          X = RHWR and NWRES;            /* Terminal */ 
          enclose( COWR, X, < NWROD_EN_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          COWR not X; 
      } /* end of rule : NWROD.EN.2 */
      rNWROD_O_1 @= { @ "NWROD.O.1 : RPO overlap of NP. Use exact value " + NWROD_O_1 + " um on side touching NWDMY"; 
          internal2( NPWR, RPO, < NWROD_O_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = RELATED_COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          A = and_edge( RHWR, NWEL, false ); 
          B = edge_size( A, outside = NWROD_O_1 ); 
          sLAYER_25 = NPWR and RPO; 
          sLAYER_24 = sLAYER_25 and NWRES; 
          sLAYER_24 not B; 
          RHWR not NPWR; 
      } /* end of rule : NWROD.O.1 */
      rNWROD_O_2 @= { @ "NWROD.O.2 : {OD AND NWDMY} overlap of {NP, PP, VTH_N, VTH_P, VTL_N, or VTL_P} (all implant layers except NW) is not allowed";
          A = OD and NWDMY; 
          A and gNP; 
          A and PP; 
          A and VTHN; 
          A and VTHP; 
          A and VTLN; 
          A and VTLP; 
      } /* end of rule : NWROD.O.2 */
      rNWROD_R_4 @= { @ "NWROD.R.4 : Only one polygon of NW in NWROD is allowed in one OD";
          sLAYER_26 = NWRES and OD; 
          A = interacting( OD, sLAYER_26, > 1 ); 
          interacting( NWRES, A ); 
      } /* end of rule : NWROD.R.4 */
      rNWROD_R_5 @= { @ "NWROD.R.5 : Only two polygons of NP in NWROD is allowed in one OD";
          A = interacting( OD, NWRES ); 
          sLAYER_27 = interacting( gNP, NWRES ); 
          VALID = interacting( A, sLAYER_27, == 2 ); 
          sLAYER_28 = not_interacting( A, VALID ); 
          interacting( gNP, sLAYER_28 );
      } /* end of rule : NWROD.R.5 */
      rNWROD_R_6 @= { @ "NWROD.R.6 : Only two polygons of RPO hole(Salicide) in NWROD is allowed in same OD";
          A = interacting( OD, NWRES ); 
          sLAYER_29 = donut_holes( RPO, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          VALID = interacting( A, sLAYER_29, == 2 ); 
          sLAYER_30 = not_interacting( A, VALID ); 
          interacting( RPO, sLAYER_30 ); 
      } /* end of rule : NWROD.R.6 */
      rNWROD_R_7 @= { @ "NWROD.R.7 : OD space for NW with parallel length > 0 if NW space <= 5um";
          sLAYER_32 = external1( NWRES, <= 5, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_31 = sLAYER_32 not NWRES; 
          sLAYER_31 inside OD; 
      } /* end of rule : NWROD.R.7 */
      
      //NWRSTI CHECKS
      //=============
      
      // NWRSTI.W.1 is checked by NWROD.W.1
      // NWRSTI.S.1 is checked by NWROD.S.1
      rNWRSTI_EN_1 @= { @ "NWRSTI.EN.1 : NP enclosure of OD >= " + NWRSTI_EN_1 + " um"; 
          enclose( ODWR_STI, NPWR_STI, < NWRSTI_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          ODWR_STI not NPWR_STI; 
      } /* end of rule : NWRSTI.EN.1 */
      rNWRSTI_EN_2 @= { @ "NWRSTI.EN.2 : OD extension on NWRSTI >= " + NWRSTI_EN_2 + " um " 
                                        "NWRSTI.EN.3 Enclosure of CO >= " + NWRSTI_EN_2 + " um"; 
          X = ODWR_STI and NWRES_STI;    /* Terminal */ 
          enclose( COWR_STI, X, < NWRSTI_EN_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          COWR_STI not X; 
      } /* end of rule : NWRSTI.EN.2 */
      
      // NWRSTI.EN.3 is checked by NWRSTI.EN.2
      rNWRSTI_EX_1 @= { @ "NWRSTI.EX.1 : OD extension on NWRSTI >= " + NWRSTI_EX_1 + " um"; 
          enclose( NWRES_STI, ODWR_STI, < NWRSTI_EX_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          A = and_edge( ODWR_STI, NWRES_STI, false ); 
          vertex( A, angles = { 90 }, shape = TRIANGLE, shape_size = OD_W_1 ); 
          angle_edge( A, == 45 ); 
          sLAYER_33 = NWRES_STI not NWDMY; 
          sLAYER_33 not OD; 
      } /* end of rule : NWRSTI.EX.1 */
      rNWRSTI_O_1 @= { @ "NWRSTI.O.1 : {NP interact with NWDMY} overlap of {PP, VTH_P, or VTL_P} (all p-type implant layers) is not allowed";
          A = interacting( gNP, NWDMY ); 
          A and PP; 
          A and VTHP; 
          A and VTLP; 
      } /* end of rule : NWRSTI.O.1 */
      
      //NT_N RULES CHECK
      //================
      NTN_OD = NTN and OD; 
      NTN_PO = NTN and POLY; 
      NTN_GATE_W = and_edge( NTN_PO, NTN_OD, false ); 
      gLAYER_169 = OD_25 or OD_33; 
      NTN_2_3V_GATE_W = and_edge( NTN_GATE_W, gLAYER_169, false ); 
      NTN_18V_GATE_W = and_edge( NTN_GATE_W, OD_18, false ); 
      rNT_N_W_1 @= { @ "NT_N.W.1 : Width >= " + NT_N_W_1 + " um"; 
          internal1( NTN, < NT_N_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : NT_N.W.1 */
      #ifdef LP 
         NTN_GATE_W_LESS_E = length_edge( NTN_GATE_W, <= NT_N_W_2_2_E ); 
         NTN_GATE_W_LESS_EM = enclose_edge( NTN_GATE_W_LESS_E, NTN_OD, <= NT_N_W_2_2_M, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = NOT_CONTAINED, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
         #ifndef HALF_NODE 
            rNT_N_W_2_1 @= { @ "NT_N.W.2.1 : Channel length of 1.2V native device [LP process] >= " + NT_N_W_2_1 + " um"; 
                NTN_GATE_W_MORE_EM = NTN_GATE_W not_coincident_inside_edge NTN_GATE_W_LESS_EM; 
                internal2( NTN_GATE_W_MORE_EM, NTN_GATE_W, < NT_N_W_2_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = RELATED_COINCIDENT, width = 0.002 ); 
            } /* end of rule : NT_N.W.2.1 */
            rNT_N_W_2_2 @= { @ "NT_N.W.2.2 : Channel length of 1.2V native device [LP process with limited E<=1um & M<=0.5um]  >= " + NT_N_W_2_2 + " um"; 
                internal1( NTN_GATE_W_LESS_EM, < NT_N_W_2_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
            } /* end of rule : NT_N.W.2.2 */
         #endif /* end of #ifndef HALF_NODE  */ 
         #ifdef HALF_NODE 
            rNT_N_W_2_3 @= { @ "NT_N.W.2.3 : Channel length of core native device [Only for N55 LP] >= " + NT_N_W_2_3 + " um"; 
                NTN_CORE_GATE_W = or_edge( not_edge( NTN_GATE_W, OD2 ), coincident_inside_edge( NTN_GATE_W, OD2 ) ); 
                internal1( NTN_CORE_GATE_W, < NT_N_W_2_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
            } /* end of rule : NT_N.W.2.3 */
         #endif /* end of #ifdef HALF_NODE  */ 
      #else /* the reverse of #ifdef LP  */ 
         #ifdef LPG 
            NTN_G_GATE_W = and_edge( NTN_GATE_W, DCO, false ); 
            NTN_LP_GATE_W = or_edge( not_edge( NTN_GATE_W, DCO ), coincident_inside_edge( NTN_GATE_W, DCO ) ); 
            rNT_N_W_2 @= { @ "NT_N.W.2 : Channel length of 1.0V native device [G process]>= " + NT_N_W_2 + " um"; 
                internal1( NTN_G_GATE_W, < NT_N_W_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
            } /* end of rule : NT_N.W.2 */
            NTN_GATE_W_LESS_E = length_edge( NTN_LP_GATE_W, <= NT_N_W_2_2_E ); 
            NTN_GATE_W_LESS_EM = enclose_edge( NTN_GATE_W_LESS_E, NTN_OD, <= NT_N_W_2_2_M, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = NOT_CONTAINED, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
            rNT_N_W_2_1 @= { @ "NT_N.W.2.1 : Channel length of 1.2V native device [LP process] >= " + NT_N_W_2_1 + " um"; 
                NTN_GATE_W_MORE_EM = NTN_LP_GATE_W not_coincident_inside_edge NTN_GATE_W_LESS_EM; 
                internal2( NTN_GATE_W_MORE_EM, NTN_LP_GATE_W, < NT_N_W_2_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = RELATED_COINCIDENT, width = 0.002 ); 
            } /* end of rule : NT_N.W.2.1 */
            rNT_N_W_2_2 @= { @ "NT_N.W.2.2 : Channel length of 1.2V native device [LP process with limited E<=1um & M<=0.5um] >= " + NT_N_W_2_2 + " um"; 
                internal1( NTN_GATE_W_LESS_EM, < NT_N_W_2_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
            } /* end of rule : NT_N.W.2.2 */
         #else /* the reverse of #ifdef LPG  */ 
            rNT_N_W_2 @= { @ "NT_N.W.2 : Channel length of 1.0V native device >= " + NT_N_W_2 + " um"; 
                internal1( NTN_GATE_W, < NT_N_W_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
            } /* end of rule : NT_N.W.2 */
         #endif /* end of #ifdef LPG  */ 
      #endif /* end of #ifdef LP  */ 
      rNT_N_W_3 @= { @ "NT_N.W.3 : Channel length of 2.5V/3.3V native device >= " + NT_N_W_3 + " um"; 
          internal1( NTN_2_3V_GATE_W, < NT_N_W_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
      } /* end of rule : NT_N.W.3 */
      rNT_N_W_4 @= { @ "NT_N.W.4 : Channel length of 1.8V native device >= " + NT_N_W_4 + " um"; 
          internal1( NTN_18V_GATE_W, < NT_N_W_4, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
      } /* end of rule : NT_N.W.4 */
      rNT_N_W_5 @= { @ "NT_N.W.5 : Channel width >= " + NT_N_W_5 + " um"; 
          length_edge( NTN_GATE_W, < NT_N_W_5 ); 
      } /* end of rule : NT_N.W.5 */
      rNT_N_S_1 @= { @ "NT_N.S.1 : Space >= " + NT_N_S_1 + " um"; 
          external1( NTN, < NT_N_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : NT_N.S.1 */
      NTN_EXC_IND = NTN not INDDMY; 
      rNT_N_S_2 @= { @ "NT_N.S.2 : Space to [Active outside NT_N] >= " + NT_N_S_2 + " um"; 
          A = DACT not NTN; 
          external2( NTN_EXC_IND, A, < NT_N_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : NT_N.S.2 */
      rNT_N_S_3 @= { @ "NT_N.S.3 : Space to NW >= " + NT_N_S_3 + " um"; 
          external2( NTN, NWI, < NT_N_S_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : NT_N.S.3 */
      rNT_N_EN_1 @= { @ "NT_N.EN.1 : Enclosure range of N+OD >= " + NT_N_EN_1_L + " um <= " + NT_N_EN_1_H + " um"; 
          A = interacting( NTN_EXC_IND, NPOD ); 
          B = interacting( NPOD, NTN_EXC_IND ); 
          enclose( B, A, < NT_N_EN_1_L, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          cutting( B, A ); 
          sLAYER_34 = size( B, clip_acute = NONE, distance = NT_N_EN_1_H ); 
          A not sLAYER_34; 
      } /* end of rule : NT_N.EN.1 */
      rNT_N_EX_1 @= { @ "NT_N.EX.1 : PO extension on (OD inside NT_N) (PO endcap) >= " + NT_N_EX_1 + " um"; 
          enclose( NTN_OD, POLY, < NT_N_EX_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : NT_N.EX.1 */
      rNT_N_A_1 @= { @ "NT_N.A.1 : Area >= " + NT_N_A_1 + " um2"; 
          sLAYER_35 = area( NTNS, < NT_N_A_1 ); 
          sLAYER_35 not_inside SRAM_EXCLUDE; 
      } /* end of rule : NT_N.A.1 */
      rNT_N_A_2 @= { @ "NT_N.A.2 : Enclosed area >= " + NT_N_A_2 + " um2"; 
          A = donut_holes( NTN, area = < NT_N_A_2PRE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          B = A not NTN; 
          area( B, < NT_N_A_2 ); 
      } /* end of rule : NT_N.A.2 */
      rNT_N_A_3 @= { @ "NT_N.A.3 : Area [one of edge length < " + NT_N_A_3_L + " um] >= " + NT_N_A_3 + " um2"; 
          X = length_edge( NTNS, < NT_N_A_3_L ); 
          Y = NTNS touching X; 
          area( Y, < NT_N_A_3 ); 
      } /* end of rule : NT_N.A.3 */
      rNT_N_A_4 @= { @ "NT_N.A.4 : Enclosed Area [one of the enclosed edge length < " + NT_N_A_4_L + " um] >= " + NT_N_A_4 + " um2"; 
          A = donut_holes( NTNS, area = < NT_N_A_4PRE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          X = length_edge( A, < NT_N_A_4_L ); 
          Y = A touching X; 
          B = Y not NT_NI; 
          sLAYER_36 = area( B, < NT_N_A_4 ); 
          sLAYER_36 not_inside SRAM_EXCLUDE; 
      } /* end of rule : NT_N.A.4 */
      rNT_N_R_1 @= { @ "NT_N.R.1 : Overlap of (NW or DNW) is not allowed";
          NTN and DNW; 
          NTN and NWEL; 
      } /* end of rule : NT_N.R.1 */
      rNT_N_R_2 @= { @ "NT_N.R.2 : P+Gate is not allowed in NT_N";
          NTN and GATE_PP; 
      } /* end of rule : NT_N.R.2 */
      rNT_N_R_3 @= { @ "NT_N.R.3 : Only one OD is allowed in NT_N "
                                  "Except NMOS capacitors with the same potential "
                                  "You have to draw a NCap_NTN layer to cover the NMOS capacitors. The NCap_NTN enclosure of OD have to be >= 0 um. "
                                  "DRC also flags NCap_NTN and OD, which is outside of the NCap_NTN in the same NT_N.";
          A = cutting( NTN_EXC_IND, OD, > 1 ); 
          not_interacting( A, NCAP_NTN ); 
          B = interacting( A, NCAP_NTN ); 
          C = interacting( OD, B ); 
          NCAP_NTN not OD;                /* OD of NMOS cap sould be exactly covered by NCap_NTN */ 
          C not NCAP_NTN;                 /* Mixture of NMOS cap and normal device is not allowed */ 
          NCAP_NTN not NTN;               /* NCap_NTN must be fully inside NTN  */ 
          interacting( A, NSDC, > 1, connect_sequence = CONNECT_DB, count_by = NET );    /* all source and all drain of all Nmos caps in the same NT_N must be connected together.  */ 
      } /* end of rule : NT_N.R.3 */
      
      //DNW CHECKS
      //==========
      rDNW_W_1 @= { @ "DNW.W.1 : Width >= " + DNW_W_1; 
          sLAYER_37 = internal1( DNW, < DNW_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          sLAYER_37 not_inside SRAM_EXCLUDE; 
      } /* end of rule : DNW.W.1 */
      rDNW_S_1 @= { @ "DNW.S.1 : Space >= " + DNW_S_1; 
          sLAYER_38 = external1( DNW, < DNW_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_38 not_inside SRAM_EXCLUDE; 
      } /* end of rule : DNW.S.1 */
      rDNW_S_2 @= { @ "DNW.S.2 : Space to NW with different potential >= " + DNW_S_2; 
          sLAYER_39 = external2( DNW, NWEL, < DNW_S_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = ALL, relational = { POINT_TOUCH }, width = 0.002 ); 
          sLAYER_39 not_inside SRAM_EXCLUDE; 
      } /* end of rule : DNW.S.2 */
      rDNW_S_3 @= { @ "DNW.S.3 : Space to {N+ACTIVE outside DNW} except dummy TCD region >= " + DNW_S_3; 
          A = NACT outside DNW; 
          sLAYER_40 = external2( DNW, A, < DNW_S_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          sLAYER_40 not_inside TCDDMY; 
      } /* end of rule : DNW.S.3 */
      RW = PWEL inside DNW; 
      PWELX = PWEL not_inside DNW; 
      RW1V = RW outside OD2; 
      RW2V = RW not_outside OD2; 
      RW1V_NODAL = stamp( RW1V, RWI, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
      RW2V_NODAL = stamp( RW2V, RWI, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
      PWEL_NODAL = stamp( PWELX, PWELI, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
      rDNW_S_4 @= { @ "DNW.S.4 : RW space to {RW OR PW} with different potential >= " + DNW_S_4 + " um"; 
          sLAYER_41 = external1( RW1V_NODAL, < DNW_S_4, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_41 not_inside SRAM_EXCLUDE; 
          sLAYER_42 = external2( RW1V_NODAL, PWEL_NODAL, < DNW_S_4, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          sLAYER_42 not_inside SRAM_EXCLUDE; 
      } /* end of rule : DNW.S.4 */
      rDNW_S_5 @= { @ "DNW.S.5 : {RW OR PW} space to {RW interact with OD2} with different potential >= " + DNW_S_5 + " um"; 
          sLAYER_43 = external1( RW2V_NODAL, < DNW_S_5, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_43 not_inside SRAM_EXCLUDE; 
          sLAYER_44 = external2( RW2V_NODAL, RW1V_NODAL, < DNW_S_5, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          sLAYER_44 not_inside SRAM_EXCLUDE; 
          sLAYER_45 = external2( RW2V_NODAL, PWEL_NODAL, < DNW_S_5, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          sLAYER_45 not_inside SRAM_EXCLUDE; 
      } /* end of rule : DNW.S.5 */
      rDNW_EN_3 @= { @ "DNW.EN.3 : Enclosure of N+ACTIVE >= " + DNW_EN_3; 
          sLAYER_46 = enclose( NACT, DNW, < DNW_EN_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          sLAYER_46 not_inside SRAM_EXCLUDE; 
      } /* end of rule : DNW.EN.3 */
      rDNW_O_1 @= { @ "DNW.O.1 : Overlap of NW >= " + DNW_O_1; 
          sLAYER_47 = internal2( DNW, NWEL, < DNW_O_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = RELATED_COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          sLAYER_47 not_inside SRAM_EXCLUDE; 
      } /* end of rule : DNW.O.1 */
      
      // DNW.R.3U is not necessary to check
      // DNW.R.4U is not necessary to check
      rDNW_R_5 @= { @ "DNW.R.5 : N+ACTIVE cut DNW is not allowed.";
          cutting( NACT, DNW ); 
      } /* end of rule : DNW.R.5 */
      
      //OD CHECKS
      //=========
      rOD_W_1 @= { @ "OD.W.1 : Width >= " + OD_W_1 + " um"; 
          internal1( OD, < OD_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : OD.W.1 */
      rOD_W_2 @= { @ "OD.W.2 : Width of MOS (<=1.2V)[for core device] >= " + OD_W_2 + " um"; 
          length_edge( GATE_W, < OD_W_2 ); 
      } /* end of rule : OD.W.2 */
      rOD_W_3 @= { @ "OD.W.3 : Width of MOS (>1.2V to <=3.3V)[for I/O device] >= " + OD_W_3 + " um"; 
          length_edge( HV_GATE_W, < OD_W_3 ); 
      } /* end of rule : OD.W.3 */
      OD_EDGE_45 = angle_edge( OD, == 45 ); 
      rOD_W_4 @= { @ "OD.W.4 : Width of 45 degree bent OD Please make sure the vertex of 45 degree pattern is on 5nm grid >= " + OD_W_4 + " um"; 
          internal1( OD_EDGE_45, < OD_W_4, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
      } /* end of rule : OD.W.4 */
      rOD_S_1 @= { @ "OD.S.1 : Spacing >= " + OD_S_1 + " um"; 
          external1( OD, < OD_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : OD.S.1 */
      HV_OD_E = and_edge( OD, OD2, false ); 
      rOD_S_2 @= { @ "OD.S.2 : Spacing (inside OD2) >= " + OD_S_2 + " um"; 
          external1( HV_OD_E, < OD_S_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT ); 
      } /* end of rule : OD.S.2 */
      gLAYER_170 = size( size( OD, - ( OD_S_3_W / 2 ), clip_acute = NONE ), OD_S_3_W / 2, clip_acute = NONE ); 
      WIDE_OD_0_p_15 = gLAYER_170 and OD; 
      rOD_S_3 @= { @ "OD.S.3 : Space of two ODs (width (W) > 0.15 um), if the parallel length (L) >= 0.2 um >= " + OD_S_3 + " um"; 
          OD_SPACE_BOTH = external1( WIDE_OD_0_p_15, < OD_S_3, extension = NONE, intersecting = {  }, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          contains( OD_SPACE_BOTH, { OD_S_1, OD_S_3_L }, FORTY_FIVE ); 
      } /* end of rule : OD.S.3 */
      rOD_S_3_1 @= { @ "OD.S.3.1 : Space to OD (width (W) > 0.15 um), if the parallel length (L) >= 0.2 um >= " + OD_S_3_1 + " um"; 
          OD_SPACE_ONE = external2( WIDE_OD_0_p_15, OD, < OD_S_3_1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          contains( OD_SPACE_ONE, { OD_S_1, OD_S_3_L }, FORTY_FIVE ); 
      } /* end of rule : OD.S.3.1 */
      rOD_S_4 @= { @ "OD.S.4 : Space to 45 degree bent OD >= " + OD_S_4 + " um"; 
          X = edge_size( OD_EDGE_45, outside = OD_S_4 ); 
          X and OD; 
      } /* end of rule : OD.S.4 */
      rOD_S_5 @= { @ "OD.S.5 : Space between two segments of U-shape or O-shape (notch only) >= " + OD_S_5 + " um"; 
          adjacent_edge( OD, angle1 = == 270, angle2 = == 270, length = < OD_S_5 ); 
      } /* end of rule : OD.S.5 */
      rOD_A_1 @= { @ "OD.A.1 : Area >= " + OD_A_1 + " um2"; 
          sLAYER_48 = area( ODS, < OD_A_1 ); 
          sLAYER_48 not_inside SRAM_EXCLUDE; 
      } /* end of rule : OD.A.1 */
      rOD_A_2 @= { @ "OD.A.2 : Enclosed area >= " + OD_A_2 + " um2"; 
          A = donut_holes( OD, area = < OD_A_2PRE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          B = A not OD; 
          area( B, < OD_A_2 ); 
      } /* end of rule : OD.A.2 */
      rOD_L_1 @= { @ "OD.L.1 : Maximum length of {ACTIVE (source) [width < " + OD_L_1_W + " um] interacts with butted_STRAP} <= " + OD_L_1 + " um"; 
          BUTTED_EDGE = length_edge( NP_PP_BTE, < OD_L_1_W ); 
          CHECK_SD = SD touching BUTTED_EDGE; 
          sLAYER_49 = CHECK_SD coincident_inside_edge OD; 
          NARROW_SD = internal1( sLAYER_49, < OD_L_1_W, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_50 = NARROW_SD touching BUTTED_EDGE; 
          sLAYER_51 = NARROW_SD touching GATE_W; 
          CHECK_OD = sLAYER_50 or sLAYER_51; 
          sLAYER_52 = OD coincident_inside_edge CHECK_OD; 
          length_edge( sLAYER_52, > OD_L_1, CONNECT ); 
      } /* end of rule : OD.L.1 */
      rOD_L_2 @= { @ "OD.L.2 : Maximum OD length [OD width is < " + OD_L_2_W + " um] between two contacts as well as between one contact and the OD line end <= " + OD_L_2 + " um"; 
          LONGP = area( INOD, > ( OD_W_1 * OD_L_2 ) ); 
          X = interacting( LONGP, COOD ); 
          CHECK_COOD = interacting( COOD, X ); 
          A = size_inside_wrapper( CHECK_COOD, X, distance = OD_L_2 / 2, increment = OD_S_1 * 0.7 ); 
          LINEN = interacting( X, A, == 1 ); 
          P2P = interacting( X, A, > 1 ); 
          B = interacting( A, LINEN ); 
          C = size_inside_wrapper( B, LINEN, distance = OD_L_2 / 2, increment = OD_S_1 * 0.7 ); 
          sLAYER_53 = LINEN not C; 
          sLAYER_54 = P2P not A; 
          BAD = sLAYER_53 or sLAYER_54; 
          BAD_EDGE = BAD coincident_inside_edge OD; 
          ERR = internal1( BAD_EDGE, < OD_L_2_W, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
          interacting( X, ERR ); 
      } /* end of rule : OD.L.2 */
      rOD_R_1 @= { @ "OD.R.1 : OD must be fully covered by {NP OR PP} except for {DOD OR NWDMY}";
          sLAYER_56 = not_interacting( OD, NWRES ); 
          sLAYER_55 = sLAYER_56 not LOGO; 
          sLAYER_55 not IMP; 
      } /* end of rule : OD.R.1 */
      
      //DUMMY OD RULE
      //================
      rDOD_W_1 @= { @ "DOD.W.1 : Width >= " + DOD_W_1 + " um"; 
          internal1( DOD, < DOD_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : DOD.W.1 */
      rDOD_S_1 @= { @ "DOD.S.1 : Space of DOD >= " + DOD_S_1; 
          external1( DOD, < DOD_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : DOD.S.1 */
      rDOD_S_2 @= { @ "DOD.S.2 : Space to OD >= " + DOD_S_2 + " um (Overlap is not allowed)"; 
          external2( ODI, DOD, < DOD_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { OVERLAP, POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : DOD.S.2 */
      rDOD_S_3 @= { @ "DOD.S.3 : Space to PO >= " + DOD_S_3 + " um (Overlap is not allowed)"; 
          external2( POI, DOD, < DOD_S_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { OVERLAP, POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : DOD.S.3 */
      rDOD_S_5 @= { @ "DOD.S.5 : Space to NW >= " + DOD_S_5 + " um"; 
          external2( NWI, DOD, < DOD_S_5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : DOD.S.5 */
      rDOD_S_6 @= { @ "DOD.S.6 : Space to FW (Overlap is not allowed) >= " + DOD_S_6 + " um"; 
          external2( FWI, DOD, < DOD_S_6, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          FWI and DOD; 
      } /* end of rule : DOD.S.6 */
      
      // DOD.S.7.0 is checked by DOD.S.7 and DOD.S.7.1
      
      // for solid L-mark (old)
      rDOD_S_7 @= { @ "DOD.S.7 : Space to LMARK (Overlap is not allowed) >= " + DOD_S_7 + " um"; 
          external2( LMARK_SOLID, DOD, < DOD_S_7, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          LMARK_SOLID and DOD; 
      } /* end of rule : DOD.S.7 */
      
      // for hollow L-mark (new)
      rDOD_S_7_1 @= { @ "DOD.S.7.1 : Space to L-slot (Overlap is not allowed) >= " + DOD_S_7_1 + " um"; 
          external2( LSLOT, DOD, < DOD_S_7_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          LSLOT and DOD; 
      } /* end of rule : DOD.S.7.1 */
      rDOD_S_8 @= { @ "DOD.S.8 : Space to NWDMY (Overlap is not allowed) >= " + DOD_S_8 + " um"; 
          external2( NWDMY, DOD, < DOD_S_8, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          NWDMY and DOD; 
      } /* end of rule : DOD.S.8 */
      rDOD_S_9 @= { @ "DOD.S.9 : Space to LOGO (Overlap is not allowed) >= 0 um";
          LOGO and DOD; 
      } /* end of rule : DOD.S.9 */
      rDOD_S_10 @= { @ "DOD.S.10 : Space to INDDMY (Overlap is not allowed) >= " + DOD_S_10 + " um"; 
          external2( INDDMY, DOD, < DOD_S_10, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          INDDMY and DOD; 
      } /* end of rule : DOD.S.10 */
      rDOD_EN_1 @= { @ "DOD.EN.1 : Enclosure by NW >= " + DOD_EN_1 + " um (DOD CUT NW is not allowed)"; 
          enclose( DOD, NWI, < DOD_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          cutting( DOD, NWI ); 
      } /* end of rule : DOD.EN.1 */
      #ifdef FULL_CHIP 
         rDOD_EN_2 @= { @ "DOD.EN.2 : Enclosure by chip edge >= " + DOD_EN_2 + " um"; 
             sLAYER_57 = size( CHIP_CHAMFERED, clip_acute = NONE, distance = - DOD_EN_2 ); 
             DOD not sLAYER_57; 
         } /* end of rule : DOD.EN.2 */
         rOD_DN_1 @= { @ "OD.DN.1 : Min {OD OR DOD} density across full chip >= 25%";
             VAR_1 = density_statistics_file( file = "OD.DN.1L.density" ); 
         _den_con = < OD_DN_1L; 
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => ALL_OD, "layer2" => gCHIP }, statistics_files = { VAR_1 }, window_function = den_save_window_1 ); 
         } /* end of rule : OD.DN.1 */
         rOD_DN_1_1 @= { @ "OD.DN.1.1 : {OD OR DOD} density across full chip <= 75%";
             VAR_2 = density_statistics_file( file = "OD.DN.1H.density" ); 
         _den_con = > OD_DN_1H; 
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => ALL_OD, "layer2" => gCHIP }, statistics_files = { VAR_2 }, window_function = den_save_window_1 ); 
         } /* end of rule : OD.DN.1.1 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      OD_EXC = NWDMY or DEN_EXC; 
      ODX = ALL_OD not OD_EXC; 
      CHIP_NOT_ODEXC = gCHIP not OD_EXC; 
      #ifdef CHECK_LOW_DENSITY 
         rOD_DN_2 @= { @ "OD.DN.2 : Min. OD density over window 150 step 75 >= 20%";
         _den_con = < OD_DN_2L; 
         _den_polygon_area_clip = false;
         _den_print = false;
         _den_print_only = false;
             ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_ODEXC }, delta_window = { OD_DN_2L_W, OD_DN_2L_W }, delta_x = OD_DN_2L_S, delta_y = OD_DN_2L_S, boundary = BACKUP, window_function = den_save_window_1 ); 
             sLAYER_58 = ERR_WIN not OD_EXC; 
             F = wide( sLAYER_58, >= OD_DN_2L_E, forty_five = INTERNAL ); 
             VAR_3 = density_statistics_file( file = "OD.DN.2L.density" ); 
         _den_con = < OD_DN_2L; 
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => ODX, "layer3" => CHIP_NOT_ODEXC }, delta_window = { OD_DN_2L_W, OD_DN_2L_W }, delta_x = OD_DN_2L_S, delta_y = OD_DN_2L_S, boundary = BACKUP, statistics_files = { VAR_3 }, window_function = den_save_window_2 ); 
         } /* end of rule : OD.DN.2 */
      #endif /* end of #ifdef CHECK_LOW_DENSITY  */ 
      rOD_DN_2_2 @= { @ "OD.DN.2.2 : Max. OD density over window 150 step 75 <= 90%";
      _den_con = > OD_DN_2H; 
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_ODEXC }, delta_window = { OD_DN_2H_W, OD_DN_2H_W }, delta_x = OD_DN_2H_S, delta_y = OD_DN_2H_S, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_59 = ERR_WIN not OD_EXC; 
          F = wide( sLAYER_59, >= OD_DN_2H_E, forty_five = INTERNAL ); 
          VAR_4 = density_statistics_file( file = "OD.DN.2H_IO.density" ); 
      _den_con = > OD_DN_2H; 
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => ODX, "layer3" => CHIP_NOT_ODEXC }, delta_window = { OD_DN_2H_W, OD_DN_2H_W }, delta_x = OD_DN_2H_S, delta_y = OD_DN_2H_S, boundary = BACKUP, statistics_files = { VAR_4 }, window_function = den_save_window_3 ); 
      } /* end of rule : OD.DN.2.2 */
      ODX_MAX_CORE = ODX not OD2; 
      CHIP_MAX_CORE = CHIP_NOT_ODEXC not OD2; 
      rOD_DN_2_1 @= { @ "OD.DN.2.1 : Max. OD density over window 150 step 75 <= 80% in core";
      _den_con = > OD_DN_2H_CORE; 
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => ODX_MAX_CORE, "layer2" => CHIP_MAX_CORE }, delta_window = { OD_DN_2H_W, OD_DN_2H_W }, delta_x = OD_DN_2H_S, delta_y = OD_DN_2H_S, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_61 = ERR_WIN not OD2; 
          sLAYER_60 = sLAYER_61 not OD_EXC; 
          F = wide( sLAYER_60, >= OD_DN_2H_E, forty_five = INTERNAL ); 
          VAR_5 = density_statistics_file( file = "OD.DN.2H_CORE.density" ); 
      _den_con = > OD_DN_2H_CORE; 
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => ODX_MAX_CORE, "layer3" => CHIP_MAX_CORE }, delta_window = { OD_DN_2H_W, OD_DN_2H_W }, delta_x = OD_DN_2H_S, delta_y = OD_DN_2H_S, boundary = BACKUP, statistics_files = { VAR_5 }, window_function = den_save_window_3 ); 
      } /* end of rule : OD.DN.2.1 */
      rOD_DN_3 @= { @ "OD.DN.3 : Min. OD density over window 150 step 75 >= 20% (within ODBLK)";
      _den_con = < OD_DN_3L; 
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_ODEXC }, delta_window = { OD_DN_3L_W, OD_DN_3L_W }, delta_x = OD_DN_3L_S, delta_y = OD_DN_3L_S, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_63 = ERR_WIN and ODBLK; 
          sLAYER_62 = sLAYER_63 not OD_EXC; 
          F = wide( sLAYER_62, >= OD_DN_3L_E, forty_five = INTERNAL ); 
          VAR_6 = density_statistics_file( file = "OD.DN.3L.density" ); 
      _den_con = < OD_DN_3L; 
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => ODX, "layer3" => CHIP_NOT_ODEXC }, delta_window = { OD_DN_3L_W, OD_DN_3L_W }, delta_x = OD_DN_3L_S, delta_y = OD_DN_3L_S, boundary = BACKUP, statistics_files = { VAR_6 }, window_function = den_save_window_2 ); 
      } /* end of rule : OD.DN.3 */
      rOD_DN_3_2 @= { @ "OD.DN.3.2 : Max. OD density over window 150 step 75 <= 90% (within ODBLK)";
      _den_con = > OD_DN_3H; 
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => ODX, "layer2" => CHIP_NOT_ODEXC }, delta_window = { OD_DN_3H_W, OD_DN_3H_W }, delta_x = OD_DN_3H_S, delta_y = OD_DN_3H_S, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_65 = ERR_WIN and ODBLK; 
          sLAYER_64 = sLAYER_65 not OD_EXC; 
          F = wide( sLAYER_64, >= OD_DN_3H_E, forty_five = INTERNAL ); 
          VAR_7 = density_statistics_file( file = "OD.DN.3H_IO.density" ); 
      _den_con = > OD_DN_3H; 
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => ODX, "layer3" => CHIP_NOT_ODEXC }, delta_window = { OD_DN_3H_W, OD_DN_3H_W }, delta_x = OD_DN_3H_S, delta_y = OD_DN_3H_S, boundary = BACKUP, statistics_files = { VAR_7 }, window_function = den_save_window_3 ); 
      } /* end of rule : OD.DN.3.2 */
      rOD_DN_3_1 @= { @ "OD.DN.3.1 : Max. OD density over window 150 step 75 <= 80% in core (within ODBLK)";
      _den_con = > OD_DN_3H_CORE; 
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => ODX_MAX_CORE, "layer2" => CHIP_MAX_CORE }, delta_window = { OD_DN_3H_W, OD_DN_3H_W }, delta_x = OD_DN_3H_S, delta_y = OD_DN_3H_S, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_68 = ERR_WIN and ODBLK; 
          sLAYER_67 = sLAYER_68 not OD2; 
          sLAYER_66 = sLAYER_67 not OD_EXC; 
          F = wide( sLAYER_66, >= OD_DN_3H_E, forty_five = INTERNAL ); 
          VAR_8 = density_statistics_file( file = "OD.DN.3H_CORE.density" ); 
      _den_con = > OD_DN_3H_CORE; 
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => ODX_MAX_CORE, "layer3" => CHIP_MAX_CORE }, delta_window = { OD_DN_3H_W, OD_DN_3H_W }, delta_x = OD_DN_3H_S, delta_y = OD_DN_3H_S, boundary = BACKUP, statistics_files = { VAR_8 }, window_function = den_save_window_3 ); 
      } /* end of rule : OD.DN.3.1 */
      #ifdef FULL_CHIP 
         rDOD_R_1 @= { @ "DOD.R.1 : DOD is must. DOD must be an individual CAD layer (datatype 1 as default, like 6;1)";
             not_interacting( CHIPX, DOD ); 
         } /* end of rule : DOD.R.1 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      
      // DOD.R.2 is checked by related rules (CSR.R.1.LAYERS_NO_EXC)
      rDOD_R_3 @= { @ "DOD.R.3 : Only square (or rectangular) and solid shapes are allowed. A 45-degree shape is not allowed.";
          not_rectangles( DOD, orientation = ORTHOGONAL ); 
          donut_holes( DOD, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      } /* end of rule : DOD.R.3 */
      
      //THICK OXIDE CHECKS
      //==================
      rOD2_W_1 @= { @ "OD2.W.1 : Width >= " + OD2_W_1 + " um"; 
          internal1( OD_18, < OD2_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          internal1( OD_25, < OD2_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          internal1( OD_33, < OD2_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : OD2.W.1 */
      rOD2_W_2 @= { @ "OD2.W.2 : Width of (OD2 OR (NW OR NT_N)) >= " + OD2_W_1 + " um " 
                                "DRC filter out the errors only on NW.";
          Y = OD2I or NT_NI; 
          X = NWI or Y; 
          sLAYER_69 = internal1( X, < OD2_W_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          A = sLAYER_69 not_inside SRAM_EXCLUDE; 
          sLAYER_70 = A outside SRAM_EXCLUDE; 
          interacting( sLAYER_70, Y ); 
          B = cutting( A, SRAM_EXCLUDE ); 
          sLAYER_71 = interacting( X, B ); 
          C = sLAYER_71 not SRAM_EXCLUDE; 
          D = internal1( C, < OD2_W_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          sLAYER_72 = interacting( B, D ); 
          interacting( sLAYER_72, Y ); 
      } /* end of rule : OD2.W.2 */
      rOD2_S_1 @= { @ "OD2.S.1 : Space >= " + OD2_S_1 + " um"; 
          external1( OD2, < OD2_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : OD2.S.1 */
      rOD2_S_2 @= { @ "OD2.S.2 : Space to {ACTIVE OR GATE} >= " + OD2_S_2 + " um"; 
          DACTG = DACT or GATE; 
          external2( OD2, DACTG, < OD2_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : OD2.S.2 */
      rOD2_S_3 @= { @ "OD2.S.3 : Space to 1.0V or 1.2V gate in S/D direction >= " + OD2_S_3 + " um"; 
          A = and_edge( OD2, OD, false ); 
          external2( A, GATE_W, < OD2_S_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
          cutting( GATE, OD2 ); 
          B = and_edge( LV_GATE_W, VAR, false ); 
          external2( B, OD2, < OD2_S_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
      } /* end of rule : OD2.S.3 */
      rOD2_S_4 @= { @ "OD2.S.4 : Space to NW. Space = 0 is allowed. >= " + OD2_S_4 + " um"; 
          external2( OD_18, NWEL, < OD2_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
          external2( OD_25, NWEL, < OD2_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
          external2( OD_33, NWEL, < OD2_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : OD2.S.4 */
      rOD2_S_5 @= { @ "OD2.S.5 : Space of (NW NOT OD2) >= " + OD2_S_5 + " um"; 
          X = NWI not OD2I; 
          sLAYER_73 = external1( X, < OD2_S_5, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_73 not_inside SRAM_EXCLUDE; 
      } /* end of rule : OD2.S.5 */
      rOD2_S_6 @= { @ "OD2.S.6 : Space of (NW AND OD2) >= " + OD2_S_6 + " um"; 
          X = NWI and OD2I; 
          sLAYER_74 = external1( X, < OD2_S_6, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_74 not_inside SRAM_EXCLUDE; 
      } /* end of rule : OD2.S.6 */
      rOD2_S_7 @= { @ "OD2.S.7 : Space of (OD2 NOT (NW OR NT_N)) >= " + OD2_S_7 + " um"; 
          sLAYER_75 = NWI or NT_NI; 
          X = OD2I not sLAYER_75; 
          sLAYER_76 = external1( X, < OD2_S_7, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_76 not_inside SRAM_EXCLUDE; 
      } /* end of rule : OD2.S.7 */
      rOD2_EN_1 @= { @ "OD2.EN.1 : Enclosure of 1.8V or 2.5V or 3.3V Gate in S/D direction. >= " + OD2_EN_1 + " um"; 
          enclose( GATE_W, OD_18, < OD2_EN_1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.004 ); 
          enclose( GATE_W, OD_25, < OD2_EN_1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.004 ); 
          enclose( GATE_W, OD_33, < OD2_EN_1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.004 ); 
      } /* end of rule : OD2.EN.1 */
      rOD2_EX_1 @= { @ "OD2.EX.1 : NW extension on OD2. Extension = 0 is allowed. >= " + OD2_EX_1 + " um"; 
          enclose( OD_18, NWEL, < OD2_EX_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
          enclose( OD_25, NWEL, < OD2_EX_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
          enclose( OD_33, NWEL, < OD2_EX_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
      } /* end of rule : OD2.EX.1 */
      rOD2_EX_2 @= { @ "OD2.EX.2 : Extension on NW. Extension = 0 is allowed. >= " + OD2_EX_2 + " um"; 
          enclose( NWEL, OD_18, < OD2_EX_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
          enclose( NWEL, OD_25, < OD2_EX_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
          enclose( NWEL, OD_33, < OD2_EX_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
      } /* end of rule : OD2.EX.2 */
      rOD2_EX_3 @= { @ "OD2.EX.3 : Extension on {ACTIVE OR GATE} >= " + OD2_EX_3 + " um"; 
      
         // This only applies to active OD or gate
          DACTG = DACT or GATE; 
          CHECK_EDGE_18 = enclose_edge( DACTG, OD_18, < OD2_EX_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
          CHECK_EDGE_18 not_coincident_outside_edge DSTP; 
          CHECK_EDGE_25 = enclose_edge( DACTG, OD_25, < OD2_EX_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
          CHECK_EDGE_25 not_coincident_outside_edge DSTP; 
          CHECK_EDGE_33 = enclose_edge( DACTG, OD_33, < OD2_EX_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
          CHECK_EDGE_33 not_coincident_outside_edge DSTP; 
          OD_18 inside DACTG; 
          OD_25 inside DACTG; 
          OD_33 inside DACTG; 
      } /* end of rule : OD2.EX.3 */
      rOD2_O_1 @= { @ "OD2.O.1 : Overlap of NW. Overlap = 0 is allowed. >= " + OD2_O_1 + " um"; 
          X = OD_18 and NWEL; 
          internal1( X, < OD2_O_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 89.5, relational = { POINT_TOUCH } ); 
          Y = OD_25 and NWEL; 
          internal1( Y, < OD2_O_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 89.5, relational = { POINT_TOUCH } ); 
          Z = OD_33 and NWEL; 
          internal1( Z, < OD2_O_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 89.5, relational = { POINT_TOUCH } ); 
      } /* end of rule : OD2.O.1 */
      rOD2_R_1 @= { @ "OD2.R.1 : OD_33, OD_25, and OD_18 can not be used on the same die.";
          X = interacting( CHIPX, OD_25 ); 
          interacting( X, OD_18 ); 
          interacting( X, OD_33 ); 
          Y = interacting( CHIPX, OD_33 ); 
          interacting( Y, OD_18 ); 
      } /* end of rule : OD2.R.1 */
      
      // OD2.R.2U is not necessary to check
      _25_33V_GATE_W = and_edge( _25V_GATE_W, OD25_33, false ); 
      _25_18V_GATE_W = and_edge( _25V_GATE_W, OD25_18, false ); 
      rOD25_33_W_1 @= { @ "OD25_33.W.1 : Channel length of 2.5V NMOS overdriven to 3.3V (NMOS Gate AND OD25_33) expect gate without PO CO in RFDMY >= " + OD25_33_W_1 + " um"; 
          sLAYER_77 = and_edge( _25_33V_GATE_W, gNP, false ); 
          _25_33V_GATE_W_NP = sLAYER_77 not_coincident_inside_edge RF_DUMMY_GATE; 
          internal1( _25_33V_GATE_W_NP, < OD25_33_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
      } /* end of rule : OD25_33.W.1 */
      rOD25_33_W_2 @= { @ "OD25_33.W.2 : Channel length of 2.5V PMOS overdriven to 3.3V (PMOS Gate AND OD25_33) expect gate without PO CO in RFDMY>= " + OD25_33_W_2 + " um"; 
          sLAYER_78 = and_edge( _25_33V_GATE_W, PP, false ); 
          _25_33V_GATE_W_PP = sLAYER_78 not_coincident_inside_edge RF_DUMMY_GATE; 
          internal1( _25_33V_GATE_W_PP, < OD25_33_W_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
      } /* end of rule : OD25_33.W.2 */
      rOD25_33_R_1 @= { @ "OD25_33.R.1 : {GATE AND OD25_33} can't overlap OD_18,OD33,or OD25_18. {Gate AND OD25_33} must be covered by OD_25. OD25_33 can't cut GATE";
          _25_33V_GATE = GATE and OD25_33; 
          _25_33V_GATE and OD_18; 
          _25_33V_GATE and OD_33; 
          _25_33V_GATE and OD25_18; 
          _25_33V_GATE not OD_25; 
          cutting( GATE, OD25_33 ); 
      } /* end of rule : OD25_33.R.1 */
      rOD25_18_W_1 @= { @ "OD25_18.W.1 : Channel length of 2.5V MOS underdriven to 1.8V (Gate AND OD25_18) >= " + OD25_18_W_1 + " um"; 
          internal1( _25_18V_GATE_W, < OD25_18_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
      } /* end of rule : OD25_18.W.1 */
      rOD25_18_R_1 @= { @ "OD25_18.R.1 : {GATE AND OD25_18} can't overlap OD_18 or OD33 or OD25_33. {Gate AND OD25_18} must be covered by OD_25. OD25_18 can't cut GATE";
          _25_18V_GATE = GATE and OD25_18; 
          _25_18V_GATE and OD_18; 
          _25_18V_GATE and OD_33; 
          _25_18V_GATE and OD25_33; 
          _25_18V_GATE not OD_25; 
          cutting( GATE, OD25_18 ); 
      } /* end of rule : OD25_18.R.1 */
      
      //PO CHECKS
      //=========
      POLY_EDGE_45 = angle_edge( POLY, == 45 ); 
      rPO_W_1 @= { @ "PO.W.1 : Width >= " + PO_W_1 + " um"; 
          internal1( POLY, < PO_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : PO.W.1 */
      rPO_S_1 @= { @ "PO.S.1 : Space >= " + PO_S_1 + " um"; 
          external1( POLY, < PO_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : PO.S.1 */
      rPO_S_2 @= { @ "PO.S.2 : GATE space in the same OD >= " + PO_S_2 + " um."; 
          external1( GATE_W, < PO_S_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT ); 
      } /* end of rule : PO.S.2 */
      rPO_W_2 @= { @ "PO.W.2 : Channel length of 2.5V MOS >= " + PO_W_2 + " um"; 
          sLAYER_79 = OD25_18 or OD25_33; 
          _25V_GATE_W_NORMAL = or_edge( not_edge( _25V_GATE_W, sLAYER_79 ), coincident_inside_edge( _25V_GATE_W, sLAYER_79 ) ); 
          internal1( _25V_GATE_W_NORMAL, < PO_W_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
      } /* end of rule : PO.W.2 */
      rPO_W_3 @= { @ "PO.W.3 : Channel length of 3.3V MOS except gate without PO CO in RFDMY >= " + PO_W_3 + " um"; 
          _33V_GATE_W_CHECK = _33V_GATE_W not_coincident_inside_edge RF_DUMMY_GATE; 
          internal1( _33V_GATE_W_CHECK, < PO_W_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
      } /* end of rule : PO.W.3 */
      rPO_W_4 @= { @ "PO.W.4 : Channel length of 1.8V MOS >= " + PO_W_4 + " um"; 
          internal1( _18V_GATE_W, < PO_W_4, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
      } /* end of rule : PO.W.4 */
      rPO_W_5 @= { @ "PO.W.5 : Width of 45 degree FIELD poly (expect PO fuse element, POFUSE, 156;0)>= " + PO_W_5 + " um " 
                              "DRC will also flag the width < 0.08um in the POFUSE. Please make sure the vertex of 45 degree pattern is on 5nm grid";
          A = or_edge( not_edge( POLY_EDGE_45, POFUSE ), coincident_inside_edge( POLY_EDGE_45, POFUSE ) ); 
          internal1( A, < PO_W_5, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
          EFUSE = POI and POFUSE; 
          internal1( EFUSE, < PO_W_5_F, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : PO.W.5 */
      rPO_S_2_1 @= { @ "PO.S.2.1 : Gate space [either one channel length > " + PO_S_2_1_W + " um] >= " + PO_S_2_1 + " um"; 
          GATE_LL = length_edge( GATE_L, > PO_S_2_1_W ); 
          GATE_F = GATE touching GATE_LL; 
          GATE_WW = POLY coincident_inside_edge GATE_F; 
          external2( GATE_W, GATE_WW, < PO_S_2_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
      } /* end of rule : PO.S.2.1 */
      rPO_S_3 @= { @ "PO.S.3 : Min. two 1.8V,2.5V or 3.3V POLY space on OD w/o contact >= " + PO_S_3 + " um"; 
          external1( HV_GATE_W, < PO_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT ); 
      } /* end of rule : PO.S.3 */
      rPO_S_4 @= { @ "PO.S.4 : Field PO space to OD >= " + PO_S_4 + " um"; 
          external2( POLY, OD, < PO_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 89.5, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : PO.S.4 */
      rPO_S_4_1 @= { @ "PO.S.4.1 : Gate space when the area enclosed by (L-shape OD & PO < " + PO_S_4_1_A + " um2) >= " + PO_S_4_1 + " um"; 
          external1( GATE, < PO_S_4_1, corner_configuration = CORNER_TO_CORNER, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT ); 
      } /* end of rule : PO.S.4.1 */
      S_GATE_W1 = length_edge( GATE_W, < PO_S_5_W ); 
      gLAYER_1146 = extend_edge( S_GATE_W1, start = OD_S_1, end = OD_S_1 ); 
      EX_GATEW_EDGE = edge_size( gLAYER_1146, inside = GRID ); 
      EX_GATEW_EDGE_T = EX_GATEW_EDGE coincident_inside_edge POLY; 
      rPO_S_5 @= { @ "PO.S.5 : Space to L-shape OD when PO & OD are in same MOS [channel width < " + PO_S_5_W + " um] >= " + PO_S_5 + " um"; 
          external2( OD, EX_GATEW_EDGE_T, < PO_S_5, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
      } /* end of rule : PO.S.5 */
      SU_GATE = GATE touching S_GATE_W1;    /* Use the same setting of PO_S_5_W for PO_S_6_W */ 
      OD_GATE_EDGE = OD coincident_inside_edge SU_GATE; 
      gLAYER_1147 = extend_edge( OD_GATE_EDGE, start = PO_S_1, end = PO_S_1 ); 
      EX_ODGATE_EDGE = edge_size( gLAYER_1147, inside = GRID ); 
      gLAYER_171 = OD coincident_inside_edge EX_ODGATE_EDGE; 
      EX_ODGATE_EDGE_T = gLAYER_171 inside_touching_edge OD_GATE_EDGE; 
      rPO_S_6 @= { @ "PO.S.6 : L-shape PO space to OD when PO and OD are in same MOS [channel width < " + PO_S_6_W + " um] >= " + PO_S_6 + " um"; 
          external2( POLY, EX_ODGATE_EDGE_T, < PO_S_6, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
      } /* end of rule : PO.S.6 */
      rPO_S_7 @= { @ "PO.S.7 : Space if at least one PO width is > 0.13 um, and the PO parallel run length is > 0.18 um (individual projection) >= " + PO_S_7 + " um"; 
          sLAYER_80 = size( size( POLY, - ( PO_S_7_W / 2 ), clip_acute = BISECTOR ), PO_S_7_W / 2, clip_acute = BISECTOR ); 
          WIDE_POLY = sLAYER_80 and POLY; 
          X = external2( WIDE_POLY, POLY, < PO_S_7, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = contains( X, { PO_S_1 - GRID, PO_S_7_L + GRID }, FORTY_FIVE ); 
          WIDEEDGE = WIDE_POLY coincident_outside_edge Y; 
          A = length_edge( WIDEEDGE, > PO_S_7_L, CONNECT ); 
          B = edge_size( A, inside = 0.001, outside = 0.001 ); 
          C = polygon_extents( B ); 
          D = contains( C, { 0.001, PO_S_7_L + GRID } ); 
          E = and_edge( A, D, false ); 
          external2( E, POLY, < PO_S_7, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
      } /* end of rule : PO.S.7 */
      rPO_S_9 @= { @ "PO.S.9 : Space of {PO AND RPO} >= " + PO_S_9 + " um"; 
          A = and_edge( POLY, RPO, false ); 
          external1( A, < PO_S_9, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT ); 
      } /* end of rule : PO.S.9 */
      rPO_S_10 @= { @ "PO.S.10 : Space at PO line-end (W<Q1=0.090) in a dense-line-end configuration: If PO has parallel run length with opposite PO (measured with T1=0.035 extension) along 2 adjacent edges of PO [any one edge <Q1 distance from the corner of the two edges], then one of the space (S1 or S2) needs to be at least this value (except for small jog with edge length < 0.06 um(R)) >= " + PO_S_10 + " um"; 
          A = adjacent_edge( POLY, angle1 = == 90, angle2 = == 90, length = < PO_S_10_Q ); 
          B = external2_edge( A, POLY, < PO_S_10, extension = EDGE, extension_distance = PO_S_10_E, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1 ); 
          C = A inside_touching_edge B; 
          D = internal2_edge( C, POLY, < PO_S_10_Q, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 90, look_thru = RELATED_COINCIDENT, orientation = { }, output_layer = LAYER2 ); 
          I = length_edge( D, >= PO_W_1 ); 
          sLAYER_1299 = extend_edge( I, start = PO_S_10_E, end = PO_S_10_E ); 
          J = edge_size( sLAYER_1299, inside = 0.001 ); 
          K = edge_size( I, inside = 0.001 ); 
          L = J not K; 
          M = L touching A; 
          N = M or K; 
          O = N touching_edge I; 
          external2( O, POLY, < PO_S_10, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
      } /* end of rule : PO.S.10 */
      PO_EXC = POI not DEN_EXC; 
      rPO_S_15 @= { @ "PO.S.15 : Large PO to gate [channel length <=0.08 um] space. The large PO is defined as PO area >=630 um and interact with regions of density > 70% flagged by 30 um x 30 um (stepping 15 um) window density check. DPO will be excluded from density check >= " + PO_S_15 + " um"; 
          A = area( PO_EXC, >= PO_S_15_A ); 
          B = polygon_extents( A ); 
          C = size( B, clip_acute = NONE, distance = 15 ); 
      _den_con = > PO_S_15_DN; 
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          D = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = C, layer_hash = { "layer1" => PO_EXC }, delta_window = { 30, 30 }, delta_x = 15, delta_y = 15, boundary = BACKUP, window_function = den_save_window_4 );    /* PRINT PO.S.15.density */ 
          E = interacting( A, D ); 
          GATE_W_S80 = internal1_edge( GATE_W, <= PO_S_15_L, extension = RADIAL, intersecting = {  } ); 
          GATE_S80 = GATE touching GATE_W_S80; 
          external2( E, GATE_S80, < PO_S_15, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
      } /* end of rule : PO.S.15 */
      rPO_S_16 @= { @ "PO.S.16 : Space to 45 degree FIELD poly >= " + PO_S_16 + " um"; 
          X = edge_size( POLY_EDGE_45, outside = PO_S_16 ); 
          X and POLY; 
      } /* end of rule : PO.S.16 */
      rPO_EX_1 @= { @ "PO.EX.1 : Extension on OD (end-cap) >= " + PO_EX_1 + " um"; 
          sLAYER_81 = enclose( OD, POLY, < PO_EX_1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 89.5, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH }, width = 0.004 ); 
          sLAYER_81 not_inside LOGO; 
      } /* end of rule : PO.EX.1 */
      rPO_EX_2 @= { @ "PO.EX.2 : OD extension on PO >= " + PO_EX_2 + " um"; 
          sLAYER_82 = enclose( POLY, OD, < PO_EX_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 89.5, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          sLAYER_82 not_inside LOGO; 
      } /* end of rule : PO.EX.2 */
      rPO_EX_3 @= { @ "PO.EX.3 : Extension on OD (end-cap) when the PO space to L-shape OD (in the same MOS) is < 0.1 um, and the channel width (W) is >= 0.15 um. >= " + PO_EX_3 + " um"; 
          A = length_edge( GATE_W, >= PO_EX_3_W ); 
          sLAYER_1300 = extend_edge( A, start = PO_EX_3, end = PO_EX_3 ); 
          B = edge_size( sLAYER_1300, inside = GRID ); 
          sLAYER_1301 = extend_edge( A, start = PO_EX_3, end = PO_EX_3 ); 
          C = edge_size( sLAYER_1301, outside = GRID ); 
          D = B coincident_outside_edge C; 
          E = external2( D, OD, < PO_EX_3_S, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
          F = E coincident_outside_edge FPO1; 
          G = edge_size( F, outside = GRID ); 
          H = GATE_L outside_touching_edge G; 
          I = edge_size( H, outside = PO_EX_3 ); 
          J = interacting( I, E ); 
          sLAYER_83 = J not POLY; 
          sLAYER_83 not_inside LOGO; 
      } /* end of rule : PO.EX.3 */
      rPO_L_1 @= { @ "PO.L.1 : Maximum PO length between 2 contacts, as well as the length bewteen one contact and the end of PO gate, when the PO width  < " + PO_L_1_W + " um (except RTMOM region) <= " + PO_L_1 + " um"; 
          LONGP = area( ILP1, > ( PO_W_1 * PO_L_1 ) ); 
          X = interacting( LONGP, COPO ); 
          CHECK_COPO = interacting( COPO, X ); 
          A = size_inside_wrapper( CHECK_COPO, X, distance = PO_L_1 / 2, increment = PO_S_1 * 0.7 ); 
          P2P = interacting( X, A, > 1 ); 
          BAD = P2P not A; 
          BAD_EDGE = BAD coincident_inside_edge POLY; 
          ERR = internal1( BAD_EDGE, < PO_L_1_W, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
          sLAYER_84 = interacting( X, ERR ); 
          X1 = sLAYER_84 not GATE; 
          CHECK_COPO1 = interacting( CHECK_COPO, X1 ); 
          A1 = size_inside_wrapper( CHECK_COPO1, X1, distance = PO_L_1 / 2, increment = PO_S_1 * 0.7 ); 
          P2P1 = interacting( X1, A1, > 1 ); 
          sLAYER_85 = P2P1 not A1; 
          BAD1 = interacting( sLAYER_85, A1, > 1 ); 
          BAD_EDGE1 = BAD1 coincident_inside_edge POLY; 
          ERR1 = internal1( BAD_EDGE1, < PO_L_1_W, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
          interacting( X1, ERR1 ); 
          sLAYER_87 = length_edge( GATE_L, < PO_L_1_W ); 
          sLAYER_86 = GATE touching sLAYER_87; 
          NARROW_GATE = sLAYER_86 and X; 
          B = size_inside_wrapper( A, X, distance = PO_L_1 / 2, increment = PO_S_1 * 0.7 ); 
          sLAYER_88 = NARROW_GATE not B; 
          sLAYER_88 not_inside RTMOMDMY; 
      } /* end of rule : PO.L.1 */
      
      //PO.L.1gU is uncheckable.
      rPO_A_1 @= { @ "PO.A.1 : Area >= " + PO_A_1 + " um2"; 
          sLAYER_89 = area( POLYS, < PO_A_1 ); 
          sLAYER_89 not_inside SRAM_EXCLUDE; 
      } /* end of rule : PO.A.1 */
      rPO_A_1_1 @= { @ "PO.A.1.1 : Area {PO not interacting with gate} >= " + PO_A_1_1 + " um2"; 
          POLY_NOT_GATE = not_interacting( POLYS, GATE ); 
          sLAYER_90 = area( POLY_NOT_GATE, < PO_A_1_1 ); 
          sLAYER_90 not_inside SRAM_EXCLUDE; 
      } /* end of rule : PO.A.1.1 */
      rPO_A_2 @= { @ "PO.A.2 : Enclosed area >= " + PO_A_2 + " um2"; 
          A = donut_holes( POLY, area = < PO_A_2PRE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          B = A not POLY; 
          area( B, < PO_A_2 ); 
      } /* end of rule : PO.A.2 */
      #ifdef FULL_CHIP 
         rPO_DN_1 @= { @ "PO.DN.1 : Min. POLY density across full chip >= 14%";
             VAR_9 = density_statistics_file( file = "PO.DN.1L.density" ); 
         _den_con = < PO_DN_1_L; 
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => ALL_POLY, "layer2" => gCHIP }, statistics_files = { VAR_9 }, window_function = den_save_window_1 ); 
         } /* end of rule : PO.DN.1 */
         rPO_DN_1_1 @= { @ "PO.DN.1.1 : Max. poly density across full chip <= 40%";
             VAR_10 = density_statistics_file( file = "PO.DN.1H.density" ); 
         _den_con = > PO_DN_1_H; 
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => ALL_POLY, "layer2" => gCHIP }, statistics_files = { VAR_10 }, window_function = den_save_window_1 ); 
         } /* end of rule : PO.DN.1.1 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      ALL_POD = ALL_OD or ALL_POLY; 
      gLAYER_173 = ODBLK or POBLK; 
      gLAYER_172 = gLAYER_173 or NWDMY; 
      PODEXC = gLAYER_172 or DEN_EXC; 
      PODX = ALL_POD not PODEXC; 
      CHIP_NOT_PODEXC = gCHIP not PODEXC; 
      #ifdef CHECK_LOW_DENSITY 
         rPO_DN_2 @= { @ "PO.DN.2 : {OD OR DOD OR PO OR DPO } local density (minimun) over window 20um x 20um stepping 10um >= 0.1%";
         _den_con = < PO_DN_2; 
         _den_polygon_area_clip = false;
         _den_print = false;
         _den_print_only = false;
             ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => ALL_POD, "layer2" => gCHIP }, delta_window = { PO_DN_2_W, PO_DN_2_W }, delta_x = PO_DN_2_S, delta_y = PO_DN_2_S, boundary = BACKUP, window_function = den_save_window_1 ); 
             sLAYER_91 = ERR_WIN not PODEXC; 
             F = wide( sLAYER_91, >= PO_DN_2_E, forty_five = INTERNAL ); 
             VAR_11 = density_statistics_file( file = "PO.DN.2.density" ); 
         _den_con = < PO_DN_2; 
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => ALL_POD, "layer3" => gCHIP }, delta_window = { PO_DN_2_W, PO_DN_2_W }, delta_x = PO_DN_2_S, delta_y = PO_DN_2_S, boundary = BACKUP, statistics_files = { VAR_11 }, window_function = den_save_window_2 ); 
         } /* end of rule : PO.DN.2 */
      #endif /* end of #ifdef CHECK_LOW_DENSITY  */ 
      POX = ALL_POLY not DEN_EXC; 
      CHIP_NOT_POEXC = gCHIP not DEN_EXC; 
      gLAYER_174 = TCDDMY or RFDMY; 
      CHECK_POBLK = POBLK not gLAYER_174; 
      CHIP_POBLK = CHIP_NOT_POEXC and CHECK_POBLK; 
      PO_POBLK = POX and CHECK_POBLK; 
      rPO_DN_3 @= { @ "PO.DN.3 : PO density within POBLK expect {TCDDMY OR RFDMY}>= 14%";
          sLAYER_1302 = chip_extent();
          VAR_12 = density_statistics_file( file = "PO.DN.3.density" ); 
      _den_con = < PO_DN_3; 
      _den_polygon_area_clip = true;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          A = density( window_layer = sLAYER_1302, layer_hash = { "layer1" => PO_POBLK, "layer2" => CHIP_POBLK }, statistics_files = { VAR_12 }, window_function = den_save_window_1 ); 
          A and CHECK_POBLK; 
      } /* end of rule : PO.DN.3 */
      rPO_R_1 @= { @ "PO.R.1 : GATE must be a rectangle orthogonal to grid. (Both bent GATE and Gate to have jog are not allowed)";
          sLAYER_92 = not_rectangles( GATE, orientation = ORTHOGONAL ); 
          sLAYER_92 not_inside LOGO; 
      } /* end of rule : PO.R.1 */
      
      // PO.R.2U is not necessary to check
      rPO_R_4 @= { @ "PO.R.4 : PO intersecting OD must form two or more diffusions except RTMOM region (RTMOMDMY, CAD layer: 155;21)";
          GATEW = and_edge( GATE, OD, false ); 
          X = not_touching( GATE, GATEW, == 2 ); 
          A = vertex( GATEW, angles = { 90 }, shape = TRIANGLE, shape_size = GRID ); 
          sLAYER_95 = interacting( GATE, A ); 
          sLAYER_94 = X or sLAYER_95; 
          sLAYER_93 = sLAYER_94 not LOGO; 
          sLAYER_93 not RTMOMDMY; 
      } /* end of rule : PO.R.4 */
      rPO_R_6 @= { @ "PO.R.6 : H-gate forbidden with channel length (V) < 0.11 mm, PO center bar length (U) < 0.425 mm, all four H-legs length (X) > 0.065 mm, and all four H-legs width (Y) < 0.255 um.";
          A1 = adjacent_edge( POLY, angle1 = == 270, angle2 = == 270, length = > 0 ); 
          A = length_edge( A1, [ PO_S_1, PO_R_6_U ) ); 
          B = and_edge( A, OD, false ); 
          C = POLY touching_edge B; 
          D = internal1_edge( POLY, < PO_R_6_V, extension = NONE, intersecting = {  }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          E = POLY touching_edge D; 
          F = C coincident_edge E; 
          G = edge_size( F, inside = PO_R_6_V / 2 ); 
          H = internal1_edge( G, ( (PO_R_6_V / 2), PO_R_6_V ], extension = NONE, intersecting = {  }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_1303 = extend_edge( H, start = GRID, end = GRID ); 
          I = edge_size( sLAYER_1303, inside = GRID ); 
          J = internal1_edge( POLY, < PO_R_6_W, extension = NONE, intersecting = {  }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          K = length_edge( J, > PO_R_6_X ); 
          L = and_edge( POLY, OD, false ); 
          M = POLY touching_edge L; 
          O = K not_coincident_edge M; 
          sLAYER_1304 = extend_edge( O, start = GRID, end = GRID ); 
          P = edge_size( sLAYER_1304, inside = GRID ); 
          sLAYER_1305 = extend_edge( O, start = - ( 2 * GRID ), end = - ( 2 * GRID ) ); 
          Q = edge_size( sLAYER_1305, inside = GRID ); 
          R = P not Q; 
          S = I or R; 
          T = adjacent_edge( S, angle1 = == 270, angle2 = == 270, length = > 0 ); 
          U = edge_size( T, inside = PO_R_6_V / 2 ); 
          V = internal1( U, ( (PO_R_6_V / 2), PO_R_6_V ], extension = NONE, intersecting = {  }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          copy( V ); 
      } /* end of rule : PO.R.6 */
      GATEI = POI and ODI; 
      GATEU = stamp( GATEI, POU, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
      NSDU_G = interacting( NSDU, POU ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSDU_G }, NSDU }} ); 
      PSDU_G = interacting( PSDU, POU ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSDU_G }, PSDU }} ); 
      #ifdef FULL_CHIP 
         FLOAT_GATE = net_area_ratio( CONNECT_DB, > 0, { "layer1" => GATEU, "layer2" => PSTPU, "layer3" => NSTPU, "layer4" => PSDU_G, "layer5" => NSDU_G, "layer6" => CBU, "layer7" => CB2U, "layer8" => UBMNU, "layer9" => UBMDU, "layer10" => COU }, 10, 10, {  }, NAR_SAVE_NET_5, false ); 
         FLOAT_NSD = net_area_ratio( CONNECT_DB, > 0, { "layer1" => NSDU_G, "layer2" => PSDU_G, "layer3" => GATEU, "layer4" => PSTPU, "layer5" => NSTPU, "layer6" => CBU, "layer7" => CB2U, "layer8" => UBMNU, "layer9" => UBMDU }, 9, 9, {  }, NAR_SAVE_NET_6, false ); 
         FLOAT_PSD = net_area_ratio( CONNECT_DB, > 0, { "layer1" => PSDU_G, "layer2" => NSDU_G, "layer3" => GATEU, "layer4" => PSTPU, "layer5" => NSTPU, "layer6" => CBU, "layer7" => CB2U, "layer8" => UBMNU, "layer9" => UBMDU }, 9, 9, {  }, NAR_SAVE_NET_6, false ); 
         EFFECTIVE_NSD = NSDU_G not FLOAT_NSD; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ EFFECTIVE_NSD }, NSDU_G }} ); 
         EFFECTIVE_PSD = PSDU_G not FLOAT_PSD; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ EFFECTIVE_PSD }, PSDU_G }} ); 
         gLAYER_176 = FLOAT_NSD or GATE; 
         gLAYER_175 = interacting( gLAYER_176, EFFECTIVE_NSD, > 1, connect_sequence = CONNECT_DB, count_by = NET ); 
         FLOAT_NSD_A = FLOAT_NSD not gLAYER_175; 
         gLAYER_178 = FLOAT_PSD or GATE; 
         gLAYER_177 = interacting( gLAYER_178, EFFECTIVE_PSD, > 1, connect_sequence = CONNECT_DB, count_by = NET ); 
         FLOAT_PSD_A = FLOAT_PSD not gLAYER_177; 
         gLAYER_179 = FLOAT_NSD_A or FLOAT_PSD_A; 
         FLOAT_GATE_CHECK = not_interacting( FLOAT_GATE, gLAYER_179 ); 
         rPO_R_8 @= { @ "PO.R.8 : It is prohibited for Floating Gate if the effective source/drain is not connected together";
             interacting( FLOAT_GATE_CHECK, NSDU, > 1, connect_sequence = CONNECT_DB, count_by = NET ); 
             interacting( FLOAT_GATE_CHECK, PSDU, > 1, connect_sequence = CONNECT_DB, count_by = NET ); 
         } /* end of rule : PO.R.8 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      #ifdef GP 
         rPO_FU_R_8 @= { @ "PO.FU.R.8 : FUSELINK must exist and be inside POFUSE if POFUSE is exist.";
             FUSELINK not_inside POFUSE; 
             not_interacting( POFUSE, FUSELINK ); 
         } /* end of rule : PO.FU.R.8 */
      #else /* the reverse of #ifdef GP  */ 
         #ifdef HALF_NODE 
            #ifdef LP 
               rPO_FU_R_8 @= { @ "PO.FU.R.8 : FUSELINK must exist and be inside POFUSE if POFUSE is exist.";
                   FUSELINK not_inside POFUSE; 
                   not_interacting( POFUSE, FUSELINK ); 
               } /* end of rule : PO.FU.R.8 */
            #endif /* end of #ifdef LP  */ 
         #endif /* end of #ifdef HALF_NODE  */ 
      #endif /* end of #ifdef GP  */ 
      
      //DUMMY POLY RULE
      //================
      #ifdef HALF_NODE 
         #ifdef LP 
            
            //<DPO.W.1> is checked by DPO.W.1.A
            //<DPO.S.1> is checked by DPO.S.1.A
            //<DPO.S.2> is checked by DPO.S.2.A
            //<DPO.S.3> is checked by DPO.S.3.A
            WAIVE_HVD = HVD_N_NW or HVD_P; 
            rDPO_W_1_A @= { @ "DPO.W.1.A : Width >= " + DPO_W_1 + " um"; 
                A = internal1( DPO, < DPO_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
                A outside WAIVE_HVD; 
            } /* end of rule : DPO.W.1.A */
            rDPO_S_1_A @= { @ "DPO.S.1.A : Space >= " + DPO_S_1 + " um"; 
                A = external1( DPO, < DPO_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
                A outside WAIVE_HVD; 
            } /* end of rule : DPO.S.1.A */
            rDPO_S_2_A @= { @ "DPO.S.2.A : Space to OD (Overlap is not allowed) >= " + DPO_S_2 + " um"; 
                A = external2( ODI, DPO, < DPO_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { OVERLAP, POINT_TOUCH }, width = 0.002 ); 
                A outside WAIVE_HVD; 
                sLAYER_96 = ODI and DPO; 
                sLAYER_96 outside WAIVE_HVD; 
            } /* end of rule : DPO.S.2.A */
            rDPO_S_3_A @= { @ "DPO.S.3.A : Space to PO (Overlap is not allowed) >= " + DPO_S_3 + " um"; 
                A = external2( POI, DPO, < DPO_S_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { OVERLAP, POINT_TOUCH }, width = 0.002 ); 
                A outside WAIVE_HVD; 
                sLAYER_97 = POI and DPO; 
                sLAYER_97 outside WAIVE_HVD; 
            } /* end of rule : DPO.S.3.A */
         #endif /* end of #ifdef LP  */ 
      #endif /* end of #ifdef HALF_NODE  */ 
      rDPO_W_1 @= { @ "DPO.W.1 : Width >= " + DPO_W_1 + " um"; 
          internal1( DPO, < DPO_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : DPO.W.1 */
      rDPO_S_1 @= { @ "DPO.S.1 : Space >= " + DPO_S_1 + " um"; 
          external1( DPO, < DPO_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : DPO.S.1 */
      rDPO_S_2 @= { @ "DPO.S.2 : Space to OD (Overlap is not allowed) >= " + DPO_S_2 + " um"; 
          external2( ODI, DPO, < DPO_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { OVERLAP, POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : DPO.S.2 */
      rDPO_S_3 @= { @ "DPO.S.3 : Space to PO (Overlap is not allowed) >= " + DPO_S_3 + " um"; 
          external2( POI, DPO, < DPO_S_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { OVERLAP, POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : DPO.S.3 */
      rDPO_S_5 @= { @ "DPO.S.5 : Space to FW (Overlap is not allowed) >= " + DPO_S_5 + " um"; 
          external2( FWI, DPO, < DPO_S_5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          FWI and DPO; 
      } /* end of rule : DPO.S.5 */
      
      // DPO.S.6.0 is checked by DPO.S.6 and DPO.S.6.1
      
      // for solid L-mark (old)
      rDPO_S_6 @= { @ "DPO.S.6 : Space to LMARK (Overlap is not allowed) >= " + DPO_S_6 + " um"; 
          external2( LMARK_SOLID, DPO, < DPO_S_6, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          LMARK_SOLID and DPO; 
      } /* end of rule : DPO.S.6 */
      
      // for hollow L-mark (new)
      rDPO_S_6_1 @= { @ "DPO.S.6.1 : Space to L-slot (Overlap is not allowed) >= " + DPO_S_6_1 + " um"; 
          external2( LSLOT, DPO, < DPO_S_6_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          LSLOT and DPO; 
      } /* end of rule : DPO.S.6.1 */
      rDPO_S_8 @= { @ "DPO.S.8 : Space to LOGO (Overlap is not allowed) >= 0 um";
          LOGO and DPO; 
      } /* end of rule : DPO.S.8 */
      rDPO_S_9 @= { @ "DPO.S.9 : Space to INDDMY (Overlap is not allowed) >= " + DPO_S_9 + " um"; 
          external2( INDDMY, DPO, < DPO_S_9, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          INDDMY and DPO; 
      } /* end of rule : DPO.S.9 */
      #ifdef FULL_CHIP 
         rDPO_EN_1 @= { @ "DPO.EN.1 : Enclosure by chip edge >= " + DPO_EN_1 + " um"; 
             sLAYER_98 = size( CHIP_CHAMFERED, clip_acute = NONE, distance = - DPO_EN_1 ); 
             DPO not sLAYER_98; 
         } /* end of rule : DPO.EN.1 */
         rDPO_R_1 @= { @ "DPO.R.1 : DPO is must. DPO must be an individual CAD layer (datatype 1 as default, like 17;1)";
             not_interacting( CHIPX, DPO ); 
         } /* end of rule : DPO.R.1 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      
      // DPO.DN.2 is checked by PO.DN.2
      // DPO.R.2 is checked by related rules (CSR.R.1.LAYERS_NO_EXC)
      rDPO_R_3 @= { @ "DPO.R.3 : Only square (or rectangular) and solid shapes are allowed. A 45-degree shape is not allowed";
          not_rectangles( DPO, orientation = ORTHOGONAL ); 
          donut_holes( DPO, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      } /* end of rule : DPO.R.3 */
      NORMAL_TCD = rectangles( TCDDMY, orientation = ORTHOGONAL, sides = { == 12, == 12 } ); 
      SMALL_TCD = rectangles( TCDDMY, orientation = ORTHOGONAL, sides = { == 9.245, == 9.245 } ); 
      rDTCD_W_1 @= { @ "DTCD.W.1 : Width of TCDDMY  = 12 or 9.245";
          sLAYER_99 = TCDDMY not NORMAL_TCD; 
          sLAYER_99 not SMALL_TCD; 
      } /* end of rule : DTCD.W.1 */
      rDTCD_R_1 @= { @ "DTCD.R.1 : TCDDMY should contain OD/PO/PP/NP/POBLK/ODBLK layer";
          TCDDMY outside ODI; 
          TCDDMY outside POI; 
          NORMAL_TCD outside PPI; 
          TCDDMY outside NPI; 
          TCDDMY outside POBLK; 
          TCDDMY outside ODBLK; 
      } /* end of rule : DTCD.R.1 */
      rDTCD_R_2 @= { @ "DTCD.R.2 : OD/PO/PP/NP/POBLK/ODBLK layout in the TCDDMY must exactly same as them in tsmc's utility.";
          _6_0_N_REC_1 = shrink( NORMAL_TCD, north = ( 12 - 11.51 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 11.43 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _6_0_N_REC_2 = shrink( NORMAL_TCD, north = ( 12 - 11.32 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 11.24 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _6_0_N_REC_3 = shrink( NORMAL_TCD, north = ( 12 - 11.13 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 11.05 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _6_0_N_REC_4 = shrink( NORMAL_TCD, north = ( 12 - 10.94 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 10.86 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _6_0_N_REC_5 = shrink( NORMAL_TCD, north = ( 12 - 10.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 10.67 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _6_0_N_REC_6 = shrink( NORMAL_TCD, north = ( 12 - 10.56 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 10.48 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _6_0_N_REC_7 = shrink( NORMAL_TCD, north = ( 12 - 10.37 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 10.29 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _6_0_N_REC_8 = shrink( NORMAL_TCD, north = ( 12 - 10.18 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 10.1 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _6_0_N_REC_9 = shrink( NORMAL_TCD, north = ( 12 - 9.99 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 9.91 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _6_0_N_REC_10 = shrink( NORMAL_TCD, north = ( 12 - 9.8 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 9.72 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _6_0_N_REC_11 = shrink( NORMAL_TCD, north = ( 12 - 9.42 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 9.34 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _6_0_N_REC_12 = shrink( NORMAL_TCD, north = ( 12 - 9.23 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 9.15 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _6_0_N_REC_13 = shrink( NORMAL_TCD, north = ( 12 - 8.85 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 8.77 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _6_0_N_REC_14 = shrink( NORMAL_TCD, north = ( 12 - 8.66 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 8.58 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _6_0_N_REC_15 = shrink( NORMAL_TCD, north = ( 12 - 8.47 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 8.39 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _6_0_N_REC_16 = shrink( NORMAL_TCD, north = ( 12 - 8.28 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 8.2 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _6_0_N_REC_17 = shrink( NORMAL_TCD, north = ( 12 - 8.09 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 8.01 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _6_0_N_REC_18 = shrink( NORMAL_TCD, north = ( 12 - 7.9 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 7.82 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _6_0_N_REC_19 = shrink( NORMAL_TCD, north = ( 12 - 7.71 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 7.63 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _6_0_N_REC_20 = shrink( NORMAL_TCD, north = ( 12 - 7.52 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 7.44 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _6_0_N_REC_21 = shrink( NORMAL_TCD, north = ( 12 - 7.33 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 7.25 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _6_0_N_REC_22 = shrink( NORMAL_TCD, north = ( 12 - 7.14 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 7.06 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _6_0_N_REC_23 = shrink( NORMAL_TCD, north = ( 12 - 6.95 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 6.87 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _6_0_N_REC_24 = shrink( NORMAL_TCD, north = ( 12 - 6.76 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 6.68 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _6_0_N_REC_25 = shrink( NORMAL_TCD, north = ( 12 - 6.57 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 6.49 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _6_0_N_REC_26 = shrink( NORMAL_TCD, north = ( 12 - 5.5 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.255 ) ) and shrink( NORMAL_TCD, south = 0.5 ) and shrink( NORMAL_TCD, west = 6.255 ); 
          _6_0_N_REC_27 = shrink( NORMAL_TCD, north = ( 12 - 9.04 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.85 ) ) and shrink( NORMAL_TCD, south = 8.96 ) and shrink( NORMAL_TCD, west = 6.25 ); 
          _6_0_N_REC_28 = shrink( NORMAL_TCD, north = ( 12 - 11.23 ) ) and shrink( NORMAL_TCD, east = ( 12 - 5.995 ) ) and shrink( NORMAL_TCD, south = 10.01 ) and shrink( NORMAL_TCD, west = 5.555 ); 
          _6_0_N_REC_29 = shrink( NORMAL_TCD, north = ( 12 - 7.99 ) ) and shrink( NORMAL_TCD, east = ( 12 - 5.995 ) ) and shrink( NORMAL_TCD, south = 6.77 ) and shrink( NORMAL_TCD, west = 5.555 ); 
          _6_0_N_REC_30 = shrink( NORMAL_TCD, north = ( 12 - 11.23 ) ) and shrink( NORMAL_TCD, east = ( 12 - 5.215 ) ) and shrink( NORMAL_TCD, south = 10.01 ) and shrink( NORMAL_TCD, west = 4.775 ); 
          _6_0_N_REC_31 = shrink( NORMAL_TCD, north = ( 12 - 9.61 ) ) and shrink( NORMAL_TCD, east = ( 12 - 5.995 ) ) and shrink( NORMAL_TCD, south = 9.17 ) and shrink( NORMAL_TCD, west = 4.775 ); 
          _6_0_N_REC_32 = shrink( NORMAL_TCD, north = ( 12 - 8.83 ) ) and shrink( NORMAL_TCD, east = ( 12 - 5.995 ) ) and shrink( NORMAL_TCD, south = 8.39 ) and shrink( NORMAL_TCD, west = 4.775 ); 
          _6_0_N_REC_33 = shrink( NORMAL_TCD, north = ( 12 - 7.99 ) ) and shrink( NORMAL_TCD, east = ( 12 - 5.215 ) ) and shrink( NORMAL_TCD, south = 6.77 ) and shrink( NORMAL_TCD, west = 4.775 ); 
          _6_0_N_REC_34 = shrink( NORMAL_TCD, north = ( 12 - 11.23 ) ) and shrink( NORMAL_TCD, east = ( 12 - 4.375 ) ) and shrink( NORMAL_TCD, south = 10.01 ) and shrink( NORMAL_TCD, west = 3.935 ); 
          _6_0_N_REC_35 = shrink( NORMAL_TCD, north = ( 12 - 7.99 ) ) and shrink( NORMAL_TCD, east = ( 12 - 4.375 ) ) and shrink( NORMAL_TCD, south = 6.77 ) and shrink( NORMAL_TCD, west = 3.935 ); 
          _6_0_N_REC_36 = shrink( NORMAL_TCD, north = ( 12 - 11.23 ) ) and shrink( NORMAL_TCD, east = ( 12 - 3.595 ) ) and shrink( NORMAL_TCD, south = 10.01 ) and shrink( NORMAL_TCD, west = 3.155 ); 
          _6_0_N_REC_37 = shrink( NORMAL_TCD, north = ( 12 - 9.61 ) ) and shrink( NORMAL_TCD, east = ( 12 - 4.375 ) ) and shrink( NORMAL_TCD, south = 9.17 ) and shrink( NORMAL_TCD, west = 3.155 ); 
          _6_0_N_REC_38 = shrink( NORMAL_TCD, north = ( 12 - 8.83 ) ) and shrink( NORMAL_TCD, east = ( 12 - 4.375 ) ) and shrink( NORMAL_TCD, south = 8.39 ) and shrink( NORMAL_TCD, west = 3.155 ); 
          _6_0_N_REC_39 = shrink( NORMAL_TCD, north = ( 12 - 7.99 ) ) and shrink( NORMAL_TCD, east = ( 12 - 3.595 ) ) and shrink( NORMAL_TCD, south = 6.77 ) and shrink( NORMAL_TCD, west = 3.155 ); 
          _6_0_N_REC_40 = shrink( NORMAL_TCD, north = ( 12 - 7.3 ) ) and shrink( NORMAL_TCD, east = ( 12 - 2.8 ) ) and shrink( NORMAL_TCD, south = 6.3 ) and shrink( NORMAL_TCD, west = 1.8 ); 
          _6_0_N_REC_41 = shrink( NORMAL_TCD, north = ( 12 - 9.61 ) ) and shrink( NORMAL_TCD, east = ( 12 - 2.755 ) ) and shrink( NORMAL_TCD, south = 9.17 ) and shrink( NORMAL_TCD, west = 1.535 ); 
          _6_0_N_REC_42 = shrink( NORMAL_TCD, north = ( 12 - 8.83 ) ) and shrink( NORMAL_TCD, east = ( 12 - 2.755 ) ) and shrink( NORMAL_TCD, south = 8.39 ) and shrink( NORMAL_TCD, west = 1.535 ); 
          _6_0_N_REC_43 = shrink( NORMAL_TCD, north = ( 12 - 5.5 ) ) and shrink( NORMAL_TCD, east = ( 12 - 5.745 ) ) and shrink( NORMAL_TCD, south = 0.5 ) and shrink( NORMAL_TCD, west = 0.745 ); 
          _6_0_N_REC_44 = shrink( NORMAL_TCD, north = ( 12 - 8.8 ) ) and shrink( NORMAL_TCD, east = ( 12 - 1.3 ) ) and shrink( NORMAL_TCD, south = 7.8 ) and shrink( NORMAL_TCD, west = 0.3 ); 
          _6_0_N_REC_45 = shrink( NORMAL_TCD, north = ( 12 - 7.3 ) ) and shrink( NORMAL_TCD, east = ( 12 - 1.3 ) ) and shrink( NORMAL_TCD, south = 6.3 ) and shrink( NORMAL_TCD, west = 0.3 ); 
          _6_0_N_REC_46 = shrink( NORMAL_TCD, north = ( 12 - 9.61 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.55 ) ) and shrink( NORMAL_TCD, south = 9.53 ) and shrink( NORMAL_TCD, west = 6.55 ); 
          _17_0_N_REC_1 = shrink( NORMAL_TCD, north = ( 12 - 7.41 ) ) and shrink( NORMAL_TCD, east = ( 12 - 6.135 ) ) and shrink( NORMAL_TCD, south = 7.35 ) and shrink( NORMAL_TCD, west = 4.635 ); 
          _17_0_N_REC_2 = shrink( NORMAL_TCD, north = ( 12 - 8.13 ) ) and shrink( NORMAL_TCD, east = ( 12 - 5.415 ) ) and shrink( NORMAL_TCD, south = 6.63 ) and shrink( NORMAL_TCD, west = 5.355 ); 
          _17_0_N_REC_3 = shrink( NORMAL_TCD, north = ( 12 - 8.13 ) ) and shrink( NORMAL_TCD, east = ( 12 - 3.795 ) ) and shrink( NORMAL_TCD, south = 6.63 ) and shrink( NORMAL_TCD, west = 3.735 ); 
          _17_0_N_REC_4 = shrink( NORMAL_TCD, north = ( 12 - 7.41 ) ) and shrink( NORMAL_TCD, east = ( 12 - 4.515 ) ) and shrink( NORMAL_TCD, south = 7.35 ) and shrink( NORMAL_TCD, west = 3.015 ); 
          _17_0_N_REC_5 = shrink( NORMAL_TCD, north = ( 12 - 9.03 ) ) and shrink( NORMAL_TCD, east = ( 12 - 2.895 ) ) and shrink( NORMAL_TCD, south = 8.97 ) and shrink( NORMAL_TCD, west = 1.395 ); 
          _17_0_N_REC_6 = shrink( NORMAL_TCD, north = ( 12 - 9.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 2.175 ) ) and shrink( NORMAL_TCD, south = 8.25 ) and shrink( NORMAL_TCD, west = 2.115 ); 
          _17_0_N_REC_7 = shrink( NORMAL_TCD, north = ( 12 - 9.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 3.795 ) ) and shrink( NORMAL_TCD, south = 8.25 ) and shrink( NORMAL_TCD, west = 3.735 ); 
          _17_0_N_REC_8 = shrink( NORMAL_TCD, north = ( 12 - 9.03 ) ) and shrink( NORMAL_TCD, east = ( 12 - 4.515 ) ) and shrink( NORMAL_TCD, south = 8.97 ) and shrink( NORMAL_TCD, west = 3.015 ); 
          _17_0_N_REC_9 = shrink( NORMAL_TCD, north = ( 12 - 9.03 ) ) and shrink( NORMAL_TCD, east = ( 12 - 6.135 ) ) and shrink( NORMAL_TCD, south = 8.97 ) and shrink( NORMAL_TCD, west = 4.635 ); 
          _17_0_N_REC_10 = shrink( NORMAL_TCD, north = ( 12 - 9.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 5.415 ) ) and shrink( NORMAL_TCD, south = 8.25 ) and shrink( NORMAL_TCD, west = 5.355 ); 
          _17_0_N_REC_11 = shrink( NORMAL_TCD, north = ( 12 - 11.37 ) ) and shrink( NORMAL_TCD, east = ( 12 - 5.415 ) ) and shrink( NORMAL_TCD, south = 9.87 ) and shrink( NORMAL_TCD, west = 5.355 ); 
          _17_0_N_REC_12 = shrink( NORMAL_TCD, north = ( 12 - 10.65 ) ) and shrink( NORMAL_TCD, east = ( 12 - 6.135 ) ) and shrink( NORMAL_TCD, south = 10.59 ) and shrink( NORMAL_TCD, west = 4.635 ); 
          _17_0_N_REC_13 = shrink( NORMAL_TCD, north = ( 12 - 11.37 ) ) and shrink( NORMAL_TCD, east = ( 12 - 3.795 ) ) and shrink( NORMAL_TCD, south = 9.87 ) and shrink( NORMAL_TCD, west = 3.735 ); 
          _17_0_N_REC_14 = shrink( NORMAL_TCD, north = ( 12 - 10.65 ) ) and shrink( NORMAL_TCD, east = ( 12 - 4.515 ) ) and shrink( NORMAL_TCD, south = 10.59 ) and shrink( NORMAL_TCD, west = 3.015 ); 
          _17_0_N_REC_15 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.7 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 11.61 ); 
          _17_0_N_REC_16 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 11.405 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 11.315 ); 
          _17_0_N_REC_17 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 10.905 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 10.845 ); 
          _17_0_N_REC_18 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 10.64 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 10.58 ); 
          _17_0_N_REC_19 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 10.375 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 10.315 ); 
          _17_0_N_REC_20 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 10.11 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 10.05 ); 
          _17_0_N_REC_21 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 9.845 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 9.785 ); 
          _17_0_N_REC_22 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 9.58 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 9.52 ); 
          _17_0_N_REC_23 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 9.315 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 9.255 ); 
          _17_0_N_REC_24 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 9.05 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 8.99 ); 
          _17_0_N_REC_25 = shrink( NORMAL_TCD, north = ( 12 - 6 ) ) and shrink( NORMAL_TCD, east = ( 12 - 8.785 ) ) and shrink( NORMAL_TCD, south = 0.15 ) and shrink( NORMAL_TCD, west = 8.725 ); 
          _17_0_N_REC_26 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 8.52 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 8.46 ); 
          _17_0_N_REC_27 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 8.255 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 8.195 ); 
          _17_0_N_REC_28 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 7.99 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 7.93 ); 
          _17_0_N_REC_29 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 7.725 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 7.665 ); 
          _17_0_N_REC_30 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 7.46 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 7.4 ); 
          _17_0_N_REC_31 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 7.195 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 7.135 ); 
          _17_0_N_REC_32 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 6.93 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 6.87 ); 
          _17_0_N_REC_33 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 6.665 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 6.605 ); 
          _17_0_N_REC_34 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 5.395 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 5.335 ); 
          _17_0_N_REC_35 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 5.13 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 5.07 ); 
          _17_0_N_REC_36 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 4.865 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 4.805 ); 
          _17_0_N_REC_37 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 4.6 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 4.54 ); 
          _17_0_N_REC_38 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 4.335 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 4.275 ); 
          _17_0_N_REC_39 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 4.07 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 4.01 ); 
          _17_0_N_REC_40 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 3.805 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 3.745 ); 
          _17_0_N_REC_41 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 3.54 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 3.48 ); 
          _17_0_N_REC_42 = shrink( NORMAL_TCD, north = ( 12 - 6 ) ) and shrink( NORMAL_TCD, east = ( 12 - 3.275 ) ) and shrink( NORMAL_TCD, south = 0.15 ) and shrink( NORMAL_TCD, west = 3.215 ); 
          _17_0_N_REC_43 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 3.01 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 2.95 ); 
          _17_0_N_REC_44 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 2.745 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 2.685 ); 
          _17_0_N_REC_45 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 2.48 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 2.42 ); 
          _17_0_N_REC_46 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 2.215 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 2.155 ); 
          _17_0_N_REC_47 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 1.95 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 1.89 ); 
          _17_0_N_REC_48 = shrink( NORMAL_TCD, north = ( 12 - 11.7 ) ) and shrink( NORMAL_TCD, east = ( 12 - 2.8 ) ) and shrink( NORMAL_TCD, south = 10.7 ) and shrink( NORMAL_TCD, west = 1.8 ); 
          _17_0_N_REC_49 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 1.685 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 1.625 ); 
          _17_0_N_REC_50 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 1.42 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 1.36 ); 
          _17_0_N_REC_51 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 1.155 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 1.095 ); 
          _17_0_N_REC_52 = shrink( NORMAL_TCD, north = ( 12 - 11.7 ) ) and shrink( NORMAL_TCD, east = ( 12 - 1.3 ) ) and shrink( NORMAL_TCD, south = 10.7 ) and shrink( NORMAL_TCD, west = 0.3 ); 
          _17_0_N_REC_53 = shrink( NORMAL_TCD, north = ( 12 - 10.2 ) ) and shrink( NORMAL_TCD, east = ( 12 - 1.3 ) ) and shrink( NORMAL_TCD, south = 9.2 ) and shrink( NORMAL_TCD, west = 0.3 ); 
          _17_0_N_REC_54 = shrink( NORMAL_TCD, north = ( 12 - 5.75 ) ) and shrink( NORMAL_TCD, east = ( 12 - 0.595 ) ) and shrink( NORMAL_TCD, south = 0.25 ) and shrink( NORMAL_TCD, west = 0.3 ); 
          _25_0_N_REC_1 = shrink( NORMAL_TCD, north = ( 12 - 6 ) ) and shrink( NORMAL_TCD, east = ( 12 - 12 ) ) and shrink( NORMAL_TCD, west = 6 ); 
          _26_0_N_REC_1 = shrink( NORMAL_TCD, north = ( 12 - 6 ) ) and shrink( NORMAL_TCD, east = ( 12 - 6 ) ); 
          _26_0_N_REC_2 = shrink( NORMAL_TCD, north = ( 12 - 12 ) ) and shrink( NORMAL_TCD, east = ( 12 - 12 ) ) and shrink( NORMAL_TCD, south = 6 ); 
          _150_20_N_REC_1 = shrink( NORMAL_TCD, north = ( 12 - 12 ) ) and shrink( NORMAL_TCD, east = ( 12 - 12 ) ); 
          _150_21_N_REC_1 = shrink( NORMAL_TCD, north = ( 12 - 12 ) ) and shrink( NORMAL_TCD, east = ( 12 - 12 ) ); 
          NORMAL_TCD_150_20 = copy( _150_20_N_REC_1 ); 
          NORMAL_TCD_150_21 = copy( _150_21_N_REC_1 ); 
          sLAYER_152 = _17_0_N_REC_1 or _17_0_N_REC_2; 
          sLAYER_151 = sLAYER_152 or _17_0_N_REC_3; 
          sLAYER_150 = sLAYER_151 or _17_0_N_REC_4; 
          sLAYER_149 = sLAYER_150 or _17_0_N_REC_5; 
          sLAYER_148 = sLAYER_149 or _17_0_N_REC_6; 
          sLAYER_147 = sLAYER_148 or _17_0_N_REC_7; 
          sLAYER_146 = sLAYER_147 or _17_0_N_REC_8; 
          sLAYER_145 = sLAYER_146 or _17_0_N_REC_9; 
          sLAYER_144 = sLAYER_145 or _17_0_N_REC_10; 
          sLAYER_143 = sLAYER_144 or _17_0_N_REC_11; 
          sLAYER_142 = sLAYER_143 or _17_0_N_REC_12; 
          sLAYER_141 = sLAYER_142 or _17_0_N_REC_13; 
          sLAYER_140 = sLAYER_141 or _17_0_N_REC_14; 
          sLAYER_139 = sLAYER_140 or _17_0_N_REC_15; 
          sLAYER_138 = sLAYER_139 or _17_0_N_REC_16; 
          sLAYER_137 = sLAYER_138 or _17_0_N_REC_17; 
          sLAYER_136 = sLAYER_137 or _17_0_N_REC_18; 
          sLAYER_135 = sLAYER_136 or _17_0_N_REC_19; 
          sLAYER_134 = sLAYER_135 or _17_0_N_REC_20; 
          sLAYER_133 = sLAYER_134 or _17_0_N_REC_21; 
          sLAYER_132 = sLAYER_133 or _17_0_N_REC_22; 
          sLAYER_131 = sLAYER_132 or _17_0_N_REC_23; 
          sLAYER_130 = sLAYER_131 or _17_0_N_REC_24; 
          sLAYER_129 = sLAYER_130 or _17_0_N_REC_25; 
          sLAYER_128 = sLAYER_129 or _17_0_N_REC_26; 
          sLAYER_127 = sLAYER_128 or _17_0_N_REC_27; 
          sLAYER_126 = sLAYER_127 or _17_0_N_REC_28; 
          sLAYER_125 = sLAYER_126 or _17_0_N_REC_29; 
          sLAYER_124 = sLAYER_125 or _17_0_N_REC_30; 
          sLAYER_123 = sLAYER_124 or _17_0_N_REC_31; 
          sLAYER_122 = sLAYER_123 or _17_0_N_REC_32; 
          sLAYER_121 = sLAYER_122 or _17_0_N_REC_33; 
          sLAYER_120 = sLAYER_121 or _17_0_N_REC_34; 
          sLAYER_119 = sLAYER_120 or _17_0_N_REC_35; 
          sLAYER_118 = sLAYER_119 or _17_0_N_REC_36; 
          sLAYER_117 = sLAYER_118 or _17_0_N_REC_37; 
          sLAYER_116 = sLAYER_117 or _17_0_N_REC_38; 
          sLAYER_115 = sLAYER_116 or _17_0_N_REC_39; 
          sLAYER_114 = sLAYER_115 or _17_0_N_REC_40; 
          sLAYER_113 = sLAYER_114 or _17_0_N_REC_41; 
          sLAYER_112 = sLAYER_113 or _17_0_N_REC_42; 
          sLAYER_111 = sLAYER_112 or _17_0_N_REC_43; 
          sLAYER_110 = sLAYER_111 or _17_0_N_REC_44; 
          sLAYER_109 = sLAYER_110 or _17_0_N_REC_45; 
          sLAYER_108 = sLAYER_109 or _17_0_N_REC_46; 
          sLAYER_107 = sLAYER_108 or _17_0_N_REC_47; 
          sLAYER_106 = sLAYER_107 or _17_0_N_REC_48; 
          sLAYER_105 = sLAYER_106 or _17_0_N_REC_49; 
          sLAYER_104 = sLAYER_105 or _17_0_N_REC_50; 
          sLAYER_103 = sLAYER_104 or _17_0_N_REC_51; 
          sLAYER_102 = sLAYER_103 or _17_0_N_REC_52; 
          sLAYER_101 = sLAYER_102 or _17_0_N_REC_53; 
          sLAYER_100 = sLAYER_101 or _17_0_N_REC_54; 
          NORMAL_TCD_17_0 = copy( sLAYER_100 ); 
          NORMAL_TCD_25_0 = copy( _25_0_N_REC_1 ); 
          sLAYER_153 = _26_0_N_REC_1 or _26_0_N_REC_2; 
          NORMAL_TCD_26_0 = copy( sLAYER_153 ); 
          sLAYER_198 = _6_0_N_REC_1 or _6_0_N_REC_2; 
          sLAYER_197 = sLAYER_198 or _6_0_N_REC_3; 
          sLAYER_196 = sLAYER_197 or _6_0_N_REC_4; 
          sLAYER_195 = sLAYER_196 or _6_0_N_REC_5; 
          sLAYER_194 = sLAYER_195 or _6_0_N_REC_6; 
          sLAYER_193 = sLAYER_194 or _6_0_N_REC_7; 
          sLAYER_192 = sLAYER_193 or _6_0_N_REC_8; 
          sLAYER_191 = sLAYER_192 or _6_0_N_REC_9; 
          sLAYER_190 = sLAYER_191 or _6_0_N_REC_10; 
          sLAYER_189 = sLAYER_190 or _6_0_N_REC_11; 
          sLAYER_188 = sLAYER_189 or _6_0_N_REC_12; 
          sLAYER_187 = sLAYER_188 or _6_0_N_REC_13; 
          sLAYER_186 = sLAYER_187 or _6_0_N_REC_14; 
          sLAYER_185 = sLAYER_186 or _6_0_N_REC_15; 
          sLAYER_184 = sLAYER_185 or _6_0_N_REC_16; 
          sLAYER_183 = sLAYER_184 or _6_0_N_REC_17; 
          sLAYER_182 = sLAYER_183 or _6_0_N_REC_18; 
          sLAYER_181 = sLAYER_182 or _6_0_N_REC_19; 
          sLAYER_180 = sLAYER_181 or _6_0_N_REC_20; 
          sLAYER_179 = sLAYER_180 or _6_0_N_REC_21; 
          sLAYER_178 = sLAYER_179 or _6_0_N_REC_22; 
          sLAYER_177 = sLAYER_178 or _6_0_N_REC_23; 
          sLAYER_176 = sLAYER_177 or _6_0_N_REC_24; 
          sLAYER_175 = sLAYER_176 or _6_0_N_REC_25; 
          sLAYER_174 = sLAYER_175 or _6_0_N_REC_26; 
          sLAYER_173 = sLAYER_174 or _6_0_N_REC_27; 
          sLAYER_172 = sLAYER_173 or _6_0_N_REC_28; 
          sLAYER_171 = sLAYER_172 or _6_0_N_REC_29; 
          sLAYER_170 = sLAYER_171 or _6_0_N_REC_30; 
          sLAYER_169 = sLAYER_170 or _6_0_N_REC_31; 
          sLAYER_168 = sLAYER_169 or _6_0_N_REC_32; 
          sLAYER_167 = sLAYER_168 or _6_0_N_REC_33; 
          sLAYER_166 = sLAYER_167 or _6_0_N_REC_34; 
          sLAYER_165 = sLAYER_166 or _6_0_N_REC_35; 
          sLAYER_164 = sLAYER_165 or _6_0_N_REC_36; 
          sLAYER_163 = sLAYER_164 or _6_0_N_REC_37; 
          sLAYER_162 = sLAYER_163 or _6_0_N_REC_38; 
          sLAYER_161 = sLAYER_162 or _6_0_N_REC_39; 
          sLAYER_160 = sLAYER_161 or _6_0_N_REC_40; 
          sLAYER_159 = sLAYER_160 or _6_0_N_REC_41; 
          sLAYER_158 = sLAYER_159 or _6_0_N_REC_42; 
          sLAYER_157 = sLAYER_158 or _6_0_N_REC_43; 
          sLAYER_156 = sLAYER_157 or _6_0_N_REC_44; 
          sLAYER_155 = sLAYER_156 or _6_0_N_REC_45; 
          sLAYER_154 = sLAYER_155 or _6_0_N_REC_46; 
          NORMAL_TCD_6_0 = copy( sLAYER_154 ); 
          NORMAL_TCD_OD = ODI and NORMAL_TCD; 
          NORMAL_TCD_PO = POI and NORMAL_TCD; 
          NORMAL_TCD_PP = PPI and NORMAL_TCD; 
          NORMAL_TCD_NP = NPI and NORMAL_TCD; 
          NORMAL_TCD_ODBLK = ODBLK and NORMAL_TCD; 
          NORMAL_TCD_POBLK = POBLK and NORMAL_TCD; 
          NORMAL_TCD_OD xor NORMAL_TCD_6_0; 
          NORMAL_TCD_PO xor NORMAL_TCD_17_0; 
          NORMAL_TCD_PP xor NORMAL_TCD_25_0; 
          NORMAL_TCD_NP xor NORMAL_TCD_26_0; 
          NORMAL_TCD_ODBLK xor NORMAL_TCD_150_20; 
          NORMAL_TCD_POBLK xor NORMAL_TCD_150_21; 
          _6_0_S_REC_1 = shrink( SMALL_TCD, north = ( 9.245 - 5.475 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 7.805 ) ) and shrink( SMALL_TCD, south = 5.035 ) and shrink( SMALL_TCD, west = 6.585 ); 
          _6_0_S_REC_2 = shrink( SMALL_TCD, north = ( 9.245 - 4.695 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 7.805 ) ) and shrink( SMALL_TCD, south = 4.255 ) and shrink( SMALL_TCD, west = 6.585 ); 
          _6_0_S_REC_3 = shrink( SMALL_TCD, north = ( 9.245 - 3.855 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 7.805 ) ) and shrink( SMALL_TCD, south = 3.415 ) and shrink( SMALL_TCD, west = 6.585 ); 
          _6_0_S_REC_4 = shrink( SMALL_TCD, north = ( 9.245 - 3.075 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 7.805 ) ) and shrink( SMALL_TCD, south = 2.635 ) and shrink( SMALL_TCD, west = 6.585 ); 
          _6_0_S_REC_5 = shrink( SMALL_TCD, north = ( 9.245 - 2.235 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 7.805 ) ) and shrink( SMALL_TCD, south = 1.795 ) and shrink( SMALL_TCD, west = 6.585 ); 
          _6_0_S_REC_6 = shrink( SMALL_TCD, north = ( 9.245 - 1.455 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 7.805 ) ) and shrink( SMALL_TCD, south = 1.015 ) and shrink( SMALL_TCD, west = 6.585 ); 
          _6_0_S_REC_7 = shrink( SMALL_TCD, north = ( 9.245 - 5.745 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 5.745 ) ) and shrink( SMALL_TCD, south = 0.745 ) and shrink( SMALL_TCD, west = 0.745 ); 
          _17_0_S_REC_1 = shrink( SMALL_TCD, north = ( 9.245 - 2.375 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 7.225 ) ) and shrink( SMALL_TCD, south = 0.875 ) and shrink( SMALL_TCD, west = 7.165 ); 
          _17_0_S_REC_2 = shrink( SMALL_TCD, north = ( 9.245 - 1.655 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 7.945 ) ) and shrink( SMALL_TCD, south = 1.595 ) and shrink( SMALL_TCD, west = 6.445 ); 
          _17_0_S_REC_3 = shrink( SMALL_TCD, north = ( 9.245 - 3.275 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 7.945 ) ) and shrink( SMALL_TCD, south = 3.215 ) and shrink( SMALL_TCD, west = 6.445 ); 
          _17_0_S_REC_4 = shrink( SMALL_TCD, north = ( 9.245 - 3.995 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 7.225 ) ) and shrink( SMALL_TCD, south = 2.495 ) and shrink( SMALL_TCD, west = 7.165 ); 
          _17_0_S_REC_5 = shrink( SMALL_TCD, north = ( 9.245 - 5.615 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 7.225 ) ) and shrink( SMALL_TCD, south = 4.115 ) and shrink( SMALL_TCD, west = 7.165 ); 
          _17_0_S_REC_6 = shrink( SMALL_TCD, north = ( 9.245 - 4.895 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 7.945 ) ) and shrink( SMALL_TCD, south = 4.835 ) and shrink( SMALL_TCD, west = 6.445 ); 
          _17_0_S_REC_7 = shrink( SMALL_TCD, north = ( 9.245 - 8.945 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 8.945 ) ) and shrink( SMALL_TCD, south = 7.945 ) and shrink( SMALL_TCD, west = 7.945 ); 
          _17_0_S_REC_8 = shrink( SMALL_TCD, north = ( 9.245 - 7.445 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 8.945 ) ) and shrink( SMALL_TCD, south = 6.445 ) and shrink( SMALL_TCD, west = 7.945 ); 
          _17_0_S_REC_9 = shrink( SMALL_TCD, north = ( 9.245 - 7.445 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 7.445 ) ) and shrink( SMALL_TCD, south = 6.445 ) and shrink( SMALL_TCD, west = 6.445 ); 
          _17_0_S_REC_10 = shrink( SMALL_TCD, north = ( 9.245 - 5.995 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 6.19 ) ) and shrink( SMALL_TCD, south = 0.495 ) and shrink( SMALL_TCD, west = 5.895 ); 
          _17_0_S_REC_11 = shrink( SMALL_TCD, north = ( 9.245 - 5.995 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 5.395 ) ) and shrink( SMALL_TCD, south = 0.495 ) and shrink( SMALL_TCD, west = 5.335 ); 
          _17_0_S_REC_12 = shrink( SMALL_TCD, north = ( 9.245 - 5.995 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 5.13 ) ) and shrink( SMALL_TCD, south = 0.495 ) and shrink( SMALL_TCD, west = 5.07 ); 
          _17_0_S_REC_13 = shrink( SMALL_TCD, north = ( 9.245 - 5.995 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 4.865 ) ) and shrink( SMALL_TCD, south = 0.495 ) and shrink( SMALL_TCD, west = 4.805 ); 
          _17_0_S_REC_14 = shrink( SMALL_TCD, north = ( 9.245 - 5.995 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 4.6 ) ) and shrink( SMALL_TCD, south = 0.495 ) and shrink( SMALL_TCD, west = 4.54 ); 
          _17_0_S_REC_15 = shrink( SMALL_TCD, north = ( 9.245 - 5.995 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 4.335 ) ) and shrink( SMALL_TCD, south = 0.495 ) and shrink( SMALL_TCD, west = 4.275 ); 
          _17_0_S_REC_16 = shrink( SMALL_TCD, north = ( 9.245 - 5.995 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 4.07 ) ) and shrink( SMALL_TCD, south = 0.495 ) and shrink( SMALL_TCD, west = 4.01 ); 
          _17_0_S_REC_17 = shrink( SMALL_TCD, north = ( 9.245 - 5.995 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 3.805 ) ) and shrink( SMALL_TCD, south = 0.495 ) and shrink( SMALL_TCD, west = 3.745 ); 
          _17_0_S_REC_18 = shrink( SMALL_TCD, north = ( 9.245 - 5.995 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 3.54 ) ) and shrink( SMALL_TCD, south = 0.495 ) and shrink( SMALL_TCD, west = 3.48 ); 
          _17_0_S_REC_19 = shrink( SMALL_TCD, north = ( 9.245 - 6.245 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 3.275 ) ) and shrink( SMALL_TCD, south = 0.245 ) and shrink( SMALL_TCD, west = 3.215 ); 
          _17_0_S_REC_20 = shrink( SMALL_TCD, north = ( 9.245 - 5.995 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 3.01 ) ) and shrink( SMALL_TCD, south = 0.495 ) and shrink( SMALL_TCD, west = 2.95 ); 
          _17_0_S_REC_21 = shrink( SMALL_TCD, north = ( 9.245 - 5.995 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 2.745 ) ) and shrink( SMALL_TCD, south = 0.495 ) and shrink( SMALL_TCD, west = 2.685 ); 
          _17_0_S_REC_22 = shrink( SMALL_TCD, north = ( 9.245 - 5.995 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 2.48 ) ) and shrink( SMALL_TCD, south = 0.495 ) and shrink( SMALL_TCD, west = 2.42 ); 
          _17_0_S_REC_23 = shrink( SMALL_TCD, north = ( 9.245 - 5.995 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 2.215 ) ) and shrink( SMALL_TCD, south = 0.495 ) and shrink( SMALL_TCD, west = 2.155 ); 
          _17_0_S_REC_24 = shrink( SMALL_TCD, north = ( 9.245 - 5.995 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 1.95 ) ) and shrink( SMALL_TCD, south = 0.495 ) and shrink( SMALL_TCD, west = 1.89 ); 
          _17_0_S_REC_25 = shrink( SMALL_TCD, north = ( 9.245 - 5.995 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 1.685 ) ) and shrink( SMALL_TCD, south = 0.495 ) and shrink( SMALL_TCD, west = 1.625 ); 
          _17_0_S_REC_26 = shrink( SMALL_TCD, north = ( 9.245 - 5.995 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 1.42 ) ) and shrink( SMALL_TCD, south = 0.495 ) and shrink( SMALL_TCD, west = 1.36 ); 
          _17_0_S_REC_27 = shrink( SMALL_TCD, north = ( 9.245 - 5.995 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 1.155 ) ) and shrink( SMALL_TCD, south = 0.495 ) and shrink( SMALL_TCD, west = 1.095 ); 
          _17_0_S_REC_28 = shrink( SMALL_TCD, north = ( 9.245 - 5.995 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 0.595 ) ) and shrink( SMALL_TCD, south = 0.495 ) and shrink( SMALL_TCD, west = 0.3 ); 
          _26_0_S_REC_1 = shrink( SMALL_TCD, north = ( 9.245 - 9.245 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 9.245 ) ); 
          _150_20_S_REC_1 = shrink( SMALL_TCD, north = ( 9.245 - 9.245 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 9.245 ) ); 
          _150_21_S_REC_1 = shrink( SMALL_TCD, north = ( 9.245 - 9.245 ) ) and shrink( SMALL_TCD, east = ( 9.245 - 9.245 ) ); 
          SMALL_TCD_150_20 = copy( _150_20_S_REC_1 ); 
          SMALL_TCD_150_21 = copy( _150_21_S_REC_1 ); 
          sLAYER_225 = _17_0_S_REC_1 or _17_0_S_REC_2; 
          sLAYER_224 = sLAYER_225 or _17_0_S_REC_3; 
          sLAYER_223 = sLAYER_224 or _17_0_S_REC_4; 
          sLAYER_222 = sLAYER_223 or _17_0_S_REC_5; 
          sLAYER_221 = sLAYER_222 or _17_0_S_REC_6; 
          sLAYER_220 = sLAYER_221 or _17_0_S_REC_7; 
          sLAYER_219 = sLAYER_220 or _17_0_S_REC_8; 
          sLAYER_218 = sLAYER_219 or _17_0_S_REC_9; 
          sLAYER_217 = sLAYER_218 or _17_0_S_REC_10; 
          sLAYER_216 = sLAYER_217 or _17_0_S_REC_11; 
          sLAYER_215 = sLAYER_216 or _17_0_S_REC_12; 
          sLAYER_214 = sLAYER_215 or _17_0_S_REC_13; 
          sLAYER_213 = sLAYER_214 or _17_0_S_REC_14; 
          sLAYER_212 = sLAYER_213 or _17_0_S_REC_15; 
          sLAYER_211 = sLAYER_212 or _17_0_S_REC_16; 
          sLAYER_210 = sLAYER_211 or _17_0_S_REC_17; 
          sLAYER_209 = sLAYER_210 or _17_0_S_REC_18; 
          sLAYER_208 = sLAYER_209 or _17_0_S_REC_19; 
          sLAYER_207 = sLAYER_208 or _17_0_S_REC_20; 
          sLAYER_206 = sLAYER_207 or _17_0_S_REC_21; 
          sLAYER_205 = sLAYER_206 or _17_0_S_REC_22; 
          sLAYER_204 = sLAYER_205 or _17_0_S_REC_23; 
          sLAYER_203 = sLAYER_204 or _17_0_S_REC_24; 
          sLAYER_202 = sLAYER_203 or _17_0_S_REC_25; 
          sLAYER_201 = sLAYER_202 or _17_0_S_REC_26; 
          sLAYER_200 = sLAYER_201 or _17_0_S_REC_27; 
          sLAYER_199 = sLAYER_200 or _17_0_S_REC_28; 
          SMALL_TCD_17_0 = copy( sLAYER_199 ); 
          SMALL_TCD_26_0 = copy( _26_0_S_REC_1 ); 
          sLAYER_231 = _6_0_S_REC_1 or _6_0_S_REC_2; 
          sLAYER_230 = sLAYER_231 or _6_0_S_REC_3; 
          sLAYER_229 = sLAYER_230 or _6_0_S_REC_4; 
          sLAYER_228 = sLAYER_229 or _6_0_S_REC_5; 
          sLAYER_227 = sLAYER_228 or _6_0_S_REC_6; 
          sLAYER_226 = sLAYER_227 or _6_0_S_REC_7; 
          SMALL_TCD_6_0 = copy( sLAYER_226 ); 
          SMALL_TCD_OD = ODI and SMALL_TCD; 
          SMALL_TCD_PO = POI and SMALL_TCD; 
          SMALL_TCD_NP = NPI and SMALL_TCD; 
          SMALL_TCD_ODBLK = ODBLK and SMALL_TCD; 
          SMALL_TCD_POBLK = POBLK and SMALL_TCD; 
          SMALL_TCD_OD xor SMALL_TCD_6_0; 
          SMALL_TCD_PO xor SMALL_TCD_17_0; 
          SMALL_TCD_NP xor SMALL_TCD_26_0; 
          SMALL_TCD_ODBLK xor SMALL_TCD_150_20; 
          SMALL_TCD_POBLK xor SMALL_TCD_150_21; 
      } /* end of rule : DTCD.R.2 */
      rDTCD_R_3 @= { @ "DTCD.R.3 : TCDDMY overlap of DOD, DPO, NW, OD2, DCO, NT_N, POFUSE, RPO, RH, VAR, mVTL, VTH_P, VTH_N, VTL_P, VTL_N, SRM, SRAMDMY, FW, LMARK, INDDMY, LOGO, or MOMDMY is not allowed.";
          TCDDMY and DOD; 
          TCDDMY and DPO; 
          TCDDMY and NWI; 
          TCDDMY and OD2I; 
          TCDDMY and DCOI; 
          TCDDMY and NT_NI; 
          TCDDMY and POFUSE; 
          TCDDMY and RPOI; 
          TCDDMY and RH; 
          TCDDMY and VARI; 
          TCDDMY and MVTLI; 
          TCDDMY and VTH_PI; 
          TCDDMY and VTH_NI; 
          TCDDMY and VTL_PI; 
          TCDDMY and VTL_NI; 
          TCDDMY and SRM; 
          TCDDMY and FWI; 
          TCDDMY and SRAMDMY; 
          TCDDMY and LMARK; 
          TCDDMY and INDDMY; 
          TCDDMY and LOGO; 
          TCDDMY and MOMDMY_ALL; 
      } /* end of rule : DTCD.R.3 */
      
      //VTH_N CHECKS
      //============
      // VTH_N.S.2 is checked by VTH_N.S.2__VTH_N.S.2.1
      // VTH_N.S.2.1 is checked by VTH_N.S.2__VTH_N.S.2.1
      // VTH_N.EN.1 is checked by VTH_N.EN.1__VTH_N.EN.2
      // VTH_N.EN.2 is checked by VTH_N.EN.1__VTH_N.EN.2
      rVTH_N_W_1 @= { @ "VTH_N.W.1 : Min. dimension of VTH_N (except Point touch of vertex [Width >= " + VTH_N_S_1_W + " um])>= " + VTH_N_W_1 + " um."; 
          sLAYER_232 = internal1( VTHNS, < VTH_N_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
          sLAYER_232 not_inside SRAM_EXCLUDE; 
      } /* end of rule : VTH_N.W.1 */
      VTHN_P = external1( VTHNS, < VTH_N_S_1, extension = RADIAL, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { }, relational = { POINT_TOUCH } ); 
      rVTH_N_S_1 @= { @ "VTH_N.S.1 : Min. space between two VTH_N  (except Point touch of vertex [Width >= " + VTH_N_S_1_W + " um]) >= " + VTH_N_S_1 + " um."; 
          X = external1( VTHNS, < VTH_N_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_234 = X not VTHN_P; 
          sLAYER_233 = interacting( X, sLAYER_234 ); 
          sLAYER_233 not_inside SRAM_EXCLUDE; 
          A = external1( VTHNS, < GRID, extension = RADIAL, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { }, relational = { POINT_TOUCH } ); 
          sLAYER_235 = size( A, clip_acute = NONE, distance = GRID ); 
          B = sLAYER_235 and VTHNS; 
          sLAYER_236 = size( size( VTHNS, - ( ( VTH_N_S_1_W - 0.002 ) / 2 ), clip_acute = BISECTOR ), ( VTH_N_S_1_W - 0.002 ) / 2, clip_acute = BISECTOR ); 
          C = sLAYER_236 and VTHNS; 
          B not C; 
      } /* end of rule : VTH_N.S.1 */
      rVTH_N_S_2__VTH_N_S_2_1 @= { @ "VTH_N.S.2__VTH_N.S.2.1 : Space to gate in PO endcap direction >= " + VTH_N_S_2 + " " 
                                                              "Space to gate in S/D direction >= " + VTH_N_S_2_1; 
          A = not_interacting( GATE, VTHN ); 
          X = and_edge( A, OD, false ); 
          sLAYER_237 = edge_size( X, outside = ( VTH_N_S_2_1 - VTH_N_S_2 ) ); 
          B = sLAYER_237 or A; 
          C = size( B, clip_acute = NONE, distance = VTH_N_S_2 ); 
          VTHN and C; 
      } /* end of rule : VTH_N.S.2__VTH_N.S.2.1 */
      rVTH_N_S_3 @= { @ "VTH_N.S.3 : Min. clearance from VTH_N to OD resistor >= " + VTH_N_S_3 + " um"; 
          external2_edge( VTHN, ODRES, < VTH_N_S_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
          external2_edge( VTHN, ODRES, < VTH_N_S_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
          VTHN and ODRES; 
      } /* end of rule : VTH_N.S.3 */
      rVTH_N_EN_1__VTH_N_EN_2 @= { @ "VTH_N.EN.1__VTH_N.EN.2 : Enclosure of gate in S/D direction >= " + VTH_N_EN_1 + " " 
                                                              "Enclosure of gate in PO endcap direction >= " + VTH_N_EN_2; 
          A = interacting( GATE, VTHN ); 
          X = and_edge( A, OD, false ); 
          sLAYER_238 = edge_size( X, outside = ( VTH_N_EN_1 - VTH_N_EN_2 ) ); 
          B = sLAYER_238 or A; 
          C = size( B, clip_acute = NONE, distance = VTH_N_EN_2 ); 
          C not VTHN; 
      } /* end of rule : VTH_N.EN.1__VTH_N.EN.2 */
      rVTH_N_A_1 @= { @ "VTH_N.A.1 : Min. VTH_N area >= " + VTH_N_A_1 + " um"; 
          sLAYER_239 = area( VTHNS, < VTH_N_A_1 ); 
          sLAYER_239 not_inside SRAM_EXCLUDE; 
      } /* end of rule : VTH_N.A.1 */
      rVTH_N_A_2 @= { @ "VTH_N.A.2 : Min. area of an enclosed VTH_N >= " + VTH_N_A_2 + " um"; 
          A = donut_holes( VTHN, area = < VTH_N_A_2PRE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          B = A not VTHN; 
          area( B, < VTH_N_A_2 ); 
      } /* end of rule : VTH_N.A.2 */
      rVTH_N_R_1 @= { @ "VTH_N.R.1 : Overlap PACT, VTLN, NT_N or OD2 is not allowed";
          VTHN and OD2; 
          VTHN and NTN; 
          VTHN and PACT; 
          VTHN and VTLN; 
      } /* end of rule : VTH_N.R.1 */
      
      //VTH_P CHECKS
      //============
      // VTH_P.S.2 is checked by VTH_P.S.2__VTH_P.S.2.1
      // VTH_P.S.2.1 is checked by VTH_P.S.2__VTH_P.S.2.1
      // VTH_P.EN.1 is checked by VTH_P.EN.1__VTH_P.EN.2
      // VTH_P.EN.2 is checked by VTH_P.EN.1__VTH_P.EN.2
      rVTH_P_W_1 @= { @ "VTH_P.W.1 : Min. dimension of VTH_P (except Point touch of vertex [Width >= " + VTH_P_S_1_W + " um])>= " + VTH_P_W_1 + " um."; 
          sLAYER_240 = internal1( VTHPS, < VTH_P_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
          sLAYER_240 not_inside SRAM_EXCLUDE; 
      } /* end of rule : VTH_P.W.1 */
      VTHP_P = external1( VTHPS, < VTH_P_S_1, extension = RADIAL, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { }, relational = { POINT_TOUCH } ); 
      rVTH_P_S_1 @= { @ "VTH_P.S.1 : Min. space between two VTH_P  (except Point touch of vertex [Width >= " + VTH_P_S_1_W + " um]) >= " + VTH_P_S_1 + " um."; 
          X = external1( VTHPS, < VTH_P_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_242 = X not VTHP_P; 
          sLAYER_241 = interacting( X, sLAYER_242 ); 
          sLAYER_241 not_inside SRAM_EXCLUDE; 
          A = external1( VTHPS, < GRID, extension = RADIAL, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { }, relational = { POINT_TOUCH } ); 
          sLAYER_243 = size( A, clip_acute = NONE, distance = GRID ); 
          B = sLAYER_243 and VTHPS; 
          sLAYER_244 = size( size( VTHPS, - ( ( VTH_P_S_1_W - 0.002 ) / 2 ), clip_acute = BISECTOR ), ( VTH_P_S_1_W - 0.002 ) / 2, clip_acute = BISECTOR ); 
          C = sLAYER_244 and VTHPS; 
          B not C; 
      } /* end of rule : VTH_P.S.1 */
      rVTH_P_S_2__VTH_P_S_2_1 @= { @ "VTH_P.S.2__VTH_P.S.2.1 : Space to gate in PO endcap direction >= " + VTH_P_S_2 + " " 
                                                              "Space to gate in S/D direction >= " + VTH_P_S_2_1; 
          A = not_interacting( GATE, VTHP ); 
          X = and_edge( A, OD, false ); 
          sLAYER_245 = edge_size( X, outside = ( VTH_P_S_2_1 - VTH_P_S_2 ) ); 
          B = sLAYER_245 or A; 
          C = size( B, clip_acute = NONE, distance = VTH_P_S_2 ); 
          VTHP and C; 
      } /* end of rule : VTH_P.S.2__VTH_P.S.2.1 */
      rVTH_P_S_3 @= { @ "VTH_P.S.3 : Min. clearance from VTH_P to OD resistor >= " + VTH_P_S_3 + " um"; 
          external2_edge( VTHP, ODRES, < VTH_P_S_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
          external2_edge( VTHP, ODRES, < VTH_P_S_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
          VTHP and ODRES; 
      } /* end of rule : VTH_P.S.3 */
      rVTH_P_EN_1__VTH_P_EN_2 @= { @ "VTH_P.EN.1__VTH_P.EN.2 : Enclosure of gate in S/D direction >= " + VTH_P_EN_1 + " " 
                                                              "Enclosure of gate in PO endcap direction >= " + VTH_P_EN_2; 
          A = interacting( GATE, VTHP ); 
          X = and_edge( A, OD, false ); 
          sLAYER_246 = edge_size( X, outside = ( VTH_P_EN_1 - VTH_P_EN_2 ) ); 
          B = sLAYER_246 or A; 
          C = size( B, clip_acute = NONE, distance = VTH_P_EN_2 ); 
          C not VTHP; 
      } /* end of rule : VTH_P.EN.1__VTH_P.EN.2 */
      rVTH_P_A_1 @= { @ "VTH_P.A.1 : Min. VTH_P area >= " + VTH_P_A_1 + " um"; 
          sLAYER_247 = area( VTHPS, < VTH_P_A_1 ); 
          sLAYER_247 not_inside SRAM_EXCLUDE; 
      } /* end of rule : VTH_P.A.1 */
      rVTH_P_A_2 @= { @ "VTH_P.A.2 : Min. area of an enclosed VTH_P >= " + VTH_P_A_2 + " um"; 
          A = donut_holes( VTHP, area = < VTH_P_A_2PRE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          B = A not VTHP; 
          area( B, < VTH_P_A_2 ); 
      } /* end of rule : VTH_P.A.2 */
      rVTH_P_R_1 @= { @ "VTH_P.R.1 : Overlap NACT, VTLP, NT_N or OD2 is not allowed";
          VTHP and OD2; 
          VTHP and NTN; 
          VTHP and NACT; 
          VTHP and VTLP; 
      } /* end of rule : VTH_P.R.1 */
      
      //VTL_N CHECKS
      //============
      // VTL_N.S.2 is checked by VTL_N.S.2__VTL_N.S.2.1
      // VTL_N.S.2.1 is checked by VTL_N.S.2__VTL_N.S.2.1
      // VTL_N.EN.1 is checked by VTL_N.EN.1__VTL_N.EN.2
      // VTL_N.EN.2 is checked by VTL_N.EN.1__VTL_N.EN.2
      rVTL_N_W_1 @= { @ "VTL_N.W.1 : Min. dimension of VTL_N (except Point touch of vertex [Width >= " + VTL_N_S_1_W + " um])>= " + VTL_N_W_1 + " um."; 
          sLAYER_248 = internal1( VTLNS, < VTL_N_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
          sLAYER_248 not_inside SRAM_EXCLUDE; 
      } /* end of rule : VTL_N.W.1 */
      VTLN_P = external1( VTLNS, < VTL_N_S_1, extension = RADIAL, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { }, relational = { POINT_TOUCH } ); 
      rVTL_N_S_1 @= { @ "VTL_N.S.1 : Min. space between two VTL_N  (except Point touch of vertex [Width >= " + VTL_N_S_1_W + " um]) >= " + VTL_N_S_1 + " um."; 
          X = external1( VTLNS, < VTL_N_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_250 = X not VTLN_P; 
          sLAYER_249 = interacting( X, sLAYER_250 ); 
          sLAYER_249 not_inside SRAM_EXCLUDE; 
          A = external1( VTLNS, < GRID, extension = RADIAL, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { }, relational = { POINT_TOUCH } ); 
          sLAYER_251 = size( A, clip_acute = NONE, distance = GRID ); 
          B = sLAYER_251 and VTLNS; 
          sLAYER_252 = size( size( VTLNS, - ( ( VTL_N_S_1_W - 0.002 ) / 2 ), clip_acute = BISECTOR ), ( VTL_N_S_1_W - 0.002 ) / 2, clip_acute = BISECTOR ); 
          C = sLAYER_252 and VTLNS; 
          B not C; 
      } /* end of rule : VTL_N.S.1 */
      rVTL_N_S_2__VTL_N_S_2_1 @= { @ "VTL_N.S.2__VTL_N.S.2.1 : Space to gate in PO endcap direction >= " + VTL_N_S_2 + " " 
                                                              "Space to gate in S/D direction >= " + VTL_N_S_2_1; 
          A = not_interacting( GATE, VTLN ); 
          X = and_edge( A, OD, false ); 
          sLAYER_253 = edge_size( X, outside = ( VTL_N_S_2_1 - VTL_N_S_2 ) ); 
          B = sLAYER_253 or A; 
          C = size( B, clip_acute = NONE, distance = VTL_N_S_2 ); 
          VTLN and C; 
      } /* end of rule : VTL_N.S.2__VTL_N.S.2.1 */
      rVTL_N_S_3 @= { @ "VTL_N.S.3 : Min. clearance from VTL_N to OD resistor >= " + VTL_N_S_3 + " um"; 
          external2_edge( VTLN, ODRES, < VTL_N_S_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
          external2_edge( VTLN, ODRES, < VTL_N_S_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
          VTLN and ODRES; 
      } /* end of rule : VTL_N.S.3 */
      rVTL_N_EN_1__VTL_N_EN_2 @= { @ "VTL_N.EN.1__VTL_N.EN.2 : Enclosure of gate in S/D direction >= " + VTL_N_EN_1 + " " 
                                                              "Enclosure of gate in PO endcap direction >= " + VTL_N_EN_2; 
          A = interacting( GATE, VTLN ); 
          X = and_edge( A, OD, false ); 
          sLAYER_254 = edge_size( X, outside = ( VTL_N_EN_1 - VTL_N_EN_2 ) ); 
          B = sLAYER_254 or A; 
          C = size( B, clip_acute = NONE, distance = VTL_N_EN_2 ); 
          C not VTLN; 
      } /* end of rule : VTL_N.EN.1__VTL_N.EN.2 */
      rVTL_N_A_1 @= { @ "VTL_N.A.1 : Min. VTL_N area >= " + VTL_N_A_1 + " um"; 
          sLAYER_255 = area( VTLNS, < VTL_N_A_1 ); 
          sLAYER_255 not_inside SRAM_EXCLUDE; 
      } /* end of rule : VTL_N.A.1 */
      rVTL_N_A_2 @= { @ "VTL_N.A.2 : Min. area of an enclosed VTL_N >= " + VTL_N_A_2 + " um"; 
          A = donut_holes( VTLN, area = < VTL_N_A_2PRE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          B = A not VTLN; 
          area( B, < VTL_N_A_2 ); 
      } /* end of rule : VTL_N.A.2 */
      rVTL_N_R_1 @= { @ "VTL_N.R.1 : Overlap PACT, VTHN, NT_N or OD2 is not allowed";
          VTLN and OD2; 
          VTLN and NTN; 
          VTLN and PACT; 
          VTLN and VTHN; 
      } /* end of rule : VTL_N.R.1 */
      
      //VTL_P CHECKS
      //============
      // VTL_P.S.2 is checked by VTL_P.S.2__VTL_P.S.2.1
      // VTL_P.S.2.1 is checked by VTL_P.S.2__VTL_P.S.2.1
      // VTL_P.EN.1 is checked by VTL_P.EN.1__VTL_P.EN.2
      // VTL_P.EN.2 is checked by VTL_P.EN.1__VTL_P.EN.2
      rVTL_P_W_1 @= { @ "VTL_P.W.1 : Min. dimension of VTL_P (except Point touch of vertex [Width >= " + VTL_P_S_1_W + " um])>= " + VTL_P_W_1 + " um."; 
          sLAYER_256 = internal1( VTLPS, < VTL_P_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
          sLAYER_256 not_inside SRAM_EXCLUDE; 
      } /* end of rule : VTL_P.W.1 */
      VTLP_P = external1( VTLPS, < VTL_P_S_1, extension = RADIAL, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { }, relational = { POINT_TOUCH } ); 
      rVTL_P_S_1 @= { @ "VTL_P.S.1 : Min. space between two VTL_P  (except Point touch of vertex [Width >= " + VTL_P_S_1_W + " um]) >= " + VTL_P_S_1 + " um."; 
          X = external1( VTLPS, < VTL_P_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_258 = X not VTLP_P; 
          sLAYER_257 = interacting( X, sLAYER_258 ); 
          sLAYER_257 not_inside SRAM_EXCLUDE; 
          A = external1( VTLPS, < GRID, extension = RADIAL, intersecting = {  }, look_thru = NOT_ADJACENT, orientation = { }, relational = { POINT_TOUCH } ); 
          sLAYER_259 = size( A, clip_acute = NONE, distance = GRID ); 
          B = sLAYER_259 and VTLPS; 
          sLAYER_260 = size( size( VTLPS, - ( ( VTL_P_S_1_W - 0.002 ) / 2 ), clip_acute = BISECTOR ), ( VTL_P_S_1_W - 0.002 ) / 2, clip_acute = BISECTOR ); 
          C = sLAYER_260 and VTLPS; 
          B not C; 
      } /* end of rule : VTL_P.S.1 */
      rVTL_P_S_2__VTL_P_S_2_1 @= { @ "VTL_P.S.2__VTL_P.S.2.1 : Space to gate in PO endcap direction >= " + VTL_P_S_2 + " " 
                                                              "Space to gate in S/D direction >= " + VTL_P_S_2_1; 
          A = not_interacting( GATE, VTLP ); 
          X = and_edge( A, OD, false ); 
          sLAYER_261 = edge_size( X, outside = ( VTL_P_S_2_1 - VTL_P_S_2 ) ); 
          B = sLAYER_261 or A; 
          C = size( B, clip_acute = NONE, distance = VTL_P_S_2 ); 
          VTLP and C; 
      } /* end of rule : VTL_P.S.2__VTL_P.S.2.1 */
      rVTL_P_S_3 @= { @ "VTL_P.S.3 : Min. clearance from VTL_P to OD resistor >= " + VTL_P_S_3 + " um"; 
          external2_edge( VTLP, ODRES, < VTL_P_S_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
          external2_edge( VTLP, ODRES, < VTL_P_S_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
          VTLP and ODRES; 
      } /* end of rule : VTL_P.S.3 */
      rVTL_P_EN_1__VTL_P_EN_2 @= { @ "VTL_P.EN.1__VTL_P.EN.2 : Enclosure of gate in S/D direction >= " + VTL_P_EN_1 + " " 
                                                              "Enclosure of gate in PO endcap direction >= " + VTL_P_EN_2; 
          A = interacting( GATE, VTLP ); 
          X = and_edge( A, OD, false ); 
          sLAYER_262 = edge_size( X, outside = ( VTL_P_EN_1 - VTL_P_EN_2 ) ); 
          B = sLAYER_262 or A; 
          C = size( B, clip_acute = NONE, distance = VTL_P_EN_2 ); 
          C not VTLP; 
      } /* end of rule : VTL_P.EN.1__VTL_P.EN.2 */
      rVTL_P_A_1 @= { @ "VTL_P.A.1 : Min. VTL_P area >= " + VTL_P_A_1 + " um"; 
          sLAYER_263 = area( VTLPS, < VTL_P_A_1 ); 
          sLAYER_263 not_inside SRAM_EXCLUDE; 
      } /* end of rule : VTL_P.A.1 */
      rVTL_P_A_2 @= { @ "VTL_P.A.2 : Min. area of an enclosed VTL_P >= " + VTL_P_A_2 + " um"; 
          A = donut_holes( VTLP, area = < VTL_P_A_2PRE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          B = A not VTLP; 
          area( B, < VTL_P_A_2 ); 
      } /* end of rule : VTL_P.A.2 */
      rVTL_P_R_1 @= { @ "VTL_P.R.1 : Overlap NACT, VTHP, NT_N or OD2 is not allowed";
          VTLP and OD2; 
          VTLP and NTN; 
          VTLP and NACT; 
          VTLP and VTHP; 
      } /* end of rule : VTL_P.R.1 */
      
      //mVTL  CHECKS
      //============
      rMVTL_EN_1 @= { @ "mVTL.EN.1 : Enclosure of gate >= 0.05um";
          enclose( GATE, MVTL, < MVTL_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          sLAYER_264 = interacting( GATE, MVTL ); 
          sLAYER_264 not MVTL; 
      } /* end of rule : mVTL.EN.1 */
      rMVTL_S_1 @= { @ "mVTL.S.1 : Space to  gate >= 0.05um";
          external2( MVTL, GATE, < MVTL_S_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : mVTL.S.1 */
      rMVTL_R_1 @= { @ "mVTL.R.1 : Overlap of VTH_N,VTH_P,VTL_N,VTL_P, NT_N, or OD2 is not allowed.";
          MVTL and VTHN; 
          MVTL and VTHP; 
          MVTL and VTLN; 
          MVTL and VTLP; 
          MVTL and NTN; 
          MVTL and OD2; 
      } /* end of rule : mVTL.R.1 */
      
      //PP CHECKS
      //=========
      ODIMP = OD coincident_inside_edge IMP; 
      PP_BEDGE = and_edge( PP, OD, false ); 
      rPP_W_1 @= { @ "PP.W.1 : Width >= " + PP_W_1 + " um"; 
          sLAYER_265 = internal1( PP, < PP_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          sLAYER_265 not_inside SRAM_EXCLUDE; 
      } /* end of rule : PP.W.1 */
      rPP_S_1 @= { @ "PP.S.1 : Space >= " + PP_S_1 + " um"; 
          sLAYER_266 = external1( PP, < PP_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_266 not_inside SRAM_EXCLUDE; 
      } /* end of rule : PP.S.1 */
      rPP_S_2 @= { @ "PP.S.2 : Space to N+ACTIVE (non-butted) >= " + PP_S_2 + " um"; 
          external2( PP, NACT, < PP_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
          X = external2_edge( PP, NACT, < 0.001, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 0, look_thru = COINCIDENT, output_layer = LAYER2 ); 
          Y = edge_size( X, outside = 0.001 ); 
          not_interacting( Y, PPOD ); 
      } /* end of rule : PP.S.2 */
      
      // PP.S.3 is checked by PP.S.2 and PP.R.2
      rPP_S_4 @= { @ "PP.S.4 : Space to NW STRAP (non-butted) >= " + PP_S_4 + " um"; 
          external2( PP, NSTP, < PP_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
          X = external2_edge( PP, NSTP, < 0.001, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 0, look_thru = COINCIDENT, output_layer = LAYER2 ); 
          Y = edge_size( X, outside = 0.001 ); 
          not_interacting( Y, PPOD ); 
      } /* end of rule : PP.S.4 */
      rPP_S_5 @= { @ "PP.S.5 : {PP edge on OD} space to NMOS GATE >= " + PP_S_5 + " um"; 
          external2( GATEN_W, PP_BEDGE, < PP_S_5, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
      } /* end of rule : PP.S.5 */
      gLAYER_1148 = extend_edge( GATEN_W, start = PP_S_6_J, end = PP_S_6_J ); 
      EX_GATEN = edge_size( gLAYER_1148, outside = PP_S_6 ); 
      rPP_S_6 @= { @ "PP.S.6 : Butted PW STRAP space to PO in the same OD [the butted N+ACTIVE extending 0 < J1 < 0.16 mm] >= " + PP_S_6 + " um"; 
          A = EX_GATEN and BUTT_PSTP; 
          B = EX_GATEN and NACT; 
          C = interacting( A, B ); 
          D = interacting( SD, C ); 
          E = GATEN_W coincident_outside_edge D; 
          sLAYER_1306 = extend_edge( E, start = PP_S_6_J, end = PP_S_6_J ); 
          F = edge_size( sLAYER_1306, outside = PP_S_6 ); 
          C and F; 
      } /* end of rule : PP.S.6 */
      rPP_S_7 @= { @ "PP.S.7 : Space to N-type unsilicided OD/PO >= " + PP_S_7 + " um"; 
          external2( PP, NYRE, < PP_S_7, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : PP.S.7 */
      rPP_EN_1 @= { @ "PP.EN.1 : {NP OR PP} enclosure of PO (except DPO) >= " + PP_EN_1 + " um"; 
          enclose( POLY, IMP, < PP_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          sLAYER_268 = POLY not SRAM_EXCLUDE; 
          sLAYER_267 = sLAYER_268 not LOGO; 
          sLAYER_267 not IMP; 
      } /* end of rule : PP.EN.1 */
      rPP_EX_1 @= { @ "PP.EX.1 : Extension on P+ACTIVE >= " + PP_EX_1 + " um"; 
          enclose( PACT, PP, < PP_EX_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
          X = enclose_edge( PACT, PP, < 0.001, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 0, look_thru = NOT_CONTAINED, output_layer = LAYER1 ); 
          Y = edge_size( X, outside = 0.001 ); 
          not_interacting( Y, NPOD ); 
          sLAYER_269 = edge_size( ODIMP, inside = 0.001 ); 
          sLAYER_269 and PACT; 
      } /* end of rule : PP.EX.1 */
      rPP_EX_2 @= { @ "PP.EX.2 : Extension on PW STRAP >= " + PP_EX_2 + " um"; 
          PSTP_CHECK = PSTP not SRCSR; 
          enclose( PSTP_CHECK, PP, < PP_EX_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
          X = enclose_edge( PSTP_CHECK, PP, < 0.001, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 0, look_thru = NOT_CONTAINED, output_layer = LAYER1 ); 
          Y = edge_size( X, outside = 0.001 ); 
          not_interacting( Y, NPOD ); 
          sLAYER_270 = edge_size( ODIMP, inside = 0.001 ); 
          sLAYER_270 and PSTP_CHECK; 
      } /* end of rule : PP.EX.2 */
      rPP_EX_3 @= { @ "PP.EX.3 : Extension on P-type unsilicided OD/PO >= " + PP_EX_3 + " um"; 
          enclose_edge( AYRE, PP, < PP_EX_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
          enclose_edge( AYRE, PP, < PP_EX_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
      } /* end of rule : PP.EX.3 */
      rPP_EX_4 @= { @ "PP.EX.4 : {PP edge on OD} extension on PMOS GATE >= " + PP_EX_4 + " um"; 
          enclose( GATEP_W, PP_BEDGE, < PP_EX_4, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.004 ); 
      } /* end of rule : PP.EX.4 */
      rPP_O_1 @= { @ "PP.O.1 : Overlap of PP and OD >= " + PP_O_1 + " um"; 
          internal2( OD, PP, < PP_O_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = RELATED_COINCIDENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : PP.O.1 */
      rPP_A_1 @= { @ "PP.A.1 : Area >= " + PP_A_1 + " um2"; 
          area( PP, < PP_A_1 ); 
      } /* end of rule : PP.A.1 */
      rPP_A_2 @= { @ "PP.A.2 : Enclosed area >= " + PP_A_2 + " um2"; 
          A = donut_holes( PP, area = < PP_A_2PRE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          B = A not PP; 
          sLAYER_271 = area( B, < PP_A_2 ); 
          sLAYER_271 not_inside SRAM_EXCLUDE; 
      } /* end of rule : PP.A.2 */
      rPP_A_3 @= { @ "PP.A.3 : Area of butted PW STRAP >= " + PP_A_3 + " um"; 
          area( BUTT_PSTP, < PP_A_3 ); 
      } /* end of rule : PP.A.3 */
      rPP_R_1 @= { @ "PP.R.1 : PP must fully cover {PMOS GATE SIZING 0.16 um} >= " + PP_R_1 + " um"; 
          EXGATE_PP = size( GATE_PP, clip_acute = NONE, distance = PP_R_1 ); 
          EXGATE_PP not PP; 
      } /* end of rule : PP.R.1 */
      rPP_R_2 @= { @ "PP.R.2 : Overlap of NP is not allowed";
          PP and gNP; 
      } /* end of rule : PP.R.2 */
      
      // PP.R.3 is checked by OD.R.1
      
      // PP.R.4 is checked by PP.EN.1
      
      //NP CHECKS
      //=========
      NP_BEDGE = and_edge( gNP, OD, false ); 
      rNP_W_1 @= { @ "NP.W.1 : Width >= " + NP_W_1 + " um"; 
          sLAYER_272 = internal1( gNP, < NP_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          sLAYER_272 not_inside SRAM_EXCLUDE; 
      } /* end of rule : NP.W.1 */
      rNP_S_1 @= { @ "NP.S.1 : Space >= " + NP_S_1 + " um"; 
          sLAYER_273 = external1( gNP, < NP_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_273 not_inside SRAM_EXCLUDE; 
      } /* end of rule : NP.S.1 */
      rNP_S_2 @= { @ "NP.S.2 : Space to P+ACTIVE (non-butted) >= " + NP_S_2 + " um"; 
          external2( gNP, PACT, < NP_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
          X = external2_edge( gNP, PACT, < 0.001, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 0, look_thru = COINCIDENT, output_layer = LAYER2 ); 
          Y = edge_size( X, outside = 0.001 ); 
          not_interacting( Y, NPOD ); 
      } /* end of rule : NP.S.2 */
      
      // NP.S.3 is checked by NP.S.2 and PP.R.2
      rNP_S_4 @= { @ "NP.S.4 : Space to PW STRAP (non-butted) >= " + NP_S_4 + " um"; 
          external2( gNP, PSTP, < NP_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
          X = external2_edge( gNP, PSTP, < 0.001, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 0, look_thru = COINCIDENT, output_layer = LAYER2 ); 
          Y = edge_size( X, outside = 0.001 ); 
          not_interacting( Y, NPOD ); 
      } /* end of rule : NP.S.4 */
      rNP_S_5 @= { @ "NP.S.5 : {NP edge on OD} space to PMOS GATE >= " + NP_S_5 + " um"; 
          external2( GATEP_W, NP_BEDGE, < NP_S_5, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
      } /* end of rule : NP.S.5 */
      gLAYER_1149 = extend_edge( GATEP_W, start = NP_S_6_J, end = NP_S_6_J ); 
      EX_GATEP = edge_size( gLAYER_1149, outside = NP_S_6 ); 
      rNP_S_6 @= { @ "NP.S.6 : Butted NW STRAP space to PO in the same OD [the butted P+ACTIVE extending 0 < J1 < 0.16 um] >= " + NP_S_6 + " um"; 
          A = EX_GATEP and BUTT_NSTP; 
          B = EX_GATEP and PACT; 
          C = interacting( A, B ); 
          D = interacting( SD, C ); 
          E = GATEP_W coincident_outside_edge D; 
          sLAYER_1307 = extend_edge( E, start = NP_S_6_J, end = NP_S_6_J ); 
          F = edge_size( sLAYER_1307, outside = NP_S_6 ); 
          C and F; 
      } /* end of rule : NP.S.6 */
      rNP_S_7 @= { @ "NP.S.7 : Space to P-type unsilicided OD/PO >= " + NP_S_7 + " um"; 
          external2( gNP, PYRE, < NP_S_7, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : NP.S.7 */
      
      // NP.EN.1 is checked by PP.EN.1
      rNP_EX_1 @= { @ "NP.EX.1 : Extension on N+ACTIVE >= " + NP_EX_1 + " um"; 
          A = NACT not ODWR; 
          enclose( A, gNP, < NP_EX_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
          X = enclose_edge( A, gNP, < 0.001, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 0, look_thru = NOT_CONTAINED, output_layer = LAYER1 ); 
          Y = edge_size( X, outside = 0.001 ); 
          not_interacting( Y, PPOD ); 
          sLAYER_274 = edge_size( ODIMP, inside = 0.001 ); 
          sLAYER_274 and NACT; 
      } /* end of rule : NP.EX.1 */
      rNP_EX_2 @= { @ "NP.EX.2 : Extension on NW STRAP >= " + NP_EX_2 + " um"; 
          enclose( NSTP, gNP, < NP_EX_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
          X = enclose_edge( NSTP, gNP, < 0.001, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 0, look_thru = NOT_CONTAINED, output_layer = LAYER1 ); 
          Y = edge_size( X, outside = 0.001 ); 
          not_interacting( Y, PPOD ); 
          sLAYER_275 = edge_size( ODIMP, inside = 0.001 ); 
          sLAYER_275 and NSTP; 
      } /* end of rule : NP.EX.2 */
      rNP_EX_3 @= { @ "NP.EX.3 : Extension on N-type unsilicided OD/PO >= " + NP_EX_3 + " um"; 
          enclose( AYRE, gNP, < NP_EX_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : NP.EX.3 */
      rNP_EX_4 @= { @ "NP.EX.4 : {NP edge on OD} extension on NMOS GATE >= " + NP_EX_4 + " um"; 
          enclose( GATEN_W, NP_BEDGE, < NP_EX_4, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.004 ); 
      } /* end of rule : NP.EX.4 */
      rNP_O_1 @= { @ "NP.O.1 : Overlap of OD >= " + NP_O_1 + " um"; 
          internal2( OD, gNP, < NP_O_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = RELATED_COINCIDENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : NP.O.1 */
      rNP_A_1 @= { @ "NP.A.1 : Area >= " + NP_A_1 + " um2"; 
          area( gNP, < NP_A_1 ); 
      } /* end of rule : NP.A.1 */
      rNP_A_2 @= { @ "NP.A.2 : Enclosed area >= " + NP_A_2 + " um2"; 
          A = donut_holes( gNP, area = < NP_A_2PRE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          B = A not gNP; 
          sLAYER_276 = area( B, < NP_A_2 ); 
          sLAYER_276 not_inside SRAM_EXCLUDE; 
      } /* end of rule : NP.A.2 */
      rNP_A_3 @= { @ "NP.A.3 : Area of butted NW STRAP >= " + NP_A_3 + " um"; 
          area( BUTT_NSTP, < NP_A_3 ); 
      } /* end of rule : NP.A.3 */
      rNP_R_1 @= { @ "NP.R.1 : NP must fully cover {NMOS GATE SIZING 0.16 um} >= " + NP_R_1 + " um"; 
          EXGATE_NP = size( GATE_NP, clip_acute = NONE, distance = NP_R_1 ); 
          EXGATE_NP not gNP; 
      } /* end of rule : NP.R.1 */
      VTLND = copy( VTLN ); 
      VTLPD = copy( VTLP ); 
      NP_NOT_NW = gNP not NWEL; 
      gLAYER_182 = NP_NOT_NW not OD2; 
      gLAYER_181 = gLAYER_182 not RH; 
      gLAYER_180 = gLAYER_181 not BJTDMY; 
      NLDDN1 = gLAYER_180 not VAR; 
      NLDDN_CORE1 = NLDDN1 not DCO; 
      NLDDN_CORE2 = NLDDN1 and DCO; 
      gLAYER_184 = size( NLDDN_CORE1, clip_acute = NONE, distance = NLDDN1V_SU ); 
      gLAYER_183 = size( gLAYER_184, clip_acute = NONE, distance = - NLDDN1V_SD ); 
      NLDDN1V_CORE1 = size( gLAYER_183, clip_acute = NONE, distance = NLDDN1V_SU ); 
      gLAYER_186 = size( NLDDN_CORE2, clip_acute = NONE, distance = NLDDN1V_SU ); 
      gLAYER_185 = size( gLAYER_186, clip_acute = NONE, distance = - NLDDN1V_SD ); 
      NLDDN1V_CORE2 = size( gLAYER_185, clip_acute = NONE, distance = NLDDN1V_SU ); 
      gLAYER_190 = NP_NOT_NW and OD2; 
      gLAYER_189 = gLAYER_190 not RH; 
      gLAYER_188 = gLAYER_189 not BJTDMY; 
      gLAYER_187 = gLAYER_188 not VAR; 
      NLDDN2 = gLAYER_187 not DCO; 
      gLAYER_192 = size( NLDDN2, clip_acute = NONE, distance = NLDDN2V_SU ); 
      gLAYER_191 = size( gLAYER_192, clip_acute = NONE, distance = - NLDDN2V_SD ); 
      NLDDN2V = size( gLAYER_191, clip_acute = NONE, distance = NLDDN2V_SU ); 
      gLAYER_197 = OD2 or DCO; 
      gLAYER_196 = gLAYER_197 or NWEL; 
      gLAYER_195 = gLAYER_196 or VTLND; 
      gLAYER_194 = size( gLAYER_195, clip_acute = NONE, distance = VTLN_SU ); 
      gLAYER_193 = size( gLAYER_194, clip_acute = NONE, distance = - VTLN_SD ); 
      VTL_N_LD = size( gLAYER_193, clip_acute = NONE, distance = VTLN_SU ); 
      PP_AND_NW = PP and NWEL; 
      gLAYER_200 = PP_AND_NW not OD2; 
      gLAYER_199 = gLAYER_200 not RH; 
      gLAYER_198 = gLAYER_199 not BJTDMY; 
      PLDDP1 = gLAYER_198 not VAR; 
      PLDDP_CORE1 = PLDDP1 not DCO; 
      PLDDP_CORE2 = PLDDP1 and DCO; 
      gLAYER_202 = size( PLDDP_CORE1, clip_acute = NONE, distance = PLDDP1V_SU ); 
      gLAYER_201 = size( gLAYER_202, clip_acute = NONE, distance = - PLDDP1V_SD ); 
      PLDDP1V_CORE1 = size( gLAYER_201, clip_acute = NONE, distance = PLDDP1V_SU ); 
      gLAYER_204 = size( PLDDP_CORE2, clip_acute = NONE, distance = PLDDP1V_SU ); 
      gLAYER_203 = size( gLAYER_204, clip_acute = NONE, distance = - PLDDP1V_SD ); 
      PLDDP1V_CORE2 = size( gLAYER_203, clip_acute = NONE, distance = PLDDP1V_SU ); 
      gLAYER_208 = PP_AND_NW and OD2; 
      gLAYER_207 = gLAYER_208 not RH; 
      gLAYER_206 = gLAYER_207 not BJTDMY; 
      gLAYER_205 = gLAYER_206 not VAR; 
      PLDDP2 = gLAYER_205 not DCO; 
      gLAYER_210 = size( PLDDP2, clip_acute = NONE, distance = PLDDP2V_SU ); 
      gLAYER_209 = size( gLAYER_210, clip_acute = NONE, distance = - PLDDP2V_SD ); 
      PLDDP2V = size( gLAYER_209, clip_acute = NONE, distance = PLDDP2V_SU ); 
      gLAYER_215 = NWEL not OD2; 
      gLAYER_214 = gLAYER_215 not VTLPD; 
      gLAYER_213 = gLAYER_214 not DCO; 
      gLAYER_212 = size( gLAYER_213, clip_acute = NONE, distance = VTLP_SU ); 
      gLAYER_211 = size( gLAYER_212, clip_acute = NONE, distance = - VTLP_SD ); 
      VTL_P_LD = size( gLAYER_211, clip_acute = NONE, distance = VTLP_SU ); 
      
      // LDN.EX.1 is checked by LDN.EX.1 and LDN.EX.1:DCO
      rLDN_EX_1 @= { @ "LDN.EX.1 : NP extension on NW  >= " + LDN_EX_1 + " " 
                                  "LDN.EX.2  NP extension on {OD2 OR DCO} >= " + LDN_EX_1 + " " 
                                  "LDN.EX.3  NP extension on {RH OR BJTDMY} >= " + LDN_EX_1 + " " 
                                  "LDN.EX.4  NP extension on VAR >= " + LDN_EX_1; 
          A = internal1( NLDDN1V_CORE1, < LDN_EX_1, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          B = external1( NLDDN1V_CORE1, < LDN_EX_1, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_277 = not_contains( A, { 0.1, LDN_EX_1 } ); 
          sLAYER_277 not_inside SRAM_EXCLUDE; 
          sLAYER_278 = not_contains( B, { 0.1, LDN_EX_1 } ); 
          sLAYER_278 not_inside SRAM_EXCLUDE; 
          C = size( DCO, clip_acute = NONE, distance = 0.005 ); 
          D = internal1( C, <= 0.015, extension = RADIAL, intersecting = {  } ); 
          sLAYER_279 = internal1( NLDDN1V_CORE1, < LDN_EX_1, corner_configuration = CORNER_TO_CORNER_OR_EDGE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          E = sLAYER_279 not_inside SRAM_EXCLUDE; 
          not_interacting( E, D ); 
          sLAYER_280 = internal1( NLDDN1V_CORE1, < LDN_EX_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection = { ON } ); 
          sLAYER_280 not_inside SRAM_EXCLUDE; 
          sLAYER_281 = external1( NLDDN1V_CORE1, < LDN_EX_1, corner_configuration = CORNER_TO_CORNER_OR_EDGE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          F = sLAYER_281 not_inside SRAM_EXCLUDE; 
          not_interacting( F, D ); 
          sLAYER_282 = external1( NLDDN1V_CORE1, < LDN_EX_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection = { ON } ); 
          sLAYER_282 not_inside SRAM_EXCLUDE; 
      } /* end of rule : LDN.EX.1 */
      rLDN_EX_1_DCO @= { @ "LDN.EX.1:DCO : NP extension on NW  >= " + LDN_EX_1 + " " 
                                          "LDN.EX.2  NP extension on OD2 >= " + LDN_EX_1 + " " 
                                          "LDN.O.1   NP overlap of DCO   >= " + LDN_EX_1 + " " 
                                          "LDN.EX.3  NP extension on {RH OR BJTDMY} >= " + LDN_EX_1 + " " 
                                          "LDN.EX.4  NP extension on VAR >= " + LDN_EX_1; 
          A = internal1( NLDDN1V_CORE2, < LDN_EX_1, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          B = external1( NLDDN1V_CORE2, < LDN_EX_1, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_283 = not_contains( A, { 0.1, LDN_EX_1 } ); 
          sLAYER_283 not_inside SRAM_EXCLUDE; 
          sLAYER_284 = not_contains( B, { 0.1, LDN_EX_1 } ); 
          sLAYER_284 not_inside SRAM_EXCLUDE; 
          C = size( DCO, clip_acute = NONE, distance = 0.005 ); 
          D = internal1( C, <= 0.015, extension = RADIAL, intersecting = {  } ); 
          sLAYER_285 = internal1( NLDDN1V_CORE2, < LDN_EX_1, corner_configuration = CORNER_TO_CORNER_OR_EDGE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          E = sLAYER_285 not_inside SRAM_EXCLUDE; 
          not_interacting( E, D ); 
          sLAYER_286 = internal1( NLDDN1V_CORE2, < LDN_EX_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection = { ON } ); 
          sLAYER_286 not_inside SRAM_EXCLUDE; 
          sLAYER_287 = external1( NLDDN1V_CORE2, < LDN_EX_1, corner_configuration = CORNER_TO_CORNER_OR_EDGE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          F = sLAYER_287 not_inside SRAM_EXCLUDE; 
          not_interacting( F, D ); 
          sLAYER_288 = external1( NLDDN1V_CORE2, < LDN_EX_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection = { ON } ); 
          sLAYER_288 not_inside SRAM_EXCLUDE; 
      } /* end of rule : LDN.EX.1:DCO */
      rLDN_O_1 @= { @ "LDN.O.1 : NP overlap of OD2  >= " + LDN_O_1 + ". " 
                                "LDN.EX.1  NP extension on NW  >= " + LDN_O_1 + " " 
                                "LDN.EX.3  NP extension on {RH OR BJTDMY} >= " + LDN_O_1 + " " 
                                "LDN.EX.4  NP extension on VAR >= " + LDN_O_1; 
          A = internal1( NLDDN2V, < LDN_O_1, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          B = external1( NLDDN2V, < LDN_O_1, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_289 = not_contains( A, { 0.1, LDN_O_1 } ); 
          sLAYER_289 not_inside SRAM_EXCLUDE; 
          sLAYER_290 = not_contains( B, { 0.1, LDN_O_1 } ); 
          sLAYER_290 not_inside SRAM_EXCLUDE; 
          sLAYER_291 = internal1( NLDDN2V, < LDN_O_1, corner_configuration = CORNER_TO_CORNER_OR_EDGE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          sLAYER_291 not_inside SRAM_EXCLUDE; 
          sLAYER_292 = internal1( NLDDN2V, < LDN_O_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection = { ON } ); 
          sLAYER_292 not_inside SRAM_EXCLUDE; 
          sLAYER_293 = external1( NLDDN2V, < LDN_O_1, corner_configuration = CORNER_TO_CORNER_OR_EDGE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_293 not_inside SRAM_EXCLUDE; 
          sLAYER_294 = external1( NLDDN2V, < LDN_O_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection = { ON } ); 
          sLAYER_294 not_inside SRAM_EXCLUDE; 
      } /* end of rule : LDN.O.1 */
      
      // LDN.EX.1 is checked by LDN.EX.1 and LDN.O.1
      // LDN.EX.2 is checked by LDN.EX.1 
      // LDN.EX.3 is checked by LDN.EX.1 and LDN.O.1
      // LDN.EX.4 is checked by LDN.EX.1 and LDN.O.1
      // LDN.O.1  is checked by LDN.EX.1 and LDN.O.1 
      // LDP.EX.1 is checked by LDP.EX.1 and LDP.EX.1:DCO
      rLDP_EX_1 @= { @ "LDP.EX.1 : PP extension on {OD2 OR DCO} >= " + LDP_EX_1 + " " 
                                  "LDP.EX.2  PP extension on {RH OR BJTDMY} >= " + LDP_EX_1 + " " 
                                  "LDP.EX.3  PP extension on VAR  >= " + LDP_EX_1 + " " 
                                  "LDP.O.1  PP overlap of NW  >= " + LDP_EX_1; 
          A = internal1( PLDDP1V_CORE1, < LDP_EX_1, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          B = external1( PLDDP1V_CORE1, < LDP_EX_1, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_295 = not_contains( A, { 0.1, LDP_EX_1 } ); 
          sLAYER_295 not_inside SRAM_EXCLUDE; 
          sLAYER_296 = not_contains( B, { 0.1, LDP_EX_1 } ); 
          sLAYER_296 not_inside SRAM_EXCLUDE; 
          C = size( DCO, clip_acute = NONE, distance = 0.005 ); 
          D = internal1( C, <= 0.015, extension = RADIAL, intersecting = {  } ); 
          sLAYER_297 = internal1( PLDDP1V_CORE1, < LDP_EX_1, corner_configuration = CORNER_TO_CORNER_OR_EDGE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          E = sLAYER_297 not_inside SRAM_EXCLUDE; 
          not_interacting( E, D ); 
          sLAYER_298 = internal1( PLDDP1V_CORE1, < LDP_EX_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection = { ON } ); 
          sLAYER_298 not_inside SRAM_EXCLUDE; 
          sLAYER_299 = external1( PLDDP1V_CORE1, < LDP_EX_1, corner_configuration = CORNER_TO_CORNER_OR_EDGE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          F = sLAYER_299 not_inside SRAM_EXCLUDE; 
          not_interacting( F, D ); 
          sLAYER_300 = external1( PLDDP1V_CORE1, < LDP_EX_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection = { ON } ); 
          sLAYER_300 not_inside SRAM_EXCLUDE; 
      } /* end of rule : LDP.EX.1 */
      rLDP_EX_1_DCO @= { @ "LDP.EX.1:DCO : PP extension on OD2 >= " + LDP_EX_1 + " " 
                                          "LDP.O.2  PP overlap of DCO >= " + LDP_EX_1 + " " 
                                          "LDP.EX.2  PP extension on {RH OR BJTDMY} >= " + LDP_EX_1 + " " 
                                          "LDP.EX.3  PP extension on VAR >= " + LDP_EX_1 + " " 
                                          "LDP.O.1  PP overlap of NW >= " + LDP_EX_1; 
          A = internal1( PLDDP1V_CORE2, < LDP_EX_1, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          B = external1( PLDDP1V_CORE2, < LDP_EX_1, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_301 = not_contains( A, { 0.1, LDP_EX_1 } ); 
          sLAYER_301 not_inside SRAM_EXCLUDE; 
          sLAYER_302 = not_contains( B, { 0.1, LDP_EX_1 } ); 
          sLAYER_302 not_inside SRAM_EXCLUDE; 
          C = size( DCO, clip_acute = NONE, distance = 0.005 ); 
          D = internal1( C, <= 0.015, extension = RADIAL, intersecting = {  } ); 
          sLAYER_303 = internal1( PLDDP1V_CORE2, < LDP_EX_1, corner_configuration = CORNER_TO_CORNER_OR_EDGE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          E = sLAYER_303 not_inside SRAM_EXCLUDE; 
          not_interacting( E, D ); 
          sLAYER_304 = internal1( PLDDP1V_CORE2, < LDP_EX_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection = { ON } ); 
          sLAYER_304 not_inside SRAM_EXCLUDE; 
          sLAYER_305 = external1( PLDDP1V_CORE2, < LDP_EX_1, corner_configuration = CORNER_TO_CORNER_OR_EDGE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          F = sLAYER_305 not_inside SRAM_EXCLUDE; 
          not_interacting( F, D ); 
          sLAYER_306 = external1( PLDDP1V_CORE2, < LDP_EX_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection = { ON } ); 
          sLAYER_306 not_inside SRAM_EXCLUDE; 
      } /* end of rule : LDP.EX.1:DCO */
      rLDP_O_2 @= { @ "LDP.O.2 : PP overlap of OD2 >= " + LDP_O_2 + " " 
                                "LDP.EX.2  PP extension on {RH OR BJTDMY} >= " + LDP_O_2 + " " 
                                "LDP.EX.3  PP extension on VAR >= " + LDP_O_2 + " " 
                                "LDP.O.1  PP overlap of NW >= " + LDP_O_2; 
          A = internal1( PLDDP2V, < LDP_O_2, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          B = external1( PLDDP2V, < LDP_O_2, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_307 = not_contains( A, { 0.1, LDP_O_2 } ); 
          sLAYER_307 not_inside SRAM_EXCLUDE; 
          sLAYER_308 = not_contains( B, { 0.1, LDP_O_2 } ); 
          sLAYER_308 not_inside SRAM_EXCLUDE; 
          sLAYER_309 = internal1( PLDDP2V, < LDP_O_2, corner_configuration = CORNER_TO_CORNER_OR_EDGE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          sLAYER_309 not_inside SRAM_EXCLUDE; 
          sLAYER_310 = internal1( PLDDP2V, < LDP_O_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection = { ON } ); 
          sLAYER_310 not_inside SRAM_EXCLUDE; 
          sLAYER_311 = external1( PLDDP2V, < LDP_O_2, corner_configuration = CORNER_TO_CORNER_OR_EDGE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_311 not_inside SRAM_EXCLUDE; 
          sLAYER_312 = external1( PLDDP2V, < LDP_O_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection = { ON } ); 
          sLAYER_312 not_inside SRAM_EXCLUDE; 
      } /* end of rule : LDP.O.2 */
      
      // LDP.EX.2 is checked by LDP.EX.1 and LDP.O.2
      // LDP.EX.3 is checked by LDP.EX.1 and LDP.O.2
      // LDP.O.1  is checked by LDP.EX.1 and LDP.O.2
      // LDP.O.2  is checked by LDP.EX.1 and LDP.O.2
      rVT_S_1 @= { @ "VT.S.1 : VTL_N space to {OD2 OR NW OR DCO} >= " + VT_S_1; 
          A = internal1( VTL_N_LD, < VT_S_1, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          B = external1( VTL_N_LD, < VT_S_1, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          not_contains( A, { 0.1, VT_S_1 } ); 
          not_contains( B, { 0.1, VT_S_1 } ); 
          internal1_error( VTL_N_LD, < VT_S_1, corner_configuration = CORNER_TO_CORNER_OR_EDGE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
          internal1_error( VTL_N_LD, < VT_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection = { ON } ); 
          external1_error( VTL_N_LD, < VT_S_1, corner_configuration = CORNER_TO_CORNER_OR_EDGE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT ); 
          external1_error( VTL_N_LD, < VT_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection = { ON } ); 
          C = size( VTLN, clip_acute = NONE, distance = GRID ); 
          D = C and OD2; 
          area( D, < 0.0005 ); 
          E = C and NWEL; 
          area( E, < 0.0005 ); 
          F = C and DCO; 
          area( F, < 0.0005 ); 
      } /* end of rule : VT.S.1 */
      rVT_EX_2 @= { @ "VT.EX.2 : NW extension on {OD2 OR VTL_P OR DCO} >= " + VT_EX_2; 
          A = internal1( VTL_P_LD, < VT_EX_2, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          B = external1( VTL_P_LD, < VT_EX_2, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          not_contains( A, { 0.1, VT_EX_2 } ); 
          not_contains( B, { 0.1, VT_EX_2 } ); 
          internal1_error( VTL_P_LD, < VT_EX_2, corner_configuration = CORNER_TO_CORNER_OR_EDGE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
          internal1_error( VTL_P_LD, < VT_EX_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection = { ON } ); 
          external1_error( VTL_P_LD, < VT_EX_2, corner_configuration = CORNER_TO_CORNER_OR_EDGE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT ); 
          external1_error( VTL_P_LD, < VT_EX_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection = { ON } ); 
          C = size( VTLP, clip_acute = NONE, distance = GRID ); 
          D = C not NWEL; 
          area( D, < 0.0005 ); 
          E = C and OD2; 
          area( E, < 0.0005 ); 
          F = C and DCO; 
          area( F, < 0.0005 ); 
      } /* end of rule : VT.EX.2 */
      #ifdef LPG 
         
         //DCO CHECKS
         //==========
         DCO_EDGE_45 = angle_edge( DCOS, == 45 ); 
         rDCO_W_1 @= { @ "DCO.W.1 : Width (except Point touch of vertex [Width >= 0.4 um]) >= " + DCO_W_1 + " um"; 
             sLAYER_313 = internal1( DCOS, < DCO_W_1, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
             sLAYER_313 not_inside SRAM_EXCLUDE; 
             sLAYER_314 = internal1( DCOS, < DCO_W_1, corner_configuration = CORNER_TO_CORNER_OR_EDGE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
             sLAYER_314 not_inside SRAM_EXCLUDE;    /* allow point-touch */ 
             sLAYER_315 = internal1( DCOS, < DCO_R_5, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection = { ON } ); 
             sLAYER_315 not_inside SRAM_EXCLUDE; 
             A = external1_edge( DCOS, < 0.001, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { } ); 
             sLAYER_316 = internal1( A, ( (DCO_R_5 + 0.002), DCO_W_1 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection = { ON } ); 
             sLAYER_316 not_inside SRAM_EXCLUDE; 
             sLAYER_317 = internal2( DCO_EDGE_45, DCOS, < DCO_W_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = RELATED_COINCIDENT, width = 0.002 ); 
             sLAYER_317 not_inside SRAM_EXCLUDE; 
         } /* end of rule : DCO.W.1 */
         rDCO_S_1 @= { @ "DCO.S.1 : Space (except Point touch of vertex [Width >= 0.4 um]) >= " + DCO_S_1 + " um"; 
             external1( DCO, < DCO_S_1, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
             external1( DCO, < DCO_S_1, corner_configuration = CORNER_TO_CORNER_OR_EDGE, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT );    /* allow point-touch */ 
             external1( DCO, < DCO_R_5, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection = { ON } ); 
             A = internal1_edge( DCO, < 0.001, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, orientation = { } ); 
             external1( A, ( (DCO_R_5 + 0.002), DCO_S_1 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, orientation = { PARALLEL }, projection = { ON } ); 
             sLAYER_318 = external2( DCO_EDGE_45, DCOS, < DCO_S_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
             sLAYER_318 not_inside SRAM_EXCLUDE; 
         } /* end of rule : DCO.S.1 */
         rDCO_S_2 @= { @ "DCO.S.2 : Space to ACTIVE >= " + DCO_S_2 + " um"; 
             external2( DCO, DACT, < DCO_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
         } /* end of rule : DCO.S.2 */
         
         // DCO.S.3 is checked by DCO.S.3__DCO.S.4
         // DCO.S.4 is checked by DCO.S.3__DCO.S.4
         rDCO_S_3__DCO_S_4 @= { @ "DCO.S.3__DCO.S.4 : Space to LP(core 1.2V) gate in S/D direction >= " + DCO_S_3 + " um " 
                                                     "Space to LP(core 1.2V) gate in end-cap direction >= " + DCO_S_4 + " um"; 
             A = not_interacting( GATE, DCO ); 
             X = and_edge( A, OD, false ); 
             sLAYER_319 = edge_size( X, outside = ( DCO_S_3 - DCO_S_4 ) ); 
             B = sLAYER_319 or A; 
             C = size( B, clip_acute = NONE, distance = DCO_S_4 ); 
             DCO and C; 
         } /* end of rule : DCO.S.3__DCO.S.4 */
         rDCO_S_5 @= { @ "DCO.S.5 : Space to NW Space = 0 is allowed >= " + DCO_S_5 + " um"; 
             external2( DCO, NWEL, < DCO_S_5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
         } /* end of rule : DCO.S.5 */
         rDCO_S_6 @= { @ "DCO.S.6 : Space to OD2 Space = 0 is allowed >= " + DCO_S_6 + " um"; 
             external2( DCO, OD2, < DCO_S_6, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = COINCIDENT, relational = { POINT_TOUCH } ); 
         } /* end of rule : DCO.S.6 */
         
         // DCO.EN.1 is checked by DCO.EN.1__DCO.EN.2
         // DCO.EN.2 is checked by DCO.EN.1__DCO.EN.2
         rDCO_EN_1__DCO_EN_2 @= { @ "DCO.EN.1__DCO.EN.2 : Enclosure of G(core 1.0V) gate in S/D direction >= " + DCO_EN_1 + " um " 
                                                         "Enclosure of G(core 1.0V) gate in end-cap direction >= " + DCO_EN_2 + " um"; 
             A = interacting( GATE, DCO ); 
             X = and_edge( A, OD, false ); 
             sLAYER_320 = edge_size( X, outside = ( DCO_EN_1 - DCO_EN_2 ) ); 
             B = sLAYER_320 or A; 
             C = size( B, clip_acute = NONE, distance = DCO_EN_2 ); 
             C not DCO; 
         } /* end of rule : DCO.EN.1__DCO.EN.2 */
         rDCO_EX_1 @= { @ "DCO.EX.1 : NW extension on DCO. Extension = 0 is allowed >= " + DCO_EX_1 + " um"; 
             enclose( DCO, NWEL, < DCO_EX_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
         } /* end of rule : DCO.EX.1 */
         rDCO_EX_2 @= { @ "DCO.EX.2 : Extension on NW. Extension = 0 is allowed >= " + DCO_EX_2 + " um"; 
             enclose( NWEL, DCO, < DCO_EX_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
         } /* end of rule : DCO.EX.2 */
         rDCO_EX_3 @= { @ "DCO.EX.3 : Extension on Active [without Gate] >= " + DCO_EX_3 + " um"; 
             enclose( DACT, DCO, < DCO_EX_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
             sLAYER_321 = not_interacting( DACT, GATE ); 
             cutting( sLAYER_321, DCO ); 
         } /* end of rule : DCO.EX.3 */
         rDCO_A_1 @= { @ "DCO.A.1 : Area >= " + DCO_A_1 + " um2"; 
             sLAYER_322 = area( DCOS, < DCO_A_1 ); 
             sLAYER_322 not_inside SRAM_EXCLUDE; 
         } /* end of rule : DCO.A.1 */
         rDCO_A_2 @= { @ "DCO.A.2 : Enclosed area >= " + DCO_A_2 + " um2"; 
             A = donut_holes( DCO, area = < DCO_A_2PRE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
             B = A not DCO; 
             area( B, < DCO_A_2 ); 
         } /* end of rule : DCO.A.2 */
         rDCO_O_1 @= { @ "DCO.O.1 : Overlap of NW. Overlap = 0 is allowed >= " + DCO_O_1 + " um"; 
             X = DCOS and NWEL; 
             sLAYER_1308 = internal1( X, < DCO_O_1, extension = RADIAL, intersecting = { } ); 
             sLAYER_1309 = vertex( X, angles = { ( 0, 89.5 ) }, shape = TRIANGLE, shape_size = DCO_O_1 ); 
             sLAYER_323 = sLAYER_1308 or sLAYER_1309;
             sLAYER_323 not_inside SRAM_EXCLUDE; 
         } /* end of rule : DCO.O.1 */
         
         // DCO.R.1U is not necessary to check
         rDCO_R_2 @= { @ "DCO.R.2 : Overlap of OD2 is no allowed.";
             DCO and OD2; 
         } /* end of rule : DCO.R.2 */
         rDCO_R_3 @= { @ "DCO.R.3 : RH cut DCO is no allowed.";
             cutting( RH, DCO ); 
         } /* end of rule : DCO.R.3 */
         
         // DCO.R.5 is checked by DCO.W.1 and DCO.S.1
      #endif /* end of #ifdef LPG  */ 
      
      //RPO CHECKS
      //==========
      NOGT = GATE not SDI; 
      gLAYER_216 = FPO1 not ESD1DMY; 
      FPO1A = gLAYER_216 not ESD2DMY; 
      gLAYER_217 = size( RPO, clip_acute = NONE, distance = - RPO_EX_1_1_W / 2 ); 
      WIDE_RPO = interacting( RPO, gLAYER_217 ); 
      rRPO_W_1 @= { @ "RPO.W.1 : Width >= " + RPO_W_1 + " um"; 
          internal1( RPO, < RPO_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : RPO.W.1 */
      rRPO_S_1 @= { @ "RPO.S.1 : Space >= " + RPO_S_1 + " um"; 
          external1( RPO, < RPO_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : RPO.S.1 */
      rRPO_S_2 @= { @ "RPO.S.2 : Space to OD >= " + RPO_S_2 + " um"; 
          external2( RPO, OD, < RPO_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : RPO.S.2 */
      rRPO_S_3 @= { @ "RPO.S.3 : Space to CO (overlap of CO is not allowed.) >= " + RPO_S_3 + " um"; 
          external2( RPO, CO, < RPO_S_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          RPO and CO; 
      } /* end of rule : RPO.S.3 */
      rRPO_S_4 @= { @ "RPO.S.4 : Space to GATE (overlap of GATE is not allowed except ESD circuit.) >= " + RPO_S_4 + " um"; 
          external2( RPO, NOGT, < RPO_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          RPO and NOGT; 
      } /* end of rule : RPO.S.4 */
      rRPO_S_5 @= { @ "RPO.S.5 : Space to PO >= " + RPO_S_5 + " um"; 
          external2( RPO, FPO1, < RPO_S_5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : RPO.S.5 */
      rRPO_EX_1 @= { @ "RPO.EX.1 : Extension on unsilicided OD/PO >= " + RPO_EX_1 + " um"; 
          enclose( OD, RPO, < RPO_EX_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          enclose( FPO1A, RPO, < RPO_EX_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          RPO inside OD; 
          RPO inside FPO1A; 
      } /* end of rule : RPO.EX.1 */
      rRPO_EX_1_1 @= { @ "RPO.EX.1.1 : Extension on unsilicided OD/PO [RPO width > 10um] >= " + RPO_EX_1_1 + " um"; 
          enclose( OD, WIDE_RPO, < RPO_EX_1_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          enclose( FPO1A, WIDE_RPO, < RPO_EX_1_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : RPO.EX.1.1 */
      rRPO_EX_2 @= { @ "RPO.EX.2 : OD extension on RPO >= " + RPO_EX_2 + " um"; 
          enclose( RPO, OD, < RPO_EX_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : RPO.EX.2 */
      rRPO_A_1 @= { @ "RPO.A.1 : Area >= " + RPO_A_1 + " um2"; 
          sLAYER_324 = area( RPOS, < RPO_A_1 ); 
          sLAYER_324 not_inside SRAM_EXCLUDE; 
      } /* end of rule : RPO.A.1 */
      rRPO_A_2 @= { @ "RPO.A.2 : Enclosed area >= " + RPO_A_2 + " um2"; 
          A = donut_holes( RPO, area = < RPO_A_2PRE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          B = A not RPO; 
          area( B, < RPO_A_2 ); 
      } /* end of rule : RPO.A.2 */
      rRPO_R_1 @= { @ "RPO.R.1 : Butted NP/PP on unsilicided OD/PO is not allowed";
          sLAYER_325 = RPO and POLY; 
          sLAYER_326 = RPO and OD; 
          X = sLAYER_325 or sLAYER_326; 
          NX = X and gNP; 
          PX = X and PP; 
          Y = interacting( NX, PX ); 
          interacting( X, Y ); 
      } /* end of rule : RPO.R.1 */
      rRES_8 @= { @ "RES.8 : RH space to GATE (overlap is not allowed) >= " + RES_8 + " um"; 
          external2( RH, GATE, < RES_8, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          RH and GATE; 
      } /* end of rule : RES.8 */
      rRES_10 @= { @ "RES.10 : RPO intersecting (PO AND RH) must form two more POs (except BJT or ESD circuit)";
          sLAYER_327 = PORESG outside BJTDMY; 
          PORES_NOT_SDI_BJT = sLAYER_327 outside INDDMY; 
          X = PORES_NOT_SDI_BJT and RH; 
          A = POLY not X; 
          interacting( X, A, < 2 ); 
          not_interacting( X, A ); 
      } /* end of rule : RES.10 */
      rRES_11 @= { @ "RES.11 : RPO intersecting (OD AND RH) must form two more ODs (except BJT or ESD circuit)";
          ODRES_NOT_SDI_BJT = ODRES not SDI; 
          X = ODRES_NOT_SDI_BJT and RH; 
          A = OD not X; 
          interacting( X, A, < 2 ); 
          not_interacting( X, A ); 
      } /* end of rule : RES.11 */
      rRES_21 @= { @ "RES.21 : NP OD resistor is not allowed interacting with NW";
          sLAYER_330 = OD and gNP; 
          sLAYER_329 = sLAYER_330 and RH; 
          sLAYER_328 = sLAYER_329 and RPDMY; 
          interacting( sLAYER_328, NWI, include_touch = ALL ); 
      } /* end of rule : RES.21 */
      rRES_22 @= { @ "RES.22 : PP OD resistor is only allowed inside NW";
          sLAYER_333 = OD and PP; 
          sLAYER_332 = sLAYER_333 and RH; 
          sLAYER_331 = sLAYER_332 and RPDMY; 
          sLAYER_331 not_inside NWI; 
      } /* end of rule : RES.22 */
      #ifdef GUIDELINE_RES 
         rRES_12G @= { @ "RES.12g : {RPO AND PO} must be fully covered by RH except for BJT or ESD circuits";
             PORESG not RH; 
         } /* end of rule : RES.12g */
         rRES_13G @= { @ "RES.13g : {RPO AND OD} must be fully covered by RH except for BJT or ESD circuits";
             ODRES not RH; 
         } /* end of rule : RES.13g */
         
         // RES.15g is not necessary to check
      #endif /* end of #ifdef GUIDELINE_RES  */ 
      
      //VAR CHECKS
      //==========
      VAR_GATE = GATE not_outside VAR; 
      VAR_RF_GATE = VAR_GATE inside RFDMY; 
      VAR_GATE_W = GATE_W inside_touching_edge VAR_GATE; 
      VAR_RF_GATE_W = GATE_W inside_touching_edge VAR_RF_GATE; 
      VAR_RF_HV_GATE_W = and_edge( VAR_RF_GATE_W, OD2, false ); 
      VAR_RF_LV_GATE_W = or_edge( not_edge( VAR_RF_GATE_W, OD2 ), coincident_inside_edge( VAR_RF_GATE_W, OD2 ) ); 
      #ifndef HALF_NODE 
         #ifdef LP 
            PWEL_P_VAR = interacting( PWEL, VAR_GATE ); 
            rVAR_W_1_A @= { @ "VAR.W.1.a : Width of {gate AND VAR} >= " + VAR_W_1 + " um"; 
                internal1( VAR_GATE, < VAR_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
            } /* end of rule : VAR.W.1.a */
            rVAR_W_2_A @= { @ "VAR.W.2.a : Channel length of { (gate NOT OD2) AND VAR } for RF circuit >= 0.2";
                internal1( VAR_RF_LV_GATE_W, < VAR_W_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
            } /* end of rule : VAR.W.2.a */
            rVAR_W_3_A @= { @ "VAR.W.3.a : Channel length of { (gate AND OD2) AND VAR } for RF circuit >= 0.4";
                internal1( VAR_RF_HV_GATE_W, < VAR_W_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
            } /* end of rule : VAR.W.3.a */
            rVAR_W_4_A @= { @ "VAR.W.4.a : Channel width of { gate AND VAR } >= " + VAR_W_4 + " um"; 
                length_edge( VAR_GATE_W, < VAR_W_4 ); 
            } /* end of rule : VAR.W.4.a */
            rVAR_S_1_A @= { @ "VAR.S.1.a : Space to Active >= 0.13";
                external2( VAR, DACT, < VAR_S_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
            } /* end of rule : VAR.S.1.a */
            rVAR_EN_1_A @= { @ "VAR.EN.1.a : Enclosure of OD >= 0.16";
                enclose( OD, VAR, < VAR_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
                cutting( OD, VAR ); 
            } /* end of rule : VAR.EN.1.a */
            rVAR_R_1_A @= { @ "VAR.R.1.a : VAR layer must be drawn to fully cover the varactor devices.";
                VAR_GATE not VAR; 
            } /* end of rule : VAR.R.1.a */
            rVAR_R_2_A @= { @ "VAR.R.2.a : Overlap of VTL_N, VTL_P, VTH_N, VTH_P, mVTL, NT_N, or RPO is not allowed.";
                VAR and VTLN; 
                VAR and VTLP; 
                VAR and VTHN; 
                VAR and VTHP; 
                VAR and NTN; 
                VAR and MVTL; 
                VAR and RPO; 
            } /* end of rule : VAR.R.2.a */
            rVAR_R_4_A @= { @ "VAR.R.4.a : Overlap of {gate SIZING 0.16 um} is not allowed.";
                VAR_E = size( VAR, clip_acute = NONE, distance = VAR_W_1 );    /* For filtering only */ 
                sLAYER_334 = interacting( GATE, VAR_E ); 
                VAR_EXG = sLAYER_334 outside VAR; 
                VAR_EXGS = size( VAR_EXG, clip_acute = NONE, distance = VAR_R_4 ); 
                VAR and VAR_EXGS; 
            } /* end of rule : VAR.R.4.a */
            rVAR_R_5_A @= { @ "VAR.R.5.a : NP must fully cover ((((VAR AND GATE) SIZING 0.19) AND OD) SIZING 0.13) for NMOS in NW capcaitor";
                sLAYER_336 = VAR and GATE; 
                sLAYER_335 = sLAYER_336 and NWEL; 
                A = size( sLAYER_335, clip_acute = NONE, distance = VAR_R_5_1 ); 
                sLAYER_337 = A and OD; 
                B = size( sLAYER_337, clip_acute = NONE, distance = VAR_R_5_2 ); 
                B not gNP; 
            } /* end of rule : VAR.R.5.a */
            rVAR_R_6_A @= { @ "VAR.R.6.a : PP must fully cover ((((VAR AND GATE) SIZING 0.19) AND OD) SIZING 0.13) for PMOS in PW capcaitor";
                sLAYER_339 = VAR and GATE; 
                sLAYER_338 = sLAYER_339 not NWEL; 
                A = size( sLAYER_338, clip_acute = NONE, distance = VAR_R_6_1 ); 
                sLAYER_340 = A and OD; 
                B = size( sLAYER_340, clip_acute = NONE, distance = VAR_R_6_2 ); 
                B not PP; 
            } /* end of rule : VAR.R.6.a */
            rVAR_R_7_A @= { @ "VAR.R.7.a : P+/PW MOS VARs must fully covered by DNW";
                sLAYER_341 = PWEL_P_VAR not DNW; 
                PWEL_P_VAR_VIO = interacting( PWEL_P_VAR, sLAYER_341 ); 
                interacting( VAR_GATE, PWEL_P_VAR_VIO ); 
            } /* end of rule : VAR.R.7.a */
            rVAR_R_8_A @= { @ "VAR.R.8.a : P+/PW MOS VARs is fully surrounded by NWEL";
                NWEL_HOLE = donut_holes( NWEL, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
                PWEL_P_VAR_VIO2 = interacting( PWEL_P_VAR, NWEL_HOLE ); 
                cutting( VAR_GATE, PWEL_P_VAR_VIO2 ); 
                PWEL_P_VAR_VIO3 = PWEL_P_VAR not_inside NWEL_HOLE; 
                VAR_GATE inside PWEL_P_VAR_VIO3; 
            } /* end of rule : VAR.R.8.a */
         #endif /* end of #ifdef LP  */ 
      #endif /* end of #ifndef HALF_NODE  */ 
      rVAR_W_1 @= { @ "VAR.W.1 : Length of {gate AND VAR} >= " + VAR_W_1 + " um"; 
          internal1( VAR_GATE, < VAR_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : VAR.W.1 */
      rVAR_W_4 @= { @ "VAR.W.4 : Channel width of { gate AND VAR } >= " + VAR_W_4 + " um"; 
          length_edge( VAR_GATE_W, < VAR_W_4 ); 
      } /* end of rule : VAR.W.4 */
      rVAR_S_1 @= { @ "VAR.S.1 : Space to Active >= 0.13";
          external2( VAR, DACT, < VAR_S_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : VAR.S.1 */
      rVAR_EN_1 @= { @ "VAR.EN.1 : Enclosure of OD >= 0.16";
          enclose( OD, VAR, < VAR_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          cutting( OD, VAR ); 
      } /* end of rule : VAR.EN.1 */
      rVAR_R_1 @= { @ "VAR.R.1 : VAR layer must be drawn to fully cover the varactor devices.";
          VAR_GATE not VAR; 
      } /* end of rule : VAR.R.1 */
      rVAR_R_2 @= { @ "VAR.R.2 : Overlap of VTL_N, VTL_P, VTH_N, VTH_P, mVTL, NT_N, PW, or RPO is not allowed.";
          VAR and VTLN; 
          VAR and VTLP; 
          VAR and NTN; 
          VAR and VTHN; 
          VAR and VTHP; 
          VAR and MVTL; 
          VAR not NWEL; 
          VAR and RPO; 
      } /* end of rule : VAR.R.2 */
      rVAR_R_3 @= { @ "VAR.R.3 : PP overlap of {gate AND VAR} is not allowed.";
          VAR_GATE and PP; 
      } /* end of rule : VAR.R.3 */
      rVAR_R_4 @= { @ "VAR.R.4 : Overlap of {gate SIZING 0.16 um} is not allowed.";
          VAR_E = size( VAR, clip_acute = NONE, distance = VAR_W_1 );    /* For filtering only */ 
          sLAYER_342 = interacting( GATE, VAR_E ); 
          VAR_EXG = sLAYER_342 outside VAR; 
          VAR_EXGS = size( VAR_EXG, clip_acute = NONE, distance = VAR_R_4 ); 
          VAR and VAR_EXGS; 
      } /* end of rule : VAR.R.4 */
      rVAR_R_5 @= { @ "VAR.R.5 : NP must fully cover ((((VAR AND GATE) SIZING 0.19) AND OD) SIZING 0.13)";
          sLAYER_343 = VAR and GATE; 
          A = size( sLAYER_343, clip_acute = NONE, distance = VAR_R_5_1 ); 
          sLAYER_344 = A and OD; 
          B = size( sLAYER_344, clip_acute = NONE, distance = VAR_R_5_2 ); 
          B not gNP; 
      } /* end of rule : VAR.R.5 */
      #ifdef LP 
         #ifndef HALF_NODE 
            
            // N65LP HVD_N CHECKS
            //============
            HVD_NX = copy( HVD_N_NW ); 
            HVD_NMOS_DRAIN = interacting( SD, HVD_NX ); 
            HVD_NGATE = interacting( HV_GATE, HVD_NX ); 
            rHVD_N_W_1 @= { @ "HVD_N.W.1 : Width >= " + HVD_N_W_1 + " um"; 
                internal1( HVD_NX, < HVD_N_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
            } /* end of rule : HVD_N.W.1 */
            rHVD_N_W_2 @= { @ "HVD_N.W.2 : Channel width of {GATE interact HVD_N} >= " + HVD_N_W_2 + " um"; 
                HV_GATE_L = and_edge( GATE_L, OD2, false ); 
                A = HV_GATE_L coincident_inside_edge HVD_NGATE; 
                internal1( A, < HVD_N_W_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
            } /* end of rule : HVD_N.W.2 */
            rHVD_N_S_1 @= { @ "HVD_N.S.1 : Space >= " + HVD_N_S_1 + " um"; 
                external1( HVD_NX, < HVD_N_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
            } /* end of rule : HVD_N.S.1 */
            rHVD_N_S_2 @= { @ "HVD_N.S.2 : Space of two HVD_N with different optentials >= " + HVD_N_S_2 + " um"; 
                A = stamp( HVD_NX, NSDC, CONNECT_DB, CONNECT_DB_HVD_N_S_2, include_touch = NONE ); 
                external1( A, < HVD_N_S_2, connect_sequence = CONNECT_DB_HVD_N_S_2, connectivity = DIFFERENT_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
                B = not_interacting( HVD_NX, NSDC ); 
                external2( B, HVD_NX, < HVD_N_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, membership = DIFFERENT_POLYGON, relational = { POINT_TOUCH }, width = 0.002 ); 
            } /* end of rule : HVD_N.S.2 */
            rHVD_N_S_3 @= { @ "HVD_N.S.3 : Space to NW >= " + HVD_N_S_3 + " um"; 
                external2( HVD_NX, NWEL, < HVD_N_S_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
            } /* end of rule : HVD_N.S.3 */
            rHVD_N_S_4 @= { @ "HVD_N.S.4 : Space to PW STRAP (overlap is not allowed) >= " + HVD_N_S_4 + " um"; 
                external2( HVD_NX, PSTP, < HVD_N_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
                HVD_NX and PSTP; 
            } /* end of rule : HVD_N.S.4 */
            rHVD_N_S_5 @= { @ "HVD_N.S.5 : Space to N+ACTIVE >= " + HVD_N_S_5 + " um"; 
                external2( HVD_NX, NACT, < HVD_N_S_5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
            } /* end of rule : HVD_N.S.5 */
            rHVD_N_S_6 @= { @ "HVD_N.S.6 : Space to DNW >= " + HVD_N_S_6 + " um,overlap is not allowed"; 
                external2( HVD_NX, DNW, < HVD_N_S_6, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
                HVD_NX and DNW; 
            } /* end of rule : HVD_N.S.6 */
            rHVD_N_EX_1 @= { @ "HVD_N.EX.1 : Extension on N+ACTIVE (Drain side must be fully inside HVD_N) >= " + HVD_N_EX_1 + " um"; 
                enclose( NACT, HVD_NX, < HVD_N_EX_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
                HVD_NMOS_DRAIN not HVD_NX; 
            } /* end of rule : HVD_N.EX.1 */
            rHVD_N_O_1 @= { @ "HVD_N.O.1 : Overlap of {I/O NMOS GATE} >= " + HVD_N_O_1 + " um"; 
                A = HV_GATE_W coincident_outside_edge HVD_NMOS_DRAIN; 
                B = edge_size( A, inside = HVD_N_O_1 ); 
                C = HVD_NX and HVD_NGATE; 
                C xor B; 
                interacting( HVD_NGATE, B, > 1 ); 
            } /* end of rule : HVD_N.O.1 */
            rHVD_N_L_1 @= { @ "HVD_N.L.1 : Channel length of {GATE interact with HVD_N} >= " + HVD_N_L_1 + " um"; 
                A = HV_GATE_W coincident_inside_edge HVD_NGATE; 
                internal1( A, < HVD_N_L_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
            } /* end of rule : HVD_N.L.1 */
            rHVD_N_A_1 @= { @ "HVD_N.A.1 : Area >= " + HVD_N_A_1 + " um"; 
                area( HVD_NX, < HVD_N_A_1 ); 
            } /* end of rule : HVD_N.A.1 */
            rHVD_N_A_2 @= { @ "HVD_N.A.2 : Enclosed area >= " + HVD_N_A_2 + " um"; 
                A = donut_holes( HVD_NX, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
                B = A not HVD_NX; 
                area( B, < HVD_N_A_2 ); 
            } /* end of rule : HVD_N.A.2 */
            rHVD_N_R_1 @= { @ "HVD_N.R.1 : Overlap of NW is not allowed";
                HVD_NX and NWEL; 
            } /* end of rule : HVD_N.R.1 */
            rHVD_N_R_2 @= { @ "HVD_N.R.2 : HVD_N edge landing on OD without landing on GATE is not allowed";
                A = and_edge( HVD_NX, OD, false ); 
                AX = edge_size( A, outside = 0.005 ); 
                B = and_edge( HVD_NX, GATE, false ); 
                BX = edge_size( B, outside = 0.005 ); 
                AX not BX; 
            } /* end of rule : HVD_N.R.2 */
            rHVD_N_R_3 @= { @ "HVD_N.R.3 : HVD_N must be fully covered by OD_25";
                HVD_NX not OD_25; 
            } /* end of rule : HVD_N.R.3 */
            rHVD_N_R_4 @= { @ "HVD_N.R.4 : {(OD NOT PO) inside one HVD_N} must be the same potential";
                interacting( HVD_NX, NSDC, > 1, connect_sequence = CONNECT_DB, count_by = NET ); 
            } /* end of rule : HVD_N.R.4 */
            rHVD_N_R_6 @= { @ "HVD_N.R.6 : {(HVD_N interact OD) AND PO} must be a rectangle, "
                                          "a concave shape is not allowed";
                sLAYER_346 = interacting( HVD_NX, OD ); 
                sLAYER_345 = sLAYER_346 and POLY; 
                not_rectangles( sLAYER_345 );
            } /* end of rule : HVD_N.R.6 */
         #else /* the reverse of #ifndef HALF_NODE  */ 
            
            //N55LP HVD_N CHECKS
            //============
            HVD_NX = copy( HVD_N_NW ); 
            HVD_NMOS_DRAIN = interacting( SD, HVD_NX ); 
            HVD_NGATE = interacting( HV_GATE, HVD_NX ); 
            rHVD_N_W_1_A @= { @ "HVD_N.W.1.a : Width >= " + HVD_N_W_1_N55LP + " um"; 
                internal1( HVD_NX, < HVD_N_W_1_N55LP, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
            } /* end of rule : HVD_N.W.1.a */
            rHVD_N_W_2_A @= { @ "HVD_N.W.2.a : Channel width of {GATE INTERACT HVD_N} >= " + HVD_N_W_2_N55LP + " um"; 
                HV_GATE_L = and_edge( GATE_L, OD2, false ); 
                A = HV_GATE_L coincident_inside_edge HVD_NGATE; 
                internal1( A, < HVD_N_W_2_N55LP, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
            } /* end of rule : HVD_N.W.2.a */
            rHVD_N_S_1_A @= { @ "HVD_N.S.1.a : Space >= " + HVD_N_S_1_N55LP + " um"; 
                external1( HVD_NX, < HVD_N_S_1_N55LP, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
            } /* end of rule : HVD_N.S.1.a */
            rHVD_N_S_2_A @= { @ "HVD_N.S.2.a : Space of two HVD_N with different potentials >= " + HVD_N_S_2_N55LP + " um"; 
                A = stamp( HVD_NX, NSDC, CONNECT_DB, CONNECT_DB_HVD_N_S_2_A, include_touch = NONE ); 
                external1( A, < HVD_N_S_2_N55LP, connect_sequence = CONNECT_DB_HVD_N_S_2_A, connectivity = DIFFERENT_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
                B = not_interacting( HVD_NX, NSDC ); 
                external2( B, HVD_NX, < HVD_N_S_2_N55LP, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, membership = DIFFERENT_POLYGON, relational = { POINT_TOUCH }, width = 0.002 ); 
            } /* end of rule : HVD_N.S.2.a */
            rHVD_N_S_3_A @= { @ "HVD_N.S.3.a : Space to NW >= " + HVD_N_S_3_N55LP + " um"; 
                external2( HVD_NX, NWEL, < HVD_N_S_3_N55LP, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
            } /* end of rule : HVD_N.S.3.a */
            rHVD_N_S_4_A @= { @ "HVD_N.S.4.a : Space to PW STRAP (overlap is not allowed) >= " + HVD_N_S_4_N55LP + " um"; 
                external2( HVD_NX, PSTP, < HVD_N_S_4_N55LP, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
                HVD_NX and PSTP; 
            } /* end of rule : HVD_N.S.4.a */
            rHVD_N_S_5_A @= { @ "HVD_N.S.5.a : Space to N+ACTIVE >= " + HVD_N_S_5_N55LP + " um"; 
                external2( HVD_NX, NACT, < HVD_N_S_5_N55LP, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
            } /* end of rule : HVD_N.S.5.a */
            rHVD_N_S_6_A @= { @ "HVD_N.S.6.a : Space to DNW >= " + HVD_N_S_6_N55LP + " um"; 
                external2( HVD_NX, DNW, < HVD_N_S_6_N55LP, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
                HVD_NX and DNW; 
            } /* end of rule : HVD_N.S.6.a */
            rHVD_N_EX_1_A @= { @ "HVD_N.EX.1.a : Extension on N+ACTIVE (Drain side must be fully inside HVD_N) >= " + HVD_N_EX_1_N55LP + " um"; 
                enclose( NACT, HVD_NX, < HVD_N_EX_1_N55LP, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
                HVD_NMOS_DRAIN not HVD_NX; 
            } /* end of rule : HVD_N.EX.1.a */
            rHVD_N_O_1_A @= { @ "HVD_N.O.1.a : Overlap of {I/O NMOS GATE} = " + HVD_N_O_1_N55LP + " um"; 
                A = HV_GATE_W coincident_outside_edge HVD_NMOS_DRAIN; 
                B = edge_size( A, inside = HVD_N_O_1_N55LP ); 
                C = HVD_NX and HVD_NGATE; 
                C xor B; 
                interacting( HVD_NGATE, B, > 1 ); 
            } /* end of rule : HVD_N.O.1.a */
            rHVD_N_L_1_A @= { @ "HVD_N.L.1.a : Channel length of {GATE INTERACT HVD_N} >= " + HVD_N_L_1_N55LP + " um"; 
                A = HV_GATE_W coincident_inside_edge HVD_NGATE; 
                internal1( A, < HVD_N_L_1_N55LP, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
            } /* end of rule : HVD_N.L.1.a */
            rHVD_N_A_1_A @= { @ "HVD_N.A.1.a : Area >= " + HVD_N_A_1_N55LP + " um"; 
                area( HVD_NX, < HVD_N_A_1_N55LP ); 
            } /* end of rule : HVD_N.A.1.a */
            rHVD_N_A_2_A @= { @ "HVD_N.A.2.a : Enclosed area >= " + HVD_N_A_2_N55LP + " um"; 
                A = donut_holes( HVD_NX, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
                B = A not HVD_NX; 
                area( B, < HVD_N_A_2_N55LP ); 
            } /* end of rule : HVD_N.A.2.a */
            DPO_HVD_N = interacting( DPO, HVD_NX ); 
            PO_HVD_N = interacting( POI, HVD_NX ); 
            rHVD_N_W_3_A @= { @ "HVD_N.W.3.a : Width of {DPO INTERACT HVD_N} = " + HVD_N_W_3_N55LP; 
                internal1( DPO_HVD_N, < HVD_N_W_3_N55LP, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
                sLAYER_1310 = wide( DPO_HVD_N, > HVD_N_W_3_N55LP, forty_five = INTERNAL ); 
                sLAYER_1311 = wide( DPO_HVD_N, >= HVD_N_W_3_N55LP, forty_five = INTERNAL ); 
                not( DPO_HVD_N, not( sLAYER_1311, sLAYER_1310 ) ); 
            } /* end of rule : HVD_N.W.3.a */
            rHVD_N_S_7_A @= { @ "HVD_N.S.7.a : PO EDGE INSIDE HVD_N space to {DPO INTERACT HVD_N} = " + HVD_N_S_7_N55LP; 
                PO_EDGE_INSIDE_HVD_N = and_edge( PO_HVD_N, HVD_NX, false ); 
                PO_EDGE_CHECK = PO_EDGE_INSIDE_HVD_N touching_edge GATE; 
                GOOD_PO_EDGE = external2_edge( PO_EDGE_CHECK, DPO_HVD_N, == HVD_N_S_7_N55LP, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                PO_EDGE_CHECK not_touching_edge GOOD_PO_EDGE; 
            } /* end of rule : HVD_N.S.7.a */
            rHVD_N_EX_2_A @= { @ "HVD_N.EX.2.a : {DPO INTERACT HVD_N} extension on OD = " + HVD_N_EX_2_N55LP; 
                OD_INSIDE_EDGE_DPO = and_edge( OD, DPO_HVD_N, false ); 
                GOOD_OD_EDGE = enclose_edge( OD_INSIDE_EDGE_DPO, DPO_HVD_N, == HVD_N_EX_2_N55LP, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1 ); 
                OD_INSIDE_EDGE_DPO not_coincident_edge GOOD_OD_EDGE; 
                enclose( OD, DPO_HVD_N, < HVD_N_EX_2_N55LP, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
            } /* end of rule : HVD_N.EX.2.a */
            rHVD_N_S_8_A @= { @ "HVD_N.S.8.a : {CO INSIDE {OD AND HVD_N}} space to {PO INTERACT HVD_N} >= " + HVD_N_S_8_N55LP; 
                OD_HVD_N = OD and HVD_NX; 
                sLAYER_347 = COI inside OD_HVD_N; 
                external2( sLAYER_347, PO_HVD_N, < HVD_N_S_8_N55LP, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
            } /* end of rule : HVD_N.S.8.a */
            rHVD_N_S_9_A @= { @ "HVD_N.S.9.a : {CO INSIDE {PO INTERACT HVD_N}} space to {{OD INTERACT HVD_N} AND NP} >= " + HVD_N_S_9_N55LP; 
                OD_HVD_N = interacting( OD, HVD_NX ); 
                sLAYER_348 = COI inside PO_HVD_N; 
                sLAYER_349 = OD_HVD_N and gNP; 
                external2( sLAYER_348, sLAYER_349, < HVD_N_S_9_N55LP, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
            } /* end of rule : HVD_N.S.9.a */
            rHVD_N_R_1_A @= { @ "HVD_N.R.1.a : Overlap of NW is not allowed";
                HVD_NX and NWEL; 
            } /* end of rule : HVD_N.R.1.a */
            rHVD_N_R_2_A @= { @ "HVD_N.R.2.a : HVD_N edge landing on OD without landing on GATE is not allowed";
                A = and_edge( HVD_NX, OD, false ); 
                AX = edge_size( A, outside = 0.005 ); 
                B = and_edge( HVD_NX, GATE, false ); 
                BX = edge_size( B, outside = 0.005 ); 
                AX not BX; 
            } /* end of rule : HVD_N.R.2.a */
            rHVD_N_R_3_A @= { @ "HVD_N.R.3.a : HVD_N must be fully covered by OD_25";
                HVD_NX not OD_25; 
            } /* end of rule : HVD_N.R.3.a */
            rHVD_N_R_4_A @= { @ "HVD_N.R.4.a : {(OD NOT PO) INSIDE same HVD_N} must be the same potential";
                interacting( HVD_NX, NSDC, > 1, connect_sequence = CONNECT_DB, count_by = NET ); 
            } /* end of rule : HVD_N.R.4.a */
            rHVD_N_R_5_A @= { @ "HVD_N.R.5.a : The number of fingers PO gate for HV NMOS should be even.";
                interacting( HVD_NX, GATE, < 100, count_parity = ODD ); 
            } /* end of rule : HVD_N.R.5.a */
            rHVD_N_R_6_A @= { @ "HVD_N.R.6.a : {(HVD_N INTERACT OD) AND PO} must be a rectangle, "
                                              "a concave shape is not allowed";
                sLAYER_351 = interacting( HVD_NX, OD ); 
                sLAYER_350 = sLAYER_351 and POLY; 
                not_rectangles( sLAYER_350 );
            } /* end of rule : HVD_N.R.6.a */
            rHVD_N_R_7_A @= { @ "HVD_N.R.7.a : HVD_N must interact with DPO";
                not_interacting( HVD_NX, DPO ); 
            } /* end of rule : HVD_N.R.7.a */
            rHVD_N_R_8_A @= { @ "HVD_N.R.8.a : ((OD INTERACT HVD_N) AND NP) must be a rectangle.";
                sLAYER_353 = interacting( OD, HVD_NX ); 
                sLAYER_352 = sLAYER_353 and gNP;
                not_rectangles( sLAYER_352 );
            } /* end of rule : HVD_N.R.8.a */
         #endif /* end of #ifndef HALF_NODE  */ 
      #else /* the reverse of #ifdef LP  */ 
         rHVD_N_WARN @= { @ "HVD_N:WARN : 5V HV MOS is allowed only in LP process";
             copy( HVD_N_NW ); 
         } /* end of rule : HVD_N:WARN */
      #endif /* end of #ifdef LP  */ 
      #ifdef LP 
         #ifndef HALF_NODE 
            
            //N65LP HVD_P CHECKS
            //============
            HVD_PMOS_DRAIN = interacting( SD, HVD_P ); 
            HVD_PGATE = interacting( HV_GATE, HVD_P ); 
            rHVD_P_W_1 @= { @ "HVD_P.W.1 : Width >= " + HVD_P_W_1 + " um"; 
                internal1( HVD_P, < HVD_P_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
            } /* end of rule : HVD_P.W.1 */
            rHVD_P_W_2 @= { @ "HVD_P.W.2 : Channel width of {GATE interact HVD_P} >= " + HVD_P_W_2 + " um"; 
                HV_GATE_L = and_edge( GATE_L, OD2, false ); 
                A = HV_GATE_L coincident_inside_edge HVD_PGATE; 
                internal1( A, < HVD_P_W_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
            } /* end of rule : HVD_P.W.2 */
            rHVD_P_S_1 @= { @ "HVD_P.S.1 : Space >= " + HVD_P_S_1 + " um"; 
                external1( HVD_P, < HVD_P_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
            } /* end of rule : HVD_P.S.1 */
            rHVD_P_S_2 @= { @ "HVD_P.S.2 : Space of two HVD_P with different potenetials >= " + HVD_P_S_2 + " um"; 
                A = stamp( HVD_P, PSDC, CONNECT_DB, CONNECT_DB_HVD_P_S_2, include_touch = NONE ); 
                external1( A, < HVD_P_S_2, connect_sequence = CONNECT_DB_HVD_P_S_2, connectivity = DIFFERENT_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
                B = not_interacting( HVD_P, PSDC ); 
                external2( B, HVD_P, < HVD_P_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, membership = DIFFERENT_POLYGON, relational = { POINT_TOUCH }, width = 0.002 ); 
            } /* end of rule : HVD_P.S.2 */
            rHVD_P_S_4 @= { @ "HVD_P.S.4 : Space to NW STRAP >= " + HVD_P_S_4 + " um"; 
                external2( HVD_P, NSTP, < HVD_P_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
                HVD_P and NSTP; 
            } /* end of rule : HVD_P.S.4 */
            rHVD_P_S_5 @= { @ "HVD_P.S.5 : Space to P+ACTIVE >= " + HVD_P_S_5 + " um"; 
                external2( HVD_P, PACT, < HVD_P_S_5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
            } /* end of rule : HVD_P.S.5 */
            rHVD_P_EX_1 @= { @ "HVD_P.EX.1 : Extension on P+ACTIVE (Drain side must be fully inside HVD_P) >= " + HVD_P_EX_1 + " um"; 
                enclose( PACT, HVD_P, < HVD_P_EX_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
                HVD_PMOS_DRAIN not HVD_P; 
            } /* end of rule : HVD_P.EX.1 */
            rHVD_P_EN_1 @= { @ "HVD_P.EN.1 : Enclosure by NW >= " + HVD_P_EN_1 + " um"; 
                enclose( HVD_P, NWEL, < HVD_P_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
            } /* end of rule : HVD_P.EN.1 */
            rHVD_P_O_1 @= { @ "HVD_P.O.1 : Overlap of {I/O PMOS GATE} == " + HVD_P_O_1 + " um"; 
                A = HV_GATE_W coincident_outside_edge HVD_PMOS_DRAIN; 
                B = edge_size( A, inside = HVD_P_O_1 ); 
                C = HVD_P and HVD_PGATE; 
                C xor B; 
                interacting( HVD_PGATE, B, > 1 ); 
            } /* end of rule : HVD_P.O.1 */
            rHVD_P_L_1 @= { @ "HVD_P.L.1 : Channel length of {GATE interact with HVD_P} >= " + HVD_P_L_1 + " um"; 
                A = HV_GATE_W coincident_inside_edge HVD_PGATE; 
                internal1( A, < HVD_P_L_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
            } /* end of rule : HVD_P.L.1 */
            rHVD_P_A_1 @= { @ "HVD_P.A.1 : Area >= " + HVD_P_A_1 + " um"; 
                area( HVD_P, < HVD_P_A_1 ); 
            } /* end of rule : HVD_P.A.1 */
            rHVD_P_A_2 @= { @ "HVD_P.A.2 : Enclosured area >= " + HVD_P_A_2 + " um"; 
                A = donut_holes( HVD_P, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
                B = A not HVD_P; 
                area( B, < HVD_P_A_2 ); 
            } /* end of rule : HVD_P.A.2 */
            rHVD_P_R_1 @= { @ "HVD_P.R.1 : HVD_P must be inside {NW not interact with DNW}";
                sLAYER_354 = not_interacting( NWEL, DNW ); 
                HVD_P not sLAYER_354; 
            } /* end of rule : HVD_P.R.1 */
            rHVD_P_R_2 @= { @ "HVD_P.R.2 : HVD_P edge landing on OD without landing on GATE is not allowed";
                A = and_edge( HVD_P, OD, false ); 
                AX = edge_size( A, outside = 0.005 ); 
                B = and_edge( HVD_P, GATE, false ); 
                BX = edge_size( B, outside = 0.005 ); 
                AX not BX; 
            } /* end of rule : HVD_P.R.2 */
            rHVD_P_R_3 @= { @ "HVD_P.R.3 : HVD_P must be fully inside OD_25";
                HVD_P not OD_25; 
            } /* end of rule : HVD_P.R.3 */
            rHVD_P_R_4 @= { @ "HVD_P.R.4 : {(OD NOT PO) inside same HVD_P} must be the same potential";
                interacting( HVD_P, PSDC, > 1, connect_sequence = CONNECT_DB, count_by = NET ); 
            } /* end of rule : HVD_P.R.4 */
            rHVD_P_R_6 @= { @ "HVD_P.R.6 : {(HVD_P interact OD) AND PO} must be a rectangle, "
                                          "a concave shape is noe allowed";
                sLAYER_356 = interacting( HVD_P, OD ); 
                sLAYER_355 = sLAYER_356 and POLY; 
                not_rectangles( sLAYER_355 );
            } /* end of rule : HVD_P.R.6 */
         #else /* the reverse of #ifndef HALF_NODE  */ 
            
            //N55LP HVD_P CHECKS
            //============
            HVD_PMOS_DRAIN = interacting( SD, HVD_P ); 
            HVD_PGATE = interacting( HV_GATE, HVD_P ); 
            rHVD_P_W_1_A @= { @ "HVD_P.W.1.a : Width >= " + HVD_P_W_1_N55LP + " um"; 
                internal1( HVD_P, < HVD_P_W_1_N55LP, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
            } /* end of rule : HVD_P.W.1.a */
            rHVD_P_W_2_A @= { @ "HVD_P.W.2.a : Channel width of {GATE INTERACT HVD_P} >= " + HVD_P_W_2_N55LP + " um"; 
                HV_GATE_L = and_edge( GATE_L, OD2, false ); 
                A = HV_GATE_L coincident_inside_edge HVD_PGATE; 
                internal1( A, < HVD_P_W_2_N55LP, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
            } /* end of rule : HVD_P.W.2.a */
            rHVD_P_S_1_A @= { @ "HVD_P.S.1.a : Space >= " + HVD_P_S_1_N55LP + " um"; 
                external1( HVD_P, < HVD_P_S_1_N55LP, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
            } /* end of rule : HVD_P.S.1.a */
            rHVD_P_S_2_A @= { @ "HVD_P.S.2.a : Space of two HVD_P with different potenetials >= " + HVD_P_S_2_N55LP + " um"; 
                A = stamp( HVD_P, PSDC, CONNECT_DB, CONNECT_DB_HVD_P_S_2_A, include_touch = NONE ); 
                external1( A, < HVD_P_S_2_N55LP, connect_sequence = CONNECT_DB_HVD_P_S_2_A, connectivity = DIFFERENT_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
                B = not_interacting( HVD_P, PSDC ); 
                external2( B, HVD_P, < HVD_P_S_2_N55LP, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, membership = DIFFERENT_POLYGON, relational = { POINT_TOUCH }, width = 0.002 ); 
            } /* end of rule : HVD_P.S.2.a */
            rHVD_P_S_4_A @= { @ "HVD_P.S.4.a : Space to NW STRAP >= " + HVD_P_S_4_N55LP + " um"; 
                external2( HVD_P, NSTP, < HVD_P_S_4_N55LP, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
                HVD_P and NSTP; 
            } /* end of rule : HVD_P.S.4.a */
            rHVD_P_S_5_A @= { @ "HVD_P.S.5.a : Space to P+ACTIVE >= " + HVD_P_S_5_N55LP + " um"; 
                external2( HVD_P, PACT, < HVD_P_S_5_N55LP, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
            } /* end of rule : HVD_P.S.5.a */
            rHVD_P_EX_1_A @= { @ "HVD_P.EX.1.a : Extension on P+ACTIVE (Drain side must be fully inside HVD_P) >= " + HVD_P_EX_1_N55LP + " um"; 
                enclose( PACT, HVD_P, < HVD_P_EX_1_N55LP, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
                HVD_PMOS_DRAIN not HVD_P; 
            } /* end of rule : HVD_P.EX.1.a */
            rHVD_P_EN_1_A @= { @ "HVD_P.EN.1.a : Enclosure by NW >= " + HVD_P_EN_1_N55LP + " um"; 
                enclose( HVD_P, NWEL, < HVD_P_EN_1_N55LP, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
            } /* end of rule : HVD_P.EN.1.a */
            rHVD_P_EN_2_A @= { @ "HVD_P.EN.2.a : Enclosure by DNW >= " + HVD_P_EN_2_N55LP + " um"; 
                enclose( HVD_P, DNW, < HVD_P_EN_2_N55LP, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
            } /* end of rule : HVD_P.EN.2.a */
            rHVD_P_O_1_A @= { @ "HVD_P.O.1.a : Overlap of {I/O PMOS GATE} = " + HVD_P_O_1_N55LP + " um"; 
                A = HV_GATE_W coincident_outside_edge HVD_PMOS_DRAIN; 
                B = edge_size( A, inside = HVD_P_O_1_N55LP ); 
                C = HVD_P and HVD_PGATE; 
                C xor B; 
                interacting( HVD_PGATE, B, > 1 ); 
            } /* end of rule : HVD_P.O.1.a */
            rHVD_P_L_1_A @= { @ "HVD_P.L.1.a : Channel length of {GATE INTERACT HVD_P} >= " + HVD_P_L_1_N55LP + " um"; 
                A = HV_GATE_W coincident_inside_edge HVD_PGATE; 
                internal1( A, < HVD_P_L_1_N55LP, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
            } /* end of rule : HVD_P.L.1.a */
            rHVD_P_A_1_A @= { @ "HVD_P.A.1.a : Area >= " + HVD_P_A_1_N55LP + " um"; 
                area( HVD_P, < HVD_P_A_1_N55LP ); 
            } /* end of rule : HVD_P.A.1.a */
            rHVD_P_A_2_A @= { @ "HVD_P.A.2.a : Enclosured area >= " + HVD_P_A_2_N55LP + " um"; 
                A = donut_holes( HVD_P, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
                B = A not HVD_P; 
                area( B, < HVD_P_A_2_N55LP ); 
            } /* end of rule : HVD_P.A.2.a */
            DPO_HVD_P = interacting( DPO, HVD_P ); 
            OD_HVD_P = interacting( ODI, HVD_P ); 
            PO_HVD_P = interacting( POI, HVD_P ); 
            rHVD_P_W_3_A @= { @ "HVD_P.W.3.a : Width of {DPO INTERACT HVD_P} = " + HVD_P_W_3_N55LP; 
                sLAYER_1312 = wide( DPO_HVD_P, > HVD_P_W_3_N55LP, forty_five = INTERNAL ); 
                sLAYER_1313 = wide( DPO_HVD_P, >= HVD_P_W_3_N55LP, forty_five = INTERNAL ); 
                not( DPO_HVD_P, not( sLAYER_1313, sLAYER_1312 ) ); 
            } /* end of rule : HVD_P.W.3.a */
            rHVD_P_S_6_A @= { @ "HVD_P.S.6.a : {PO INTERACT HVD_P} space to {DPO INSIDE HVD_P} = " + HVD_P_S_6_N55LP; 
                PO_EDGE_INSIDE_HVD_P = and_edge( PO_HVD_P, HVD_P, false ); 
                PO_EDGE_CHECK = PO_EDGE_INSIDE_HVD_P touching_edge GATE; 
                GOOD_PO_EDGE = external2_edge( PO_EDGE_CHECK, DPO_HVD_P, == HVD_P_S_6_N55LP, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                PO_EDGE_CHECK not_touching_edge GOOD_PO_EDGE; 
            } /* end of rule : HVD_P.S.6.a */
            rHVD_P_EX_2_A @= { @ "HVD_P.EX.2.a : {DPO INTERACT HVD_P} extension on OD = " + HVD_P_EX_2_N55LP; 
                OD_INSIDE_EDGE_DPO = and_edge( OD, DPO_HVD_P, false ); 
                GOOD_OD_EDGE = enclose_edge( OD_INSIDE_EDGE_DPO, DPO_HVD_P, == HVD_P_EX_2_N55LP, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1 ); 
                OD_INSIDE_EDGE_DPO not_coincident_edge GOOD_OD_EDGE; 
                enclose( OD, DPO_HVD_P, < HVD_P_EX_2_N55LP, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
            } /* end of rule : HVD_P.EX.2.a */
            rHVD_P_S_7_A @= { @ "HVD_P.S.7.a : {CO inside {OD covered with HVD_P}} space to {PO interact HVD_P} >= " + HVD_P_S_7_N55LP; 
                OD_INSIDE_HVD_P = OD and HVD_P; 
                sLAYER_357 = COI inside OD_INSIDE_HVD_P; 
                external2( sLAYER_357, PO_HVD_P, < HVD_P_S_7_N55LP, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
            } /* end of rule : HVD_P.S.7.a */
            rHVD_P_S_8_A @= { @ "HVD_P.S.8.a : {CO INSIDE {PO INTERACT HVD_P}} space to {{OD INTERACT HVD_P} and PP} >= " + HVD_P_S_8_N55LP; 
                sLAYER_358 = COI inside PO_HVD_P; 
                sLAYER_359 = OD_HVD_P and PP; 
                external2( sLAYER_358, sLAYER_359, < HVD_P_S_8_N55LP, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
            } /* end of rule : HVD_P.S.8.a */
            rHVD_P_R_1_A @= { @ "HVD_P.R.1.a : HVD_P must be inside {NW AND DNW}";
                sLAYER_360 = NWEL and DNW; 
                HVD_P not sLAYER_360; 
            } /* end of rule : HVD_P.R.1.a */
            rHVD_P_R_2_A @= { @ "HVD_P.R.2.a : HVD_P edge landing on OD without landing on GATE is not allowed";
                A = and_edge( HVD_P, OD, false ); 
                B = and_edge( HVD_P, GATE, false ); 
                AX = edge_size( A, outside = 0.005 ); 
                BX = edge_size( B, outside = 0.005 ); 
                AX not BX; 
            } /* end of rule : HVD_P.R.2.a */
            rHVD_P_R_3_A @= { @ "HVD_P.R.3.a : HVD_P must be fully inside OD_25";
                HVD_P not OD_25; 
            } /* end of rule : HVD_P.R.3.a */
            rHVD_P_R_4_A @= { @ "HVD_P.R.4.a : {(OD NOT PO) INSIDE same HVD_P} must be the same potential";
                interacting( HVD_P, PSDC, > 1, connect_sequence = CONNECT_DB, count_by = NET ); 
            } /* end of rule : HVD_P.R.4.a */
            rHVD_P_R_5_A @= { @ "HVD_P.R.5.a : The number of fingers PO gate for HV PMOS should be even.";
            
            
                interacting( HVD_P, GATE, < 100, count_parity = ODD ); 
            } /* end of rule : HVD_P.R.5.a */
            rHVD_P_R_6_A @= { @ "HVD_P.R.6.a : {(HVD_P INTERACT OD) AND PO} must be a rectangle, "
                                              "a concave shape is noe allowed";
                sLAYER_362 = interacting( HVD_P, OD ); 
                sLAYER_361 = sLAYER_362 and POLY; 
                not_rectangles( sLAYER_361 );
            } /* end of rule : HVD_P.R.6.a */
            rHVD_P_R_7_A @= { @ "HVD_P.R.7.a : HVD_P must interact with DPO";
                not_interacting( HVD_P, DPO ); 
            } /* end of rule : HVD_P.R.7.a */
            rHVD_P_R_8_A @= { @ "HVD_P.R.8.a : {{OD INTERACT HVD_P} AND PP} must be a rectangle.";
                sLAYER_363 = interacting( OD, HVD_P ); 
                not_rectangles( sLAYER_363 );
            } /* end of rule : HVD_P.R.8.a */
         #endif /* end of #ifndef HALF_NODE  */ 
      #else /* the reverse of #ifdef LP  */ 
         rHVD_P_WARN @= { @ "HVD_P:WARN : 5V HV MOS is allowed only in LP process";
             copy( HVD_P ); 
         } /* end of rule : HVD_P:WARN */
      #endif /* end of #ifdef LP  */ 
      
      //GUARD RING RULES
      //=================
      #ifdef HALF_NODE 
         HVPMOS = interacting( PPOD, HVD_P ); 
         HVNMOS = interacting( NPOD, HVD_N_NW ); 
         PSTP_HOLES = donut_holes( PSTP, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
         NSTP_HOLES = donut_holes( NSTP, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
         HVPTAP_GUARD_RING_HOLE = enclosing( PTAP_GUARD_RING_HOLE, HVNMOS ); 
         HVNTAP_GUARD_RING_HOLE = enclosing( NTAP_GUARD_RING_HOLE, HVPMOS ); 
         rGR_R_1_A @= { @ "GR.R.1.a : It is not allowed to place HVNMOS and HVPMOS inside the same guard-ring";
             HVNMOS not_inside PTAP_GUARD_RING_HOLE; 
             HVPMOS not_inside NTAP_GUARD_RING_HOLE; 
         } /* end of rule : GR.R.1.a */
         rGR_R_2_A @= { @ "GR.R.2.a : HV NMOS must be surrounded by P+ guard ring";
             HVNMOS not_inside PSTP_HOLES; 
         } /* end of rule : GR.R.2.a */
         rGR_R_3_A @= { @ "GR.R.3.a : HV PMOS must be surrounded by N+ guard ring";
             HVPMOS not_inside NSTP_HOLES; 
         } /* end of rule : GR.R.3.a */
         
         // GR.R.4.a is not necessary to check
         // GR.R.5.a is not necessary to check
         
         // GR.R.14.a is not necessary to check
         // GR.R.15.a is uncheckable
      #else /* the reverse of #ifdef HALF_NODE  */ 
         HVPMOS = interacting( PPOD, HVD_P ); 
         HVNMOS = interacting( NPOD, HVD_N_NW ); 
         gLAYER_218 = and_edge( HVPMOS, POLY, false ); 
         HVPMOS_LSIDE = HVPMOS touching_edge gLAYER_218; 
         HVPMOS_WSIDE = HVPMOS not_coincident_edge HVPMOS_LSIDE; 
         rGR_R_1 @= { @ "GR.R.1 : It is not allowed to place HVNMOS and HVPMOS inside the same guard-ring";
             HVNMOS not_inside PTAP_GUARD_RING_HOLE; 
             HVPMOS not_inside NTAP_GUARD_RING_HOLE; 
         } /* end of rule : GR.R.1 */
         
         // GR.R.2U is uncheckable
         // GR.R.3U is uncheckable
         // GR.R.4.RU is uncheckable
         // GR.R.5U is uncheckable
         // GR.R.6U is uncheckable
         
         // GR.R.7 is checked by GR.R.7__GR.R.8
         // GR.R.8 is checked by GR.R.7__GR.R.8
         rGR_R_7__GR_R_8 @= { @ "GR.R.7__GR.R.8 : For one row and two rows multi-OD in the same guard ring, the outer edge of OD in PO endcap direction of each HV PMOS space to the N+/NW guard ring (NW STRAP) <= " + GR_R_7 + " um. The OD space in PO endcap direction between two rows multi-OD HV PMOS in the same guard ring <= " + GR_R_8 + " um"; 
             A = external1_edge( HVPMOS_LSIDE, <= GR_R_8, extension = RADIAL, intersecting = {  }, look_thru = NOT_ADJACENT ); 
             B = HVPMOS_LSIDE not_coincident_edge A; 
             C = external2_edge( B, NSTP, <= GR_R_7, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT, output_layer = LAYER1 ); 
             B not_coincident_edge C; 
         } /* end of rule : GR.R.7__GR.R.8 */
         
         // GR.R.9U is uncheckable
         // GR.R.10 is checked by GR.R.10__GR.R.11
         // GR.R.11 is checked by GR.R.10__GR.R.11
         rGR_R_10__GR_R_11 @= { @ "GR.R.10__GR.R.11 : For one row and two rows multi-OD in the same guard ring, the outer edge of OD in S/D direction of HV PMOS row space to the N+/NW guard ring (NW STRAP) <= " + GR_R_10 + " um. The OD space in S/D direction between each HV PMOS in the same guard ring <= " + GR_R_11 + " um"; 
             A = external1_edge( HVPMOS_WSIDE, <= GR_R_10, extension = RADIAL, intersecting = {  }, look_thru = NOT_ADJACENT ); 
             B = HVPMOS_WSIDE not_coincident_edge A; 
             C = external2_edge( B, NSTP, <= GR_R_11, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT, output_layer = LAYER1 ); 
             B not_coincident_edge C; 
         } /* end of rule : GR.R.10__GR.R.11 */
         
         // GR.R.12U is uncheckable
         HVPMOS_2RS_EXT = external1( HVPMOS_LSIDE, <= GR_R_8, extension = RADIAL, intersecting = {  }, look_thru = NOT_ADJACENT ); 
         HVPMOS_2RS = outside_touching( HVPMOS, HVPMOS_2RS_EXT ); 
         HVPMOS_2RS_WSIDE = HVPMOS_2RS not_coincident_edge HVPMOS_LSIDE; 
         rGR_R_13 @= { @ "GR.R.13 : The OD width of two rows multi-OD HV PMOS within the same guard ring <= " + GR_R_13 + " um"; 
             length_edge( HVPMOS_2RS_WSIDE, > GR_R_13 ); 
         } /* end of rule : GR.R.13 */
         rGR_R_14 @= { @ "GR.R.14 : HV N/PMOS enclosed by (guard ring with RPO) is not allowed.";
             sLAYER_364 = donut_holes( NSTP, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
             sLAYER_365 = donut_holes( PSTP, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
             GR_HOLE = sLAYER_364 or sLAYER_365; 
             sLAYER_366 = HVPMOS or HVNMOS; 
             GR_HOLE_CHK = enclosing( GR_HOLE, sLAYER_366 ); 
             sLAYER_367 = outside_touching( NSTP, GR_HOLE_CHK ); 
             sLAYER_367 and RPO; 
             sLAYER_368 = outside_touching( PSTP, GR_HOLE_CHK ); 
             sLAYER_368 and RPO; 
         } /* end of rule : GR.R.14 */
         
         // GR.R.15.RU is uncheckable
      #endif /* end of #ifdef HALF_NODE  */ 
      #ifdef LP 
         #ifndef HALF_NODE 
            
            // Breakdown Characterization RULES
            //================================
            // N65
            HVPMOS_GATE = GATE and HVPMOS; 
            HVNMOS_GATE = GATE and HVNMOS; 
            rBV_W_1G @= { @ "BV.W.1g : Maximum HV NMOS channel width <= " + BV_W_1 + " um"; 
                HVNMOS_GATE_W = POLY coincident_inside_edge HVNMOS_GATE; 
                VALID_HVNGATE_W = length_edge( HVNMOS_GATE_W, <= BV_W_1 ); 
                HVNMOS_GATE_W not_coincident_edge VALID_HVNGATE_W; 
            } /* end of rule : BV.W.1g */
            rBV_W_2G @= { @ "BV.W.2g : Maximum HV NMOS channel width <= " + BV_W_2 + " um"; 
                HVPMOS_GATE_W = POLY coincident_inside_edge HVPMOS_GATE; 
                VALID_HVPGATE_W = length_edge( HVPMOS_GATE_W, <= BV_W_2 ); 
                HVPMOS_GATE_W not_coincident_edge VALID_HVPGATE_W; 
            } /* end of rule : BV.W.2g */
            rBV_R_1G @= { @ "BV.R.1g : Maximum finger number of PO gate in the same OD <= " + BV_R_1 + " um"; 
                interacting( HVPMOS, GATE, > dtoi(BV_R_1) ); 
                interacting( HVNMOS, GATE, > dtoi(BV_R_1) ); 
            } /* end of rule : BV.R.1g */
         #else /* the reverse of #ifndef HALF_NODE  */ 
            
            //N55
            HVPMOS_GATE = GATE and HVPMOS; 
            HVNMOS_GATE = GATE and HVNMOS; 
            
            // BV.W.1.ag is checked by BV.W.1.a
            rBV_W_1_A @= { @ "BV.W.1.a : Maximum HV MOS channel width with Nf=2 <= " + BV_W_1_N55LP + " um"; 
                HVNMOS_GATE_W = POLY coincident_inside_edge HVNMOS_GATE; 
                VALID_HVNGATE_W = length_edge( HVNMOS_GATE_W, <= BV_W_1_N55LP ); 
                HVNMOS_GATE_W not_coincident_edge VALID_HVNGATE_W; 
                HVPMOS_GATE_W = POLY coincident_inside_edge HVPMOS_GATE; 
                VALID_HVPGATE_W = length_edge( HVPMOS_GATE_W, <= BV_W_1_N55LP ); 
                HVPMOS_GATE_W not_coincident_edge VALID_HVPGATE_W; 
            } /* end of rule : BV.W.1.a */
            
            // BV.W.2.ag is checked by BV.W.2.a
            rBV_W_2_A @= { @ "BV.W.2.a : Maximum HV MOS channel width with Nf>2 <= " + BV_W_2_N55LP + " um"; 
                HVNMOS_CHECK = interacting( HVNMOS, GATE, > 2 ); 
                HVNMOS_GATE_CHECK = GATE and HVNMOS_CHECK; 
                HVNMOS_GATE_W = POLY coincident_inside_edge HVNMOS_GATE_CHECK; 
                VALID_HVNGATE_W = length_edge( HVNMOS_GATE_W, <= BV_W_2_N55LP ); 
                HVNMOS_GATE_W not_coincident_edge VALID_HVNGATE_W; 
                HVPMOS_CHECK = interacting( HVPMOS, GATE, > 2 ); 
                HVPMOS_GATE_CHECK = GATE and HVPMOS_CHECK; 
                HVPMOS_GATE_W = POLY coincident_inside_edge HVPMOS_GATE_CHECK; 
                VALID_HVPGATE_W = length_edge( HVPMOS_GATE_W, <= BV_W_2_N55LP ); 
                HVPMOS_GATE_W not_coincident_edge VALID_HVPGATE_W; 
            } /* end of rule : BV.W.2.a */
            
            // BV.R.1.ag is checked by BV.R.1.a
            rBV_R_1_A @= { @ "BV.R.1.a : Maximum finger number of PO gate in the same OD <= " + BV_R_1_N55LP + " um"; 
                interacting( HVPMOS, GATE, > dtoi(BV_R_1_N55LP) ); 
                interacting( HVNMOS, GATE, > dtoi(BV_R_1_N55LP) ); 
            } /* end of rule : BV.R.1.a */
         #endif /* end of #ifndef HALF_NODE  */ 
      #endif /* end of #ifdef LP  */ 
   #endif /* end of #ifdef FRONT_END  */ 
   
   //CO CHECKS
   //=========
   rCO_W_1 @= { @ "CO.W.1 : Width (maximum = minimum except for seal-ring and fuse protection ring) = " + CO_W_1 + " um " 
                           "CO.R.3  45-degree rotated CO is not allowed";
       A = not_rectangles( COS, orientation = ORTHOGONAL, sides = { == CO_W_1, == CO_W_1 } ); 
       sLAYER_369 = A not VIA_EXD; 
       sLAYER_369 not_inside SRAM_EXCLUDE; 
   } /* end of rule : CO.W.1 */
   
   // CSR.W.3 is checked by CO.W.2
   rCO_W_2 @= { @ "CO.W.2 : CO bar width = " + CO_W_2 + " um (CO bar is covered by SEALRING layer and only allowed in seal-ring and fuse protecion ring)"; 
       internal1_error( CO_BAR, < CO_W_2, extension = NONE, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
       A = wide( CO_BAR, > CO_W_2, forty_five = INTERNAL ); 
       B = angle_edge( CO_BAR, == 45 ); 
       C = internal1( B, < ( CO_W_2 + GRID ), extension = RADIAL, intersecting = {  } ); 
       D = A not C; 
       contains( D, { 1, 0.005 }, FORTY_FIVE ); 
   } /* end of rule : CO.W.2 */
   rCO_S_1 @= { @ "CO.S.1 : Spacing >= " + CO_S_1 + " um"; 
       external1( CO, < CO_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
   } /* end of rule : CO.S.1 */
   rCO_S_2 @= { @ "CO.S.2 : Space to 3-neighboring CO (< 0.15 um distance) >= " + CO_S_2 + " um"; 
       X = rectangle_spacing1( CO, count = > 2, distance = < CO_S_2_N ); 
       external2( X, CO, < CO_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
   } /* end of rule : CO.S.2 */
   CO_NODAL = stamp( CO, COI, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
   rCO_S_2_1 @= { @ "CO.S.2.1 : Space to neighboring CO [different net and common parallel run length > 0] >= " + CO_S_2_1 + " um"; 
       external1( CO_NODAL, < CO_S_2_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
   } /* end of rule : CO.S.2.1 */
   rCO_S_2_2 @= { @ "CO.S.2.2 : Space to neighboring CO [different net] >= " + CO_S_2_2 + " um"; 
       external1( CO_NODAL, < CO_S_2_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT ); 
   } /* end of rule : CO.S.2.2 */
   rCO_S_3 @= { @ "CO.S.3 : Space to GATE (Overlap of GATE is not allowed) >= " + CO_S_3 + " um"; 
       A = external2( COOD, GATE, < CO_S_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
       A not_inside SRAMDMY_PERI; 
       CO and GATE; 
   } /* end of rule : CO.S.3 */
   rCO_S_4 @= { @ "CO.S.4 : {CO inside PO} space to OD >= " + CO_S_4 + " um"; 
       external2( COPO, OD, < CO_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
   } /* end of rule : CO.S.4 */
   rCO_S_5 @= { @ "CO.S.5 : {CO inside OD} space to 1.8V or 2.5V or 3.3V GATE >= " + CO_S_5 + " um"; 
       external2( COOD, HV_GATE, < CO_S_5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
   } /* end of rule : CO.S.5 */
   rCO_S_6 @= { @ "CO.S.6 : Space to butted PP/NP edge on OD (overlap of NP/PP boundary on OD is not allowed.) >= " + CO_S_6 + " um"; 
       external2( NP_PP_BTE, COOD, < CO_S_6, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
       enclose( COOD, NP_PP_BTE, < CO_S_6, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
       sLAYER_371 = COOD not CSRDMY; 
       sLAYER_370 = sLAYER_371 not SEALRING; 
       cutting( sLAYER_370, PP );          /* exclude sealring region  */ 
       enclose( COOD, PP, < 0.001, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
       enclose( COOD, gNP, < 0.001, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
   } /* end of rule : CO.S.6 */
   
   //CO.EN.0 is checked by either {CO.EN.2/CO.EN.3} or CO.EN.4
   rCO_EN_1 @= { @ "CO.EN.1 : Enclosure by OD >= " + CO_EN_1 + " um"; 
       enclose( COOD, OD, < CO_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
   } /* end of rule : CO.EN.1 */
   rCO_EN_1_1 @= { @ "CO.EN.1.1 : Enclosure by OD [at least two opposite side] >= " + CO_EN_1_1 + " um."; 
       X = not_enclosed_by( COOD, OD, distances = { { { CO_EN_1, RADIAL }, { CO_EN_1_1, NONE }, { CO_EN_1, RADIAL }, { CO_EN_1_1, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
       Y = enclose_edge( X, OD, < CO_EN_1_1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
       Z = X touching_edge Y; 
       vertex( Z, angles = { 90 }, shape = TRIANGLE, shape_size = CO_W_1 );    /* adjacent narrow sides */ 
   } /* end of rule : CO.EN.1.1 */
   rCO_EN_2 @= { @ "CO.EN.2 : Enclosure by PO >= " + CO_EN_2; 
       enclose( COPO, POLYS, < CO_EN_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
       COPO not POLY; 
   } /* end of rule : CO.EN.2 */
   
   // CO.EN.3 is checked by CO.EN.3__CO.EN.4
   // CO.EN.4 is checked by CO.EN.3__CO.EN.4
   rCO_EN_3__CO_EN_4 @= { @ "CO.EN.3__CO.EN.4 : Enclosure by PO [at least two opposite sides] >= " + CO_EN_3 + " ,or [all sides] >= " + CO_EN_4; 
       X = not_enclosed_by( CO, POLYS, distances = { { { CO_EN_2, RADIAL }, { CO_EN_3, NONE }, { CO_EN_2, RADIAL }, { CO_EN_3, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH } ); 
       enclose( X, POLYS, < CO_EN_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
   } /* end of rule : CO.EN.3__CO.EN.4 */
   
   // CO.R.2 is checked by RPO.S.3
   
   // CO.R.3 is checked by CO.W.1
   // CO.R.4 is checked by M1.EN.1 and CO.EN.2
   #ifdef BACK_END 
      
      //M1 CHECKS
      //=========
      gLAYER_219 = size( size( M1, - ( M1_S_2_W / 2 ), clip_acute = BISECTOR ), M1_S_2_W / 2, clip_acute = BISECTOR ); 
      M1WIDE_FIRST = gLAYER_219 and M1; 
      #ifdef HALF_NODE 
         gLAYER_220 = size( size( M1WIDE_FIRST, - ( ( M1_S_2_1_W + OFFSETX ) / 2 ), clip_acute = BISECTOR ), ( M1_S_2_1_W + OFFSETX ) / 2, clip_acute = BISECTOR ); 
         M1WIDE_0_p_4 = gLAYER_220 and M1WIDE_FIRST; 
         gLAYER_221 = size( size( M1, - ( M1_S_2_2_W / 2 ), clip_acute = BISECTOR ), M1_S_2_2_W / 2, clip_acute = BISECTOR ); 
         M1WIDE_0_p_2 = gLAYER_221 and M1; 
         gLAYER_222 = size( size( M1WIDE_FIRST, - ( M1_S_2_3_W / 2 ), clip_acute = BISECTOR ), M1_S_2_3_W / 2, clip_acute = BISECTOR ); 
         M1WIDE_0_p_42 = gLAYER_222 and M1WIDE_FIRST; 
      #else /* the reverse of #ifdef HALF_NODE  */ 
         gLAYER_223 = size( size( M1WIDE_FIRST, - ( M1_S_2_1_W / 2 ), clip_acute = BISECTOR ), M1_S_2_1_W / 2, clip_acute = BISECTOR ); 
         M1WIDE_0_p_4 = gLAYER_223 and M1WIDE_FIRST; 
      #endif /* end of #ifdef HALF_NODE  */ 
      gLAYER_224 = size( size( M1WIDE_FIRST, - ( M1_S_3_W / 2 ), clip_acute = BISECTOR ), M1_S_3_W / 2, clip_acute = BISECTOR ); 
      M1WIDE_1_p_5 = gLAYER_224 and M1WIDE_FIRST; 
      gLAYER_225 = size( size( M1WIDE_1_p_5, - ( M1_S_4_W / 2 ), clip_acute = BISECTOR ), M1_S_4_W / 2, clip_acute = BISECTOR ); 
      M1WIDE_4_p_5 = gLAYER_225 and M1WIDE_1_p_5; 
      M1_10 = M1WIDE_FIRST not CB_NON_CUP; 
      M1_11 = M1WIDE_0_p_4 not CB_NON_CUP; 
      #ifdef HALF_NODE 
         M1_12 = M1WIDE_0_p_2 not CB_NON_CUP; 
         M1_13 = M1WIDE_0_p_42 not CB_NON_CUP; 
      #endif /* end of #ifdef HALF_NODE  */ 
      M1_2 = M1WIDE_1_p_5 not CB_NON_CUP; 
      M1_3 = M1WIDE_4_p_5 not CB_NON_CUP; 
      M1AS3 = area( M1, > ( M1_S_3_L * M1_W_1 ) );    /* filter small metal for M1.S.3 */ 
      M1AS4 = area( M1AS3, > ( M1_S_4_L * M1_W_1 ) );    /* filter small metal for M1.S.4 */ 
      M1_EDGE_45 = angle_edge( M1, == 45 ); 
      rM1_W_1 @= { @ "M1.W.1 : Width >= " + M1_W_1 + " um"; 
          sLAYER_372 = internal1( M1S, < M1_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          sLAYER_372 not_inside SRAM_EXCLUDE; 
      } /* end of rule : M1.W.1 */
      rM1_W_2 @= { @ "M1.W.2 : Width of 45-degree bent MM1 Please make sure the vertex of 45 degree pattern is on 5nm grid >= " + M1_W_2 + " um"; 
          internal1( M1_EDGE_45, < M1_W_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
      } /* end of rule : M1.W.2 */
      rM1_W_3 @= { @ "M1.W.3 : Maximum width <= " + M1_W_3 + " um"; 
          size( size( M1, - ( M1_W_3 / 2 ), clip_acute = BISECTOR ), M1_W_3 / 2, clip_acute = BISECTOR ); 
      } /* end of rule : M1.W.3 */
      rM1_S_1 @= { @ "M1.S.1 : Spacing >= " + M1_S_1 + " um"; 
          external1( M1, < M1_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : M1.S.1 */
      
      //M1.S.2.S is checked by M1.S.2
      rM1_S_2 @= { @ "M1.S.2 : Space [at least one metal line width > " + M1_S_2_W + " um  and the parallel metal run length > " + M1_S_2_L + " um ] (union projection) >= " + M1_S_2; 
          X = external2( M1_10, M1, < M1_S_2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M1; 
          contains( Y, { GRID, M1_S_2_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M1.S.2 */
      
      //M1.S.2.1.S is checked by M1.S.2.1
      rM1_S_2_1 @= { @ "M1.S.2.1 : Space [at least one metal line width > " + M1_S_2_1_W + " um  and the parallel metal run length > " + M1_S_2_1_L + " um ] (union projection) >= " + M1_S_2_1; 
          X = external2( M1_11, M1, < M1_S_2_1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M1; 
          contains( Y, { GRID, M1_S_2_1_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M1.S.2.1 */
      #ifdef HALF_NODE 
         
         //M1.S.2.2.S is checked by M1.S.2.2
         rM1_S_2_2 @= { @ "M1.S.2.2 : Space [at least one metal line width > " + M1_S_2_2_W + " um  and the parallel metal run length > " + M1_S_2_2_L + " um ] (union projection) >= " + M1_S_2_2; 
             X = external2( M1_12, M1, < M1_S_2_2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
             Y = X not M1; 
             contains( Y, { GRID, M1_S_2_2_L + GRID }, FORTY_FIVE ); 
         } /* end of rule : M1.S.2.2 */
         
         //M1.S.2.3.S is checked by M1.S.2.3
         rM1_S_2_3 @= { @ "M1.S.2.3 : Space [at least one metal line width > " + M1_S_2_3_W + " um  and the parallel metal run length > " + M1_S_2_3_L + " um ] (union projection) >= " + M1_S_2_3; 
             X = external2( M1_13, M1, < M1_S_2_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
             Y = X not M1; 
             contains( Y, { GRID, M1_S_2_3_L + GRID }, FORTY_FIVE ); 
         } /* end of rule : M1.S.2.3 */
      #endif /* end of #ifdef HALF_NODE  */ 
      
      //M1.S.3.S is checked by M1.S.3
      rM1_S_3 @= { @ "M1.S.3 : Space [at least one metal line width > " + M1_S_3_W + " um  and the parallel metal run length > " + M1_S_3_L + " um ] (union projection) >= " + M1_S_3; 
          X = external2( M1_2, M1AS3, < M1_S_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M1; 
          contains( Y, { GRID, M1_S_3_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M1.S.3 */
      
      //M1.S.4.S is checked by M1.S.4
      rM1_S_4 @= { @ "M1.S.4 : Space [at least one metal line width > " + M1_S_4_W + " um  and the parallel metal run length > " + M1_S_4_L + " um ] (union projection) >= " + M1_S_4; 
          X = external2( M1_3, M1AS4, < M1_S_4, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M1; 
          contains( Y, { GRID, M1_S_4_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M1.S.4 */
      rM1_S_5 @= { @ "M1.S.5 : If M1 has parallel run length with opposite M1 along two adjacent edges of M1 [any one edge < " + M1_S_5_Q + " um (Q) and its opposite extension< 0.035um (T) distance from the corner of the two edges of M1], then one of the space (S1 or S2) to opposite M1 must be >= " + M1_S_5 + " um."; 
          A = adjacent_edge( M1, angle1 = == 90, angle2 = == 90, length = < M1_S_5_Q ); 
          B = external2_edge( A, M1, < M1_S_5, extension = EDGE, extension_distance = M1_S_5_E, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1 ); 
          C = A inside_touching_edge B; 
          D = internal2_edge( C, M1, < M1_S_5_Q, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 90, look_thru = RELATED_COINCIDENT, orientation = { }, output_layer = LAYER2 ); 
          I = length_edge( D, >= M1_W_1 ); 
          sLAYER_1314 = extend_edge( I, start = M1_S_5_E, end = M1_S_5_E ); 
          J = edge_size( sLAYER_1314, inside = 0.001 ); 
          K = edge_size( I, inside = 0.001 ); 
          L = J not K; 
          M = L touching A; 
          N = M or K; 
          O = N touching_edge I; 
          external2( O, M1, < M1_S_5, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
      } /* end of rule : M1.S.5 */
      rM1_S_6 @= { @ "M1.S.6 : Space to 45-degree bent M1 >= " + M1_S_6 + " um"; 
          X = edge_size( M1_EDGE_45, outside = M1_S_6 ); 
          X and M1; 
      } /* end of rule : M1.S.6 */
      
      //M1.EN.0 is checked by M1.EN.1
      rM1_EN_1 @= { @ "M1.EN.1 : Enclosure of CO >= " + M1_EN_1 + " um"; 
          COS not M1S; 
      } /* end of rule : M1.EN.1 */
      
      // M1.EN.0 is checked by M1.EN.2__M1.EN.3
      // M1.EN.2 is checked by M1.EN.2__M1.EN.3
      // M1.EN.3 is checked by M1.EN.2__M1.EN.3
      rM1_EN_2__M1_EN_3 @= { @ "M1.EN.2__M1.EN.3 : Enclosure of CO [at least two opposite sides] >= " + M1_EN_2 + ", or [all sides] >= " + M1_EN_3 + " um"; 
          A = not_enclosed_by( COS, M1S, distances = { { { 0, RADIAL }, { M1_EN_2, NONE }, { 0, RADIAL }, { M1_EN_2, NONE } } }, intersecting_failures = { ACUTE } ); 
          sLAYER_373 = enclose( A, M1S, < M1_EN_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          sLAYER_373 not_inside SRAM_EXCLUDE; 
      } /* end of rule : M1.EN.2__M1.EN.3 */
      gLAYER_226 = size( size( M1WIDE_FIRST, - ( M1_EN_4_W / 2 ), clip_acute = BISECTOR ), M1_EN_4_W / 2, clip_acute = BISECTOR ); 
      M1WIDE_1_p_0 = gLAYER_226 and M1WIDE_FIRST; 
      rM1_EN_4 @= { @ "M1.EN.4 : Enclosure of CO [M1 width > 1um] >= " + M1_EN_4 + " um"; 
          A = COS inside M1WIDE_1_p_0; 
          enclose( A, M1S, < M1_EN_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : M1.EN.4 */
      rM1_A_1 @= { @ "M1.A.1 : Area >= " + M1_A_1 + " um2"; 
          sLAYER_374 = area( M1S, < M1_A_1 ); 
          sLAYER_374 not_inside SRAM_EXCLUDE; 
      } /* end of rule : M1.A.1 */
      rM1_A_2 @= { @ "M1.A.2 : Enclosed area >= " + M1_A_2 + " um2"; 
          X = donut_holes( M1S, area = < M1_A_2PRE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          sLAYER_376 = X not M1I; 
          sLAYER_375 = area( sLAYER_376, < M1_A_2 ); 
          sLAYER_375 not_inside SRAM_EXCLUDE; 
      } /* end of rule : M1.A.2 */
      M1DN1H_EXC = copy( M1_EXC ); 
      M1DN1L_EXC = copy( M1_EXC_LOW ); 
      #ifdef CHECK_LOW_DENSITY 
         rM1_DN_1 @= { @ "M1.DN.1 : M1 local density must be >= " + M1_DN_1L + " range over " + M1_DN_1L_W + " um x " + M1_DN_1L_W + " um step " + M1_DN_1L_S + " um"; 
             M1_CHECK = M1X not M1DN1L_EXC; 
             CHIP_CHECK = gCHIP not M1DN1L_EXC; 
         _den_con = < M1_DN_1L; 
         _den_polygon_area_clip = false;
         _den_print = false;
         _den_print_only = false;
             ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M1_CHECK, "layer2" => CHIP_CHECK }, delta_window = { M1_DN_1L_W, M1_DN_1L_W }, delta_x = M1_DN_1L_S, delta_y = M1_DN_1L_S, boundary = BACKUP, window_function = den_save_window_1 ); 
             sLAYER_377 = ERR_WIN not M1DN1L_EXC; 
             F = wide( sLAYER_377, >= M1_DN_1L_E, forty_five = INTERNAL ); 
             VAR_13 = density_statistics_file( file = "M1.DN.1.density" ); 
         _den_con = < M1_DN_1L; 
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M1_CHECK, "layer3" => CHIP_CHECK }, delta_window = { M1_DN_1L_W, M1_DN_1L_W }, delta_x = M1_DN_1L_S, delta_y = M1_DN_1L_S, boundary = BACKUP, statistics_files = { VAR_13 }, window_function = den_save_window_2 ); 
         } /* end of rule : M1.DN.1 */
      #endif /* end of #ifdef CHECK_LOW_DENSITY  */ 
      rM1_DN_1_1 @= { @ "M1.DN.1.1 : M1 local density must be <= " + M1_DN_1H + " range over " + M1_DN_1H_W + " um x " + M1_DN_1H_W + " um step " + M1_DN_1H_S + " um"; 
          M1_CHECK = M1X not M1DN1H_EXC; 
          CHIP_CHECK = gCHIP not M1DN1H_EXC; 
      _den_con = > M1_DN_1H; 
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M1_CHECK, "layer2" => CHIP_CHECK }, delta_window = { M1_DN_1H_W, M1_DN_1H_W }, delta_x = M1_DN_1H_S, delta_y = M1_DN_1H_S, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_378 = ERR_WIN not M1DN1H_EXC; 
          F = wide( sLAYER_378, >= M1_DN_1H_E, forty_five = INTERNAL ); 
          VAR_14 = density_statistics_file( file = "M1.DN.1.1.density" ); 
      _den_con = > M1_DN_1H; 
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M1_CHECK, "layer3" => CHIP_CHECK }, delta_window = { M1_DN_1H_W, M1_DN_1H_W }, delta_x = M1_DN_1H_S, delta_y = M1_DN_1H_S, boundary = BACKUP, statistics_files = { VAR_14 }, window_function = den_save_window_3 ); 
      } /* end of rule : M1.DN.1.1 */
      M1DN2_EXC = copy( EMPTYI ); 
      rM1_DN_2 @= { @ "M1.DN.2 : M1 local density must be <= " + M1_DN_2 + " range over " + M1_DN_2_W + " um x " + M1_DN_2_W + " um step " + M1_DN_2_S + " um"; 
          M1_CHECK = M1X not M1DN2_EXC; 
      _den_con = > M1_DN_2; 
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M1_CHECK, "layer2" => gCHIP }, delta_window = { M1_DN_2_W, M1_DN_2_W }, delta_x = M1_DN_2_S, delta_y = M1_DN_2_S, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_379 = ERR_WIN not M1DN2_EXC; 
          F = wide( sLAYER_379, >= M1_DN_2_E, forty_five = INTERNAL ); 
          VAR_15 = density_statistics_file( file = "M1.DN.2.density" ); 
      _den_con = > M1_DN_2; 
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M1_CHECK, "layer3" => gCHIP }, delta_window = { M1_DN_2_W, M1_DN_2_W }, delta_x = M1_DN_2_S, delta_y = M1_DN_2_S, boundary = BACKUP, statistics_files = { VAR_15 }, window_function = den_save_window_3 ); 
      } /* end of rule : M1.DN.2 */
      rM1_DN_4 @= { @ "M1.DN.4 : The metal density difference between any two " + M1_DN_4_W + " um x " + M1_DN_4_W + " um neighboring checking windows including DM1EXCL <= " + M1_DN_4; 
          sLAYER_1315 = chip_extent();
          VAR_16 = density_statistics_file( file = "M1.DN.4.density" ); 
      _gden_con = <= 1;
      _gden_gcon = > M1_DN_4; 
      _gden_absolute = true;
      _gden_corner = true;
      _gden_corner_value = -1.0;
      _gden_polygon_area_clip = true;
      _gden_print = true;
      _gden_print_only = false;
          sLAYER_1315 = sLAYER_1315 or gCHIP;
gradient_density( window_layer = sLAYER_1315, layer_hash = { "layer1" => M1X, "layer2" => gCHIP }, delta_window = { M1_DN_4_W, M1_DN_4_W }, delta_x = M1_DN_4_W, delta_y = M1_DN_4_W, boundary = BACKUP, statistics_files = { VAR_16 }, window_function = gden_save_window_7 ); 
      } /* end of rule : M1.DN.4 */
      
      //M1.R.1U is not necessary to check
      
      // Pre-Notice rules
      // New Mx.R.3
      //==============
      M1_CORE = M1X not SRCSR; 
      
      //VIA1 CHECKS
      //===========
      gLAYER_227 = size( size( M2, - ( M2_S_2_W / 2 ), clip_acute = BISECTOR ), M2_S_2_W / 2, clip_acute = BISECTOR ); 
      M2WIDE_FIRST = gLAYER_227 and M2; 
      gLAYER_228 = size( size( M2WIDE_FIRST, - ( M2_S_2_1_W / 2 ), clip_acute = BISECTOR ), M2_S_2_1_W / 2, clip_acute = BISECTOR ); 
      M2WIDE_0_p_4 = gLAYER_228 and M2WIDE_FIRST; 
      #ifdef HALF_NODE 
         gLAYER_229 = size( size( M2, - ( M2_S_2_2_W / 2 ), clip_acute = BISECTOR ), M2_S_2_2_W / 2, clip_acute = BISECTOR ); 
         M2WIDE_0_p_2 = gLAYER_229 and M2; 
         gLAYER_230 = size( size( M2WIDE_FIRST, - ( M2_S_2_3_W / 2 ), clip_acute = BISECTOR ), M2_S_2_3_W / 2, clip_acute = BISECTOR ); 
         M2WIDE_0_p_4S = gLAYER_230 and M2WIDE_FIRST; 
      #endif /* end of #ifdef HALF_NODE  */ 
      gLAYER_231 = size( size( M2WIDE_FIRST, - ( M2_S_3_W / 2 ), clip_acute = BISECTOR ), M2_S_3_W / 2, clip_acute = BISECTOR ); 
      M2WIDE_1_p_5 = gLAYER_231 and M2WIDE_FIRST; 
      gLAYER_232 = size( size( M2WIDE_1_p_5, - ( M2_S_4_W / 2 ), clip_acute = BISECTOR ), M2_S_4_W / 2, clip_acute = BISECTOR ); 
      M2WIDE_4_p_5 = gLAYER_232 and M2WIDE_1_p_5; 
      gLAYER_233 = size( size( M1WIDE_FIRST, - ( VIA1_R_2_W / 2 ), clip_acute = BISECTOR ), VIA1_R_2_W / 2, clip_acute = BISECTOR ); 
      M1WIDE_0_p_42_VIA1 = gLAYER_233 and M1WIDE_FIRST; 
      gLAYER_234 = size( size( M1WIDE_0_p_42_VIA1, - ( VIA1_R_4_W / 2 ), clip_acute = BISECTOR ), VIA1_R_4_W / 2, clip_acute = BISECTOR ); 
      M1WIDE_0_p_7_VIA1 = gLAYER_234 and M1WIDE_0_p_42_VIA1; 
      gLAYER_235 = size( size( M1WIDE_0_p_7_VIA1, - ( VIA1_R_3_W / 2 ), clip_acute = BISECTOR ), VIA1_R_3_W / 2, clip_acute = BISECTOR ); 
      M1WIDE_0_p_98_VIA1 = gLAYER_235 and M1WIDE_0_p_7_VIA1; 
      gLAYER_236 = size( size( M1WIDE_0_p_98_VIA1, - ( VIA1_R_5_W / 2 ), clip_acute = BISECTOR ), VIA1_R_5_W / 2, clip_acute = BISECTOR ); 
      M1WIDE_2_VIA1 = gLAYER_236 and M1WIDE_0_p_98_VIA1; 
      gLAYER_237 = size( size( M1WIDE_2_VIA1, - ( VIA1_R_6_W / 2 ), clip_acute = BISECTOR ), VIA1_R_6_W / 2, clip_acute = BISECTOR ); 
      M1WIDE_3_VIA1 = gLAYER_237 and M1WIDE_2_VIA1; 
      gLAYER_238 = size( size( M2WIDE_FIRST, - ( VIA1_R_2_W / 2 ), clip_acute = BISECTOR ), VIA1_R_2_W / 2, clip_acute = BISECTOR ); 
      M2WIDE_0_p_42_VIA1 = gLAYER_238 and M2WIDE_FIRST; 
      gLAYER_239 = size( size( M2WIDE_0_p_42_VIA1, - ( VIA1_R_4_W / 2 ), clip_acute = BISECTOR ), VIA1_R_4_W / 2, clip_acute = BISECTOR ); 
      M2WIDE_0_p_7_VIA1 = gLAYER_239 and M2WIDE_0_p_42_VIA1; 
      gLAYER_240 = size( size( M2WIDE_0_p_7_VIA1, - ( VIA1_R_3_W / 2 ), clip_acute = BISECTOR ), VIA1_R_3_W / 2, clip_acute = BISECTOR ); 
      M2WIDE_0_p_98_VIA1 = gLAYER_240 and M2WIDE_0_p_7_VIA1; 
      gLAYER_241 = size( size( M2WIDE_0_p_98_VIA1, - ( VIA1_R_5_W / 2 ), clip_acute = BISECTOR ), VIA1_R_5_W / 2, clip_acute = BISECTOR ); 
      M2WIDE_2_VIA1 = gLAYER_241 and M2WIDE_0_p_98_VIA1; 
      gLAYER_242 = size( size( M2WIDE_2_VIA1, - ( VIA1_R_6_W / 2 ), clip_acute = BISECTOR ), VIA1_R_6_W / 2, clip_acute = BISECTOR ); 
      M2WIDE_3_VIA1 = gLAYER_242 and M2WIDE_2_VIA1; 
      rVIA1_W_1 @= { @ "VIA1.W.1 : Width (maximum = minimum except for seal-ring and fuse protection ring) = " + VIA1_W_1 + " um " 
                                  "VIA1.R.1 45-degree rotated VIA is not allowed";
          A = not_rectangles( VIA1S, orientation = ORTHOGONAL, sides = { == VIA1_W_1, == VIA1_W_1 } ); 
          sLAYER_380 = A not VIA_EXD; 
          sLAYER_380 not SRAM_EXCLUDE; 
      } /* end of rule : VIA1.W.1 */
      
      // CSR.W.3 is checked by VIA1.W.2
      rVIA1_W_2 @= { @ "VIA1.W.2 : VIA1 bar width = " + VIA1_W_2 + " (VIA1 bar is covered by SEALRING layer and only allowed in seal-ring and fuse protecion ring)"; 
          internal1( VIA1_BAR, < VIA1_W_2, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          A = wide( VIA1_BAR, > VIA1_W_2, forty_five = INTERNAL ); 
          B = angle_edge( VIA1_BAR, == 45 ); 
          C = internal1( B, < ( VIA1_W_2 + 2 * GRID ), extension = RADIAL, intersecting = {  } ); 
          D = A not C; 
          contains( D, { 1, 0.005 }, FORTY_FIVE ); 
      } /* end of rule : VIA1.W.2 */
      rVIA1_S_1 @= { @ "VIA1.S.1 : Spacing >= " + VIA1_S_1 + " um"; 
          external1( VIA1, < VIA1_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : VIA1.S.1 */
      rVIA1_S_2 @= { @ "VIA1.S.2 : Space to 3-neighboring VIAx (< 0.14 um distance) >= " + VIA1_S_2 + " um"; 
          X = rectangle_spacing1( VIA1, count = > 2, distance = < VIA1_S_2_S ); 
          external2( X, VIA1, < VIA1_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : VIA1.S.2 */
      rVIA1_S_3 @= { @ "VIA1.S.3 : Space to neighboring VIAx [different net and common parallel run length > 0] >= " + VIA1_S_3 + " um"; 
          VIA1_NODAL = stamp( VIA1, VIA1I, CONNECT_DB, CONNECT_DB_VIA1_S_3, include_touch = NONE ); 
          external1( VIA1_NODAL, < VIA1_S_3, connect_sequence = CONNECT_DB_VIA1_S_3, connectivity = DIFFERENT_NET, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
      } /* end of rule : VIA1.S.3 */
      
      //VIA1.EN.0 is checked by either {VIA1.EN.1/VIA1.EN.2} or VIA1.EN.3
      rVIA1_EN_1 @= { @ "VIA1.EN.1 : Enclosure by M1 >= 0 um";
          VIA1 not M1; 
      } /* end of rule : VIA1.EN.1 */
      
      // VIA1.EN.2 is checked by VIA1.EN.2__VIA1.EN.3
      // VIA1.EN.3 is checked by VIA1.EN.2__VIA1.EN.3
      rVIA1_EN_2__VIA1_EN_3 @= { @ "VIA1.EN.2__VIA1.EN.3 : Enclosure by M1 [at least two opposite sides] >= " + VIA1_EN_2 + " , or [all sides] >= " + VIA1_EN_3; 
          X = not_enclosed_by( VIA1, M1S, distances = { { { 0, RADIAL }, { VIA1_EN_2, NONE }, { 0, RADIAL }, { VIA1_EN_2, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          enclose( X, M1S, < VIA1_EN_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : VIA1.EN.2__VIA1.EN.3 */
      
      // VIA1.R.1 is checked by VIA1.W.1
      // VIA1.R.2 is checked by VIA1.R.2__VIA1.R.3
      // VIA1.R.2.S is checked by VIA1.R.2__VIA1.R.3
      // VIA1.R.3 is checked by VIA1.R.2__VIA1.R.3
      
      // VIA1.R.3.S is checked by VIA1.R.2__VIA1.R.3
      rVIA1_R_2__VIA1_R_3 @= { @ "VIA1.R.2__VIA1.R.3 : When M1 or M2 width > " + VIA1_R_2_W + " um, more than one VIA1 is required. " 
                                                      "2 vias spacing should be <= " + VIA1_R_2_S1 + " um or 4 vias spacing should be <= " + VIA1_R_2_S2 + " um " 
                                                      "When M1 or M2 width > " + VIA1_R_3_W + " um, more than three VIA1 is required. " 
                                                      "4 vias spacing should be <= " + VIA1_R_3_S1 + " um or 9 vias spacing should be <= " + VIA1_R_3_S2 + " um"; 
          sLAYER_381 = M1WIDE_0_p_42_VIA1 and M2; 
          sLAYER_382 = M2WIDE_0_p_42_VIA1 and M1; 
          M2OVPM1_W_ = sLAYER_381 or sLAYER_382; 
          sLAYER_383 = M1WIDE_0_p_98_VIA1 and M2; 
          sLAYER_384 = M2WIDE_0_p_98_VIA1 and M1; 
          M2OVPM1_B = sLAYER_383 or sLAYER_384; 
          M2OVPM1_W = M2OVPM1_W_ not M2OVPM1_B; 
          CHECKED_VIA1_W_ = VIA1_EXD not_outside M2OVPM1_W; 
          CHECKED_VIA1_B = VIA1_EXD not_outside M2OVPM1_B; 
          CHECKED_VIA1_W = CHECKED_VIA1_W_ not CHECKED_VIA1_B; 
          M1_EFFECT = interacting( M1I, M2OVPM1_W_ ); 
          M2_EFFECT = interacting( M2I, M2OVPM1_W_ ); 
          EFFECT_M2OVPM1_ = M1_EFFECT and M2_EFFECT; 
          EFFECT_M2OVPM1 = interacting( EFFECT_M2OVPM1_, M2OVPM1_W_ ); 
          EFFECT_VIA = interacting( VIA1_EXD, EFFECT_M2OVPM1 ); 
          V1MERGED_A = size_inside_wrapper( EFFECT_VIA, EFFECT_M2OVPM1, distance = VIA1_R_2_S1 / 2, increment = M1_S_1 * 0.7 ); 
          V1MERGED_B = size_inside_wrapper( V1MERGED_A, EFFECT_M2OVPM1, distance = VIA1_R_2_S2_S1, increment = M1_S_1 * 0.7 ); 
          V1MERGED_C = size_inside_wrapper( V1MERGED_B, EFFECT_M2OVPM1, distance = ( VIA1_R_3_S2 - VIA1_R_2_S2 ) / 2, increment = M1_S_1 * 0.7 ); 
          V1MERGED_A2R = interacting( V1MERGED_A, EFFECT_VIA, < 2 ); 
          V1MERGED_A2 = V1MERGED_A outside V1MERGED_A2R; 
          V1MERGED_A4R = interacting( V1MERGED_A2, EFFECT_VIA, < 4 ); 
          V1MERGED_A4 = V1MERGED_A2 outside V1MERGED_A4R; 
          V1MERGED_B4R = interacting( V1MERGED_B, EFFECT_VIA, < 4 ); 
          V1MERGED_B4 = V1MERGED_B outside V1MERGED_B4R; 
          V1MERGED_C9R = interacting( V1MERGED_C, EFFECT_VIA, < 9 ); 
          V1MERGED_C9 = V1MERGED_C outside V1MERGED_C9R; 
          GMERGEW = V1MERGED_A2 or V1MERGED_B4; 
          GMERGEB = V1MERGED_A4 or V1MERGED_C9; 
          GVIA_W = interacting( CHECKED_VIA1_W, GMERGEW ); 
          GVIA_B = interacting( CHECKED_VIA1_B, GMERGEB ); 
          GOOD_AREA_W = interacting( M2OVPM1_W, GVIA_W ); 
          GOOD_AREA_B = interacting( M2OVPM1_B, GVIA_B ); 
          CHECKED_VIA1_W outside GOOD_AREA_W; 
          CHECKED_VIA1_B outside GOOD_AREA_B; 
      } /* end of rule : VIA1.R.2__VIA1.R.3 */
      
      //VIA1.R.4 is checked by VIA1.R.4:M1 and VIA1.R.4:M2
      //VIA1.R.4.S is checked by VIA1.R.4:M1 and VIA1.R.4:M2
      rVIA1_R_4_M1 @= { @ "VIA1.R.4:M1 : At least two VIAx must be used for a connection that is <= " + VIA1_R_4_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA1_R_4_W + " um (L) and width > " + VIA1_R_4_W + " um (W). (It is allowed to use one VIAx for a connection that is > " + VIA1_R_4_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA1_R_4_W + " um (L) and width > " + VIA1_R_4_W + " um (W).)"; 
          sLAYER_386 = size( M1WIDE_0_p_7_VIA1, clip_acute = NONE, distance = VIA1_R_4_D + GRID ); 
          sLAYER_385 = sLAYER_386 not M1WIDE_0_p_7_VIA1; 
          BRANCH1 = sLAYER_385 and M1; 
          sLAYER_387 = interacting( BRANCH1, M1WIDE_0_p_7_VIA1 ); 
          BRANCH1HASVIA = interacting( sLAYER_387, VIA1 ); 
          BRANCH1EDGE = M1WIDE_0_p_7_VIA1 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA1_R_4_D, increment = M1_S_1 * 0.5 ); 
          sLAYER_388 = BRANCH and M2; 
          GOODBRANCH = interacting( sLAYER_388, VIA1, > 1 ); 
          sLAYER_389 = VIA1 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_389 outside GOODBRANCH; 
          sLAYER_392 = interacting( M2, BRANCHSINGLEVIA ); 
          sLAYER_391 = sLAYER_392 and M1; 
          sLAYER_390 = interacting( sLAYER_391, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_390, VIA1, == 1 ); 
          sLAYER_393 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_393 not VIA_EXD; 
      } /* end of rule : VIA1.R.4:M1 */
      rVIA1_R_4_M2 @= { @ "VIA1.R.4:M2 : At least two VIAx must be used for a connection that is <= " + VIA1_R_4_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA1_R_4_W + " um (L) and width > " + VIA1_R_4_W + " um (W). (It is allowed to use one VIAx for a connection that is > " + VIA1_R_4_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA1_R_4_W + " um (L) and width > " + VIA1_R_4_W + " um (W).)"; 
          sLAYER_395 = size( M2WIDE_0_p_7_VIA1, clip_acute = NONE, distance = VIA1_R_4_D + GRID ); 
          sLAYER_394 = sLAYER_395 not M2WIDE_0_p_7_VIA1; 
          BRANCH1 = sLAYER_394 and M2; 
          sLAYER_396 = interacting( BRANCH1, M2WIDE_0_p_7_VIA1 ); 
          BRANCH1HASVIA = interacting( sLAYER_396, VIA1 ); 
          BRANCH1EDGE = M2WIDE_0_p_7_VIA1 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA1_R_4_D, increment = M2_S_1 * 0.5 ); 
          sLAYER_397 = BRANCH and M1; 
          GOODBRANCH = interacting( sLAYER_397, VIA1, > 1 ); 
          sLAYER_398 = VIA1 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_398 outside GOODBRANCH; 
          sLAYER_401 = interacting( M1, BRANCHSINGLEVIA ); 
          sLAYER_400 = sLAYER_401 and M2; 
          sLAYER_399 = interacting( sLAYER_400, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_399, VIA1, == 1 ); 
          sLAYER_402 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_402 not VIA_EXD; 
      } /* end of rule : VIA1.R.4:M2 */
      
      //VIA1.R.5 is checked by VIA1.R.5:M1 and VIA1.R.5:M2
      
      //VIA1.R.5.S is checked by VIA1.R.5:M1 and VIA1.R.5:M2
      rVIA1_R_5_M1 @= { @ "VIA1.R.5:M1 : At least two VIAx must be used for a connection that is <= " + VIA1_R_5_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA1_R_5_W + " um (L) and width > " + VIA1_R_5_W + " um (W). It is allowed to use one VIAx for a connection that is > " + VIA1_R_5_D + " um (D) away from a metal plate (either Mx or Mx+1) with length> " + VIA1_R_5_W + " um (L) and width > " + VIA1_R_5_W + " um (W)."; 
          sLAYER_404 = size( M1WIDE_2_VIA1, clip_acute = NONE, distance = VIA1_R_5_D + GRID ); 
          sLAYER_403 = sLAYER_404 not M1WIDE_2_VIA1; 
          BRANCH1 = sLAYER_403 and M1; 
          sLAYER_405 = interacting( BRANCH1, M1WIDE_2_VIA1 ); 
          BRANCH1HASVIA = interacting( sLAYER_405, VIA1 ); 
          BRANCH1EDGE = M1WIDE_2_VIA1 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA1_R_5_D, increment = M1_S_1 * 0.7 ); 
          sLAYER_406 = BRANCH and M2; 
          GOODBRANCH = interacting( sLAYER_406, VIA1, > 1 ); 
          sLAYER_407 = VIA1 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_407 outside GOODBRANCH; 
          sLAYER_410 = interacting( M2, BRANCHSINGLEVIA ); 
          sLAYER_409 = sLAYER_410 and M1; 
          sLAYER_408 = interacting( sLAYER_409, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_408, VIA1, == 1 ); 
          sLAYER_411 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_411 not VIA_EXD; 
      } /* end of rule : VIA1.R.5:M1 */
      rVIA1_R_5_M2 @= { @ "VIA1.R.5:M2 : At least two VIAx must be used for a connection that is <= " + VIA1_R_5_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA1_R_5_W + " um (L) and width > " + VIA1_R_5_W + " um (W). It is allowed to use one VIAx for a connection that is > " + VIA1_R_5_D + " um (D) away from a metal plate (either Mx or Mx+1) with length> " + VIA1_R_5_W + " um (L) and width > " + VIA1_R_5_W + " um (W)."; 
          sLAYER_413 = size( M2WIDE_2_VIA1, clip_acute = NONE, distance = VIA1_R_5_D + GRID ); 
          sLAYER_412 = sLAYER_413 not M2WIDE_2_VIA1; 
          BRANCH1 = sLAYER_412 and M2; 
          sLAYER_414 = interacting( BRANCH1, M2WIDE_2_VIA1 ); 
          BRANCH1HASVIA = interacting( sLAYER_414, VIA1 ); 
          BRANCH1EDGE = M2WIDE_2_VIA1 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA1_R_5_D, increment = M2_S_1 * 0.7 ); 
          sLAYER_415 = BRANCH and M1; 
          GOODBRANCH = interacting( sLAYER_415, VIA1, > 1 ); 
          sLAYER_416 = VIA1 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_416 outside GOODBRANCH; 
          sLAYER_419 = interacting( M1, BRANCHSINGLEVIA ); 
          sLAYER_418 = sLAYER_419 and M2; 
          sLAYER_417 = interacting( sLAYER_418, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_417, VIA1, == 1 ); 
          sLAYER_420 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_420 not VIA_EXD; 
      } /* end of rule : VIA1.R.5:M2 */
      M1BIG_3_VIA1 = contains( M1WIDE_3_VIA1, { VIA1_R_6_W, VIA1_R_6_L + GRID }, FORTY_FIVE ); 
      
      //VIA1.R.6 is checked by VIA1.R.6:M1 and VIA1.R.6:M2
      //VIA1.R.6.S is checked by VIA1.R.6:M1 and VIA1.R.6:M2
      rVIA1_R_6_M1 @= { @ "VIA1.R.6:M1 : At least two VIAx must be used for a connection that is <= " + VIA1_R_6_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA1_R_6_L + " um (L) and width > " + VIA1_R_6_W + " um (W). (It is allowed to use one VIAx for a connection that is > " + VIA1_R_6_D + " um (D) away from a metal plate (either Mx or Mx+1) with length> " + VIA1_R_6_L + " um (L) and width > " + VIA1_R_6_W + " um (W))."; 
          sLAYER_422 = size( M1BIG_3_VIA1, clip_acute = NONE, distance = VIA1_R_6_D + GRID ); 
          sLAYER_421 = sLAYER_422 not M1BIG_3_VIA1; 
          BRANCH1 = sLAYER_421 and M1; 
          sLAYER_423 = interacting( BRANCH1, M1BIG_3_VIA1 ); 
          BRANCH1HASVIA = interacting( sLAYER_423, VIA1 ); 
          BRANCH1EDGE = M1BIG_3_VIA1 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA1_R_6_D, increment = M1_S_1 * 0.7 ); 
          sLAYER_424 = BRANCH and M2; 
          GOODBRANCH = interacting( sLAYER_424, VIA1, > 1 ); 
          sLAYER_425 = VIA1 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_425 outside GOODBRANCH; 
          sLAYER_428 = interacting( M2, BRANCHSINGLEVIA ); 
          sLAYER_427 = sLAYER_428 and M1; 
          sLAYER_426 = interacting( sLAYER_427, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_426, VIA1, == 1 ); 
          sLAYER_429 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_429 not VIA_EXD; 
      } /* end of rule : VIA1.R.6:M1 */
      M2BIG_3_VIA1 = contains( M2WIDE_3_VIA1, { VIA1_R_6_W, VIA1_R_6_L + GRID }, FORTY_FIVE ); 
      rVIA1_R_6_M2 @= { @ "VIA1.R.6:M2 : At least two VIAx must be used for a connection that is <= " + VIA1_R_6_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA1_R_6_L + " um (L) and width > " + VIA1_R_6_W + " um (W). (It is allowed to use one VIAx for a connection that is > " + VIA1_R_6_D + " um (D) away from a metal plate (either Mx or Mx+1) with length> " + VIA1_R_6_L + " um (L) and width > " + VIA1_R_6_W + " um (W))."; 
          sLAYER_431 = size( M2BIG_3_VIA1, clip_acute = NONE, distance = VIA1_R_6_D + GRID ); 
          sLAYER_430 = sLAYER_431 not M2BIG_3_VIA1; 
          BRANCH1 = sLAYER_430 and M2; 
          sLAYER_432 = interacting( BRANCH1, M2BIG_3_VIA1 ); 
          BRANCH1HASVIA = interacting( sLAYER_432, VIA1 ); 
          BRANCH1EDGE = M2BIG_3_VIA1 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA1_R_6_D, increment = M2_S_1 * 0.7 ); 
          sLAYER_433 = BRANCH and M1; 
          GOODBRANCH = interacting( sLAYER_433, VIA1, > 1 ); 
          sLAYER_434 = VIA1 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_434 outside GOODBRANCH; 
          sLAYER_437 = interacting( M1, BRANCHSINGLEVIA ); 
          sLAYER_436 = sLAYER_437 and M2; 
          sLAYER_435 = interacting( sLAYER_436, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_435, VIA1, == 1 ); 
          sLAYER_438 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_438 not VIA_EXD; 
      } /* end of rule : VIA1.R.6:M2 */
      
      // VIA1.R.7 is checked by VIA1.EN.1 and M2.EN.1
      rVIA1_R_11 @= { @ "VIA1.R.11 : Single VIAx is not allowed for H-shape  Mx+1 when all of the following conditions come into existence: "
                                    "1. The Mx+1 has H-shape interact with two metal holes : both two metal hole area <= " + VIA1_R_11_A + " um2 and two metal hole length(L2) <= " + VIA1_R_11_L2 + " um " 
                                    "2. The VIAx overlaps on the center metal bar of this H-shape Mx+1 "
                                    "3. The length (L) of the center metal bar <= " + VIA1_R_11_L + " um and the width of metal bar is <= " + VIA1_R_11_W + " um."; 
          W = not( M2I, wide( M2I, > VIA1_R_11_W, forty_five = INTERNAL ) ); 
          sLAYER_439 = donut_holes( M2I, area = <= VIA1_R_11_A, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          H_HOLE = interacting( sLAYER_439, W ); 
          A0 = interacting( M2I, H_HOLE ); 
          A = A0 coincident_outside_edge H_HOLE; 
          sLAYER_441 = internal1( A, <= VIA1_R_11_W, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_440 = sLAYER_441 inside A0; 
          B0 = interacting( sLAYER_440, H_HOLE, == 2 ); 
          sLAYER_444 = internal1( A, <= VIA1_R_11_L, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_443 = sLAYER_444 inside A0; 
          sLAYER_442 = sLAYER_443 and W; 
          B1 = interacting( sLAYER_442, H_HOLE, == 2 ); 
          HOLE_NOTCH = external1( H_HOLE, <= VIA1_R_11_W, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_445 = B1 not HOLE_NOTCH; 
          B2 = sLAYER_445 or B0; 
          sLAYER_447 = external1( B2, <= VIA1_R_11_W, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { }, output_type = EXTENTS ); 
          sLAYER_446 = outside_touching( sLAYER_447, B2, == 2 ); 
          CORNER_M = sLAYER_446 and W; 
          B = B2 or CORNER_M; 
          CENTER_BAR1 = not_contains( B, { GRID, VIA1_R_11_L + GRID }, FORTY_FIVE ); 
          sLAYER_448 = interacting( CENTER_BAR1, H_HOLE, == 2 ); 
          CENTER_BAR2 = interacting( sLAYER_448, VIA1I ); 
          C = CENTER_BAR2 coincident_outside_edge H_HOLE; 
          D = external2_edge( C, A, <= VIA1_R_11_L2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          E = C not_coincident_inside_edge D; 
          CENTER_BAR3 = CENTER_BAR2 not_touching E; 
          CHECK_VIA = VIA1I not_outside CENTER_BAR3; 
          sLAYER_451 = interacting( A0, CHECK_VIA ); 
          sLAYER_452 = interacting( M1I, CHECK_VIA ); 
          sLAYER_450 = sLAYER_451 and sLAYER_452;
          sLAYER_449 = interacting( sLAYER_450, VIA1I, == 1 ); 
          CHECK_VIA and sLAYER_449; 
      } /* end of rule : VIA1.R.11 */
      
      //M2 CHECKS
      //=========
      M21 = M2WIDE_FIRST not CB_NON_CUP; 
      M211 = M2WIDE_0_p_4 not CB_NON_CUP; 
      #ifdef HALF_NODE 
         M212 = M2WIDE_0_p_2 not CB_NON_CUP; 
         M213 = M2WIDE_0_p_4S not CB_NON_CUP; 
      #endif /* end of #ifdef HALF_NODE  */ 
      M22 = M2WIDE_1_p_5 not CB_NON_CUP; 
      M23 = M2WIDE_4_p_5 not CB_NON_CUP; 
      M2AS3 = area( M2, > ( M2_S_3_L * M2_W_1 ) );    /* filter small metal for M2.S.3 */ 
      M2AS4 = area( M2AS3, > ( M2_S_4_L * M2_W_1 ) );    /* filter small metal for M2.S.4 */ 
      M2_EDGE_45 = angle_edge( M2, == 45 ); 
      rM2_W_1 @= { @ "M2.W.1 : Width >= " + M2_W_1 + " um"; 
          internal1( M2, < M2_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : M2.W.1 */
      rM2_W_2 @= { @ "M2.W.2 : Width of 45-degree bent Mx Please make sure the vertex of 45 degree pattern is on 5nm grid >= " + M2_W_2 + " um"; 
          internal1( M2_EDGE_45, < M2_W_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
      } /* end of rule : M2.W.2 */
      rM2_W_3 @= { @ "M2.W.3 : Maximum width <= " + M2_W_3 + " um"; 
          size( size( M2, - ( M2_W_3 / 2 ), clip_acute = BISECTOR ), M2_W_3 / 2, clip_acute = BISECTOR ); 
      } /* end of rule : M2.W.3 */
      rM2_S_1 @= { @ "M2.S.1 : Spacing >= " + M2_S_1 + " um"; 
          external1( M2, < M2_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : M2.S.1 */
      
      //M2.S.2.S is checked by M2.S.2 
      rM2_S_2 @= { @ "M2.S.2 : Space [at least one metal line width > " + M2_S_2_W + " um  and the parallel metal run length > " + M2_S_2_L + " um ] (union projection) >= " + M2_S_2; 
          X = external2( M21, M2, < M2_S_2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M2; 
          contains( Y, { GRID, M2_S_2_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M2.S.2 */
      
      //M2.S.2.1.S is checked by M2.S.2.1
      rM2_S_2_1 @= { @ "M2.S.2.1 : Space [at least one metal line width > " + M2_S_2_1_W + " um  and the parallel metal run length > " + M2_S_2_1_L + " um ] (union projection) >= " + M2_S_2_1; 
          X = external2( M211, M2, < M2_S_2_1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M2; 
          contains( Y, { GRID, M2_S_2_1_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M2.S.2.1 */
      #ifdef HALF_NODE 
         
         //M2.S.2.2.S is checked by M2.S.2.2
         rM2_S_2_2 @= { @ "M2.S.2.2 : Space [at least one metal line width > " + M2_S_2_2_W + " um  and the parallel metal run length > " + M2_S_2_2_L + " um ] (union projection) >= " + M2_S_2_2; 
             X = external2( M212, M2, < M2_S_2_2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
             Y = X not M2; 
             contains( Y, { GRID, M2_S_2_2_L + GRID }, FORTY_FIVE ); 
         } /* end of rule : M2.S.2.2 */
         
         //M2.S.2.3.S is checked by M2.S.2.3
         rM2_S_2_3 @= { @ "M2.S.2.3 : Space [at least one metal line width > " + M2_S_2_3_W + " um  and the parallel metal run length > " + M2_S_2_3_L + " um ] (union projection) >= " + M2_S_2_3; 
             X = external2( M213, M2, < M2_S_2_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
             Y = X not M2; 
             contains( Y, { GRID, M2_S_2_3_L + GRID }, FORTY_FIVE ); 
         } /* end of rule : M2.S.2.3 */
      #endif /* end of #ifdef HALF_NODE  */ 
      
      //M2.S.3.S is checked by M2.S.3
      rM2_S_3 @= { @ "M2.S.3 : Space [at least one metal line width > " + M2_S_3_W + " um  and the parallel metal run length > " + M2_S_3_L + " um ] (union projection) >= " + M2_S_3; 
          X = external2( M22, M2AS3, < M2_S_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M2; 
          contains( Y, { GRID, M2_S_3_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M2.S.3 */
      
      //M2.S.4.S is checked by M2.S.4
      rM2_S_4 @= { @ "M2.S.4 : Space [at least one metal line width > " + M2_S_4_W + " um  and the parallel metal run length > " + M2_S_4_L + " um ] (union projection) >= " + M2_S_4; 
          X = external2( M23, M2AS4, < M2_S_4, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M2; 
          contains( Y, { GRID, M2_S_4_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M2.S.4 */
      rM2_S_5 @= { @ "M2.S.5 : Space at Mx line-end (W<Q=0.120) in a dense-line-end configuration: If Mx has parallel run length with opposite Mx (measured with T=0.035 extension) along 2 adjacent edges of Mx [any one edge <Q distance from the corner of the two edges], then one of the space (S1 or S2) needs to be at least this value (except for small jog with edge length < 0.10 um (R)) >= " + M2_S_5 + " um."; 
          M2SX = M2 not SRAM_EXCLUDE; 
          A = adjacent_edge( M2SX, angle1 = == 90, angle2 = == 90, length = < M2_S_5_Q ); 
          B = external2_edge( A, M2SX, < M2_S_5, extension = EDGE, extension_distance = M2_S_5_E, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1 ); 
          C = A inside_touching_edge B; 
          D = internal2_edge( C, M2SX, < M2_S_5_Q, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 90, look_thru = RELATED_COINCIDENT, orientation = { }, output_layer = LAYER2 ); 
          I = length_edge( D, >= M2_W_1 ); 
          sLAYER_1316 = extend_edge( I, start = M2_S_5_E, end = M2_S_5_E ); 
          J = edge_size( sLAYER_1316, inside = 0.001 ); 
          K = edge_size( I, inside = 0.001 ); 
          L = J not K; 
          M = L touching A; 
          N = M or K; 
          O = N touching_edge I; 
          external2( O, M2SX, < M2_S_5, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
      } /* end of rule : M2.S.5 */
      
      //M2.EN.0 is checked by either {M2.EN.1/M2.EN.2} or M2.EN.3
      rM2_EN_1 @= { @ "M2.EN.1 : Enclosure of VIA1 >= 0 um";
          VIA1 not M2; 
      } /* end of rule : M2.EN.1 */
      
      // M2.EN.2 is checked by M2.EN.2__M2.EN.3
      // M2.EN.3 is checked by M2.EN.2__M2.EN.3
      rM2_EN_2__M2_EN_3 @= { @ "M2.EN.2__M2.EN.3 : Enclosure of VIA1 [at least two opposite sides] >= " + M2_EN_2 + " ,or [all sides] >= " + M2_EN_3; 
          X = not_enclosed_by( VIA1, M2, distances = { { { 0, RADIAL }, { M2_EN_2, NONE }, { 0, RADIAL }, { M2_EN_2, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          enclose( X, M2, < M2_EN_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : M2.EN.2__M2.EN.3 */
      rM2_A_1 @= { @ "M2.A.1 : Area >= " + M2_A_1 + " um2"; 
          A = area( M2, < M2_A_1 ); 
          A not SRAM_EXCLUDE; 
      } /* end of rule : M2.A.1 */
      rM2_A_2 @= { @ "M2.A.2 : Enclosed area >= " + M2_A_2 + " um"; 
          X = donut_holes( M2, area = < M2_A_2PRE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          sLAYER_453 = X not M2; 
          area( sLAYER_453, < M2_A_2 ); 
      } /* end of rule : M2.A.2 */
      rM2_S_6 @= { @ "M2.S.6 : Space to 45 degree bent M2 >= " + M2_S_6 + " um"; 
          X = edge_size( M2_EDGE_45, outside = M2_S_6 ); 
          X and M2; 
      } /* end of rule : M2.S.6 */
      M2DN1H_EXC = copy( M2_EXC ); 
      M2DN1L_EXC = copy( M2_EXC_LOW ); 
      #ifdef CHECK_LOW_DENSITY 
         rM2_DN_1 @= { @ "M2.DN.1 : M2 local density must be >= " + M2_DN_1L + " range over " + M2_DN_1L_W + " um x " + M2_DN_1L_W + " um step " + M2_DN_1L_S + " um"; 
             M2_CHECK = M2X not M2DN1L_EXC; 
             CHIP_CHECK = gCHIP not M2DN1L_EXC; 
         _den_con = < M2_DN_1L; 
         _den_polygon_area_clip = false;
         _den_print = false;
         _den_print_only = false;
             ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M2_CHECK, "layer2" => CHIP_CHECK }, delta_window = { M2_DN_1L_W, M2_DN_1L_W }, delta_x = M2_DN_1L_S, delta_y = M2_DN_1L_S, boundary = BACKUP, window_function = den_save_window_1 ); 
             sLAYER_454 = ERR_WIN not M2DN1L_EXC; 
             F = wide( sLAYER_454, >= M2_DN_1L_E, forty_five = INTERNAL ); 
             VAR_17 = density_statistics_file( file = "M2.DN.1.density" ); 
         _den_con = < M2_DN_1L; 
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M2_CHECK, "layer3" => CHIP_CHECK }, delta_window = { M2_DN_1L_W, M2_DN_1L_W }, delta_x = M2_DN_1L_S, delta_y = M2_DN_1L_S, boundary = BACKUP, statistics_files = { VAR_17 }, window_function = den_save_window_2 ); 
         } /* end of rule : M2.DN.1 */
      #endif /* end of #ifdef CHECK_LOW_DENSITY  */ 
      rM2_DN_1_1 @= { @ "M2.DN.1.1 : M2 local density must be <= " + M2_DN_1H + " range over " + M2_DN_1H_W + " um x " + M2_DN_1H_W + " um step " + M2_DN_1H_S + " um"; 
          M2_CHECK = M2X not M2DN1H_EXC; 
          CHIP_CHECK = gCHIP not M2DN1H_EXC; 
      _den_con = > M2_DN_1H; 
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M2_CHECK, "layer2" => CHIP_CHECK }, delta_window = { M2_DN_1H_W, M2_DN_1H_W }, delta_x = M2_DN_1H_S, delta_y = M2_DN_1H_S, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_455 = ERR_WIN not M2DN1H_EXC; 
          F = wide( sLAYER_455, >= M2_DN_1H_E, forty_five = INTERNAL ); 
          VAR_18 = density_statistics_file( file = "M2.DN.1.1.density" ); 
      _den_con = > M2_DN_1H; 
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M2_CHECK, "layer3" => CHIP_CHECK }, delta_window = { M2_DN_1H_W, M2_DN_1H_W }, delta_x = M2_DN_1H_S, delta_y = M2_DN_1H_S, boundary = BACKUP, statistics_files = { VAR_18 }, window_function = den_save_window_3 ); 
      } /* end of rule : M2.DN.1.1 */
      M2DN2_EXC = copy( EMPTYI ); 
      rM2_DN_2 @= { @ "M2.DN.2 : M2 local density must be <= " + M2_DN_2 + " range over " + M2_DN_2_W + " um x " + M2_DN_2_W + " um step " + M2_DN_2_S + " um"; 
          M2_CHECK = M2X not M2DN2_EXC; 
      _den_con = > M2_DN_2; 
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M2_CHECK, "layer2" => gCHIP }, delta_window = { M2_DN_2_W, M2_DN_2_W }, delta_x = M2_DN_2_S, delta_y = M2_DN_2_S, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_456 = ERR_WIN not M2DN2_EXC; 
          F = wide( sLAYER_456, >= M2_DN_2_E, forty_five = INTERNAL ); 
          VAR_19 = density_statistics_file( file = "M2.DN.2.density" ); 
      _den_con = > M2_DN_2; 
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M2_CHECK, "layer3" => gCHIP }, delta_window = { M2_DN_2_W, M2_DN_2_W }, delta_x = M2_DN_2_S, delta_y = M2_DN_2_S, boundary = BACKUP, statistics_files = { VAR_19 }, window_function = den_save_window_3 ); 
      } /* end of rule : M2.DN.2 */
      rM2_DN_4 @= { @ "M2.DN.4 : The metal density difference between any two " + M2_DN_4_W + " um x " + M2_DN_4_W + " um neighboring checking windows including DM2EXCL <= " + M2_DN_4; 
          sLAYER_1317 = chip_extent();
          VAR_20 = density_statistics_file( file = "M2.DN.4.density" ); 
      _gden_con = <= 1;
      _gden_gcon = > M2_DN_4; 
      _gden_absolute = true;
      _gden_corner = true;
      _gden_corner_value = -1.0;
      _gden_polygon_area_clip = true;
      _gden_print = true;
      _gden_print_only = false;
          sLAYER_1317 = sLAYER_1317 or gCHIP;
gradient_density( window_layer = sLAYER_1317, layer_hash = { "layer1" => M2X, "layer2" => gCHIP }, delta_window = { M2_DN_4_W, M2_DN_4_W }, delta_x = M2_DN_4_W, delta_y = M2_DN_4_W, boundary = BACKUP, statistics_files = { VAR_20 }, window_function = gden_save_window_7 ); 
      } /* end of rule : M2.DN.4 */
      
      //M2.R.1U is not necessary to check
      
      // Mx.DN.5
      //===========
      M2_CORE = M2X not SRCSR; 
      
      //VIA2 CHECKS
      //===========
      gLAYER_243 = size( size( M3, - ( M3_S_2_W / 2 ), clip_acute = BISECTOR ), M3_S_2_W / 2, clip_acute = BISECTOR ); 
      M3WIDE_FIRST = gLAYER_243 and M3; 
      gLAYER_244 = size( size( M3WIDE_FIRST, - ( M3_S_2_1_W / 2 ), clip_acute = BISECTOR ), M3_S_2_1_W / 2, clip_acute = BISECTOR ); 
      M3WIDE_0_p_4 = gLAYER_244 and M3WIDE_FIRST; 
      #ifdef HALF_NODE 
         gLAYER_245 = size( size( M3, - ( M3_S_2_2_W / 2 ), clip_acute = BISECTOR ), M3_S_2_2_W / 2, clip_acute = BISECTOR ); 
         M3WIDE_0_p_2 = gLAYER_245 and M3; 
         gLAYER_246 = size( size( M3WIDE_FIRST, - ( M3_S_2_3_W / 2 ), clip_acute = BISECTOR ), M3_S_2_3_W / 2, clip_acute = BISECTOR ); 
         M3WIDE_0_p_4S = gLAYER_246 and M3WIDE_FIRST; 
      #endif /* end of #ifdef HALF_NODE  */ 
      gLAYER_247 = size( size( M3WIDE_FIRST, - ( M3_S_3_W / 2 ), clip_acute = BISECTOR ), M3_S_3_W / 2, clip_acute = BISECTOR ); 
      M3WIDE_1_p_5 = gLAYER_247 and M3WIDE_FIRST; 
      gLAYER_248 = size( size( M3WIDE_1_p_5, - ( M3_S_4_W / 2 ), clip_acute = BISECTOR ), M3_S_4_W / 2, clip_acute = BISECTOR ); 
      M3WIDE_4_p_5 = gLAYER_248 and M3WIDE_1_p_5; 
      gLAYER_249 = size( size( M2WIDE_FIRST, - ( VIA2_R_2_W / 2 ), clip_acute = BISECTOR ), VIA2_R_2_W / 2, clip_acute = BISECTOR ); 
      M2WIDE_0_p_42_VIA2 = gLAYER_249 and M2WIDE_FIRST; 
      gLAYER_250 = size( size( M2WIDE_0_p_42_VIA2, - ( VIA2_R_4_W / 2 ), clip_acute = BISECTOR ), VIA2_R_4_W / 2, clip_acute = BISECTOR ); 
      M2WIDE_0_p_7_VIA2 = gLAYER_250 and M2WIDE_0_p_42_VIA2; 
      gLAYER_251 = size( size( M2WIDE_0_p_7_VIA2, - ( VIA2_R_3_W / 2 ), clip_acute = BISECTOR ), VIA2_R_3_W / 2, clip_acute = BISECTOR ); 
      M2WIDE_0_p_98_VIA2 = gLAYER_251 and M2WIDE_0_p_7_VIA2; 
      gLAYER_252 = size( size( M2WIDE_0_p_98_VIA2, - ( VIA2_R_5_W / 2 ), clip_acute = BISECTOR ), VIA2_R_5_W / 2, clip_acute = BISECTOR ); 
      M2WIDE_2_VIA2 = gLAYER_252 and M2WIDE_0_p_98_VIA2; 
      gLAYER_253 = size( size( M2WIDE_2_VIA2, - ( VIA2_R_6_W / 2 ), clip_acute = BISECTOR ), VIA2_R_6_W / 2, clip_acute = BISECTOR ); 
      M2WIDE_3_VIA2 = gLAYER_253 and M2WIDE_2_VIA2; 
      gLAYER_254 = size( size( M3WIDE_FIRST, - ( VIA2_R_2_W / 2 ), clip_acute = BISECTOR ), VIA2_R_2_W / 2, clip_acute = BISECTOR ); 
      M3WIDE_0_p_42_VIA2 = gLAYER_254 and M3WIDE_FIRST; 
      gLAYER_255 = size( size( M3WIDE_0_p_42_VIA2, - ( VIA2_R_4_W / 2 ), clip_acute = BISECTOR ), VIA2_R_4_W / 2, clip_acute = BISECTOR ); 
      M3WIDE_0_p_7_VIA2 = gLAYER_255 and M3WIDE_0_p_42_VIA2; 
      gLAYER_256 = size( size( M3WIDE_0_p_7_VIA2, - ( VIA2_R_3_W / 2 ), clip_acute = BISECTOR ), VIA2_R_3_W / 2, clip_acute = BISECTOR ); 
      M3WIDE_0_p_98_VIA2 = gLAYER_256 and M3WIDE_0_p_7_VIA2; 
      gLAYER_257 = size( size( M3WIDE_0_p_98_VIA2, - ( VIA2_R_5_W / 2 ), clip_acute = BISECTOR ), VIA2_R_5_W / 2, clip_acute = BISECTOR ); 
      M3WIDE_2_VIA2 = gLAYER_257 and M3WIDE_0_p_98_VIA2; 
      gLAYER_258 = size( size( M3WIDE_2_VIA2, - ( VIA2_R_6_W / 2 ), clip_acute = BISECTOR ), VIA2_R_6_W / 2, clip_acute = BISECTOR ); 
      M3WIDE_3_VIA2 = gLAYER_258 and M3WIDE_2_VIA2; 
      rVIA2_W_1 @= { @ "VIA2.W.1 : Width (maximum = minimum except for seal-ring and fuse protection ring) = " + VIA2_W_1 + " um " 
                                  "VIA2.R.1 45-degree rotated VIA is not allowed";
          A = not_rectangles( VIA2, orientation = ORTHOGONAL, sides = { == VIA2_W_1, == VIA2_W_1 } ); 
          A not VIA_EXD; 
      } /* end of rule : VIA2.W.1 */
      
      // CSR.W.3 is checked by VIA2.W.2
      rVIA2_W_2 @= { @ "VIA2.W.2 : VIA2 bar width = " + VIA2_W_2 + " (VIA2 bar is covered by SEALRING layer and only allowed in seal-ring and fuse protecion ring)"; 
          internal1( VIA2_BAR, < VIA2_W_2, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          A = wide( VIA2_BAR, > VIA2_W_2, forty_five = INTERNAL ); 
          B = angle_edge( VIA2_BAR, == 45 ); 
          C = internal1( B, < ( VIA2_W_2 + 2 * GRID ), extension = RADIAL, intersecting = {  } ); 
          D = A not C; 
          contains( D, { 1, 0.005 }, FORTY_FIVE ); 
      } /* end of rule : VIA2.W.2 */
      rVIA2_S_1 @= { @ "VIA2.S.1 : Spacing >= " + VIA2_S_1 + " um"; 
          external1( VIA2, < VIA2_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : VIA2.S.1 */
      rVIA2_S_2 @= { @ "VIA2.S.2 : Space to 3-neighboring VIAx (< 0.14 um distance) >= " + VIA2_S_2 + " um"; 
          X = rectangle_spacing1( VIA2, count = > 2, distance = < VIA2_S_2_S ); 
          external2( X, VIA2, < VIA2_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : VIA2.S.2 */
      rVIA2_S_3 @= { @ "VIA2.S.3 : Space to neighboring VIAx [different net and common parallel run length > 0] >= " + VIA2_S_3 + " um"; 
          VIA2_NODAL = stamp( VIA2, VIA2I, CONNECT_DB, CONNECT_DB_VIA2_S_3, include_touch = NONE ); 
          external1( VIA2_NODAL, < VIA2_S_3, connect_sequence = CONNECT_DB_VIA2_S_3, connectivity = DIFFERENT_NET, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
      } /* end of rule : VIA2.S.3 */
      
      //VIA2.EN.0 is checked by either {VIA2.EN.1/VIA2.EN.2} or VIA2.EN.3
      rVIA2_EN_1 @= { @ "VIA2.EN.1 : Enclosure by M2 >= 0 um";
          VIA2 not M2; 
      } /* end of rule : VIA2.EN.1 */
      
      // VIA2.EN.2 is checked by VIA2.EN.2__VIA2.EN.3
      // VIA2.EN.3 is checked by VIA2.EN.2__VIA2.EN.3
      rVIA2_EN_2__VIA2_EN_3 @= { @ "VIA2.EN.2__VIA2.EN.3 : Enclosure by M2 [at least two opposite sides] >= " + VIA2_EN_2 + " , or [all sides] >= " + VIA2_EN_3; 
          A = VIA2 not SRAM_EXCLUDE; 
          X = not_enclosed_by( A, M2, distances = { { { 0, RADIAL }, { VIA2_EN_2, NONE }, { 0, RADIAL }, { VIA2_EN_2, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          enclose( X, M2, < VIA2_EN_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : VIA2.EN.2__VIA2.EN.3 */
      
      // VIA2.R.1 is checked by VIA2.W.1
      // VIA2.R.2 is checked by VIA2.R.2__VIA2.R.3
      // VIA2.R.2.S is checked by VIA2.R.2__VIA2.R.3
      // VIA2.R.3 is checked by VIA2.R.2__VIA2.R.3
      
      // VIA2.R.3.S is checked by VIA2.R.2__VIA2.R.3
      rVIA2_R_2__VIA2_R_3 @= { @ "VIA2.R.2__VIA2.R.3 : When M2 or M3 width > " + VIA2_R_2_W + " um, more than one VIA2 is required. " 
                                                      "2 vias spacing should be <= " + VIA2_R_2_S1 + " um or 4 vias spacing should be <= " + VIA2_R_2_S2 + " um " 
                                                      "When M2 or M3 width > " + VIA2_R_3_W + " um, more than three VIA2 is required. " 
                                                      "4 vias spacing should be <= " + VIA2_R_3_S1 + " um or 9 vias spacing should be <= " + VIA2_R_3_S2 + " um"; 
          sLAYER_457 = M2WIDE_0_p_42_VIA2 and M3; 
          sLAYER_458 = M3WIDE_0_p_42_VIA2 and M2; 
          M3OVPM2_W_ = sLAYER_457 or sLAYER_458; 
          sLAYER_459 = M2WIDE_0_p_98_VIA2 and M3; 
          sLAYER_460 = M3WIDE_0_p_98_VIA2 and M2; 
          M3OVPM2_B = sLAYER_459 or sLAYER_460; 
          M3OVPM2_W = M3OVPM2_W_ not M3OVPM2_B; 
          CHECKED_VIA2_W_ = VIA2_EXD not_outside M3OVPM2_W; 
          CHECKED_VIA2_B = VIA2_EXD not_outside M3OVPM2_B; 
          CHECKED_VIA2_W = CHECKED_VIA2_W_ not CHECKED_VIA2_B; 
          M2_EFFECT = interacting( M2I, M3OVPM2_W_ ); 
          M3_EFFECT = interacting( M3I, M3OVPM2_W_ ); 
          EFFECT_M3OVPM2_ = M2_EFFECT and M3_EFFECT; 
          EFFECT_M3OVPM2 = interacting( EFFECT_M3OVPM2_, M3OVPM2_W_ ); 
          EFFECT_VIA = interacting( VIA2_EXD, EFFECT_M3OVPM2 ); 
          V2MERGED_A = size_inside_wrapper( EFFECT_VIA, EFFECT_M3OVPM2, distance = VIA2_R_2_S1 / 2, increment = M2_S_1 * 0.7 ); 
          V2MERGED_B = size_inside_wrapper( V2MERGED_A, EFFECT_M3OVPM2, distance = VIA2_R_2_S2_S1, increment = M2_S_1 * 0.7 ); 
          V2MERGED_C = size_inside_wrapper( V2MERGED_B, EFFECT_M3OVPM2, distance = ( VIA2_R_3_S2 - VIA2_R_2_S2 ) / 2, increment = M2_S_1 * 0.7 ); 
          V2MERGED_A2R = interacting( V2MERGED_A, EFFECT_VIA, < 2 ); 
          V2MERGED_A2 = V2MERGED_A outside V2MERGED_A2R; 
          V2MERGED_A4R = interacting( V2MERGED_A2, EFFECT_VIA, < 4 ); 
          V2MERGED_A4 = V2MERGED_A2 outside V2MERGED_A4R; 
          V2MERGED_B4R = interacting( V2MERGED_B, EFFECT_VIA, < 4 ); 
          V2MERGED_B4 = V2MERGED_B outside V2MERGED_B4R; 
          V2MERGED_C9R = interacting( V2MERGED_C, EFFECT_VIA, < 9 ); 
          V2MERGED_C9 = V2MERGED_C outside V2MERGED_C9R; 
          GMERGEW = V2MERGED_A2 or V2MERGED_B4; 
          GMERGEB = V2MERGED_A4 or V2MERGED_C9; 
          GVIA_W = interacting( CHECKED_VIA2_W, GMERGEW ); 
          GVIA_B = interacting( CHECKED_VIA2_B, GMERGEB ); 
          GOOD_AREA_W = interacting( M3OVPM2_W, GVIA_W ); 
          GOOD_AREA_B = interacting( M3OVPM2_B, GVIA_B ); 
          CHECKED_VIA2_W outside GOOD_AREA_W; 
          CHECKED_VIA2_B outside GOOD_AREA_B; 
      } /* end of rule : VIA2.R.2__VIA2.R.3 */
      
      //VIA2.R.4 is checked by VIA2.R.4:M2 and VIA2.R.4:M3
      //VIA2.R.4.S is checked by VIA2.R.4:M2 and VIA2.R.4:M3
      rVIA2_R_4_M2 @= { @ "VIA2.R.4:M2 : At least two VIAx must be used for a connection that is <= " + VIA2_R_4_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA2_R_4_W + " um (L) and width > " + VIA2_R_4_W + " um (W). (It is allowed to use one VIAx for a connection that is > " + VIA2_R_4_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA2_R_4_W + " um (L) and width > " + VIA2_R_4_W + " um (W).)"; 
          sLAYER_462 = size( M2WIDE_0_p_7_VIA2, clip_acute = NONE, distance = VIA2_R_4_D + GRID ); 
          sLAYER_461 = sLAYER_462 not M2WIDE_0_p_7_VIA2; 
          BRANCH1 = sLAYER_461 and M2; 
          sLAYER_463 = interacting( BRANCH1, M2WIDE_0_p_7_VIA2 ); 
          BRANCH1HASVIA = interacting( sLAYER_463, VIA2 ); 
          BRANCH1EDGE = M2WIDE_0_p_7_VIA2 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA2_R_4_D, increment = M2_S_1 * 0.5 ); 
          sLAYER_464 = BRANCH and M3; 
          GOODBRANCH = interacting( sLAYER_464, VIA2, > 1 ); 
          sLAYER_465 = VIA2 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_465 outside GOODBRANCH; 
          sLAYER_468 = interacting( M3, BRANCHSINGLEVIA ); 
          sLAYER_467 = sLAYER_468 and M2; 
          sLAYER_466 = interacting( sLAYER_467, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_466, VIA2, == 1 ); 
          sLAYER_469 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_469 not VIA_EXD; 
      } /* end of rule : VIA2.R.4:M2 */
      rVIA2_R_4_M3 @= { @ "VIA2.R.4:M3 : At least two VIAx must be used for a connection that is <= " + VIA2_R_4_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA2_R_4_W + " um (L) and width > " + VIA2_R_4_W + " um (W). (It is allowed to use one VIAx for a connection that is > " + VIA2_R_4_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA2_R_4_W + " um (L) and width > " + VIA2_R_4_W + " um (W).)"; 
          sLAYER_471 = size( M3WIDE_0_p_7_VIA2, clip_acute = NONE, distance = VIA2_R_4_D + GRID ); 
          sLAYER_470 = sLAYER_471 not M3WIDE_0_p_7_VIA2; 
          BRANCH1 = sLAYER_470 and M3; 
          sLAYER_472 = interacting( BRANCH1, M3WIDE_0_p_7_VIA2 ); 
          BRANCH1HASVIA = interacting( sLAYER_472, VIA2 ); 
          BRANCH1EDGE = M3WIDE_0_p_7_VIA2 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA2_R_4_D, increment = M3_S_1 * 0.5 ); 
          sLAYER_473 = BRANCH and M2; 
          GOODBRANCH = interacting( sLAYER_473, VIA2, > 1 ); 
          sLAYER_474 = VIA2 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_474 outside GOODBRANCH; 
          sLAYER_477 = interacting( M2, BRANCHSINGLEVIA ); 
          sLAYER_476 = sLAYER_477 and M3; 
          sLAYER_475 = interacting( sLAYER_476, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_475, VIA2, == 1 ); 
          sLAYER_478 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_478 not VIA_EXD; 
      } /* end of rule : VIA2.R.4:M3 */
      
      //VIA2.R.5 is checked by VIA2.R.5:M2 and VIA2.R.5:M3
      
      //VIA2.R.5.S is checked by VIA2.R.5:M2 and VIA2.R.5:M3
      rVIA2_R_5_M2 @= { @ "VIA2.R.5:M2 : At least two VIAx must be used for a connection that is <= " + VIA2_R_5_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA2_R_5_W + " um (L) and width > " + VIA2_R_5_W + " um (W). It is allowed to use one VIAx for a connection that is > " + VIA2_R_5_D + " um (D) away from a metal plate (either Mx or Mx+1) with length> " + VIA2_R_5_W + " um (L) and width > " + VIA2_R_5_W + " um (W)."; 
          sLAYER_480 = size( M2WIDE_2_VIA2, clip_acute = NONE, distance = VIA2_R_5_D + GRID ); 
          sLAYER_479 = sLAYER_480 not M2WIDE_2_VIA2; 
          BRANCH1 = sLAYER_479 and M2; 
          sLAYER_481 = interacting( BRANCH1, M2WIDE_2_VIA2 ); 
          BRANCH1HASVIA = interacting( sLAYER_481, VIA2 ); 
          BRANCH1EDGE = M2WIDE_2_VIA2 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA2_R_5_D, increment = M2_S_1 * 0.7 ); 
          sLAYER_482 = BRANCH and M3; 
          GOODBRANCH = interacting( sLAYER_482, VIA2, > 1 ); 
          sLAYER_483 = VIA2 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_483 outside GOODBRANCH; 
          sLAYER_486 = interacting( M3, BRANCHSINGLEVIA ); 
          sLAYER_485 = sLAYER_486 and M2; 
          sLAYER_484 = interacting( sLAYER_485, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_484, VIA2, == 1 ); 
          sLAYER_487 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_487 not VIA_EXD; 
      } /* end of rule : VIA2.R.5:M2 */
      rVIA2_R_5_M3 @= { @ "VIA2.R.5:M3 : At least two VIAx must be used for a connection that is <= " + VIA2_R_5_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA2_R_5_W + " um (L) and width > " + VIA2_R_5_W + " um (W). It is allowed to use one VIAx for a connection that is > " + VIA2_R_5_D + " um (D) away from a metal plate (either Mx or Mx+1) with length> " + VIA2_R_5_W + " um (L) and width > " + VIA2_R_5_W + " um (W)."; 
          sLAYER_489 = size( M3WIDE_2_VIA2, clip_acute = NONE, distance = VIA2_R_5_D + GRID ); 
          sLAYER_488 = sLAYER_489 not M3WIDE_2_VIA2; 
          BRANCH1 = sLAYER_488 and M3; 
          sLAYER_490 = interacting( BRANCH1, M3WIDE_2_VIA2 ); 
          BRANCH1HASVIA = interacting( sLAYER_490, VIA2 ); 
          BRANCH1EDGE = M3WIDE_2_VIA2 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA2_R_5_D, increment = M3_S_1 * 0.7 ); 
          sLAYER_491 = BRANCH and M2; 
          GOODBRANCH = interacting( sLAYER_491, VIA2, > 1 ); 
          sLAYER_492 = VIA2 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_492 outside GOODBRANCH; 
          sLAYER_495 = interacting( M2, BRANCHSINGLEVIA ); 
          sLAYER_494 = sLAYER_495 and M3; 
          sLAYER_493 = interacting( sLAYER_494, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_493, VIA2, == 1 ); 
          sLAYER_496 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_496 not VIA_EXD; 
      } /* end of rule : VIA2.R.5:M3 */
      M2BIG_3_VIA2 = contains( M2WIDE_3_VIA2, { VIA2_R_6_W, VIA2_R_6_L + GRID }, FORTY_FIVE ); 
      
      //VIA2.R.6 is checked by VIA2.R.6:M2 and VIA2.R.6:M3
      //VIA2.R.6.S is checked by VIA2.R.6:M2 and VIA2.R.6:M3
      rVIA2_R_6_M2 @= { @ "VIA2.R.6:M2 : At least two VIAx must be used for a connection that is <= " + VIA2_R_6_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA2_R_6_L + " um (L) and width > " + VIA2_R_6_W + " um (W). (It is allowed to use one VIAx for a connection that is > " + VIA2_R_6_D + " um (D) away from a metal plate (either Mx or Mx+1) with length> " + VIA2_R_6_L + " um (L) and width > " + VIA2_R_6_W + " um (W))."; 
          sLAYER_498 = size( M2BIG_3_VIA2, clip_acute = NONE, distance = VIA2_R_6_D + GRID ); 
          sLAYER_497 = sLAYER_498 not M2BIG_3_VIA2; 
          BRANCH1 = sLAYER_497 and M2; 
          sLAYER_499 = interacting( BRANCH1, M2BIG_3_VIA2 ); 
          BRANCH1HASVIA = interacting( sLAYER_499, VIA2 ); 
          BRANCH1EDGE = M2BIG_3_VIA2 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA2_R_6_D, increment = M2_S_1 * 0.7 ); 
          sLAYER_500 = BRANCH and M3; 
          GOODBRANCH = interacting( sLAYER_500, VIA2, > 1 ); 
          sLAYER_501 = VIA2 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_501 outside GOODBRANCH; 
          sLAYER_504 = interacting( M3, BRANCHSINGLEVIA ); 
          sLAYER_503 = sLAYER_504 and M2; 
          sLAYER_502 = interacting( sLAYER_503, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_502, VIA2, == 1 ); 
          sLAYER_505 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_505 not VIA_EXD; 
      } /* end of rule : VIA2.R.6:M2 */
      M3BIG_3_VIA2 = contains( M3WIDE_3_VIA2, { VIA2_R_6_W, VIA2_R_6_L + GRID }, FORTY_FIVE ); 
      rVIA2_R_6_M3 @= { @ "VIA2.R.6:M3 : At least two VIAx must be used for a connection that is <= " + VIA2_R_6_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA2_R_6_L + " um (L) and width > " + VIA2_R_6_W + " um (W). (It is allowed to use one VIAx for a connection that is > " + VIA2_R_6_D + " um (D) away from a metal plate (either Mx or Mx+1) with length> " + VIA2_R_6_L + " um (L) and width > " + VIA2_R_6_W + " um (W))."; 
          sLAYER_507 = size( M3BIG_3_VIA2, clip_acute = NONE, distance = VIA2_R_6_D + GRID ); 
          sLAYER_506 = sLAYER_507 not M3BIG_3_VIA2; 
          BRANCH1 = sLAYER_506 and M3; 
          sLAYER_508 = interacting( BRANCH1, M3BIG_3_VIA2 ); 
          BRANCH1HASVIA = interacting( sLAYER_508, VIA2 ); 
          BRANCH1EDGE = M3BIG_3_VIA2 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA2_R_6_D, increment = M3_S_1 * 0.7 ); 
          sLAYER_509 = BRANCH and M2; 
          GOODBRANCH = interacting( sLAYER_509, VIA2, > 1 ); 
          sLAYER_510 = VIA2 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_510 outside GOODBRANCH; 
          sLAYER_513 = interacting( M2, BRANCHSINGLEVIA ); 
          sLAYER_512 = sLAYER_513 and M3; 
          sLAYER_511 = interacting( sLAYER_512, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_511, VIA2, == 1 ); 
          sLAYER_514 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_514 not VIA_EXD; 
      } /* end of rule : VIA2.R.6:M3 */
      
      // VIA2.R.7 is checked by VIA2.EN.1 and M3.EN.1
      rVIA2_R_11 @= { @ "VIA2.R.11 : Single VIAx is not allowed for H-shape  Mx+1 when all of the following conditions come into existence: "
                                    "1. The Mx+1 has H-shape interact with two metal holes : both two metal hole area <= " + VIA2_R_11_A + " um2 and two metal hole length(L2) <= " + VIA2_R_11_L2 + " um " 
                                    "2. The VIAx overlaps on the center metal bar of this H-shape Mx+1 "
                                    "3. The length (L) of the center metal bar <= " + VIA2_R_11_L + " um and the width of metal bar is <= " + VIA2_R_11_W + " um."; 
          W = not( M3I, wide( M3I, > VIA2_R_11_W, forty_five = INTERNAL ) ); 
          sLAYER_515 = donut_holes( M3I, area = <= VIA2_R_11_A, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          H_HOLE = interacting( sLAYER_515, W ); 
          A0 = interacting( M3I, H_HOLE ); 
          A = A0 coincident_outside_edge H_HOLE; 
          sLAYER_517 = internal1( A, <= VIA2_R_11_W, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_516 = sLAYER_517 inside A0; 
          B0 = interacting( sLAYER_516, H_HOLE, == 2 ); 
          sLAYER_520 = internal1( A, <= VIA2_R_11_L, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_519 = sLAYER_520 inside A0; 
          sLAYER_518 = sLAYER_519 and W; 
          B1 = interacting( sLAYER_518, H_HOLE, == 2 ); 
          HOLE_NOTCH = external1( H_HOLE, <= VIA2_R_11_W, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_521 = B1 not HOLE_NOTCH; 
          B2 = sLAYER_521 or B0; 
          sLAYER_523 = external1( B2, <= VIA2_R_11_W, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { }, output_type = EXTENTS ); 
          sLAYER_522 = outside_touching( sLAYER_523, B2, == 2 ); 
          CORNER_M = sLAYER_522 and W; 
          B = B2 or CORNER_M; 
          CENTER_BAR1 = not_contains( B, { GRID, VIA2_R_11_L + GRID }, FORTY_FIVE ); 
          sLAYER_524 = interacting( CENTER_BAR1, H_HOLE, == 2 ); 
          CENTER_BAR2 = interacting( sLAYER_524, VIA2I ); 
          C = CENTER_BAR2 coincident_outside_edge H_HOLE; 
          D = external2_edge( C, A, <= VIA2_R_11_L2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          E = C not_coincident_inside_edge D; 
          CENTER_BAR3 = CENTER_BAR2 not_touching E; 
          CHECK_VIA = VIA2I not_outside CENTER_BAR3; 
          sLAYER_527 = interacting( A0, CHECK_VIA ); 
          sLAYER_528 = interacting( M2I, CHECK_VIA ); 
          sLAYER_526 = sLAYER_527 and sLAYER_528;
          sLAYER_525 = interacting( sLAYER_526, VIA2I, == 1 ); 
          CHECK_VIA and sLAYER_525; 
      } /* end of rule : VIA2.R.11 */
      
      //M3 CHECKS
      //=========
      M31 = M3WIDE_FIRST not CB_NON_CUP; 
      M311 = M3WIDE_0_p_4 not CB_NON_CUP; 
      #ifdef HALF_NODE 
         M312 = M3WIDE_0_p_2 not CB_NON_CUP; 
         M313 = M3WIDE_0_p_4S not CB_NON_CUP; 
      #endif /* end of #ifdef HALF_NODE  */ 
      M32 = M3WIDE_1_p_5 not CB_NON_CUP; 
      M33 = M3WIDE_4_p_5 not CB_NON_CUP; 
      M3AS3 = area( M3, > ( M3_S_3_L * M3_W_1 ) );    /* filter small metal for M3.S.3 */ 
      M3AS4 = area( M3AS3, > ( M3_S_4_L * M3_W_1 ) );    /* filter small metal for M3.S.4 */ 
      M3_EDGE_45 = angle_edge( M3, == 45 ); 
      rM3_W_1 @= { @ "M3.W.1 : Width >= " + M3_W_1 + " um"; 
          internal1( M3, < M3_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : M3.W.1 */
      rM3_W_2 @= { @ "M3.W.2 : Width of 45-degree bent Mx Please make sure the vertex of 45 degree pattern is on 5nm grid >= " + M3_W_2 + " um"; 
          internal1( M3_EDGE_45, < M3_W_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
      } /* end of rule : M3.W.2 */
      rM3_W_3 @= { @ "M3.W.3 : Maximum width <= " + M3_W_3 + " um"; 
          size( size( M3, - ( M3_W_3 / 2 ), clip_acute = BISECTOR ), M3_W_3 / 2, clip_acute = BISECTOR ); 
      } /* end of rule : M3.W.3 */
      rM3_S_1 @= { @ "M3.S.1 : Spacing >= " + M3_S_1 + " um"; 
          external1( M3, < M3_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : M3.S.1 */
      
      //M3.S.2.S is checked by M3.S.2 
      rM3_S_2 @= { @ "M3.S.2 : Space [at least one metal line width > " + M3_S_2_W + " um  and the parallel metal run length > " + M3_S_2_L + " um ] (union projection) >= " + M3_S_2; 
          X = external2( M31, M3, < M3_S_2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M3; 
          contains( Y, { GRID, M3_S_2_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M3.S.2 */
      
      //M3.S.2.1.S is checked by M3.S.2.1
      rM3_S_2_1 @= { @ "M3.S.2.1 : Space [at least one metal line width > " + M3_S_2_1_W + " um  and the parallel metal run length > " + M3_S_2_1_L + " um ] (union projection) >= " + M3_S_2_1; 
          X = external2( M311, M3, < M3_S_2_1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M3; 
          contains( Y, { GRID, M3_S_2_1_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M3.S.2.1 */
      #ifdef HALF_NODE 
         
         //M3.S.2.2.S is checked by M3.S.2.2
         rM3_S_2_2 @= { @ "M3.S.2.2 : Space [at least one metal line width > " + M3_S_2_2_W + " um  and the parallel metal run length > " + M3_S_2_2_L + " um ] (union projection) >= " + M3_S_2_2; 
             X = external2( M312, M3, < M3_S_2_2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
             Y = X not M3; 
             contains( Y, { GRID, M3_S_2_2_L + GRID }, FORTY_FIVE ); 
         } /* end of rule : M3.S.2.2 */
         
         //M3.S.2.3.S is checked by M3.S.2.3
         rM3_S_2_3 @= { @ "M3.S.2.3 : Space [at least one metal line width > " + M3_S_2_3_W + " um  and the parallel metal run length > " + M3_S_2_3_L + " um ] (union projection) >= " + M3_S_2_3; 
             X = external2( M313, M3, < M3_S_2_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
             Y = X not M3; 
             contains( Y, { GRID, M3_S_2_3_L + GRID }, FORTY_FIVE ); 
         } /* end of rule : M3.S.2.3 */
      #endif /* end of #ifdef HALF_NODE  */ 
      
      //M3.S.3.S is checked by M3.S.3
      rM3_S_3 @= { @ "M3.S.3 : Space [at least one metal line width > " + M3_S_3_W + " um  and the parallel metal run length > " + M3_S_3_L + " um ] (union projection) >= " + M3_S_3; 
          X = external2( M32, M3AS3, < M3_S_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M3; 
          contains( Y, { GRID, M3_S_3_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M3.S.3 */
      
      //M3.S.4.S is checked by M3.S.4
      rM3_S_4 @= { @ "M3.S.4 : Space [at least one metal line width > " + M3_S_4_W + " um  and the parallel metal run length > " + M3_S_4_L + " um ] (union projection) >= " + M3_S_4; 
          X = external2( M33, M3AS4, < M3_S_4, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M3; 
          contains( Y, { GRID, M3_S_4_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M3.S.4 */
      rM3_S_5 @= { @ "M3.S.5 : Space at Mx line-end (W<Q=0.120) in a dense-line-end configuration: If Mx has parallel run length with opposite Mx (measured with T=0.035 extension) along 2 adjacent edges of Mx [any one edge <Q distance from the corner of the two edges], then one of the space (S1 or S2) needs to be at least this value (except for small jog with edge length < 0.10 um (R)) >= " + M3_S_5 + " um."; 
          A = adjacent_edge( M3, angle1 = == 90, angle2 = == 90, length = < M3_S_5_Q ); 
          B = external2_edge( A, M3, < M3_S_5, extension = EDGE, extension_distance = M3_S_5_E, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1 ); 
          C = A inside_touching_edge B; 
          D = internal2_edge( C, M3, < M3_S_5_Q, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 90, look_thru = RELATED_COINCIDENT, orientation = { }, output_layer = LAYER2 ); 
          I = length_edge( D, >= M3_W_1 ); 
          sLAYER_1318 = extend_edge( I, start = M3_S_5_E, end = M3_S_5_E ); 
          J = edge_size( sLAYER_1318, inside = 0.001 ); 
          K = edge_size( I, inside = 0.001 ); 
          L = J not K; 
          M = L touching A; 
          N = M or K; 
          O = N touching_edge I; 
          external2( O, M3, < M3_S_5, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
      } /* end of rule : M3.S.5 */
      
      //M3.EN.0 is checked by either {M3.EN.1/M3.EN.2} or M3.EN.3
      rM3_EN_1 @= { @ "M3.EN.1 : Enclosure of VIA2 >= 0 um";
          VIA2 not M3; 
      } /* end of rule : M3.EN.1 */
      
      // M3.EN.2 is checked by M3.EN.2__M3.EN.3
      // M3.EN.3 is checked by M3.EN.2__M3.EN.3
      rM3_EN_2__M3_EN_3 @= { @ "M3.EN.2__M3.EN.3 : Enclosure of VIA2 [at least two opposite sides] >= " + M3_EN_2 + " ,or [all sides] >= " + M3_EN_3; 
          A = VIA2 not SRAM_EXCLUDE; 
          X = not_enclosed_by( A, M3, distances = { { { 0, RADIAL }, { M3_EN_2, NONE }, { 0, RADIAL }, { M3_EN_2, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          enclose( X, M3, < M3_EN_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : M3.EN.2__M3.EN.3 */
      rM3_A_1 @= { @ "M3.A.1 : Area >= " + M3_A_1 + " um2"; 
          area( M3, < M3_A_1 ); 
      } /* end of rule : M3.A.1 */
      rM3_A_2 @= { @ "M3.A.2 : Enclosed area >= " + M3_A_2 + " um"; 
          X = donut_holes( M3, area = < M3_A_2PRE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          sLAYER_529 = X not M3; 
          area( sLAYER_529, < M3_A_2 ); 
      } /* end of rule : M3.A.2 */
      rM3_S_6 @= { @ "M3.S.6 : Space to 45 degree bent M3 >= " + M3_S_6 + " um"; 
          X = edge_size( M3_EDGE_45, outside = M3_S_6 ); 
          X and M3; 
      } /* end of rule : M3.S.6 */
      M3DN1H_EXC = copy( M3_EXC ); 
      M3DN1L_EXC = copy( M3_EXC_LOW ); 
      #ifdef CHECK_LOW_DENSITY 
         rM3_DN_1 @= { @ "M3.DN.1 : M3 local density must be >= " + M3_DN_1L + " range over " + M3_DN_1L_W + " um x " + M3_DN_1L_W + " um step " + M3_DN_1L_S + " um"; 
             M3_CHECK = M3X not M3DN1L_EXC; 
             CHIP_CHECK = gCHIP not M3DN1L_EXC; 
         _den_con = < M3_DN_1L; 
         _den_polygon_area_clip = false;
         _den_print = false;
         _den_print_only = false;
             ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M3_CHECK, "layer2" => CHIP_CHECK }, delta_window = { M3_DN_1L_W, M3_DN_1L_W }, delta_x = M3_DN_1L_S, delta_y = M3_DN_1L_S, boundary = BACKUP, window_function = den_save_window_1 ); 
             sLAYER_530 = ERR_WIN not M3DN1L_EXC; 
             F = wide( sLAYER_530, >= M3_DN_1L_E, forty_five = INTERNAL ); 
             VAR_21 = density_statistics_file( file = "M3.DN.1.density" ); 
         _den_con = < M3_DN_1L; 
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M3_CHECK, "layer3" => CHIP_CHECK }, delta_window = { M3_DN_1L_W, M3_DN_1L_W }, delta_x = M3_DN_1L_S, delta_y = M3_DN_1L_S, boundary = BACKUP, statistics_files = { VAR_21 }, window_function = den_save_window_2 ); 
         } /* end of rule : M3.DN.1 */
      #endif /* end of #ifdef CHECK_LOW_DENSITY  */ 
      rM3_DN_1_1 @= { @ "M3.DN.1.1 : M3 local density must be <= " + M3_DN_1H + " range over " + M3_DN_1H_W + " um x " + M3_DN_1H_W + " um step " + M3_DN_1H_S + " um"; 
          M3_CHECK = M3X not M3DN1H_EXC; 
          CHIP_CHECK = gCHIP not M3DN1H_EXC; 
      _den_con = > M3_DN_1H; 
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M3_CHECK, "layer2" => CHIP_CHECK }, delta_window = { M3_DN_1H_W, M3_DN_1H_W }, delta_x = M3_DN_1H_S, delta_y = M3_DN_1H_S, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_531 = ERR_WIN not M3DN1H_EXC; 
          F = wide( sLAYER_531, >= M3_DN_1H_E, forty_five = INTERNAL ); 
          VAR_22 = density_statistics_file( file = "M3.DN.1.1.density" ); 
      _den_con = > M3_DN_1H; 
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M3_CHECK, "layer3" => CHIP_CHECK }, delta_window = { M3_DN_1H_W, M3_DN_1H_W }, delta_x = M3_DN_1H_S, delta_y = M3_DN_1H_S, boundary = BACKUP, statistics_files = { VAR_22 }, window_function = den_save_window_3 ); 
      } /* end of rule : M3.DN.1.1 */
      M3DN2_EXC = copy( EMPTYI ); 
      rM3_DN_2 @= { @ "M3.DN.2 : M3 local density must be <= " + M3_DN_2 + " range over " + M3_DN_2_W + " um x " + M3_DN_2_W + " um step " + M3_DN_2_S + " um"; 
          M3_CHECK = M3X not M3DN2_EXC; 
      _den_con = > M3_DN_2; 
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M3_CHECK, "layer2" => gCHIP }, delta_window = { M3_DN_2_W, M3_DN_2_W }, delta_x = M3_DN_2_S, delta_y = M3_DN_2_S, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_532 = ERR_WIN not M3DN2_EXC; 
          F = wide( sLAYER_532, >= M3_DN_2_E, forty_five = INTERNAL ); 
          VAR_23 = density_statistics_file( file = "M3.DN.2.density" ); 
      _den_con = > M3_DN_2; 
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M3_CHECK, "layer3" => gCHIP }, delta_window = { M3_DN_2_W, M3_DN_2_W }, delta_x = M3_DN_2_S, delta_y = M3_DN_2_S, boundary = BACKUP, statistics_files = { VAR_23 }, window_function = den_save_window_3 ); 
      } /* end of rule : M3.DN.2 */
      rM3_DN_4 @= { @ "M3.DN.4 : The metal density difference between any two " + M3_DN_4_W + " um x " + M3_DN_4_W + " um neighboring checking windows including DM3EXCL <= " + M3_DN_4; 
          sLAYER_1319 = chip_extent();
          VAR_24 = density_statistics_file( file = "M3.DN.4.density" ); 
      _gden_con = <= 1;
      _gden_gcon = > M3_DN_4; 
      _gden_absolute = true;
      _gden_corner = true;
      _gden_corner_value = -1.0;
      _gden_polygon_area_clip = true;
      _gden_print = true;
      _gden_print_only = false;
          sLAYER_1319 = sLAYER_1319 or gCHIP;
gradient_density( window_layer = sLAYER_1319, layer_hash = { "layer1" => M3X, "layer2" => gCHIP }, delta_window = { M3_DN_4_W, M3_DN_4_W }, delta_x = M3_DN_4_W, delta_y = M3_DN_4_W, boundary = BACKUP, statistics_files = { VAR_24 }, window_function = gden_save_window_7 ); 
      } /* end of rule : M3.DN.4 */
      
      //M3.R.1U is not necessary to check
      
      // Mx.DN.5
      //===========
      M3_CORE = M3X not SRCSR; 
      rM1_DN_5 @= { @ "M1.DN.5 : It is not allowed to have local density > " + MX_DN_5 + " of all 3 consecutive metal (M1,M2,M3) over any " + MX_DN_5_W + " um x " + MX_DN_5_W + " um window (stepping " + MX_DN_5_S + " um)"; 
          sLAYER_1320 = chip_extent();
          VAR_25 = density_statistics_file( file = "M1.DN.5.density" ); 
      _den_con = > 0;
      _den_polygon_area_clip = true;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( window_layer = sLAYER_1320, layer_hash = { "layer1" => M1_CORE, "layer2" => M2_CORE, "layer3" => M3_CORE }, delta_window = { MX_DN_5_W, MX_DN_5_W }, delta_x = MX_DN_5_S, delta_y = MX_DN_5_S, boundary = BACKUP, statistics_files = { VAR_25 }, window_function = den_save_window_8 ); 
      } /* end of rule : M1.DN.5 */
      
      //Mx.DN.6 is checked by M1.DN.6    
      rM1_DN_6 @= { @ "M1.DN.6 : It is not allowed to have local density < " + M1_DN_6 + " of all 3 consecutive metal (M1,M2,M3) under ((CBM SIZING 25) SIZING -25) whose size is >= 200um X 200um"; 
          A = net_area_ratio( CONNECT_DB, < M1_DN_6, { "layer1" => M1DN6_CHECK_CBM, "layer2" => M1DN6_M1_CHECK }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
          B = net_area_ratio( CONNECT_DB, < M1_DN_6, { "layer1" => M1DN6_CHECK_CBM, "layer2" => M1DN6_M2_CHECK }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
          C = net_area_ratio( CONNECT_DB, < M1_DN_6, { "layer1" => M1DN6_CHECK_CBM, "layer2" => M1DN6_M3_CHECK }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
          sLAYER_533 = A and B; 
          sLAYER_533 and C; 
      } /* end of rule : M1.DN.6 */
      
      //VIA3 CHECKS
      //===========
      gLAYER_260 = size( size( M4, - ( M4_S_2_W / 2 ), clip_acute = BISECTOR ), M4_S_2_W / 2, clip_acute = BISECTOR ); 
      M4WIDE_FIRST = gLAYER_260 and M4; 
      gLAYER_261 = size( size( M4WIDE_FIRST, - ( M4_S_2_1_W / 2 ), clip_acute = BISECTOR ), M4_S_2_1_W / 2, clip_acute = BISECTOR ); 
      M4WIDE_0_p_4 = gLAYER_261 and M4WIDE_FIRST; 
      #ifdef HALF_NODE 
         gLAYER_262 = size( size( M4, - ( M4_S_2_2_W / 2 ), clip_acute = BISECTOR ), M4_S_2_2_W / 2, clip_acute = BISECTOR ); 
         M4WIDE_0_p_2 = gLAYER_262 and M4; 
         gLAYER_263 = size( size( M4WIDE_FIRST, - ( M4_S_2_3_W / 2 ), clip_acute = BISECTOR ), M4_S_2_3_W / 2, clip_acute = BISECTOR ); 
         M4WIDE_0_p_4S = gLAYER_263 and M4WIDE_FIRST; 
      #endif /* end of #ifdef HALF_NODE  */ 
      gLAYER_264 = size( size( M4WIDE_FIRST, - ( M4_S_3_W / 2 ), clip_acute = BISECTOR ), M4_S_3_W / 2, clip_acute = BISECTOR ); 
      M4WIDE_1_p_5 = gLAYER_264 and M4WIDE_FIRST; 
      gLAYER_265 = size( size( M4WIDE_1_p_5, - ( M4_S_4_W / 2 ), clip_acute = BISECTOR ), M4_S_4_W / 2, clip_acute = BISECTOR ); 
      M4WIDE_4_p_5 = gLAYER_265 and M4WIDE_1_p_5; 
      gLAYER_266 = size( size( M3WIDE_FIRST, - ( VIA3_R_2_W / 2 ), clip_acute = BISECTOR ), VIA3_R_2_W / 2, clip_acute = BISECTOR ); 
      M3WIDE_0_p_42_VIA3 = gLAYER_266 and M3WIDE_FIRST; 
      gLAYER_267 = size( size( M3WIDE_0_p_42_VIA3, - ( VIA3_R_4_W / 2 ), clip_acute = BISECTOR ), VIA3_R_4_W / 2, clip_acute = BISECTOR ); 
      M3WIDE_0_p_7_VIA3 = gLAYER_267 and M3WIDE_0_p_42_VIA3; 
      gLAYER_268 = size( size( M3WIDE_0_p_7_VIA3, - ( VIA3_R_3_W / 2 ), clip_acute = BISECTOR ), VIA3_R_3_W / 2, clip_acute = BISECTOR ); 
      M3WIDE_0_p_98_VIA3 = gLAYER_268 and M3WIDE_0_p_7_VIA3; 
      gLAYER_269 = size( size( M3WIDE_0_p_98_VIA3, - ( VIA3_R_5_W / 2 ), clip_acute = BISECTOR ), VIA3_R_5_W / 2, clip_acute = BISECTOR ); 
      M3WIDE_2_VIA3 = gLAYER_269 and M3WIDE_0_p_98_VIA3; 
      gLAYER_270 = size( size( M3WIDE_2_VIA3, - ( VIA3_R_6_W / 2 ), clip_acute = BISECTOR ), VIA3_R_6_W / 2, clip_acute = BISECTOR ); 
      M3WIDE_3_VIA3 = gLAYER_270 and M3WIDE_2_VIA3; 
      gLAYER_271 = size( size( M4WIDE_FIRST, - ( VIA3_R_2_W / 2 ), clip_acute = BISECTOR ), VIA3_R_2_W / 2, clip_acute = BISECTOR ); 
      M4WIDE_0_p_42_VIA3 = gLAYER_271 and M4WIDE_FIRST; 
      gLAYER_272 = size( size( M4WIDE_0_p_42_VIA3, - ( VIA3_R_4_W / 2 ), clip_acute = BISECTOR ), VIA3_R_4_W / 2, clip_acute = BISECTOR ); 
      M4WIDE_0_p_7_VIA3 = gLAYER_272 and M4WIDE_0_p_42_VIA3; 
      gLAYER_273 = size( size( M4WIDE_0_p_7_VIA3, - ( VIA3_R_3_W / 2 ), clip_acute = BISECTOR ), VIA3_R_3_W / 2, clip_acute = BISECTOR ); 
      M4WIDE_0_p_98_VIA3 = gLAYER_273 and M4WIDE_0_p_7_VIA3; 
      gLAYER_274 = size( size( M4WIDE_0_p_98_VIA3, - ( VIA3_R_5_W / 2 ), clip_acute = BISECTOR ), VIA3_R_5_W / 2, clip_acute = BISECTOR ); 
      M4WIDE_2_VIA3 = gLAYER_274 and M4WIDE_0_p_98_VIA3; 
      gLAYER_275 = size( size( M4WIDE_2_VIA3, - ( VIA3_R_6_W / 2 ), clip_acute = BISECTOR ), VIA3_R_6_W / 2, clip_acute = BISECTOR ); 
      M4WIDE_3_VIA3 = gLAYER_275 and M4WIDE_2_VIA3; 
      rVIA3_W_1 @= { @ "VIA3.W.1 : Width (maximum = minimum except for seal-ring and fuse protection ring) = " + VIA3_W_1 + " um " 
                                  "VIA3.R.1 45-degree rotated VIA is not allowed";
          A = not_rectangles( VIA3, orientation = ORTHOGONAL, sides = { == VIA3_W_1, == VIA3_W_1 } ); 
          A not VIA_EXD; 
      } /* end of rule : VIA3.W.1 */
      
      // CSR.W.3 is checked by VIA3.W.2
      rVIA3_W_2 @= { @ "VIA3.W.2 : VIA3 bar width = " + VIA3_W_2 + " (VIA3 bar is covered by SEALRING layer and only allowed in seal-ring and fuse protecion ring)"; 
          internal1( VIA3_BAR, < VIA3_W_2, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          A = wide( VIA3_BAR, > VIA3_W_2, forty_five = INTERNAL ); 
          B = angle_edge( VIA3_BAR, == 45 ); 
          C = internal1( B, < ( VIA3_W_2 + 2 * GRID ), extension = RADIAL, intersecting = {  } ); 
          D = A not C; 
          contains( D, { 1, 0.005 }, FORTY_FIVE ); 
      } /* end of rule : VIA3.W.2 */
      rVIA3_S_1 @= { @ "VIA3.S.1 : Spacing >= " + VIA3_S_1 + " um"; 
          external1( VIA3, < VIA3_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : VIA3.S.1 */
      rVIA3_S_2 @= { @ "VIA3.S.2 : Space to 3-neighboring VIAx (< 0.14 um distance) >= " + VIA3_S_2 + " um"; 
          X = rectangle_spacing1( VIA3, count = > 2, distance = < VIA3_S_2_S ); 
          external2( X, VIA3, < VIA3_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : VIA3.S.2 */
      rVIA3_S_3 @= { @ "VIA3.S.3 : Space to neighboring VIAx [different net and common parallel run length > 0] >= " + VIA3_S_3 + " um"; 
          VIA3_NODAL = stamp( VIA3, VIA3I, CONNECT_DB, CONNECT_DB_VIA3_S_3, include_touch = NONE ); 
          external1( VIA3_NODAL, < VIA3_S_3, connect_sequence = CONNECT_DB_VIA3_S_3, connectivity = DIFFERENT_NET, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
      } /* end of rule : VIA3.S.3 */
      
      //VIA3.EN.0 is checked by either {VIA3.EN.1/VIA3.EN.2} or VIA3.EN.3
      rVIA3_EN_1 @= { @ "VIA3.EN.1 : Enclosure by M3 >= 0 um";
          VIA3 not M3; 
      } /* end of rule : VIA3.EN.1 */
      
      // VIA3.EN.2 is checked by VIA3.EN.2__VIA3.EN.3
      // VIA3.EN.3 is checked by VIA3.EN.2__VIA3.EN.3
      rVIA3_EN_2__VIA3_EN_3 @= { @ "VIA3.EN.2__VIA3.EN.3 : Enclosure by M3 [at least two opposite sides] >= " + VIA3_EN_2 + " , or [all sides] >= " + VIA3_EN_3; 
          X = not_enclosed_by( VIA3, M3, distances = { { { 0, RADIAL }, { VIA3_EN_2, NONE }, { 0, RADIAL }, { VIA3_EN_2, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          enclose( X, M3, < VIA3_EN_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : VIA3.EN.2__VIA3.EN.3 */
      
      // VIA3.R.1 is checked by VIA3.W.1
      // VIA3.R.2 is checked by VIA3.R.2__VIA3.R.3
      // VIA3.R.2.S is checked by VIA3.R.2__VIA3.R.3
      // VIA3.R.3 is checked by VIA3.R.2__VIA3.R.3
      
      // VIA3.R.3.S is checked by VIA3.R.2__VIA3.R.3
      rVIA3_R_2__VIA3_R_3 @= { @ "VIA3.R.2__VIA3.R.3 : When M3 or M4 width > " + VIA3_R_2_W + " um, more than one VIA3 is required. " 
                                                      "2 vias spacing should be <= " + VIA3_R_2_S1 + " um or 4 vias spacing should be <= " + VIA3_R_2_S2 + " um " 
                                                      "When M3 or M4 width > " + VIA3_R_3_W + " um, more than three VIA3 is required. " 
                                                      "4 vias spacing should be <= " + VIA3_R_3_S1 + " um or 9 vias spacing should be <= " + VIA3_R_3_S2 + " um"; 
          sLAYER_534 = M3WIDE_0_p_42_VIA3 and M4; 
          sLAYER_535 = M4WIDE_0_p_42_VIA3 and M3; 
          M4OVPM3_W_ = sLAYER_534 or sLAYER_535; 
          sLAYER_536 = M3WIDE_0_p_98_VIA3 and M4; 
          sLAYER_537 = M4WIDE_0_p_98_VIA3 and M3; 
          M4OVPM3_B = sLAYER_536 or sLAYER_537; 
          M4OVPM3_W = M4OVPM3_W_ not M4OVPM3_B; 
          CHECKED_VIA3_W_ = VIA3_EXD not_outside M4OVPM3_W; 
          CHECKED_VIA3_B = VIA3_EXD not_outside M4OVPM3_B; 
          CHECKED_VIA3_W = CHECKED_VIA3_W_ not CHECKED_VIA3_B; 
          M3_EFFECT = interacting( M3I, M4OVPM3_W_ ); 
          M4_EFFECT = interacting( M4I, M4OVPM3_W_ ); 
          EFFECT_M4OVPM3_ = M3_EFFECT and M4_EFFECT; 
          EFFECT_M4OVPM3 = interacting( EFFECT_M4OVPM3_, M4OVPM3_W_ ); 
          EFFECT_VIA = interacting( VIA3_EXD, EFFECT_M4OVPM3 ); 
          V3MERGED_A = size_inside_wrapper( EFFECT_VIA, EFFECT_M4OVPM3, distance = VIA3_R_2_S1 / 2, increment = M3_S_1 * 0.7 ); 
          V3MERGED_B = size_inside_wrapper( V3MERGED_A, EFFECT_M4OVPM3, distance = VIA3_R_2_S2_S1, increment = M3_S_1 * 0.7 ); 
          V3MERGED_C = size_inside_wrapper( V3MERGED_B, EFFECT_M4OVPM3, distance = ( VIA3_R_3_S2 - VIA3_R_2_S2 ) / 2, increment = M3_S_1 * 0.7 ); 
          V3MERGED_A2R = interacting( V3MERGED_A, EFFECT_VIA, < 2 ); 
          V3MERGED_A2 = V3MERGED_A outside V3MERGED_A2R; 
          V3MERGED_A4R = interacting( V3MERGED_A2, EFFECT_VIA, < 4 ); 
          V3MERGED_A4 = V3MERGED_A2 outside V3MERGED_A4R; 
          V3MERGED_B4R = interacting( V3MERGED_B, EFFECT_VIA, < 4 ); 
          V3MERGED_B4 = V3MERGED_B outside V3MERGED_B4R; 
          V3MERGED_C9R = interacting( V3MERGED_C, EFFECT_VIA, < 9 ); 
          V3MERGED_C9 = V3MERGED_C outside V3MERGED_C9R; 
          GMERGEW = V3MERGED_A2 or V3MERGED_B4; 
          GMERGEB = V3MERGED_A4 or V3MERGED_C9; 
          GVIA_W = interacting( CHECKED_VIA3_W, GMERGEW ); 
          GVIA_B = interacting( CHECKED_VIA3_B, GMERGEB ); 
          GOOD_AREA_W = interacting( M4OVPM3_W, GVIA_W ); 
          GOOD_AREA_B = interacting( M4OVPM3_B, GVIA_B ); 
          CHECKED_VIA3_W outside GOOD_AREA_W; 
          CHECKED_VIA3_B outside GOOD_AREA_B; 
      } /* end of rule : VIA3.R.2__VIA3.R.3 */
      
      //VIA3.R.4 is checked by VIA3.R.4:M3 and VIA3.R.4:M4
      //VIA3.R.4.S is checked by VIA3.R.4:M3 and VIA3.R.4:M4
      rVIA3_R_4_M3 @= { @ "VIA3.R.4:M3 : At least two VIAx must be used for a connection that is <= " + VIA3_R_4_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA3_R_4_W + " um (L) and width > " + VIA3_R_4_W + " um (W). (It is allowed to use one VIAx for a connection that is > " + VIA3_R_4_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA3_R_4_W + " um (L) and width > " + VIA3_R_4_W + " um (W).)"; 
          sLAYER_539 = size( M3WIDE_0_p_7_VIA3, clip_acute = NONE, distance = VIA3_R_4_D + GRID ); 
          sLAYER_538 = sLAYER_539 not M3WIDE_0_p_7_VIA3; 
          BRANCH1 = sLAYER_538 and M3; 
          sLAYER_540 = interacting( BRANCH1, M3WIDE_0_p_7_VIA3 ); 
          BRANCH1HASVIA = interacting( sLAYER_540, VIA3 ); 
          BRANCH1EDGE = M3WIDE_0_p_7_VIA3 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA3_R_4_D, increment = M3_S_1 * 0.5 ); 
          sLAYER_541 = BRANCH and M4; 
          GOODBRANCH = interacting( sLAYER_541, VIA3, > 1 ); 
          sLAYER_542 = VIA3 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_542 outside GOODBRANCH; 
          sLAYER_545 = interacting( M4, BRANCHSINGLEVIA ); 
          sLAYER_544 = sLAYER_545 and M3; 
          sLAYER_543 = interacting( sLAYER_544, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_543, VIA3, == 1 ); 
          sLAYER_546 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_546 not VIA_EXD; 
      } /* end of rule : VIA3.R.4:M3 */
      rVIA3_R_4_M4 @= { @ "VIA3.R.4:M4 : At least two VIAx must be used for a connection that is <= " + VIA3_R_4_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA3_R_4_W + " um (L) and width > " + VIA3_R_4_W + " um (W). (It is allowed to use one VIAx for a connection that is > " + VIA3_R_4_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA3_R_4_W + " um (L) and width > " + VIA3_R_4_W + " um (W).)"; 
          sLAYER_548 = size( M4WIDE_0_p_7_VIA3, clip_acute = NONE, distance = VIA3_R_4_D + GRID ); 
          sLAYER_547 = sLAYER_548 not M4WIDE_0_p_7_VIA3; 
          BRANCH1 = sLAYER_547 and M4; 
          sLAYER_549 = interacting( BRANCH1, M4WIDE_0_p_7_VIA3 ); 
          BRANCH1HASVIA = interacting( sLAYER_549, VIA3 ); 
          BRANCH1EDGE = M4WIDE_0_p_7_VIA3 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA3_R_4_D, increment = M4_S_1 * 0.5 ); 
          sLAYER_550 = BRANCH and M3; 
          GOODBRANCH = interacting( sLAYER_550, VIA3, > 1 ); 
          sLAYER_551 = VIA3 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_551 outside GOODBRANCH; 
          sLAYER_554 = interacting( M3, BRANCHSINGLEVIA ); 
          sLAYER_553 = sLAYER_554 and M4; 
          sLAYER_552 = interacting( sLAYER_553, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_552, VIA3, == 1 ); 
          sLAYER_555 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_555 not VIA_EXD; 
      } /* end of rule : VIA3.R.4:M4 */
      
      //VIA3.R.5 is checked by VIA3.R.5:M3 and VIA3.R.5:M4
      
      //VIA3.R.5.S is checked by VIA3.R.5:M3 and VIA3.R.5:M4
      rVIA3_R_5_M3 @= { @ "VIA3.R.5:M3 : At least two VIAx must be used for a connection that is <= " + VIA3_R_5_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA3_R_5_W + " um (L) and width > " + VIA3_R_5_W + " um (W). It is allowed to use one VIAx for a connection that is > " + VIA3_R_5_D + " um (D) away from a metal plate (either Mx or Mx+1) with length> " + VIA3_R_5_W + " um (L) and width > " + VIA3_R_5_W + " um (W)."; 
          sLAYER_557 = size( M3WIDE_2_VIA3, clip_acute = NONE, distance = VIA3_R_5_D + GRID ); 
          sLAYER_556 = sLAYER_557 not M3WIDE_2_VIA3; 
          BRANCH1 = sLAYER_556 and M3; 
          sLAYER_558 = interacting( BRANCH1, M3WIDE_2_VIA3 ); 
          BRANCH1HASVIA = interacting( sLAYER_558, VIA3 ); 
          BRANCH1EDGE = M3WIDE_2_VIA3 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA3_R_5_D, increment = M3_S_1 * 0.7 ); 
          sLAYER_559 = BRANCH and M4; 
          GOODBRANCH = interacting( sLAYER_559, VIA3, > 1 ); 
          sLAYER_560 = VIA3 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_560 outside GOODBRANCH; 
          sLAYER_563 = interacting( M4, BRANCHSINGLEVIA ); 
          sLAYER_562 = sLAYER_563 and M3; 
          sLAYER_561 = interacting( sLAYER_562, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_561, VIA3, == 1 ); 
          sLAYER_564 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_564 not VIA_EXD; 
      } /* end of rule : VIA3.R.5:M3 */
      rVIA3_R_5_M4 @= { @ "VIA3.R.5:M4 : At least two VIAx must be used for a connection that is <= " + VIA3_R_5_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA3_R_5_W + " um (L) and width > " + VIA3_R_5_W + " um (W). It is allowed to use one VIAx for a connection that is > " + VIA3_R_5_D + " um (D) away from a metal plate (either Mx or Mx+1) with length> " + VIA3_R_5_W + " um (L) and width > " + VIA3_R_5_W + " um (W)."; 
          sLAYER_566 = size( M4WIDE_2_VIA3, clip_acute = NONE, distance = VIA3_R_5_D + GRID ); 
          sLAYER_565 = sLAYER_566 not M4WIDE_2_VIA3; 
          BRANCH1 = sLAYER_565 and M4; 
          sLAYER_567 = interacting( BRANCH1, M4WIDE_2_VIA3 ); 
          BRANCH1HASVIA = interacting( sLAYER_567, VIA3 ); 
          BRANCH1EDGE = M4WIDE_2_VIA3 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA3_R_5_D, increment = M4_S_1 * 0.7 ); 
          sLAYER_568 = BRANCH and M3; 
          GOODBRANCH = interacting( sLAYER_568, VIA3, > 1 ); 
          sLAYER_569 = VIA3 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_569 outside GOODBRANCH; 
          sLAYER_572 = interacting( M3, BRANCHSINGLEVIA ); 
          sLAYER_571 = sLAYER_572 and M4; 
          sLAYER_570 = interacting( sLAYER_571, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_570, VIA3, == 1 ); 
          sLAYER_573 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_573 not VIA_EXD; 
      } /* end of rule : VIA3.R.5:M4 */
      M3BIG_3_VIA3 = contains( M3WIDE_3_VIA3, { VIA3_R_6_W, VIA3_R_6_L + GRID }, FORTY_FIVE ); 
      
      //VIA3.R.6 is checked by VIA3.R.6:M3 and VIA3.R.6:M4
      //VIA3.R.6.S is checked by VIA3.R.6:M3 and VIA3.R.6:M4
      rVIA3_R_6_M3 @= { @ "VIA3.R.6:M3 : At least two VIAx must be used for a connection that is <= " + VIA3_R_6_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA3_R_6_L + " um (L) and width > " + VIA3_R_6_W + " um (W). (It is allowed to use one VIAx for a connection that is > " + VIA3_R_6_D + " um (D) away from a metal plate (either Mx or Mx+1) with length> " + VIA3_R_6_L + " um (L) and width > " + VIA3_R_6_W + " um (W))."; 
          sLAYER_575 = size( M3BIG_3_VIA3, clip_acute = NONE, distance = VIA3_R_6_D + GRID ); 
          sLAYER_574 = sLAYER_575 not M3BIG_3_VIA3; 
          BRANCH1 = sLAYER_574 and M3; 
          sLAYER_576 = interacting( BRANCH1, M3BIG_3_VIA3 ); 
          BRANCH1HASVIA = interacting( sLAYER_576, VIA3 ); 
          BRANCH1EDGE = M3BIG_3_VIA3 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA3_R_6_D, increment = M3_S_1 * 0.7 ); 
          sLAYER_577 = BRANCH and M4; 
          GOODBRANCH = interacting( sLAYER_577, VIA3, > 1 ); 
          sLAYER_578 = VIA3 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_578 outside GOODBRANCH; 
          sLAYER_581 = interacting( M4, BRANCHSINGLEVIA ); 
          sLAYER_580 = sLAYER_581 and M3; 
          sLAYER_579 = interacting( sLAYER_580, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_579, VIA3, == 1 ); 
          sLAYER_582 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_582 not VIA_EXD; 
      } /* end of rule : VIA3.R.6:M3 */
      M4BIG_3_VIA3 = contains( M4WIDE_3_VIA3, { VIA3_R_6_W, VIA3_R_6_L + GRID }, FORTY_FIVE ); 
      rVIA3_R_6_M4 @= { @ "VIA3.R.6:M4 : At least two VIAx must be used for a connection that is <= " + VIA3_R_6_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA3_R_6_L + " um (L) and width > " + VIA3_R_6_W + " um (W). (It is allowed to use one VIAx for a connection that is > " + VIA3_R_6_D + " um (D) away from a metal plate (either Mx or Mx+1) with length> " + VIA3_R_6_L + " um (L) and width > " + VIA3_R_6_W + " um (W))."; 
          sLAYER_584 = size( M4BIG_3_VIA3, clip_acute = NONE, distance = VIA3_R_6_D + GRID ); 
          sLAYER_583 = sLAYER_584 not M4BIG_3_VIA3; 
          BRANCH1 = sLAYER_583 and M4; 
          sLAYER_585 = interacting( BRANCH1, M4BIG_3_VIA3 ); 
          BRANCH1HASVIA = interacting( sLAYER_585, VIA3 ); 
          BRANCH1EDGE = M4BIG_3_VIA3 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA3_R_6_D, increment = M4_S_1 * 0.7 ); 
          sLAYER_586 = BRANCH and M3; 
          GOODBRANCH = interacting( sLAYER_586, VIA3, > 1 ); 
          sLAYER_587 = VIA3 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_587 outside GOODBRANCH; 
          sLAYER_590 = interacting( M3, BRANCHSINGLEVIA ); 
          sLAYER_589 = sLAYER_590 and M4; 
          sLAYER_588 = interacting( sLAYER_589, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_588, VIA3, == 1 ); 
          sLAYER_591 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_591 not VIA_EXD; 
      } /* end of rule : VIA3.R.6:M4 */
      
      // VIA3.R.7 is checked by VIA3.EN.1 and M4.EN.1
      rVIA3_R_11 @= { @ "VIA3.R.11 : Single VIAx is not allowed for H-shape  Mx+1 when all of the following conditions come into existence: "
                                    "1. The Mx+1 has H-shape interact with two metal holes : both two metal hole area <= " + VIA3_R_11_A + " um2 and two metal hole length(L2) <= " + VIA3_R_11_L2 + " um " 
                                    "2. The VIAx overlaps on the center metal bar of this H-shape Mx+1 "
                                    "3. The length (L) of the center metal bar <= " + VIA3_R_11_L + " um and the width of metal bar is <= " + VIA3_R_11_W + " um."; 
          W = not( M4I, wide( M4I, > VIA3_R_11_W, forty_five = INTERNAL ) ); 
          sLAYER_592 = donut_holes( M4I, area = <= VIA3_R_11_A, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          H_HOLE = interacting( sLAYER_592, W ); 
          A0 = interacting( M4I, H_HOLE ); 
          A = A0 coincident_outside_edge H_HOLE; 
          sLAYER_594 = internal1( A, <= VIA3_R_11_W, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_593 = sLAYER_594 inside A0; 
          B0 = interacting( sLAYER_593, H_HOLE, == 2 ); 
          sLAYER_597 = internal1( A, <= VIA3_R_11_L, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_596 = sLAYER_597 inside A0; 
          sLAYER_595 = sLAYER_596 and W; 
          B1 = interacting( sLAYER_595, H_HOLE, == 2 ); 
          HOLE_NOTCH = external1( H_HOLE, <= VIA3_R_11_W, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_598 = B1 not HOLE_NOTCH; 
          B2 = sLAYER_598 or B0; 
          sLAYER_600 = external1( B2, <= VIA3_R_11_W, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { }, output_type = EXTENTS ); 
          sLAYER_599 = outside_touching( sLAYER_600, B2, == 2 ); 
          CORNER_M = sLAYER_599 and W; 
          B = B2 or CORNER_M; 
          CENTER_BAR1 = not_contains( B, { GRID, VIA3_R_11_L + GRID }, FORTY_FIVE ); 
          sLAYER_601 = interacting( CENTER_BAR1, H_HOLE, == 2 ); 
          CENTER_BAR2 = interacting( sLAYER_601, VIA3I ); 
          C = CENTER_BAR2 coincident_outside_edge H_HOLE; 
          D = external2_edge( C, A, <= VIA3_R_11_L2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          E = C not_coincident_inside_edge D; 
          CENTER_BAR3 = CENTER_BAR2 not_touching E; 
          CHECK_VIA = VIA3I not_outside CENTER_BAR3; 
          sLAYER_604 = interacting( A0, CHECK_VIA ); 
          sLAYER_605 = interacting( M3I, CHECK_VIA ); 
          sLAYER_603 = sLAYER_604 and sLAYER_605;
          sLAYER_602 = interacting( sLAYER_603, VIA3I, == 1 ); 
          CHECK_VIA and sLAYER_602; 
      } /* end of rule : VIA3.R.11 */
      
      //M4 CHECKS
      //=========
      M41 = M4WIDE_FIRST not CB_NON_CUP; 
      M411 = M4WIDE_0_p_4 not CB_NON_CUP; 
      #ifdef HALF_NODE 
         M412 = M4WIDE_0_p_2 not CB_NON_CUP; 
         M413 = M4WIDE_0_p_4S not CB_NON_CUP; 
      #endif /* end of #ifdef HALF_NODE  */ 
      M42 = M4WIDE_1_p_5 not CB_NON_CUP; 
      M43 = M4WIDE_4_p_5 not CB_NON_CUP; 
      M4AS3 = area( M4, > ( M4_S_3_L * M4_W_1 ) );    /* filter small metal for M4.S.3 */ 
      M4AS4 = area( M4AS3, > ( M4_S_4_L * M4_W_1 ) );    /* filter small metal for M4.S.4 */ 
      M4_EDGE_45 = angle_edge( M4, == 45 ); 
      rM4_W_1 @= { @ "M4.W.1 : Width >= " + M4_W_1 + " um"; 
          internal1( M4, < M4_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : M4.W.1 */
      rM4_W_2 @= { @ "M4.W.2 : Width of 45-degree bent Mx Please make sure the vertex of 45 degree pattern is on 5nm grid >= " + M4_W_2 + " um"; 
          internal1( M4_EDGE_45, < M4_W_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
      } /* end of rule : M4.W.2 */
      rM4_W_3 @= { @ "M4.W.3 : Maximum width <= " + M4_W_3 + " um"; 
          size( size( M4, - ( M4_W_3 / 2 ), clip_acute = BISECTOR ), M4_W_3 / 2, clip_acute = BISECTOR ); 
      } /* end of rule : M4.W.3 */
      rM4_S_1 @= { @ "M4.S.1 : Spacing >= " + M4_S_1 + " um"; 
          external1( M4, < M4_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : M4.S.1 */
      
      //M4.S.2.S is checked by M4.S.2 
      rM4_S_2 @= { @ "M4.S.2 : Space [at least one metal line width > " + M4_S_2_W + " um  and the parallel metal run length > " + M4_S_2_L + " um ] (union projection) >= " + M4_S_2; 
          X = external2( M41, M4, < M4_S_2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M4; 
          contains( Y, { GRID, M4_S_2_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M4.S.2 */
      
      //M4.S.2.1.S is checked by M4.S.2.1
      rM4_S_2_1 @= { @ "M4.S.2.1 : Space [at least one metal line width > " + M4_S_2_1_W + " um  and the parallel metal run length > " + M4_S_2_1_L + " um ] (union projection) >= " + M4_S_2_1; 
          X = external2( M411, M4, < M4_S_2_1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M4; 
          contains( Y, { GRID, M4_S_2_1_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M4.S.2.1 */
      #ifdef HALF_NODE 
         
         //M4.S.2.2.S is checked by M4.S.2.2
         rM4_S_2_2 @= { @ "M4.S.2.2 : Space [at least one metal line width > " + M4_S_2_2_W + " um  and the parallel metal run length > " + M4_S_2_2_L + " um ] (union projection) >= " + M4_S_2_2; 
             X = external2( M412, M4, < M4_S_2_2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
             Y = X not M4; 
             contains( Y, { GRID, M4_S_2_2_L + GRID }, FORTY_FIVE ); 
         } /* end of rule : M4.S.2.2 */
         
         //M4.S.2.3.S is checked by M4.S.2.3
         rM4_S_2_3 @= { @ "M4.S.2.3 : Space [at least one metal line width > " + M4_S_2_3_W + " um  and the parallel metal run length > " + M4_S_2_3_L + " um ] (union projection) >= " + M4_S_2_3; 
             X = external2( M413, M4, < M4_S_2_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
             Y = X not M4; 
             contains( Y, { GRID, M4_S_2_3_L + GRID }, FORTY_FIVE ); 
         } /* end of rule : M4.S.2.3 */
      #endif /* end of #ifdef HALF_NODE  */ 
      
      //M4.S.3.S is checked by M4.S.3
      rM4_S_3 @= { @ "M4.S.3 : Space [at least one metal line width > " + M4_S_3_W + " um  and the parallel metal run length > " + M4_S_3_L + " um ] (union projection) >= " + M4_S_3; 
          X = external2( M42, M4AS3, < M4_S_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M4; 
          contains( Y, { GRID, M4_S_3_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M4.S.3 */
      
      //M4.S.4.S is checked by M4.S.4
      rM4_S_4 @= { @ "M4.S.4 : Space [at least one metal line width > " + M4_S_4_W + " um  and the parallel metal run length > " + M4_S_4_L + " um ] (union projection) >= " + M4_S_4; 
          X = external2( M43, M4AS4, < M4_S_4, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M4; 
          contains( Y, { GRID, M4_S_4_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M4.S.4 */
      rM4_S_5 @= { @ "M4.S.5 : Space at Mx line-end (W<Q=0.120) in a dense-line-end configuration: If Mx has parallel run length with opposite Mx (measured with T=0.035 extension) along 2 adjacent edges of Mx [any one edge <Q distance from the corner of the two edges], then one of the space (S1 or S2) needs to be at least this value (except for small jog with edge length < 0.10 um (R)) >= " + M4_S_5 + " um."; 
          A = adjacent_edge( M4, angle1 = == 90, angle2 = == 90, length = < M4_S_5_Q ); 
          B = external2_edge( A, M4, < M4_S_5, extension = EDGE, extension_distance = M4_S_5_E, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1 ); 
          C = A inside_touching_edge B; 
          D = internal2_edge( C, M4, < M4_S_5_Q, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 90, look_thru = RELATED_COINCIDENT, orientation = { }, output_layer = LAYER2 ); 
          I = length_edge( D, >= M4_W_1 ); 
          sLAYER_1321 = extend_edge( I, start = M4_S_5_E, end = M4_S_5_E ); 
          J = edge_size( sLAYER_1321, inside = 0.001 ); 
          K = edge_size( I, inside = 0.001 ); 
          L = J not K; 
          M = L touching A; 
          N = M or K; 
          O = N touching_edge I; 
          external2( O, M4, < M4_S_5, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
      } /* end of rule : M4.S.5 */
      
      //M4.EN.0 is checked by either {M4.EN.1/M4.EN.2} or M4.EN.3
      rM4_EN_1 @= { @ "M4.EN.1 : Enclosure of VIA3 >= 0 um";
          VIA3 not M4; 
      } /* end of rule : M4.EN.1 */
      
      // M4.EN.2 is checked by M4.EN.2__M4.EN.3
      // M4.EN.3 is checked by M4.EN.2__M4.EN.3
      rM4_EN_2__M4_EN_3 @= { @ "M4.EN.2__M4.EN.3 : Enclosure of VIA3 [at least two opposite sides] >= " + M4_EN_2 + " ,or [all sides] >= " + M4_EN_3; 
          X = not_enclosed_by( VIA3, M4, distances = { { { 0, RADIAL }, { M4_EN_2, NONE }, { 0, RADIAL }, { M4_EN_2, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          enclose( X, M4, < M4_EN_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : M4.EN.2__M4.EN.3 */
      rM4_A_1 @= { @ "M4.A.1 : Area >= " + M4_A_1 + " um2"; 
          area( M4, < M4_A_1 ); 
      } /* end of rule : M4.A.1 */
      rM4_A_2 @= { @ "M4.A.2 : Enclosed area >= " + M4_A_2 + " um"; 
          X = donut_holes( M4, area = < M4_A_2PRE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          sLAYER_606 = X not M4; 
          area( sLAYER_606, < M4_A_2 ); 
      } /* end of rule : M4.A.2 */
      rM4_S_6 @= { @ "M4.S.6 : Space to 45 degree bent M4 >= " + M4_S_6 + " um"; 
          X = edge_size( M4_EDGE_45, outside = M4_S_6 ); 
          X and M4; 
      } /* end of rule : M4.S.6 */
      M4DN1H_EXC = copy( M4_EXC ); 
      M4DN1L_EXC = copy( M4_EXC_LOW ); 
      #ifdef CHECK_LOW_DENSITY 
         rM4_DN_1 @= { @ "M4.DN.1 : M4 local density must be >= " + M4_DN_1L + " range over " + M4_DN_1L_W + " um x " + M4_DN_1L_W + " um step " + M4_DN_1L_S + " um"; 
             M4_CHECK = M4X not M4DN1L_EXC; 
             CHIP_CHECK = gCHIP not M4DN1L_EXC; 
         _den_con = < M4_DN_1L; 
         _den_polygon_area_clip = false;
         _den_print = false;
         _den_print_only = false;
             ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M4_CHECK, "layer2" => CHIP_CHECK }, delta_window = { M4_DN_1L_W, M4_DN_1L_W }, delta_x = M4_DN_1L_S, delta_y = M4_DN_1L_S, boundary = BACKUP, window_function = den_save_window_1 ); 
             sLAYER_607 = ERR_WIN not M4DN1L_EXC; 
             F = wide( sLAYER_607, >= M4_DN_1L_E, forty_five = INTERNAL ); 
             VAR_26 = density_statistics_file( file = "M4.DN.1.density" ); 
         _den_con = < M4_DN_1L; 
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M4_CHECK, "layer3" => CHIP_CHECK }, delta_window = { M4_DN_1L_W, M4_DN_1L_W }, delta_x = M4_DN_1L_S, delta_y = M4_DN_1L_S, boundary = BACKUP, statistics_files = { VAR_26 }, window_function = den_save_window_2 ); 
         } /* end of rule : M4.DN.1 */
      #endif /* end of #ifdef CHECK_LOW_DENSITY  */ 
      rM4_DN_1_1 @= { @ "M4.DN.1.1 : M4 local density must be <= " + M4_DN_1H + " range over " + M4_DN_1H_W + " um x " + M4_DN_1H_W + " um step " + M4_DN_1H_S + " um"; 
          M4_CHECK = M4X not M4DN1H_EXC; 
          CHIP_CHECK = gCHIP not M4DN1H_EXC; 
      _den_con = > M4_DN_1H; 
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M4_CHECK, "layer2" => CHIP_CHECK }, delta_window = { M4_DN_1H_W, M4_DN_1H_W }, delta_x = M4_DN_1H_S, delta_y = M4_DN_1H_S, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_608 = ERR_WIN not M4DN1H_EXC; 
          F = wide( sLAYER_608, >= M4_DN_1H_E, forty_five = INTERNAL ); 
          VAR_27 = density_statistics_file( file = "M4.DN.1.1.density" ); 
      _den_con = > M4_DN_1H; 
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M4_CHECK, "layer3" => CHIP_CHECK }, delta_window = { M4_DN_1H_W, M4_DN_1H_W }, delta_x = M4_DN_1H_S, delta_y = M4_DN_1H_S, boundary = BACKUP, statistics_files = { VAR_27 }, window_function = den_save_window_3 ); 
      } /* end of rule : M4.DN.1.1 */
      M4DN2_EXC = copy( EMPTYI ); 
      rM4_DN_2 @= { @ "M4.DN.2 : M4 local density must be <= " + M4_DN_2 + " range over " + M4_DN_2_W + " um x " + M4_DN_2_W + " um step " + M4_DN_2_S + " um"; 
          M4_CHECK = M4X not M4DN2_EXC; 
      _den_con = > M4_DN_2; 
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M4_CHECK, "layer2" => gCHIP }, delta_window = { M4_DN_2_W, M4_DN_2_W }, delta_x = M4_DN_2_S, delta_y = M4_DN_2_S, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_609 = ERR_WIN not M4DN2_EXC; 
          F = wide( sLAYER_609, >= M4_DN_2_E, forty_five = INTERNAL ); 
          VAR_28 = density_statistics_file( file = "M4.DN.2.density" ); 
      _den_con = > M4_DN_2; 
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M4_CHECK, "layer3" => gCHIP }, delta_window = { M4_DN_2_W, M4_DN_2_W }, delta_x = M4_DN_2_S, delta_y = M4_DN_2_S, boundary = BACKUP, statistics_files = { VAR_28 }, window_function = den_save_window_3 ); 
      } /* end of rule : M4.DN.2 */
      rM4_DN_4 @= { @ "M4.DN.4 : The metal density difference between any two " + M4_DN_4_W + " um x " + M4_DN_4_W + " um neighboring checking windows including DM4EXCL <= " + M4_DN_4; 
          sLAYER_1322 = chip_extent();
          VAR_29 = density_statistics_file( file = "M4.DN.4.density" ); 
      _gden_con = <= 1;
      _gden_gcon = > M4_DN_4; 
      _gden_absolute = true;
      _gden_corner = true;
      _gden_corner_value = -1.0;
      _gden_polygon_area_clip = true;
      _gden_print = true;
      _gden_print_only = false;
          sLAYER_1322 = sLAYER_1322 or gCHIP;
gradient_density( window_layer = sLAYER_1322, layer_hash = { "layer1" => M4X, "layer2" => gCHIP }, delta_window = { M4_DN_4_W, M4_DN_4_W }, delta_x = M4_DN_4_W, delta_y = M4_DN_4_W, boundary = BACKUP, statistics_files = { VAR_29 }, window_function = gden_save_window_7 ); 
      } /* end of rule : M4.DN.4 */
      
      //M4.R.1U is not necessary to check
      
      // Mx.DN.5
      //===========
      M4_CORE = M4X not SRCSR; 
      rM2_DN_5 @= { @ "M2.DN.5 : It is not allowed to have local density > " + MX_DN_5 + " of all 3 consecutive metal (M2,M3,M4) over any " + MX_DN_5_W + " um x " + MX_DN_5_W + " um window (stepping " + MX_DN_5_S + " um)"; 
          sLAYER_1323 = chip_extent();
          VAR_30 = density_statistics_file( file = "M2.DN.5.density" ); 
      _den_con = > 0;
      _den_polygon_area_clip = true;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( window_layer = sLAYER_1323, layer_hash = { "layer1" => M2_CORE, "layer2" => M3_CORE, "layer3" => M4_CORE }, delta_window = { MX_DN_5_W, MX_DN_5_W }, delta_x = MX_DN_5_S, delta_y = MX_DN_5_S, boundary = BACKUP, statistics_files = { VAR_30 }, window_function = den_save_window_8 ); 
      } /* end of rule : M2.DN.5 */
      
      //Mx.DN.6 is checked by M2.DN.6    
      rM2_DN_6 @= { @ "M2.DN.6 : It is not allowed to have local density < " + M2_DN_6 + " of all 3 consecutive metal (M2,M3,M4) under ((CBM SIZING 25) SIZING -25) whose size is >= 200um X 200um"; 
          A = net_area_ratio( CONNECT_DB, < M2_DN_6, { "layer1" => M2DN6_CHECK_CBM, "layer2" => M2DN6_M2_CHECK }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
          B = net_area_ratio( CONNECT_DB, < M2_DN_6, { "layer1" => M2DN6_CHECK_CBM, "layer2" => M2DN6_M3_CHECK }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
          C = net_area_ratio( CONNECT_DB, < M2_DN_6, { "layer1" => M2DN6_CHECK_CBM, "layer2" => M2DN6_M4_CHECK }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
          sLAYER_610 = A and B; 
          sLAYER_610 and C; 
      } /* end of rule : M2.DN.6 */
      
      //VIA4 CHECKS
      //===========
      gLAYER_277 = size( size( M5, - ( M5_S_2_W / 2 ), clip_acute = BISECTOR ), M5_S_2_W / 2, clip_acute = BISECTOR ); 
      M5WIDE_FIRST = gLAYER_277 and M5; 
      gLAYER_278 = size( size( M5WIDE_FIRST, - ( M5_S_2_1_W / 2 ), clip_acute = BISECTOR ), M5_S_2_1_W / 2, clip_acute = BISECTOR ); 
      M5WIDE_0_p_4 = gLAYER_278 and M5WIDE_FIRST; 
      #ifdef HALF_NODE 
         gLAYER_279 = size( size( M5, - ( M5_S_2_2_W / 2 ), clip_acute = BISECTOR ), M5_S_2_2_W / 2, clip_acute = BISECTOR ); 
         M5WIDE_0_p_2 = gLAYER_279 and M5; 
         gLAYER_280 = size( size( M5WIDE_FIRST, - ( M5_S_2_3_W / 2 ), clip_acute = BISECTOR ), M5_S_2_3_W / 2, clip_acute = BISECTOR ); 
         M5WIDE_0_p_4S = gLAYER_280 and M5WIDE_FIRST; 
      #endif /* end of #ifdef HALF_NODE  */ 
      gLAYER_281 = size( size( M5WIDE_FIRST, - ( M5_S_3_W / 2 ), clip_acute = BISECTOR ), M5_S_3_W / 2, clip_acute = BISECTOR ); 
      M5WIDE_1_p_5 = gLAYER_281 and M5WIDE_FIRST; 
      gLAYER_282 = size( size( M5WIDE_1_p_5, - ( M5_S_4_W / 2 ), clip_acute = BISECTOR ), M5_S_4_W / 2, clip_acute = BISECTOR ); 
      M5WIDE_4_p_5 = gLAYER_282 and M5WIDE_1_p_5; 
      gLAYER_283 = size( size( M4WIDE_FIRST, - ( VIA4_R_2_W / 2 ), clip_acute = BISECTOR ), VIA4_R_2_W / 2, clip_acute = BISECTOR ); 
      M4WIDE_0_p_42_VIA4 = gLAYER_283 and M4WIDE_FIRST; 
      gLAYER_284 = size( size( M4WIDE_0_p_42_VIA4, - ( VIA4_R_4_W / 2 ), clip_acute = BISECTOR ), VIA4_R_4_W / 2, clip_acute = BISECTOR ); 
      M4WIDE_0_p_7_VIA4 = gLAYER_284 and M4WIDE_0_p_42_VIA4; 
      gLAYER_285 = size( size( M4WIDE_0_p_7_VIA4, - ( VIA4_R_3_W / 2 ), clip_acute = BISECTOR ), VIA4_R_3_W / 2, clip_acute = BISECTOR ); 
      M4WIDE_0_p_98_VIA4 = gLAYER_285 and M4WIDE_0_p_7_VIA4; 
      gLAYER_286 = size( size( M4WIDE_0_p_98_VIA4, - ( VIA4_R_5_W / 2 ), clip_acute = BISECTOR ), VIA4_R_5_W / 2, clip_acute = BISECTOR ); 
      M4WIDE_2_VIA4 = gLAYER_286 and M4WIDE_0_p_98_VIA4; 
      gLAYER_287 = size( size( M4WIDE_2_VIA4, - ( VIA4_R_6_W / 2 ), clip_acute = BISECTOR ), VIA4_R_6_W / 2, clip_acute = BISECTOR ); 
      M4WIDE_3_VIA4 = gLAYER_287 and M4WIDE_2_VIA4; 
      gLAYER_288 = size( size( M5WIDE_FIRST, - ( VIA4_R_2_W / 2 ), clip_acute = BISECTOR ), VIA4_R_2_W / 2, clip_acute = BISECTOR ); 
      M5WIDE_0_p_42_VIA4 = gLAYER_288 and M5WIDE_FIRST; 
      gLAYER_289 = size( size( M5WIDE_0_p_42_VIA4, - ( VIA4_R_4_W / 2 ), clip_acute = BISECTOR ), VIA4_R_4_W / 2, clip_acute = BISECTOR ); 
      M5WIDE_0_p_7_VIA4 = gLAYER_289 and M5WIDE_0_p_42_VIA4; 
      gLAYER_290 = size( size( M5WIDE_0_p_7_VIA4, - ( VIA4_R_3_W / 2 ), clip_acute = BISECTOR ), VIA4_R_3_W / 2, clip_acute = BISECTOR ); 
      M5WIDE_0_p_98_VIA4 = gLAYER_290 and M5WIDE_0_p_7_VIA4; 
      gLAYER_291 = size( size( M5WIDE_0_p_98_VIA4, - ( VIA4_R_5_W / 2 ), clip_acute = BISECTOR ), VIA4_R_5_W / 2, clip_acute = BISECTOR ); 
      M5WIDE_2_VIA4 = gLAYER_291 and M5WIDE_0_p_98_VIA4; 
      gLAYER_292 = size( size( M5WIDE_2_VIA4, - ( VIA4_R_6_W / 2 ), clip_acute = BISECTOR ), VIA4_R_6_W / 2, clip_acute = BISECTOR ); 
      M5WIDE_3_VIA4 = gLAYER_292 and M5WIDE_2_VIA4; 
      rVIA4_W_1 @= { @ "VIA4.W.1 : Width (maximum = minimum except for seal-ring and fuse protection ring) = " + VIA4_W_1 + " um " 
                                  "VIA4.R.1 45-degree rotated VIA is not allowed";
          A = not_rectangles( VIA4, orientation = ORTHOGONAL, sides = { == VIA4_W_1, == VIA4_W_1 } ); 
          A not VIA_EXD; 
      } /* end of rule : VIA4.W.1 */
      
      // CSR.W.3 is checked by VIA4.W.2
      rVIA4_W_2 @= { @ "VIA4.W.2 : VIA4 bar width = " + VIA4_W_2 + " (VIA4 bar is covered by SEALRING layer and only allowed in seal-ring and fuse protecion ring)"; 
          internal1( VIA4_BAR, < VIA4_W_2, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          A = wide( VIA4_BAR, > VIA4_W_2, forty_five = INTERNAL ); 
          B = angle_edge( VIA4_BAR, == 45 ); 
          C = internal1( B, < ( VIA4_W_2 + 2 * GRID ), extension = RADIAL, intersecting = {  } ); 
          D = A not C; 
          contains( D, { 1, 0.005 }, FORTY_FIVE ); 
      } /* end of rule : VIA4.W.2 */
      rVIA4_S_1 @= { @ "VIA4.S.1 : Spacing >= " + VIA4_S_1 + " um"; 
          external1( VIA4, < VIA4_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : VIA4.S.1 */
      rVIA4_S_2 @= { @ "VIA4.S.2 : Space to 3-neighboring VIAx (< 0.14 um distance) >= " + VIA4_S_2 + " um"; 
          X = rectangle_spacing1( VIA4, count = > 2, distance = < VIA4_S_2_S ); 
          external2( X, VIA4, < VIA4_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : VIA4.S.2 */
      rVIA4_S_3 @= { @ "VIA4.S.3 : Space to neighboring VIAx [different net and common parallel run length > 0] >= " + VIA4_S_3 + " um"; 
          VIA4_NODAL = stamp( VIA4, VIA4I, CONNECT_DB, CONNECT_DB_VIA4_S_3, include_touch = NONE ); 
          external1( VIA4_NODAL, < VIA4_S_3, connect_sequence = CONNECT_DB_VIA4_S_3, connectivity = DIFFERENT_NET, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
      } /* end of rule : VIA4.S.3 */
      
      //VIA4.EN.0 is checked by either {VIA4.EN.1/VIA4.EN.2} or VIA4.EN.3
      rVIA4_EN_1 @= { @ "VIA4.EN.1 : Enclosure by M4 >= 0 um";
          VIA4 not M4; 
      } /* end of rule : VIA4.EN.1 */
      
      // VIA4.EN.2 is checked by VIA4.EN.2__VIA4.EN.3
      // VIA4.EN.3 is checked by VIA4.EN.2__VIA4.EN.3
      rVIA4_EN_2__VIA4_EN_3 @= { @ "VIA4.EN.2__VIA4.EN.3 : Enclosure by M4 [at least two opposite sides] >= " + VIA4_EN_2 + " , or [all sides] >= " + VIA4_EN_3; 
          X = not_enclosed_by( VIA4, M4, distances = { { { 0, RADIAL }, { VIA4_EN_2, NONE }, { 0, RADIAL }, { VIA4_EN_2, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          enclose( X, M4, < VIA4_EN_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : VIA4.EN.2__VIA4.EN.3 */
      
      // VIA4.R.1 is checked by VIA4.W.1
      // VIA4.R.2 is checked by VIA4.R.2__VIA4.R.3
      // VIA4.R.2.S is checked by VIA4.R.2__VIA4.R.3
      // VIA4.R.3 is checked by VIA4.R.2__VIA4.R.3
      
      // VIA4.R.3.S is checked by VIA4.R.2__VIA4.R.3
      rVIA4_R_2__VIA4_R_3 @= { @ "VIA4.R.2__VIA4.R.3 : When M4 or M5 width > " + VIA4_R_2_W + " um, more than one VIA4 is required. " 
                                                      "2 vias spacing should be <= " + VIA4_R_2_S1 + " um or 4 vias spacing should be <= " + VIA4_R_2_S2 + " um " 
                                                      "When M4 or M5 width > " + VIA4_R_3_W + " um, more than three VIA4 is required. " 
                                                      "4 vias spacing should be <= " + VIA4_R_3_S1 + " um or 9 vias spacing should be <= " + VIA4_R_3_S2 + " um"; 
          sLAYER_611 = M4WIDE_0_p_42_VIA4 and M5; 
          sLAYER_612 = M5WIDE_0_p_42_VIA4 and M4; 
          M5OVPM4_W_ = sLAYER_611 or sLAYER_612; 
          sLAYER_613 = M4WIDE_0_p_98_VIA4 and M5; 
          sLAYER_614 = M5WIDE_0_p_98_VIA4 and M4; 
          M5OVPM4_B = sLAYER_613 or sLAYER_614; 
          M5OVPM4_W = M5OVPM4_W_ not M5OVPM4_B; 
          CHECKED_VIA4_W_ = VIA4_EXD not_outside M5OVPM4_W; 
          CHECKED_VIA4_B = VIA4_EXD not_outside M5OVPM4_B; 
          CHECKED_VIA4_W = CHECKED_VIA4_W_ not CHECKED_VIA4_B; 
          M4_EFFECT = interacting( M4I, M5OVPM4_W_ ); 
          M5_EFFECT = interacting( M5I, M5OVPM4_W_ ); 
          EFFECT_M5OVPM4_ = M4_EFFECT and M5_EFFECT; 
          EFFECT_M5OVPM4 = interacting( EFFECT_M5OVPM4_, M5OVPM4_W_ ); 
          EFFECT_VIA = interacting( VIA4_EXD, EFFECT_M5OVPM4 ); 
          V4MERGED_A = size_inside_wrapper( EFFECT_VIA, EFFECT_M5OVPM4, distance = VIA4_R_2_S1 / 2, increment = M4_S_1 * 0.7 ); 
          V4MERGED_B = size_inside_wrapper( V4MERGED_A, EFFECT_M5OVPM4, distance = VIA4_R_2_S2_S1, increment = M4_S_1 * 0.7 ); 
          V4MERGED_C = size_inside_wrapper( V4MERGED_B, EFFECT_M5OVPM4, distance = ( VIA4_R_3_S2 - VIA4_R_2_S2 ) / 2, increment = M4_S_1 * 0.7 ); 
          V4MERGED_A2R = interacting( V4MERGED_A, EFFECT_VIA, < 2 ); 
          V4MERGED_A2 = V4MERGED_A outside V4MERGED_A2R; 
          V4MERGED_A4R = interacting( V4MERGED_A2, EFFECT_VIA, < 4 ); 
          V4MERGED_A4 = V4MERGED_A2 outside V4MERGED_A4R; 
          V4MERGED_B4R = interacting( V4MERGED_B, EFFECT_VIA, < 4 ); 
          V4MERGED_B4 = V4MERGED_B outside V4MERGED_B4R; 
          V4MERGED_C9R = interacting( V4MERGED_C, EFFECT_VIA, < 9 ); 
          V4MERGED_C9 = V4MERGED_C outside V4MERGED_C9R; 
          GMERGEW = V4MERGED_A2 or V4MERGED_B4; 
          GMERGEB = V4MERGED_A4 or V4MERGED_C9; 
          GVIA_W = interacting( CHECKED_VIA4_W, GMERGEW ); 
          GVIA_B = interacting( CHECKED_VIA4_B, GMERGEB ); 
          GOOD_AREA_W = interacting( M5OVPM4_W, GVIA_W ); 
          GOOD_AREA_B = interacting( M5OVPM4_B, GVIA_B ); 
          CHECKED_VIA4_W outside GOOD_AREA_W; 
          CHECKED_VIA4_B outside GOOD_AREA_B; 
      } /* end of rule : VIA4.R.2__VIA4.R.3 */
      
      //VIA4.R.4 is checked by VIA4.R.4:M4 and VIA4.R.4:M5
      //VIA4.R.4.S is checked by VIA4.R.4:M4 and VIA4.R.4:M5
      rVIA4_R_4_M4 @= { @ "VIA4.R.4:M4 : At least two VIAx must be used for a connection that is <= " + VIA4_R_4_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA4_R_4_W + " um (L) and width > " + VIA4_R_4_W + " um (W). (It is allowed to use one VIAx for a connection that is > " + VIA4_R_4_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA4_R_4_W + " um (L) and width > " + VIA4_R_4_W + " um (W).)"; 
          sLAYER_616 = size( M4WIDE_0_p_7_VIA4, clip_acute = NONE, distance = VIA4_R_4_D + GRID ); 
          sLAYER_615 = sLAYER_616 not M4WIDE_0_p_7_VIA4; 
          BRANCH1 = sLAYER_615 and M4; 
          sLAYER_617 = interacting( BRANCH1, M4WIDE_0_p_7_VIA4 ); 
          BRANCH1HASVIA = interacting( sLAYER_617, VIA4 ); 
          BRANCH1EDGE = M4WIDE_0_p_7_VIA4 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA4_R_4_D, increment = M4_S_1 * 0.5 ); 
          sLAYER_618 = BRANCH and M5; 
          GOODBRANCH = interacting( sLAYER_618, VIA4, > 1 ); 
          sLAYER_619 = VIA4 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_619 outside GOODBRANCH; 
          sLAYER_622 = interacting( M5, BRANCHSINGLEVIA ); 
          sLAYER_621 = sLAYER_622 and M4; 
          sLAYER_620 = interacting( sLAYER_621, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_620, VIA4, == 1 ); 
          sLAYER_623 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_623 not VIA_EXD; 
      } /* end of rule : VIA4.R.4:M4 */
      rVIA4_R_4_M5 @= { @ "VIA4.R.4:M5 : At least two VIAx must be used for a connection that is <= " + VIA4_R_4_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA4_R_4_W + " um (L) and width > " + VIA4_R_4_W + " um (W). (It is allowed to use one VIAx for a connection that is > " + VIA4_R_4_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA4_R_4_W + " um (L) and width > " + VIA4_R_4_W + " um (W).)"; 
          sLAYER_625 = size( M5WIDE_0_p_7_VIA4, clip_acute = NONE, distance = VIA4_R_4_D + GRID ); 
          sLAYER_624 = sLAYER_625 not M5WIDE_0_p_7_VIA4; 
          BRANCH1 = sLAYER_624 and M5; 
          sLAYER_626 = interacting( BRANCH1, M5WIDE_0_p_7_VIA4 ); 
          BRANCH1HASVIA = interacting( sLAYER_626, VIA4 ); 
          BRANCH1EDGE = M5WIDE_0_p_7_VIA4 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA4_R_4_D, increment = M5_S_1 * 0.5 ); 
          sLAYER_627 = BRANCH and M4; 
          GOODBRANCH = interacting( sLAYER_627, VIA4, > 1 ); 
          sLAYER_628 = VIA4 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_628 outside GOODBRANCH; 
          sLAYER_631 = interacting( M4, BRANCHSINGLEVIA ); 
          sLAYER_630 = sLAYER_631 and M5; 
          sLAYER_629 = interacting( sLAYER_630, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_629, VIA4, == 1 ); 
          sLAYER_632 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_632 not VIA_EXD; 
      } /* end of rule : VIA4.R.4:M5 */
      
      //VIA4.R.5 is checked by VIA4.R.5:M4 and VIA4.R.5:M5
      
      //VIA4.R.5.S is checked by VIA4.R.5:M4 and VIA4.R.5:M5
      rVIA4_R_5_M4 @= { @ "VIA4.R.5:M4 : At least two VIAx must be used for a connection that is <= " + VIA4_R_5_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA4_R_5_W + " um (L) and width > " + VIA4_R_5_W + " um (W). It is allowed to use one VIAx for a connection that is > " + VIA4_R_5_D + " um (D) away from a metal plate (either Mx or Mx+1) with length> " + VIA4_R_5_W + " um (L) and width > " + VIA4_R_5_W + " um (W)."; 
          sLAYER_634 = size( M4WIDE_2_VIA4, clip_acute = NONE, distance = VIA4_R_5_D + GRID ); 
          sLAYER_633 = sLAYER_634 not M4WIDE_2_VIA4; 
          BRANCH1 = sLAYER_633 and M4; 
          sLAYER_635 = interacting( BRANCH1, M4WIDE_2_VIA4 ); 
          BRANCH1HASVIA = interacting( sLAYER_635, VIA4 ); 
          BRANCH1EDGE = M4WIDE_2_VIA4 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA4_R_5_D, increment = M4_S_1 * 0.7 ); 
          sLAYER_636 = BRANCH and M5; 
          GOODBRANCH = interacting( sLAYER_636, VIA4, > 1 ); 
          sLAYER_637 = VIA4 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_637 outside GOODBRANCH; 
          sLAYER_640 = interacting( M5, BRANCHSINGLEVIA ); 
          sLAYER_639 = sLAYER_640 and M4; 
          sLAYER_638 = interacting( sLAYER_639, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_638, VIA4, == 1 ); 
          sLAYER_641 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_641 not VIA_EXD; 
      } /* end of rule : VIA4.R.5:M4 */
      rVIA4_R_5_M5 @= { @ "VIA4.R.5:M5 : At least two VIAx must be used for a connection that is <= " + VIA4_R_5_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA4_R_5_W + " um (L) and width > " + VIA4_R_5_W + " um (W). It is allowed to use one VIAx for a connection that is > " + VIA4_R_5_D + " um (D) away from a metal plate (either Mx or Mx+1) with length> " + VIA4_R_5_W + " um (L) and width > " + VIA4_R_5_W + " um (W)."; 
          sLAYER_643 = size( M5WIDE_2_VIA4, clip_acute = NONE, distance = VIA4_R_5_D + GRID ); 
          sLAYER_642 = sLAYER_643 not M5WIDE_2_VIA4; 
          BRANCH1 = sLAYER_642 and M5; 
          sLAYER_644 = interacting( BRANCH1, M5WIDE_2_VIA4 ); 
          BRANCH1HASVIA = interacting( sLAYER_644, VIA4 ); 
          BRANCH1EDGE = M5WIDE_2_VIA4 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA4_R_5_D, increment = M5_S_1 * 0.7 ); 
          sLAYER_645 = BRANCH and M4; 
          GOODBRANCH = interacting( sLAYER_645, VIA4, > 1 ); 
          sLAYER_646 = VIA4 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_646 outside GOODBRANCH; 
          sLAYER_649 = interacting( M4, BRANCHSINGLEVIA ); 
          sLAYER_648 = sLAYER_649 and M5; 
          sLAYER_647 = interacting( sLAYER_648, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_647, VIA4, == 1 ); 
          sLAYER_650 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_650 not VIA_EXD; 
      } /* end of rule : VIA4.R.5:M5 */
      M4BIG_3_VIA4 = contains( M4WIDE_3_VIA4, { VIA4_R_6_W, VIA4_R_6_L + GRID }, FORTY_FIVE ); 
      
      //VIA4.R.6 is checked by VIA4.R.6:M4 and VIA4.R.6:M5
      //VIA4.R.6.S is checked by VIA4.R.6:M4 and VIA4.R.6:M5
      rVIA4_R_6_M4 @= { @ "VIA4.R.6:M4 : At least two VIAx must be used for a connection that is <= " + VIA4_R_6_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA4_R_6_L + " um (L) and width > " + VIA4_R_6_W + " um (W). (It is allowed to use one VIAx for a connection that is > " + VIA4_R_6_D + " um (D) away from a metal plate (either Mx or Mx+1) with length> " + VIA4_R_6_L + " um (L) and width > " + VIA4_R_6_W + " um (W))."; 
          sLAYER_652 = size( M4BIG_3_VIA4, clip_acute = NONE, distance = VIA4_R_6_D + GRID ); 
          sLAYER_651 = sLAYER_652 not M4BIG_3_VIA4; 
          BRANCH1 = sLAYER_651 and M4; 
          sLAYER_653 = interacting( BRANCH1, M4BIG_3_VIA4 ); 
          BRANCH1HASVIA = interacting( sLAYER_653, VIA4 ); 
          BRANCH1EDGE = M4BIG_3_VIA4 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA4_R_6_D, increment = M4_S_1 * 0.7 ); 
          sLAYER_654 = BRANCH and M5; 
          GOODBRANCH = interacting( sLAYER_654, VIA4, > 1 ); 
          sLAYER_655 = VIA4 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_655 outside GOODBRANCH; 
          sLAYER_658 = interacting( M5, BRANCHSINGLEVIA ); 
          sLAYER_657 = sLAYER_658 and M4; 
          sLAYER_656 = interacting( sLAYER_657, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_656, VIA4, == 1 ); 
          sLAYER_659 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_659 not VIA_EXD; 
      } /* end of rule : VIA4.R.6:M4 */
      M5BIG_3_VIA4 = contains( M5WIDE_3_VIA4, { VIA4_R_6_W, VIA4_R_6_L + GRID }, FORTY_FIVE ); 
      rVIA4_R_6_M5 @= { @ "VIA4.R.6:M5 : At least two VIAx must be used for a connection that is <= " + VIA4_R_6_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA4_R_6_L + " um (L) and width > " + VIA4_R_6_W + " um (W). (It is allowed to use one VIAx for a connection that is > " + VIA4_R_6_D + " um (D) away from a metal plate (either Mx or Mx+1) with length> " + VIA4_R_6_L + " um (L) and width > " + VIA4_R_6_W + " um (W))."; 
          sLAYER_661 = size( M5BIG_3_VIA4, clip_acute = NONE, distance = VIA4_R_6_D + GRID ); 
          sLAYER_660 = sLAYER_661 not M5BIG_3_VIA4; 
          BRANCH1 = sLAYER_660 and M5; 
          sLAYER_662 = interacting( BRANCH1, M5BIG_3_VIA4 ); 
          BRANCH1HASVIA = interacting( sLAYER_662, VIA4 ); 
          BRANCH1EDGE = M5BIG_3_VIA4 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA4_R_6_D, increment = M5_S_1 * 0.7 ); 
          sLAYER_663 = BRANCH and M4; 
          GOODBRANCH = interacting( sLAYER_663, VIA4, > 1 ); 
          sLAYER_664 = VIA4 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_664 outside GOODBRANCH; 
          sLAYER_667 = interacting( M4, BRANCHSINGLEVIA ); 
          sLAYER_666 = sLAYER_667 and M5; 
          sLAYER_665 = interacting( sLAYER_666, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_665, VIA4, == 1 ); 
          sLAYER_668 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_668 not VIA_EXD; 
      } /* end of rule : VIA4.R.6:M5 */
      
      // VIA4.R.7 is checked by VIA4.EN.1 and M5.EN.1
      rVIA4_R_11 @= { @ "VIA4.R.11 : Single VIAx is not allowed for H-shape  Mx+1 when all of the following conditions come into existence: "
                                    "1. The Mx+1 has H-shape interact with two metal holes : both two metal hole area <= " + VIA4_R_11_A + " um2 and two metal hole length(L2) <= " + VIA4_R_11_L2 + " um " 
                                    "2. The VIAx overlaps on the center metal bar of this H-shape Mx+1 "
                                    "3. The length (L) of the center metal bar <= " + VIA4_R_11_L + " um and the width of metal bar is <= " + VIA4_R_11_W + " um."; 
          W = not( M5I, wide( M5I, > VIA4_R_11_W, forty_five = INTERNAL ) ); 
          sLAYER_669 = donut_holes( M5I, area = <= VIA4_R_11_A, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          H_HOLE = interacting( sLAYER_669, W ); 
          A0 = interacting( M5I, H_HOLE ); 
          A = A0 coincident_outside_edge H_HOLE; 
          sLAYER_671 = internal1( A, <= VIA4_R_11_W, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_670 = sLAYER_671 inside A0; 
          B0 = interacting( sLAYER_670, H_HOLE, == 2 ); 
          sLAYER_674 = internal1( A, <= VIA4_R_11_L, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_673 = sLAYER_674 inside A0; 
          sLAYER_672 = sLAYER_673 and W; 
          B1 = interacting( sLAYER_672, H_HOLE, == 2 ); 
          HOLE_NOTCH = external1( H_HOLE, <= VIA4_R_11_W, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_675 = B1 not HOLE_NOTCH; 
          B2 = sLAYER_675 or B0; 
          sLAYER_677 = external1( B2, <= VIA4_R_11_W, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { }, output_type = EXTENTS ); 
          sLAYER_676 = outside_touching( sLAYER_677, B2, == 2 ); 
          CORNER_M = sLAYER_676 and W; 
          B = B2 or CORNER_M; 
          CENTER_BAR1 = not_contains( B, { GRID, VIA4_R_11_L + GRID }, FORTY_FIVE ); 
          sLAYER_678 = interacting( CENTER_BAR1, H_HOLE, == 2 ); 
          CENTER_BAR2 = interacting( sLAYER_678, VIA4I ); 
          C = CENTER_BAR2 coincident_outside_edge H_HOLE; 
          D = external2_edge( C, A, <= VIA4_R_11_L2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          E = C not_coincident_inside_edge D; 
          CENTER_BAR3 = CENTER_BAR2 not_touching E; 
          CHECK_VIA = VIA4I not_outside CENTER_BAR3; 
          sLAYER_681 = interacting( A0, CHECK_VIA ); 
          sLAYER_682 = interacting( M4I, CHECK_VIA ); 
          sLAYER_680 = sLAYER_681 and sLAYER_682;
          sLAYER_679 = interacting( sLAYER_680, VIA4I, == 1 ); 
          CHECK_VIA and sLAYER_679; 
      } /* end of rule : VIA4.R.11 */
      
      //M5 CHECKS
      //=========
      M51 = M5WIDE_FIRST not CB_NON_CUP; 
      M511 = M5WIDE_0_p_4 not CB_NON_CUP; 
      #ifdef HALF_NODE 
         M512 = M5WIDE_0_p_2 not CB_NON_CUP; 
         M513 = M5WIDE_0_p_4S not CB_NON_CUP; 
      #endif /* end of #ifdef HALF_NODE  */ 
      M52 = M5WIDE_1_p_5 not CB_NON_CUP; 
      M53 = M5WIDE_4_p_5 not CB_NON_CUP; 
      M5AS3 = area( M5, > ( M5_S_3_L * M5_W_1 ) );    /* filter small metal for M5.S.3 */ 
      M5AS4 = area( M5AS3, > ( M5_S_4_L * M5_W_1 ) );    /* filter small metal for M5.S.4 */ 
      M5_EDGE_45 = angle_edge( M5, == 45 ); 
      rM5_W_1 @= { @ "M5.W.1 : Width >= " + M5_W_1 + " um"; 
          internal1( M5, < M5_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : M5.W.1 */
      rM5_W_2 @= { @ "M5.W.2 : Width of 45-degree bent Mx Please make sure the vertex of 45 degree pattern is on 5nm grid >= " + M5_W_2 + " um"; 
          internal1( M5_EDGE_45, < M5_W_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
      } /* end of rule : M5.W.2 */
      rM5_W_3 @= { @ "M5.W.3 : Maximum width <= " + M5_W_3 + " um"; 
          size( size( M5, - ( M5_W_3 / 2 ), clip_acute = BISECTOR ), M5_W_3 / 2, clip_acute = BISECTOR ); 
      } /* end of rule : M5.W.3 */
      rM5_S_1 @= { @ "M5.S.1 : Spacing >= " + M5_S_1 + " um"; 
          external1( M5, < M5_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : M5.S.1 */
      
      //M5.S.2.S is checked by M5.S.2 
      rM5_S_2 @= { @ "M5.S.2 : Space [at least one metal line width > " + M5_S_2_W + " um  and the parallel metal run length > " + M5_S_2_L + " um ] (union projection) >= " + M5_S_2; 
          X = external2( M51, M5, < M5_S_2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M5; 
          contains( Y, { GRID, M5_S_2_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M5.S.2 */
      
      //M5.S.2.1.S is checked by M5.S.2.1
      rM5_S_2_1 @= { @ "M5.S.2.1 : Space [at least one metal line width > " + M5_S_2_1_W + " um  and the parallel metal run length > " + M5_S_2_1_L + " um ] (union projection) >= " + M5_S_2_1; 
          X = external2( M511, M5, < M5_S_2_1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M5; 
          contains( Y, { GRID, M5_S_2_1_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M5.S.2.1 */
      #ifdef HALF_NODE 
         
         //M5.S.2.2.S is checked by M5.S.2.2
         rM5_S_2_2 @= { @ "M5.S.2.2 : Space [at least one metal line width > " + M5_S_2_2_W + " um  and the parallel metal run length > " + M5_S_2_2_L + " um ] (union projection) >= " + M5_S_2_2; 
             X = external2( M512, M5, < M5_S_2_2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
             Y = X not M5; 
             contains( Y, { GRID, M5_S_2_2_L + GRID }, FORTY_FIVE ); 
         } /* end of rule : M5.S.2.2 */
         
         //M5.S.2.3.S is checked by M5.S.2.3
         rM5_S_2_3 @= { @ "M5.S.2.3 : Space [at least one metal line width > " + M5_S_2_3_W + " um  and the parallel metal run length > " + M5_S_2_3_L + " um ] (union projection) >= " + M5_S_2_3; 
             X = external2( M513, M5, < M5_S_2_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
             Y = X not M5; 
             contains( Y, { GRID, M5_S_2_3_L + GRID }, FORTY_FIVE ); 
         } /* end of rule : M5.S.2.3 */
      #endif /* end of #ifdef HALF_NODE  */ 
      
      //M5.S.3.S is checked by M5.S.3
      rM5_S_3 @= { @ "M5.S.3 : Space [at least one metal line width > " + M5_S_3_W + " um  and the parallel metal run length > " + M5_S_3_L + " um ] (union projection) >= " + M5_S_3; 
          X = external2( M52, M5AS3, < M5_S_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M5; 
          contains( Y, { GRID, M5_S_3_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M5.S.3 */
      
      //M5.S.4.S is checked by M5.S.4
      rM5_S_4 @= { @ "M5.S.4 : Space [at least one metal line width > " + M5_S_4_W + " um  and the parallel metal run length > " + M5_S_4_L + " um ] (union projection) >= " + M5_S_4; 
          X = external2( M53, M5AS4, < M5_S_4, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M5; 
          contains( Y, { GRID, M5_S_4_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M5.S.4 */
      rM5_S_5 @= { @ "M5.S.5 : Space at Mx line-end (W<Q=0.120) in a dense-line-end configuration: If Mx has parallel run length with opposite Mx (measured with T=0.035 extension) along 2 adjacent edges of Mx [any one edge <Q distance from the corner of the two edges], then one of the space (S1 or S2) needs to be at least this value (except for small jog with edge length < 0.10 um (R)) >= " + M5_S_5 + " um."; 
          A = adjacent_edge( M5, angle1 = == 90, angle2 = == 90, length = < M5_S_5_Q ); 
          B = external2_edge( A, M5, < M5_S_5, extension = EDGE, extension_distance = M5_S_5_E, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1 ); 
          C = A inside_touching_edge B; 
          D = internal2_edge( C, M5, < M5_S_5_Q, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 90, look_thru = RELATED_COINCIDENT, orientation = { }, output_layer = LAYER2 ); 
          I = length_edge( D, >= M5_W_1 ); 
          sLAYER_1324 = extend_edge( I, start = M5_S_5_E, end = M5_S_5_E ); 
          J = edge_size( sLAYER_1324, inside = 0.001 ); 
          K = edge_size( I, inside = 0.001 ); 
          L = J not K; 
          M = L touching A; 
          N = M or K; 
          O = N touching_edge I; 
          external2( O, M5, < M5_S_5, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
      } /* end of rule : M5.S.5 */
      
      //M5.EN.0 is checked by either {M5.EN.1/M5.EN.2} or M5.EN.3
      rM5_EN_1 @= { @ "M5.EN.1 : Enclosure of VIA4 >= 0 um";
          VIA4 not M5; 
      } /* end of rule : M5.EN.1 */
      
      // M5.EN.2 is checked by M5.EN.2__M5.EN.3
      // M5.EN.3 is checked by M5.EN.2__M5.EN.3
      rM5_EN_2__M5_EN_3 @= { @ "M5.EN.2__M5.EN.3 : Enclosure of VIA4 [at least two opposite sides] >= " + M5_EN_2 + " ,or [all sides] >= " + M5_EN_3; 
          X = not_enclosed_by( VIA4, M5, distances = { { { 0, RADIAL }, { M5_EN_2, NONE }, { 0, RADIAL }, { M5_EN_2, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          enclose( X, M5, < M5_EN_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : M5.EN.2__M5.EN.3 */
      rM5_A_1 @= { @ "M5.A.1 : Area >= " + M5_A_1 + " um2"; 
          area( M5, < M5_A_1 ); 
      } /* end of rule : M5.A.1 */
      rM5_A_2 @= { @ "M5.A.2 : Enclosed area >= " + M5_A_2 + " um"; 
          X = donut_holes( M5, area = < M5_A_2PRE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          sLAYER_683 = X not M5; 
          area( sLAYER_683, < M5_A_2 ); 
      } /* end of rule : M5.A.2 */
      rM5_S_6 @= { @ "M5.S.6 : Space to 45 degree bent M5 >= " + M5_S_6 + " um"; 
          X = edge_size( M5_EDGE_45, outside = M5_S_6 ); 
          X and M5; 
      } /* end of rule : M5.S.6 */
      M5DN1H_EXC = copy( M5_EXC ); 
      M5DN1L_EXC = copy( M5_EXC_LOW ); 
      #ifdef CHECK_LOW_DENSITY 
         rM5_DN_1 @= { @ "M5.DN.1 : M5 local density must be >= " + M5_DN_1L + " range over " + M5_DN_1L_W + " um x " + M5_DN_1L_W + " um step " + M5_DN_1L_S + " um"; 
             M5_CHECK = M5X not M5DN1L_EXC; 
             CHIP_CHECK = gCHIP not M5DN1L_EXC; 
         _den_con = < M5_DN_1L; 
         _den_polygon_area_clip = false;
         _den_print = false;
         _den_print_only = false;
             ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M5_CHECK, "layer2" => CHIP_CHECK }, delta_window = { M5_DN_1L_W, M5_DN_1L_W }, delta_x = M5_DN_1L_S, delta_y = M5_DN_1L_S, boundary = BACKUP, window_function = den_save_window_1 ); 
             sLAYER_684 = ERR_WIN not M5DN1L_EXC; 
             F = wide( sLAYER_684, >= M5_DN_1L_E, forty_five = INTERNAL ); 
             VAR_31 = density_statistics_file( file = "M5.DN.1.density" ); 
         _den_con = < M5_DN_1L; 
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M5_CHECK, "layer3" => CHIP_CHECK }, delta_window = { M5_DN_1L_W, M5_DN_1L_W }, delta_x = M5_DN_1L_S, delta_y = M5_DN_1L_S, boundary = BACKUP, statistics_files = { VAR_31 }, window_function = den_save_window_2 ); 
         } /* end of rule : M5.DN.1 */
      #endif /* end of #ifdef CHECK_LOW_DENSITY  */ 
      rM5_DN_1_1 @= { @ "M5.DN.1.1 : M5 local density must be <= " + M5_DN_1H + " range over " + M5_DN_1H_W + " um x " + M5_DN_1H_W + " um step " + M5_DN_1H_S + " um"; 
          M5_CHECK = M5X not M5DN1H_EXC; 
          CHIP_CHECK = gCHIP not M5DN1H_EXC; 
      _den_con = > M5_DN_1H; 
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M5_CHECK, "layer2" => CHIP_CHECK }, delta_window = { M5_DN_1H_W, M5_DN_1H_W }, delta_x = M5_DN_1H_S, delta_y = M5_DN_1H_S, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_685 = ERR_WIN not M5DN1H_EXC; 
          F = wide( sLAYER_685, >= M5_DN_1H_E, forty_five = INTERNAL ); 
          VAR_32 = density_statistics_file( file = "M5.DN.1.1.density" ); 
      _den_con = > M5_DN_1H; 
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M5_CHECK, "layer3" => CHIP_CHECK }, delta_window = { M5_DN_1H_W, M5_DN_1H_W }, delta_x = M5_DN_1H_S, delta_y = M5_DN_1H_S, boundary = BACKUP, statistics_files = { VAR_32 }, window_function = den_save_window_3 ); 
      } /* end of rule : M5.DN.1.1 */
      M5DN2_EXC = copy( EMPTYI ); 
      rM5_DN_2 @= { @ "M5.DN.2 : M5 local density must be <= " + M5_DN_2 + " range over " + M5_DN_2_W + " um x " + M5_DN_2_W + " um step " + M5_DN_2_S + " um"; 
          M5_CHECK = M5X not M5DN2_EXC; 
      _den_con = > M5_DN_2; 
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M5_CHECK, "layer2" => gCHIP }, delta_window = { M5_DN_2_W, M5_DN_2_W }, delta_x = M5_DN_2_S, delta_y = M5_DN_2_S, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_686 = ERR_WIN not M5DN2_EXC; 
          F = wide( sLAYER_686, >= M5_DN_2_E, forty_five = INTERNAL ); 
          VAR_33 = density_statistics_file( file = "M5.DN.2.density" ); 
      _den_con = > M5_DN_2; 
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M5_CHECK, "layer3" => gCHIP }, delta_window = { M5_DN_2_W, M5_DN_2_W }, delta_x = M5_DN_2_S, delta_y = M5_DN_2_S, boundary = BACKUP, statistics_files = { VAR_33 }, window_function = den_save_window_3 ); 
      } /* end of rule : M5.DN.2 */
      rM5_DN_4 @= { @ "M5.DN.4 : The metal density difference between any two " + M5_DN_4_W + " um x " + M5_DN_4_W + " um neighboring checking windows including DM5EXCL <= " + M5_DN_4; 
          sLAYER_1325 = chip_extent();
          VAR_34 = density_statistics_file( file = "M5.DN.4.density" ); 
      _gden_con = <= 1;
      _gden_gcon = > M5_DN_4; 
      _gden_absolute = true;
      _gden_corner = true;
      _gden_corner_value = -1.0;
      _gden_polygon_area_clip = true;
      _gden_print = true;
      _gden_print_only = false;
          sLAYER_1325 = sLAYER_1325 or gCHIP;
gradient_density( window_layer = sLAYER_1325, layer_hash = { "layer1" => M5X, "layer2" => gCHIP }, delta_window = { M5_DN_4_W, M5_DN_4_W }, delta_x = M5_DN_4_W, delta_y = M5_DN_4_W, boundary = BACKUP, statistics_files = { VAR_34 }, window_function = gden_save_window_7 ); 
      } /* end of rule : M5.DN.4 */
      
      //M5.R.1U is not necessary to check
      
      // Mx.DN.5
      //===========
      M5_CORE = M5X not SRCSR; 
      rM3_DN_5 @= { @ "M3.DN.5 : It is not allowed to have local density > " + MX_DN_5 + " of all 3 consecutive metal (M3,M4,M5) over any " + MX_DN_5_W + " um x " + MX_DN_5_W + " um window (stepping " + MX_DN_5_S + " um)"; 
          sLAYER_1326 = chip_extent();
          VAR_35 = density_statistics_file( file = "M3.DN.5.density" ); 
      _den_con = > 0;
      _den_polygon_area_clip = true;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( window_layer = sLAYER_1326, layer_hash = { "layer1" => M3_CORE, "layer2" => M4_CORE, "layer3" => M5_CORE }, delta_window = { MX_DN_5_W, MX_DN_5_W }, delta_x = MX_DN_5_S, delta_y = MX_DN_5_S, boundary = BACKUP, statistics_files = { VAR_35 }, window_function = den_save_window_8 ); 
      } /* end of rule : M3.DN.5 */
      
      //Mx.DN.6 is checked by M3.DN.6    
      rM3_DN_6 @= { @ "M3.DN.6 : It is not allowed to have local density < " + M3_DN_6 + " of all 3 consecutive metal (M3,M4,M5) under ((CBM SIZING 25) SIZING -25) whose size is >= 200um X 200um"; 
          A = net_area_ratio( CONNECT_DB, < M3_DN_6, { "layer1" => M3DN6_CHECK_CBM, "layer2" => M3DN6_M3_CHECK }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
          B = net_area_ratio( CONNECT_DB, < M3_DN_6, { "layer1" => M3DN6_CHECK_CBM, "layer2" => M3DN6_M4_CHECK }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
          C = net_area_ratio( CONNECT_DB, < M3_DN_6, { "layer1" => M3DN6_CHECK_CBM, "layer2" => M3DN6_M5_CHECK }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
          sLAYER_687 = A and B; 
          sLAYER_687 and C; 
      } /* end of rule : M3.DN.6 */
      
      //VIA5 CHECKS
      //===========
      gLAYER_294 = size( size( M6, - ( M6_S_2_W / 2 ), clip_acute = BISECTOR ), M6_S_2_W / 2, clip_acute = BISECTOR ); 
      M6WIDE_FIRST = gLAYER_294 and M6; 
      gLAYER_295 = size( size( M6WIDE_FIRST, - ( M6_S_2_1_W / 2 ), clip_acute = BISECTOR ), M6_S_2_1_W / 2, clip_acute = BISECTOR ); 
      M6WIDE_0_p_4 = gLAYER_295 and M6WIDE_FIRST; 
      #ifdef HALF_NODE 
         gLAYER_296 = size( size( M6, - ( M6_S_2_2_W / 2 ), clip_acute = BISECTOR ), M6_S_2_2_W / 2, clip_acute = BISECTOR ); 
         M6WIDE_0_p_2 = gLAYER_296 and M6; 
         gLAYER_297 = size( size( M6WIDE_FIRST, - ( M6_S_2_3_W / 2 ), clip_acute = BISECTOR ), M6_S_2_3_W / 2, clip_acute = BISECTOR ); 
         M6WIDE_0_p_4S = gLAYER_297 and M6WIDE_FIRST; 
      #endif /* end of #ifdef HALF_NODE  */ 
      gLAYER_298 = size( size( M6WIDE_FIRST, - ( M6_S_3_W / 2 ), clip_acute = BISECTOR ), M6_S_3_W / 2, clip_acute = BISECTOR ); 
      M6WIDE_1_p_5 = gLAYER_298 and M6WIDE_FIRST; 
      gLAYER_299 = size( size( M6WIDE_1_p_5, - ( M6_S_4_W / 2 ), clip_acute = BISECTOR ), M6_S_4_W / 2, clip_acute = BISECTOR ); 
      M6WIDE_4_p_5 = gLAYER_299 and M6WIDE_1_p_5; 
      gLAYER_300 = size( size( M5WIDE_FIRST, - ( VIA5_R_2_W / 2 ), clip_acute = BISECTOR ), VIA5_R_2_W / 2, clip_acute = BISECTOR ); 
      M5WIDE_0_p_42_VIA5 = gLAYER_300 and M5WIDE_FIRST; 
      gLAYER_301 = size( size( M5WIDE_0_p_42_VIA5, - ( VIA5_R_4_W / 2 ), clip_acute = BISECTOR ), VIA5_R_4_W / 2, clip_acute = BISECTOR ); 
      M5WIDE_0_p_7_VIA5 = gLAYER_301 and M5WIDE_0_p_42_VIA5; 
      gLAYER_302 = size( size( M5WIDE_0_p_7_VIA5, - ( VIA5_R_3_W / 2 ), clip_acute = BISECTOR ), VIA5_R_3_W / 2, clip_acute = BISECTOR ); 
      M5WIDE_0_p_98_VIA5 = gLAYER_302 and M5WIDE_0_p_7_VIA5; 
      gLAYER_303 = size( size( M5WIDE_0_p_98_VIA5, - ( VIA5_R_5_W / 2 ), clip_acute = BISECTOR ), VIA5_R_5_W / 2, clip_acute = BISECTOR ); 
      M5WIDE_2_VIA5 = gLAYER_303 and M5WIDE_0_p_98_VIA5; 
      gLAYER_304 = size( size( M5WIDE_2_VIA5, - ( VIA5_R_6_W / 2 ), clip_acute = BISECTOR ), VIA5_R_6_W / 2, clip_acute = BISECTOR ); 
      M5WIDE_3_VIA5 = gLAYER_304 and M5WIDE_2_VIA5; 
      gLAYER_305 = size( size( M6WIDE_FIRST, - ( VIA5_R_2_W / 2 ), clip_acute = BISECTOR ), VIA5_R_2_W / 2, clip_acute = BISECTOR ); 
      M6WIDE_0_p_42_VIA5 = gLAYER_305 and M6WIDE_FIRST; 
      gLAYER_306 = size( size( M6WIDE_0_p_42_VIA5, - ( VIA5_R_4_W / 2 ), clip_acute = BISECTOR ), VIA5_R_4_W / 2, clip_acute = BISECTOR ); 
      M6WIDE_0_p_7_VIA5 = gLAYER_306 and M6WIDE_0_p_42_VIA5; 
      gLAYER_307 = size( size( M6WIDE_0_p_7_VIA5, - ( VIA5_R_3_W / 2 ), clip_acute = BISECTOR ), VIA5_R_3_W / 2, clip_acute = BISECTOR ); 
      M6WIDE_0_p_98_VIA5 = gLAYER_307 and M6WIDE_0_p_7_VIA5; 
      gLAYER_308 = size( size( M6WIDE_0_p_98_VIA5, - ( VIA5_R_5_W / 2 ), clip_acute = BISECTOR ), VIA5_R_5_W / 2, clip_acute = BISECTOR ); 
      M6WIDE_2_VIA5 = gLAYER_308 and M6WIDE_0_p_98_VIA5; 
      gLAYER_309 = size( size( M6WIDE_2_VIA5, - ( VIA5_R_6_W / 2 ), clip_acute = BISECTOR ), VIA5_R_6_W / 2, clip_acute = BISECTOR ); 
      M6WIDE_3_VIA5 = gLAYER_309 and M6WIDE_2_VIA5; 
      rVIA5_W_1 @= { @ "VIA5.W.1 : Width (maximum = minimum except for seal-ring and fuse protection ring) = " + VIA5_W_1 + " um " 
                                  "VIA5.R.1 45-degree rotated VIA is not allowed";
          A = not_rectangles( VIA5, orientation = ORTHOGONAL, sides = { == VIA5_W_1, == VIA5_W_1 } ); 
          A not VIA_EXD; 
      } /* end of rule : VIA5.W.1 */
      
      // CSR.W.3 is checked by VIA5.W.2
      rVIA5_W_2 @= { @ "VIA5.W.2 : VIA5 bar width = " + VIA5_W_2 + " (VIA5 bar is covered by SEALRING layer and only allowed in seal-ring and fuse protecion ring)"; 
          internal1( VIA5_BAR, < VIA5_W_2, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          A = wide( VIA5_BAR, > VIA5_W_2, forty_five = INTERNAL ); 
          B = angle_edge( VIA5_BAR, == 45 ); 
          C = internal1( B, < ( VIA5_W_2 + 2 * GRID ), extension = RADIAL, intersecting = {  } ); 
          D = A not C; 
          contains( D, { 1, 0.005 }, FORTY_FIVE ); 
      } /* end of rule : VIA5.W.2 */
      rVIA5_S_1 @= { @ "VIA5.S.1 : Spacing >= " + VIA5_S_1 + " um"; 
          external1( VIA5, < VIA5_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : VIA5.S.1 */
      rVIA5_S_2 @= { @ "VIA5.S.2 : Space to 3-neighboring VIAx (< 0.14 um distance) >= " + VIA5_S_2 + " um"; 
          X = rectangle_spacing1( VIA5, count = > 2, distance = < VIA5_S_2_S ); 
          external2( X, VIA5, < VIA5_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : VIA5.S.2 */
      rVIA5_S_3 @= { @ "VIA5.S.3 : Space to neighboring VIAx [different net and common parallel run length > 0] >= " + VIA5_S_3 + " um"; 
          VIA5_NODAL = stamp( VIA5, VIA5I, CONNECT_DB, CONNECT_DB_VIA5_S_3, include_touch = NONE ); 
          external1( VIA5_NODAL, < VIA5_S_3, connect_sequence = CONNECT_DB_VIA5_S_3, connectivity = DIFFERENT_NET, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
      } /* end of rule : VIA5.S.3 */
      
      //VIA5.EN.0 is checked by either {VIA5.EN.1/VIA5.EN.2} or VIA5.EN.3
      rVIA5_EN_1 @= { @ "VIA5.EN.1 : Enclosure by M5 >= 0 um";
          VIA5 not M5; 
      } /* end of rule : VIA5.EN.1 */
      
      // VIA5.EN.2 is checked by VIA5.EN.2__VIA5.EN.3
      // VIA5.EN.3 is checked by VIA5.EN.2__VIA5.EN.3
      rVIA5_EN_2__VIA5_EN_3 @= { @ "VIA5.EN.2__VIA5.EN.3 : Enclosure by M5 [at least two opposite sides] >= " + VIA5_EN_2 + " , or [all sides] >= " + VIA5_EN_3; 
          X = not_enclosed_by( VIA5, M5, distances = { { { 0, RADIAL }, { VIA5_EN_2, NONE }, { 0, RADIAL }, { VIA5_EN_2, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          enclose( X, M5, < VIA5_EN_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : VIA5.EN.2__VIA5.EN.3 */
      
      // VIA5.R.1 is checked by VIA5.W.1
      // VIA5.R.2 is checked by VIA5.R.2__VIA5.R.3
      // VIA5.R.2.S is checked by VIA5.R.2__VIA5.R.3
      // VIA5.R.3 is checked by VIA5.R.2__VIA5.R.3
      
      // VIA5.R.3.S is checked by VIA5.R.2__VIA5.R.3
      rVIA5_R_2__VIA5_R_3 @= { @ "VIA5.R.2__VIA5.R.3 : When M5 or M6 width > " + VIA5_R_2_W + " um, more than one VIA5 is required. " 
                                                      "2 vias spacing should be <= " + VIA5_R_2_S1 + " um or 4 vias spacing should be <= " + VIA5_R_2_S2 + " um " 
                                                      "When M5 or M6 width > " + VIA5_R_3_W + " um, more than three VIA5 is required. " 
                                                      "4 vias spacing should be <= " + VIA5_R_3_S1 + " um or 9 vias spacing should be <= " + VIA5_R_3_S2 + " um"; 
          sLAYER_688 = M5WIDE_0_p_42_VIA5 and M6; 
          sLAYER_689 = M6WIDE_0_p_42_VIA5 and M5; 
          M6OVPM5_W_ = sLAYER_688 or sLAYER_689; 
          sLAYER_690 = M5WIDE_0_p_98_VIA5 and M6; 
          sLAYER_691 = M6WIDE_0_p_98_VIA5 and M5; 
          M6OVPM5_B = sLAYER_690 or sLAYER_691; 
          M6OVPM5_W = M6OVPM5_W_ not M6OVPM5_B; 
          CHECKED_VIA5_W_ = VIA5_EXD not_outside M6OVPM5_W; 
          CHECKED_VIA5_B = VIA5_EXD not_outside M6OVPM5_B; 
          CHECKED_VIA5_W = CHECKED_VIA5_W_ not CHECKED_VIA5_B; 
          M5_EFFECT = interacting( M5I, M6OVPM5_W_ ); 
          M6_EFFECT = interacting( M6I, M6OVPM5_W_ ); 
          EFFECT_M6OVPM5_ = M5_EFFECT and M6_EFFECT; 
          EFFECT_M6OVPM5 = interacting( EFFECT_M6OVPM5_, M6OVPM5_W_ ); 
          EFFECT_VIA = interacting( VIA5_EXD, EFFECT_M6OVPM5 ); 
          V5MERGED_A = size_inside_wrapper( EFFECT_VIA, EFFECT_M6OVPM5, distance = VIA5_R_2_S1 / 2, increment = M5_S_1 * 0.7 ); 
          V5MERGED_B = size_inside_wrapper( V5MERGED_A, EFFECT_M6OVPM5, distance = VIA5_R_2_S2_S1, increment = M5_S_1 * 0.7 ); 
          V5MERGED_C = size_inside_wrapper( V5MERGED_B, EFFECT_M6OVPM5, distance = ( VIA5_R_3_S2 - VIA5_R_2_S2 ) / 2, increment = M5_S_1 * 0.7 ); 
          V5MERGED_A2R = interacting( V5MERGED_A, EFFECT_VIA, < 2 ); 
          V5MERGED_A2 = V5MERGED_A outside V5MERGED_A2R; 
          V5MERGED_A4R = interacting( V5MERGED_A2, EFFECT_VIA, < 4 ); 
          V5MERGED_A4 = V5MERGED_A2 outside V5MERGED_A4R; 
          V5MERGED_B4R = interacting( V5MERGED_B, EFFECT_VIA, < 4 ); 
          V5MERGED_B4 = V5MERGED_B outside V5MERGED_B4R; 
          V5MERGED_C9R = interacting( V5MERGED_C, EFFECT_VIA, < 9 ); 
          V5MERGED_C9 = V5MERGED_C outside V5MERGED_C9R; 
          GMERGEW = V5MERGED_A2 or V5MERGED_B4; 
          GMERGEB = V5MERGED_A4 or V5MERGED_C9; 
          GVIA_W = interacting( CHECKED_VIA5_W, GMERGEW ); 
          GVIA_B = interacting( CHECKED_VIA5_B, GMERGEB ); 
          GOOD_AREA_W = interacting( M6OVPM5_W, GVIA_W ); 
          GOOD_AREA_B = interacting( M6OVPM5_B, GVIA_B ); 
          CHECKED_VIA5_W outside GOOD_AREA_W; 
          CHECKED_VIA5_B outside GOOD_AREA_B; 
      } /* end of rule : VIA5.R.2__VIA5.R.3 */
      
      //VIA5.R.4 is checked by VIA5.R.4:M5 and VIA5.R.4:M6
      //VIA5.R.4.S is checked by VIA5.R.4:M5 and VIA5.R.4:M6
      rVIA5_R_4_M5 @= { @ "VIA5.R.4:M5 : At least two VIAx must be used for a connection that is <= " + VIA5_R_4_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA5_R_4_W + " um (L) and width > " + VIA5_R_4_W + " um (W). (It is allowed to use one VIAx for a connection that is > " + VIA5_R_4_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA5_R_4_W + " um (L) and width > " + VIA5_R_4_W + " um (W).)"; 
          sLAYER_693 = size( M5WIDE_0_p_7_VIA5, clip_acute = NONE, distance = VIA5_R_4_D + GRID ); 
          sLAYER_692 = sLAYER_693 not M5WIDE_0_p_7_VIA5; 
          BRANCH1 = sLAYER_692 and M5; 
          sLAYER_694 = interacting( BRANCH1, M5WIDE_0_p_7_VIA5 ); 
          BRANCH1HASVIA = interacting( sLAYER_694, VIA5 ); 
          BRANCH1EDGE = M5WIDE_0_p_7_VIA5 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA5_R_4_D, increment = M5_S_1 * 0.5 ); 
          sLAYER_695 = BRANCH and M6; 
          GOODBRANCH = interacting( sLAYER_695, VIA5, > 1 ); 
          sLAYER_696 = VIA5 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_696 outside GOODBRANCH; 
          sLAYER_699 = interacting( M6, BRANCHSINGLEVIA ); 
          sLAYER_698 = sLAYER_699 and M5; 
          sLAYER_697 = interacting( sLAYER_698, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_697, VIA5, == 1 ); 
          sLAYER_700 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_700 not VIA_EXD; 
      } /* end of rule : VIA5.R.4:M5 */
      rVIA5_R_4_M6 @= { @ "VIA5.R.4:M6 : At least two VIAx must be used for a connection that is <= " + VIA5_R_4_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA5_R_4_W + " um (L) and width > " + VIA5_R_4_W + " um (W). (It is allowed to use one VIAx for a connection that is > " + VIA5_R_4_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA5_R_4_W + " um (L) and width > " + VIA5_R_4_W + " um (W).)"; 
          sLAYER_702 = size( M6WIDE_0_p_7_VIA5, clip_acute = NONE, distance = VIA5_R_4_D + GRID ); 
          sLAYER_701 = sLAYER_702 not M6WIDE_0_p_7_VIA5; 
          BRANCH1 = sLAYER_701 and M6; 
          sLAYER_703 = interacting( BRANCH1, M6WIDE_0_p_7_VIA5 ); 
          BRANCH1HASVIA = interacting( sLAYER_703, VIA5 ); 
          BRANCH1EDGE = M6WIDE_0_p_7_VIA5 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA5_R_4_D, increment = M6_S_1 * 0.5 ); 
          sLAYER_704 = BRANCH and M5; 
          GOODBRANCH = interacting( sLAYER_704, VIA5, > 1 ); 
          sLAYER_705 = VIA5 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_705 outside GOODBRANCH; 
          sLAYER_708 = interacting( M5, BRANCHSINGLEVIA ); 
          sLAYER_707 = sLAYER_708 and M6; 
          sLAYER_706 = interacting( sLAYER_707, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_706, VIA5, == 1 ); 
          sLAYER_709 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_709 not VIA_EXD; 
      } /* end of rule : VIA5.R.4:M6 */
      
      //VIA5.R.5 is checked by VIA5.R.5:M5 and VIA5.R.5:M6
      
      //VIA5.R.5.S is checked by VIA5.R.5:M5 and VIA5.R.5:M6
      rVIA5_R_5_M5 @= { @ "VIA5.R.5:M5 : At least two VIAx must be used for a connection that is <= " + VIA5_R_5_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA5_R_5_W + " um (L) and width > " + VIA5_R_5_W + " um (W). It is allowed to use one VIAx for a connection that is > " + VIA5_R_5_D + " um (D) away from a metal plate (either Mx or Mx+1) with length> " + VIA5_R_5_W + " um (L) and width > " + VIA5_R_5_W + " um (W)."; 
          sLAYER_711 = size( M5WIDE_2_VIA5, clip_acute = NONE, distance = VIA5_R_5_D + GRID ); 
          sLAYER_710 = sLAYER_711 not M5WIDE_2_VIA5; 
          BRANCH1 = sLAYER_710 and M5; 
          sLAYER_712 = interacting( BRANCH1, M5WIDE_2_VIA5 ); 
          BRANCH1HASVIA = interacting( sLAYER_712, VIA5 ); 
          BRANCH1EDGE = M5WIDE_2_VIA5 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA5_R_5_D, increment = M5_S_1 * 0.7 ); 
          sLAYER_713 = BRANCH and M6; 
          GOODBRANCH = interacting( sLAYER_713, VIA5, > 1 ); 
          sLAYER_714 = VIA5 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_714 outside GOODBRANCH; 
          sLAYER_717 = interacting( M6, BRANCHSINGLEVIA ); 
          sLAYER_716 = sLAYER_717 and M5; 
          sLAYER_715 = interacting( sLAYER_716, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_715, VIA5, == 1 ); 
          sLAYER_718 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_718 not VIA_EXD; 
      } /* end of rule : VIA5.R.5:M5 */
      rVIA5_R_5_M6 @= { @ "VIA5.R.5:M6 : At least two VIAx must be used for a connection that is <= " + VIA5_R_5_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA5_R_5_W + " um (L) and width > " + VIA5_R_5_W + " um (W). It is allowed to use one VIAx for a connection that is > " + VIA5_R_5_D + " um (D) away from a metal plate (either Mx or Mx+1) with length> " + VIA5_R_5_W + " um (L) and width > " + VIA5_R_5_W + " um (W)."; 
          sLAYER_720 = size( M6WIDE_2_VIA5, clip_acute = NONE, distance = VIA5_R_5_D + GRID ); 
          sLAYER_719 = sLAYER_720 not M6WIDE_2_VIA5; 
          BRANCH1 = sLAYER_719 and M6; 
          sLAYER_721 = interacting( BRANCH1, M6WIDE_2_VIA5 ); 
          BRANCH1HASVIA = interacting( sLAYER_721, VIA5 ); 
          BRANCH1EDGE = M6WIDE_2_VIA5 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA5_R_5_D, increment = M6_S_1 * 0.7 ); 
          sLAYER_722 = BRANCH and M5; 
          GOODBRANCH = interacting( sLAYER_722, VIA5, > 1 ); 
          sLAYER_723 = VIA5 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_723 outside GOODBRANCH; 
          sLAYER_726 = interacting( M5, BRANCHSINGLEVIA ); 
          sLAYER_725 = sLAYER_726 and M6; 
          sLAYER_724 = interacting( sLAYER_725, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_724, VIA5, == 1 ); 
          sLAYER_727 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_727 not VIA_EXD; 
      } /* end of rule : VIA5.R.5:M6 */
      M5BIG_3_VIA5 = contains( M5WIDE_3_VIA5, { VIA5_R_6_W, VIA5_R_6_L + GRID }, FORTY_FIVE ); 
      
      //VIA5.R.6 is checked by VIA5.R.6:M5 and VIA5.R.6:M6
      //VIA5.R.6.S is checked by VIA5.R.6:M5 and VIA5.R.6:M6
      rVIA5_R_6_M5 @= { @ "VIA5.R.6:M5 : At least two VIAx must be used for a connection that is <= " + VIA5_R_6_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA5_R_6_L + " um (L) and width > " + VIA5_R_6_W + " um (W). (It is allowed to use one VIAx for a connection that is > " + VIA5_R_6_D + " um (D) away from a metal plate (either Mx or Mx+1) with length> " + VIA5_R_6_L + " um (L) and width > " + VIA5_R_6_W + " um (W))."; 
          sLAYER_729 = size( M5BIG_3_VIA5, clip_acute = NONE, distance = VIA5_R_6_D + GRID ); 
          sLAYER_728 = sLAYER_729 not M5BIG_3_VIA5; 
          BRANCH1 = sLAYER_728 and M5; 
          sLAYER_730 = interacting( BRANCH1, M5BIG_3_VIA5 ); 
          BRANCH1HASVIA = interacting( sLAYER_730, VIA5 ); 
          BRANCH1EDGE = M5BIG_3_VIA5 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA5_R_6_D, increment = M5_S_1 * 0.7 ); 
          sLAYER_731 = BRANCH and M6; 
          GOODBRANCH = interacting( sLAYER_731, VIA5, > 1 ); 
          sLAYER_732 = VIA5 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_732 outside GOODBRANCH; 
          sLAYER_735 = interacting( M6, BRANCHSINGLEVIA ); 
          sLAYER_734 = sLAYER_735 and M5; 
          sLAYER_733 = interacting( sLAYER_734, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_733, VIA5, == 1 ); 
          sLAYER_736 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_736 not VIA_EXD; 
      } /* end of rule : VIA5.R.6:M5 */
      M6BIG_3_VIA5 = contains( M6WIDE_3_VIA5, { VIA5_R_6_W, VIA5_R_6_L + GRID }, FORTY_FIVE ); 
      rVIA5_R_6_M6 @= { @ "VIA5.R.6:M6 : At least two VIAx must be used for a connection that is <= " + VIA5_R_6_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA5_R_6_L + " um (L) and width > " + VIA5_R_6_W + " um (W). (It is allowed to use one VIAx for a connection that is > " + VIA5_R_6_D + " um (D) away from a metal plate (either Mx or Mx+1) with length> " + VIA5_R_6_L + " um (L) and width > " + VIA5_R_6_W + " um (W))."; 
          sLAYER_738 = size( M6BIG_3_VIA5, clip_acute = NONE, distance = VIA5_R_6_D + GRID ); 
          sLAYER_737 = sLAYER_738 not M6BIG_3_VIA5; 
          BRANCH1 = sLAYER_737 and M6; 
          sLAYER_739 = interacting( BRANCH1, M6BIG_3_VIA5 ); 
          BRANCH1HASVIA = interacting( sLAYER_739, VIA5 ); 
          BRANCH1EDGE = M6BIG_3_VIA5 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA5_R_6_D, increment = M6_S_1 * 0.7 ); 
          sLAYER_740 = BRANCH and M5; 
          GOODBRANCH = interacting( sLAYER_740, VIA5, > 1 ); 
          sLAYER_741 = VIA5 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_741 outside GOODBRANCH; 
          sLAYER_744 = interacting( M5, BRANCHSINGLEVIA ); 
          sLAYER_743 = sLAYER_744 and M6; 
          sLAYER_742 = interacting( sLAYER_743, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_742, VIA5, == 1 ); 
          sLAYER_745 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_745 not VIA_EXD; 
      } /* end of rule : VIA5.R.6:M6 */
      
      // VIA5.R.7 is checked by VIA5.EN.1 and M6.EN.1
      rVIA5_R_11 @= { @ "VIA5.R.11 : Single VIAx is not allowed for H-shape  Mx+1 when all of the following conditions come into existence: "
                                    "1. The Mx+1 has H-shape interact with two metal holes : both two metal hole area <= " + VIA5_R_11_A + " um2 and two metal hole length(L2) <= " + VIA5_R_11_L2 + " um " 
                                    "2. The VIAx overlaps on the center metal bar of this H-shape Mx+1 "
                                    "3. The length (L) of the center metal bar <= " + VIA5_R_11_L + " um and the width of metal bar is <= " + VIA5_R_11_W + " um."; 
          W = not( M6I, wide( M6I, > VIA5_R_11_W, forty_five = INTERNAL ) ); 
          sLAYER_746 = donut_holes( M6I, area = <= VIA5_R_11_A, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          H_HOLE = interacting( sLAYER_746, W ); 
          A0 = interacting( M6I, H_HOLE ); 
          A = A0 coincident_outside_edge H_HOLE; 
          sLAYER_748 = internal1( A, <= VIA5_R_11_W, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_747 = sLAYER_748 inside A0; 
          B0 = interacting( sLAYER_747, H_HOLE, == 2 ); 
          sLAYER_751 = internal1( A, <= VIA5_R_11_L, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_750 = sLAYER_751 inside A0; 
          sLAYER_749 = sLAYER_750 and W; 
          B1 = interacting( sLAYER_749, H_HOLE, == 2 ); 
          HOLE_NOTCH = external1( H_HOLE, <= VIA5_R_11_W, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_752 = B1 not HOLE_NOTCH; 
          B2 = sLAYER_752 or B0; 
          sLAYER_754 = external1( B2, <= VIA5_R_11_W, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { }, output_type = EXTENTS ); 
          sLAYER_753 = outside_touching( sLAYER_754, B2, == 2 ); 
          CORNER_M = sLAYER_753 and W; 
          B = B2 or CORNER_M; 
          CENTER_BAR1 = not_contains( B, { GRID, VIA5_R_11_L + GRID }, FORTY_FIVE ); 
          sLAYER_755 = interacting( CENTER_BAR1, H_HOLE, == 2 ); 
          CENTER_BAR2 = interacting( sLAYER_755, VIA5I ); 
          C = CENTER_BAR2 coincident_outside_edge H_HOLE; 
          D = external2_edge( C, A, <= VIA5_R_11_L2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          E = C not_coincident_inside_edge D; 
          CENTER_BAR3 = CENTER_BAR2 not_touching E; 
          CHECK_VIA = VIA5I not_outside CENTER_BAR3; 
          sLAYER_758 = interacting( A0, CHECK_VIA ); 
          sLAYER_759 = interacting( M5I, CHECK_VIA ); 
          sLAYER_757 = sLAYER_758 and sLAYER_759;
          sLAYER_756 = interacting( sLAYER_757, VIA5I, == 1 ); 
          CHECK_VIA and sLAYER_756; 
      } /* end of rule : VIA5.R.11 */
      
      //M6 CHECKS
      //=========
      M61 = M6WIDE_FIRST not CB_NON_CUP; 
      M611 = M6WIDE_0_p_4 not CB_NON_CUP; 
      #ifdef HALF_NODE 
         M612 = M6WIDE_0_p_2 not CB_NON_CUP; 
         M613 = M6WIDE_0_p_4S not CB_NON_CUP; 
      #endif /* end of #ifdef HALF_NODE  */ 
      M62 = M6WIDE_1_p_5 not CB_NON_CUP; 
      M63 = M6WIDE_4_p_5 not CB_NON_CUP; 
      M6AS3 = area( M6, > ( M6_S_3_L * M6_W_1 ) );    /* filter small metal for M6.S.3 */ 
      M6AS4 = area( M6AS3, > ( M6_S_4_L * M6_W_1 ) );    /* filter small metal for M6.S.4 */ 
      M6_EDGE_45 = angle_edge( M6, == 45 ); 
      rM6_W_1 @= { @ "M6.W.1 : Width >= " + M6_W_1 + " um"; 
          internal1( M6, < M6_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : M6.W.1 */
      rM6_W_2 @= { @ "M6.W.2 : Width of 45-degree bent Mx Please make sure the vertex of 45 degree pattern is on 5nm grid >= " + M6_W_2 + " um"; 
          internal1( M6_EDGE_45, < M6_W_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
      } /* end of rule : M6.W.2 */
      rM6_W_3 @= { @ "M6.W.3 : Maximum width <= " + M6_W_3 + " um"; 
          size( size( M6, - ( M6_W_3 / 2 ), clip_acute = BISECTOR ), M6_W_3 / 2, clip_acute = BISECTOR ); 
      } /* end of rule : M6.W.3 */
      rM6_S_1 @= { @ "M6.S.1 : Spacing >= " + M6_S_1 + " um"; 
          external1( M6, < M6_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : M6.S.1 */
      
      //M6.S.2.S is checked by M6.S.2 
      rM6_S_2 @= { @ "M6.S.2 : Space [at least one metal line width > " + M6_S_2_W + " um  and the parallel metal run length > " + M6_S_2_L + " um ] (union projection) >= " + M6_S_2; 
          X = external2( M61, M6, < M6_S_2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M6; 
          contains( Y, { GRID, M6_S_2_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M6.S.2 */
      
      //M6.S.2.1.S is checked by M6.S.2.1
      rM6_S_2_1 @= { @ "M6.S.2.1 : Space [at least one metal line width > " + M6_S_2_1_W + " um  and the parallel metal run length > " + M6_S_2_1_L + " um ] (union projection) >= " + M6_S_2_1; 
          X = external2( M611, M6, < M6_S_2_1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M6; 
          contains( Y, { GRID, M6_S_2_1_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M6.S.2.1 */
      #ifdef HALF_NODE 
         
         //M6.S.2.2.S is checked by M6.S.2.2
         rM6_S_2_2 @= { @ "M6.S.2.2 : Space [at least one metal line width > " + M6_S_2_2_W + " um  and the parallel metal run length > " + M6_S_2_2_L + " um ] (union projection) >= " + M6_S_2_2; 
             X = external2( M612, M6, < M6_S_2_2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
             Y = X not M6; 
             contains( Y, { GRID, M6_S_2_2_L + GRID }, FORTY_FIVE ); 
         } /* end of rule : M6.S.2.2 */
         
         //M6.S.2.3.S is checked by M6.S.2.3
         rM6_S_2_3 @= { @ "M6.S.2.3 : Space [at least one metal line width > " + M6_S_2_3_W + " um  and the parallel metal run length > " + M6_S_2_3_L + " um ] (union projection) >= " + M6_S_2_3; 
             X = external2( M613, M6, < M6_S_2_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
             Y = X not M6; 
             contains( Y, { GRID, M6_S_2_3_L + GRID }, FORTY_FIVE ); 
         } /* end of rule : M6.S.2.3 */
      #endif /* end of #ifdef HALF_NODE  */ 
      
      //M6.S.3.S is checked by M6.S.3
      rM6_S_3 @= { @ "M6.S.3 : Space [at least one metal line width > " + M6_S_3_W + " um  and the parallel metal run length > " + M6_S_3_L + " um ] (union projection) >= " + M6_S_3; 
          X = external2( M62, M6AS3, < M6_S_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M6; 
          contains( Y, { GRID, M6_S_3_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M6.S.3 */
      
      //M6.S.4.S is checked by M6.S.4
      rM6_S_4 @= { @ "M6.S.4 : Space [at least one metal line width > " + M6_S_4_W + " um  and the parallel metal run length > " + M6_S_4_L + " um ] (union projection) >= " + M6_S_4; 
          X = external2( M63, M6AS4, < M6_S_4, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M6; 
          contains( Y, { GRID, M6_S_4_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M6.S.4 */
      rM6_S_5 @= { @ "M6.S.5 : Space at Mx line-end (W<Q=0.120) in a dense-line-end configuration: If Mx has parallel run length with opposite Mx (measured with T=0.035 extension) along 2 adjacent edges of Mx [any one edge <Q distance from the corner of the two edges], then one of the space (S1 or S2) needs to be at least this value (except for small jog with edge length < 0.10 um (R)) >= " + M6_S_5 + " um."; 
          A = adjacent_edge( M6, angle1 = == 90, angle2 = == 90, length = < M6_S_5_Q ); 
          B = external2_edge( A, M6, < M6_S_5, extension = EDGE, extension_distance = M6_S_5_E, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1 ); 
          C = A inside_touching_edge B; 
          D = internal2_edge( C, M6, < M6_S_5_Q, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 90, look_thru = RELATED_COINCIDENT, orientation = { }, output_layer = LAYER2 ); 
          I = length_edge( D, >= M6_W_1 ); 
          sLAYER_1327 = extend_edge( I, start = M6_S_5_E, end = M6_S_5_E ); 
          J = edge_size( sLAYER_1327, inside = 0.001 ); 
          K = edge_size( I, inside = 0.001 ); 
          L = J not K; 
          M = L touching A; 
          N = M or K; 
          O = N touching_edge I; 
          external2( O, M6, < M6_S_5, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
      } /* end of rule : M6.S.5 */
      
      //M6.EN.0 is checked by either {M6.EN.1/M6.EN.2} or M6.EN.3
      rM6_EN_1 @= { @ "M6.EN.1 : Enclosure of VIA5 >= 0 um";
          VIA5 not M6; 
      } /* end of rule : M6.EN.1 */
      
      // M6.EN.2 is checked by M6.EN.2__M6.EN.3
      // M6.EN.3 is checked by M6.EN.2__M6.EN.3
      rM6_EN_2__M6_EN_3 @= { @ "M6.EN.2__M6.EN.3 : Enclosure of VIA5 [at least two opposite sides] >= " + M6_EN_2 + " ,or [all sides] >= " + M6_EN_3; 
          X = not_enclosed_by( VIA5, M6, distances = { { { 0, RADIAL }, { M6_EN_2, NONE }, { 0, RADIAL }, { M6_EN_2, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          enclose( X, M6, < M6_EN_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : M6.EN.2__M6.EN.3 */
      rM6_A_1 @= { @ "M6.A.1 : Area >= " + M6_A_1 + " um2"; 
          area( M6, < M6_A_1 ); 
      } /* end of rule : M6.A.1 */
      rM6_A_2 @= { @ "M6.A.2 : Enclosed area >= " + M6_A_2 + " um"; 
          X = donut_holes( M6, area = < M6_A_2PRE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          sLAYER_760 = X not M6; 
          area( sLAYER_760, < M6_A_2 ); 
      } /* end of rule : M6.A.2 */
      rM6_S_6 @= { @ "M6.S.6 : Space to 45 degree bent M6 >= " + M6_S_6 + " um"; 
          X = edge_size( M6_EDGE_45, outside = M6_S_6 ); 
          X and M6; 
      } /* end of rule : M6.S.6 */
      M6DN1H_EXC = copy( M6_EXC ); 
      M6DN1L_EXC = copy( M6_EXC_LOW ); 
      #ifdef CHECK_LOW_DENSITY 
         rM6_DN_1 @= { @ "M6.DN.1 : M6 local density must be >= " + M6_DN_1L + " range over " + M6_DN_1L_W + " um x " + M6_DN_1L_W + " um step " + M6_DN_1L_S + " um"; 
             M6_CHECK = M6X not M6DN1L_EXC; 
             CHIP_CHECK = gCHIP not M6DN1L_EXC; 
         _den_con = < M6_DN_1L; 
         _den_polygon_area_clip = false;
         _den_print = false;
         _den_print_only = false;
             ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M6_CHECK, "layer2" => CHIP_CHECK }, delta_window = { M6_DN_1L_W, M6_DN_1L_W }, delta_x = M6_DN_1L_S, delta_y = M6_DN_1L_S, boundary = BACKUP, window_function = den_save_window_1 ); 
             sLAYER_761 = ERR_WIN not M6DN1L_EXC; 
             F = wide( sLAYER_761, >= M6_DN_1L_E, forty_five = INTERNAL ); 
             VAR_36 = density_statistics_file( file = "M6.DN.1.density" ); 
         _den_con = < M6_DN_1L; 
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M6_CHECK, "layer3" => CHIP_CHECK }, delta_window = { M6_DN_1L_W, M6_DN_1L_W }, delta_x = M6_DN_1L_S, delta_y = M6_DN_1L_S, boundary = BACKUP, statistics_files = { VAR_36 }, window_function = den_save_window_2 ); 
         } /* end of rule : M6.DN.1 */
      #endif /* end of #ifdef CHECK_LOW_DENSITY  */ 
      rM6_DN_1_1 @= { @ "M6.DN.1.1 : M6 local density must be <= " + M6_DN_1H + " range over " + M6_DN_1H_W + " um x " + M6_DN_1H_W + " um step " + M6_DN_1H_S + " um"; 
          M6_CHECK = M6X not M6DN1H_EXC; 
          CHIP_CHECK = gCHIP not M6DN1H_EXC; 
      _den_con = > M6_DN_1H; 
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M6_CHECK, "layer2" => CHIP_CHECK }, delta_window = { M6_DN_1H_W, M6_DN_1H_W }, delta_x = M6_DN_1H_S, delta_y = M6_DN_1H_S, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_762 = ERR_WIN not M6DN1H_EXC; 
          F = wide( sLAYER_762, >= M6_DN_1H_E, forty_five = INTERNAL ); 
          VAR_37 = density_statistics_file( file = "M6.DN.1.1.density" ); 
      _den_con = > M6_DN_1H; 
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M6_CHECK, "layer3" => CHIP_CHECK }, delta_window = { M6_DN_1H_W, M6_DN_1H_W }, delta_x = M6_DN_1H_S, delta_y = M6_DN_1H_S, boundary = BACKUP, statistics_files = { VAR_37 }, window_function = den_save_window_3 ); 
      } /* end of rule : M6.DN.1.1 */
      M6DN2_EXC = copy( EMPTYI ); 
      rM6_DN_2 @= { @ "M6.DN.2 : M6 local density must be <= " + M6_DN_2 + " range over " + M6_DN_2_W + " um x " + M6_DN_2_W + " um step " + M6_DN_2_S + " um"; 
          M6_CHECK = M6X not M6DN2_EXC; 
      _den_con = > M6_DN_2; 
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M6_CHECK, "layer2" => gCHIP }, delta_window = { M6_DN_2_W, M6_DN_2_W }, delta_x = M6_DN_2_S, delta_y = M6_DN_2_S, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_763 = ERR_WIN not M6DN2_EXC; 
          F = wide( sLAYER_763, >= M6_DN_2_E, forty_five = INTERNAL ); 
          VAR_38 = density_statistics_file( file = "M6.DN.2.density" ); 
      _den_con = > M6_DN_2; 
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M6_CHECK, "layer3" => gCHIP }, delta_window = { M6_DN_2_W, M6_DN_2_W }, delta_x = M6_DN_2_S, delta_y = M6_DN_2_S, boundary = BACKUP, statistics_files = { VAR_38 }, window_function = den_save_window_3 ); 
      } /* end of rule : M6.DN.2 */
      rM6_DN_4 @= { @ "M6.DN.4 : The metal density difference between any two " + M6_DN_4_W + " um x " + M6_DN_4_W + " um neighboring checking windows including DM6EXCL <= " + M6_DN_4; 
          sLAYER_1328 = chip_extent();
          VAR_39 = density_statistics_file( file = "M6.DN.4.density" ); 
      _gden_con = <= 1;
      _gden_gcon = > M6_DN_4; 
      _gden_absolute = true;
      _gden_corner = true;
      _gden_corner_value = -1.0;
      _gden_polygon_area_clip = true;
      _gden_print = true;
      _gden_print_only = false;
          sLAYER_1328 = sLAYER_1328 or gCHIP;
gradient_density( window_layer = sLAYER_1328, layer_hash = { "layer1" => M6X, "layer2" => gCHIP }, delta_window = { M6_DN_4_W, M6_DN_4_W }, delta_x = M6_DN_4_W, delta_y = M6_DN_4_W, boundary = BACKUP, statistics_files = { VAR_39 }, window_function = gden_save_window_7 ); 
      } /* end of rule : M6.DN.4 */
      
      //M6.R.1U is not necessary to check
      
      // Mx.DN.5
      //===========
      M6_CORE = M6X not SRCSR; 
      rM4_DN_5 @= { @ "M4.DN.5 : It is not allowed to have local density > " + MX_DN_5 + " of all 3 consecutive metal (M4,M5,M6) over any " + MX_DN_5_W + " um x " + MX_DN_5_W + " um window (stepping " + MX_DN_5_S + " um)"; 
          sLAYER_1329 = chip_extent();
          VAR_40 = density_statistics_file( file = "M4.DN.5.density" ); 
      _den_con = > 0;
      _den_polygon_area_clip = true;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( window_layer = sLAYER_1329, layer_hash = { "layer1" => M4_CORE, "layer2" => M5_CORE, "layer3" => M6_CORE }, delta_window = { MX_DN_5_W, MX_DN_5_W }, delta_x = MX_DN_5_S, delta_y = MX_DN_5_S, boundary = BACKUP, statistics_files = { VAR_40 }, window_function = den_save_window_8 ); 
      } /* end of rule : M4.DN.5 */
      
      //Mx.DN.6 is checked by M4.DN.6    
      rM4_DN_6 @= { @ "M4.DN.6 : It is not allowed to have local density < " + M4_DN_6 + " of all 3 consecutive metal (M4,M5,M6) under ((CBM SIZING 25) SIZING -25) whose size is >= 200um X 200um"; 
          A = net_area_ratio( CONNECT_DB, < M4_DN_6, { "layer1" => M4DN6_CHECK_CBM, "layer2" => M4DN6_M4_CHECK }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
          B = net_area_ratio( CONNECT_DB, < M4_DN_6, { "layer1" => M4DN6_CHECK_CBM, "layer2" => M4DN6_M5_CHECK }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
          C = net_area_ratio( CONNECT_DB, < M4_DN_6, { "layer1" => M4DN6_CHECK_CBM, "layer2" => M4DN6_M6_CHECK }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
          sLAYER_764 = A and B; 
          sLAYER_764 and C; 
      } /* end of rule : M4.DN.6 */
      
      //VIA6 CHECKS
      //===========
      gLAYER_311 = size( size( M7, - ( M7_S_2_W / 2 ), clip_acute = BISECTOR ), M7_S_2_W / 2, clip_acute = BISECTOR ); 
      M7WIDE_FIRST = gLAYER_311 and M7; 
      gLAYER_312 = size( size( M7WIDE_FIRST, - ( M7_S_2_1_W / 2 ), clip_acute = BISECTOR ), M7_S_2_1_W / 2, clip_acute = BISECTOR ); 
      M7WIDE_0_p_4 = gLAYER_312 and M7WIDE_FIRST; 
      #ifdef HALF_NODE 
         gLAYER_313 = size( size( M7, - ( M7_S_2_2_W / 2 ), clip_acute = BISECTOR ), M7_S_2_2_W / 2, clip_acute = BISECTOR ); 
         M7WIDE_0_p_2 = gLAYER_313 and M7; 
         gLAYER_314 = size( size( M7WIDE_FIRST, - ( M7_S_2_3_W / 2 ), clip_acute = BISECTOR ), M7_S_2_3_W / 2, clip_acute = BISECTOR ); 
         M7WIDE_0_p_4S = gLAYER_314 and M7WIDE_FIRST; 
      #endif /* end of #ifdef HALF_NODE  */ 
      gLAYER_315 = size( size( M7WIDE_FIRST, - ( M7_S_3_W / 2 ), clip_acute = BISECTOR ), M7_S_3_W / 2, clip_acute = BISECTOR ); 
      M7WIDE_1_p_5 = gLAYER_315 and M7WIDE_FIRST; 
      gLAYER_316 = size( size( M7WIDE_1_p_5, - ( M7_S_4_W / 2 ), clip_acute = BISECTOR ), M7_S_4_W / 2, clip_acute = BISECTOR ); 
      M7WIDE_4_p_5 = gLAYER_316 and M7WIDE_1_p_5; 
      gLAYER_317 = size( size( M6WIDE_FIRST, - ( VIA6_R_2_W / 2 ), clip_acute = BISECTOR ), VIA6_R_2_W / 2, clip_acute = BISECTOR ); 
      M6WIDE_0_p_42_VIA6 = gLAYER_317 and M6WIDE_FIRST; 
      gLAYER_318 = size( size( M6WIDE_0_p_42_VIA6, - ( VIA6_R_4_W / 2 ), clip_acute = BISECTOR ), VIA6_R_4_W / 2, clip_acute = BISECTOR ); 
      M6WIDE_0_p_7_VIA6 = gLAYER_318 and M6WIDE_0_p_42_VIA6; 
      gLAYER_319 = size( size( M6WIDE_0_p_7_VIA6, - ( VIA6_R_3_W / 2 ), clip_acute = BISECTOR ), VIA6_R_3_W / 2, clip_acute = BISECTOR ); 
      M6WIDE_0_p_98_VIA6 = gLAYER_319 and M6WIDE_0_p_7_VIA6; 
      gLAYER_320 = size( size( M6WIDE_0_p_98_VIA6, - ( VIA6_R_5_W / 2 ), clip_acute = BISECTOR ), VIA6_R_5_W / 2, clip_acute = BISECTOR ); 
      M6WIDE_2_VIA6 = gLAYER_320 and M6WIDE_0_p_98_VIA6; 
      gLAYER_321 = size( size( M6WIDE_2_VIA6, - ( VIA6_R_6_W / 2 ), clip_acute = BISECTOR ), VIA6_R_6_W / 2, clip_acute = BISECTOR ); 
      M6WIDE_3_VIA6 = gLAYER_321 and M6WIDE_2_VIA6; 
      gLAYER_322 = size( size( M7WIDE_FIRST, - ( VIA6_R_2_W / 2 ), clip_acute = BISECTOR ), VIA6_R_2_W / 2, clip_acute = BISECTOR ); 
      M7WIDE_0_p_42_VIA6 = gLAYER_322 and M7WIDE_FIRST; 
      gLAYER_323 = size( size( M7WIDE_0_p_42_VIA6, - ( VIA6_R_4_W / 2 ), clip_acute = BISECTOR ), VIA6_R_4_W / 2, clip_acute = BISECTOR ); 
      M7WIDE_0_p_7_VIA6 = gLAYER_323 and M7WIDE_0_p_42_VIA6; 
      gLAYER_324 = size( size( M7WIDE_0_p_7_VIA6, - ( VIA6_R_3_W / 2 ), clip_acute = BISECTOR ), VIA6_R_3_W / 2, clip_acute = BISECTOR ); 
      M7WIDE_0_p_98_VIA6 = gLAYER_324 and M7WIDE_0_p_7_VIA6; 
      gLAYER_325 = size( size( M7WIDE_0_p_98_VIA6, - ( VIA6_R_5_W / 2 ), clip_acute = BISECTOR ), VIA6_R_5_W / 2, clip_acute = BISECTOR ); 
      M7WIDE_2_VIA6 = gLAYER_325 and M7WIDE_0_p_98_VIA6; 
      gLAYER_326 = size( size( M7WIDE_2_VIA6, - ( VIA6_R_6_W / 2 ), clip_acute = BISECTOR ), VIA6_R_6_W / 2, clip_acute = BISECTOR ); 
      M7WIDE_3_VIA6 = gLAYER_326 and M7WIDE_2_VIA6; 
      rVIA6_W_1 @= { @ "VIA6.W.1 : Width (maximum = minimum except for seal-ring and fuse protection ring) = " + VIA6_W_1 + " um " 
                                  "VIA6.R.1 45-degree rotated VIA is not allowed";
          A = not_rectangles( VIA6, orientation = ORTHOGONAL, sides = { == VIA6_W_1, == VIA6_W_1 } ); 
          A not VIA_EXD; 
      } /* end of rule : VIA6.W.1 */
      
      // CSR.W.3 is checked by VIA6.W.2
      rVIA6_W_2 @= { @ "VIA6.W.2 : VIA6 bar width = " + VIA6_W_2 + " (VIA6 bar is covered by SEALRING layer and only allowed in seal-ring and fuse protecion ring)"; 
          internal1( VIA6_BAR, < VIA6_W_2, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          A = wide( VIA6_BAR, > VIA6_W_2, forty_five = INTERNAL ); 
          B = angle_edge( VIA6_BAR, == 45 ); 
          C = internal1( B, < ( VIA6_W_2 + 2 * GRID ), extension = RADIAL, intersecting = {  } ); 
          D = A not C; 
          contains( D, { 1, 0.005 }, FORTY_FIVE ); 
      } /* end of rule : VIA6.W.2 */
      rVIA6_S_1 @= { @ "VIA6.S.1 : Spacing >= " + VIA6_S_1 + " um"; 
          external1( VIA6, < VIA6_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : VIA6.S.1 */
      rVIA6_S_2 @= { @ "VIA6.S.2 : Space to 3-neighboring VIAx (< 0.14 um distance) >= " + VIA6_S_2 + " um"; 
          X = rectangle_spacing1( VIA6, count = > 2, distance = < VIA6_S_2_S ); 
          external2( X, VIA6, < VIA6_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : VIA6.S.2 */
      rVIA6_S_3 @= { @ "VIA6.S.3 : Space to neighboring VIAx [different net and common parallel run length > 0] >= " + VIA6_S_3 + " um"; 
          VIA6_NODAL = stamp( VIA6, VIA6I, CONNECT_DB, CONNECT_DB_VIA6_S_3, include_touch = NONE ); 
          external1( VIA6_NODAL, < VIA6_S_3, connect_sequence = CONNECT_DB_VIA6_S_3, connectivity = DIFFERENT_NET, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
      } /* end of rule : VIA6.S.3 */
      
      //VIA6.EN.0 is checked by either {VIA6.EN.1/VIA6.EN.2} or VIA6.EN.3
      rVIA6_EN_1 @= { @ "VIA6.EN.1 : Enclosure by M6 >= 0 um";
          VIA6 not M6; 
      } /* end of rule : VIA6.EN.1 */
      
      // VIA6.EN.2 is checked by VIA6.EN.2__VIA6.EN.3
      // VIA6.EN.3 is checked by VIA6.EN.2__VIA6.EN.3
      rVIA6_EN_2__VIA6_EN_3 @= { @ "VIA6.EN.2__VIA6.EN.3 : Enclosure by M6 [at least two opposite sides] >= " + VIA6_EN_2 + " , or [all sides] >= " + VIA6_EN_3; 
          X = not_enclosed_by( VIA6, M6, distances = { { { 0, RADIAL }, { VIA6_EN_2, NONE }, { 0, RADIAL }, { VIA6_EN_2, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          enclose( X, M6, < VIA6_EN_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : VIA6.EN.2__VIA6.EN.3 */
      
      // VIA6.R.1 is checked by VIA6.W.1
      // VIA6.R.2 is checked by VIA6.R.2__VIA6.R.3
      // VIA6.R.2.S is checked by VIA6.R.2__VIA6.R.3
      // VIA6.R.3 is checked by VIA6.R.2__VIA6.R.3
      
      // VIA6.R.3.S is checked by VIA6.R.2__VIA6.R.3
      rVIA6_R_2__VIA6_R_3 @= { @ "VIA6.R.2__VIA6.R.3 : When M6 or M7 width > " + VIA6_R_2_W + " um, more than one VIA6 is required. " 
                                                      "2 vias spacing should be <= " + VIA6_R_2_S1 + " um or 4 vias spacing should be <= " + VIA6_R_2_S2 + " um " 
                                                      "When M6 or M7 width > " + VIA6_R_3_W + " um, more than three VIA6 is required. " 
                                                      "4 vias spacing should be <= " + VIA6_R_3_S1 + " um or 9 vias spacing should be <= " + VIA6_R_3_S2 + " um"; 
          sLAYER_765 = M6WIDE_0_p_42_VIA6 and M7; 
          sLAYER_766 = M7WIDE_0_p_42_VIA6 and M6; 
          M7OVPM6_W_ = sLAYER_765 or sLAYER_766; 
          sLAYER_767 = M6WIDE_0_p_98_VIA6 and M7; 
          sLAYER_768 = M7WIDE_0_p_98_VIA6 and M6; 
          M7OVPM6_B = sLAYER_767 or sLAYER_768; 
          M7OVPM6_W = M7OVPM6_W_ not M7OVPM6_B; 
          CHECKED_VIA6_W_ = VIA6_EXD not_outside M7OVPM6_W; 
          CHECKED_VIA6_B = VIA6_EXD not_outside M7OVPM6_B; 
          CHECKED_VIA6_W = CHECKED_VIA6_W_ not CHECKED_VIA6_B; 
          M6_EFFECT = interacting( M6I, M7OVPM6_W_ ); 
          M7_EFFECT = interacting( M7I, M7OVPM6_W_ ); 
          EFFECT_M7OVPM6_ = M6_EFFECT and M7_EFFECT; 
          EFFECT_M7OVPM6 = interacting( EFFECT_M7OVPM6_, M7OVPM6_W_ ); 
          EFFECT_VIA = interacting( VIA6_EXD, EFFECT_M7OVPM6 ); 
          V6MERGED_A = size_inside_wrapper( EFFECT_VIA, EFFECT_M7OVPM6, distance = VIA6_R_2_S1 / 2, increment = M6_S_1 * 0.7 ); 
          V6MERGED_B = size_inside_wrapper( V6MERGED_A, EFFECT_M7OVPM6, distance = VIA6_R_2_S2_S1, increment = M6_S_1 * 0.7 ); 
          V6MERGED_C = size_inside_wrapper( V6MERGED_B, EFFECT_M7OVPM6, distance = ( VIA6_R_3_S2 - VIA6_R_2_S2 ) / 2, increment = M6_S_1 * 0.7 ); 
          V6MERGED_A2R = interacting( V6MERGED_A, EFFECT_VIA, < 2 ); 
          V6MERGED_A2 = V6MERGED_A outside V6MERGED_A2R; 
          V6MERGED_A4R = interacting( V6MERGED_A2, EFFECT_VIA, < 4 ); 
          V6MERGED_A4 = V6MERGED_A2 outside V6MERGED_A4R; 
          V6MERGED_B4R = interacting( V6MERGED_B, EFFECT_VIA, < 4 ); 
          V6MERGED_B4 = V6MERGED_B outside V6MERGED_B4R; 
          V6MERGED_C9R = interacting( V6MERGED_C, EFFECT_VIA, < 9 ); 
          V6MERGED_C9 = V6MERGED_C outside V6MERGED_C9R; 
          GMERGEW = V6MERGED_A2 or V6MERGED_B4; 
          GMERGEB = V6MERGED_A4 or V6MERGED_C9; 
          GVIA_W = interacting( CHECKED_VIA6_W, GMERGEW ); 
          GVIA_B = interacting( CHECKED_VIA6_B, GMERGEB ); 
          GOOD_AREA_W = interacting( M7OVPM6_W, GVIA_W ); 
          GOOD_AREA_B = interacting( M7OVPM6_B, GVIA_B ); 
          CHECKED_VIA6_W outside GOOD_AREA_W; 
          CHECKED_VIA6_B outside GOOD_AREA_B; 
      } /* end of rule : VIA6.R.2__VIA6.R.3 */
      
      //VIA6.R.4 is checked by VIA6.R.4:M6 and VIA6.R.4:M7
      //VIA6.R.4.S is checked by VIA6.R.4:M6 and VIA6.R.4:M7
      rVIA6_R_4_M6 @= { @ "VIA6.R.4:M6 : At least two VIAx must be used for a connection that is <= " + VIA6_R_4_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA6_R_4_W + " um (L) and width > " + VIA6_R_4_W + " um (W). (It is allowed to use one VIAx for a connection that is > " + VIA6_R_4_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA6_R_4_W + " um (L) and width > " + VIA6_R_4_W + " um (W).)"; 
          sLAYER_770 = size( M6WIDE_0_p_7_VIA6, clip_acute = NONE, distance = VIA6_R_4_D + GRID ); 
          sLAYER_769 = sLAYER_770 not M6WIDE_0_p_7_VIA6; 
          BRANCH1 = sLAYER_769 and M6; 
          sLAYER_771 = interacting( BRANCH1, M6WIDE_0_p_7_VIA6 ); 
          BRANCH1HASVIA = interacting( sLAYER_771, VIA6 ); 
          BRANCH1EDGE = M6WIDE_0_p_7_VIA6 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA6_R_4_D, increment = M6_S_1 * 0.5 ); 
          sLAYER_772 = BRANCH and M7; 
          GOODBRANCH = interacting( sLAYER_772, VIA6, > 1 ); 
          sLAYER_773 = VIA6 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_773 outside GOODBRANCH; 
          sLAYER_776 = interacting( M7, BRANCHSINGLEVIA ); 
          sLAYER_775 = sLAYER_776 and M6; 
          sLAYER_774 = interacting( sLAYER_775, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_774, VIA6, == 1 ); 
          sLAYER_777 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_777 not VIA_EXD; 
      } /* end of rule : VIA6.R.4:M6 */
      rVIA6_R_4_M7 @= { @ "VIA6.R.4:M7 : At least two VIAx must be used for a connection that is <= " + VIA6_R_4_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA6_R_4_W + " um (L) and width > " + VIA6_R_4_W + " um (W). (It is allowed to use one VIAx for a connection that is > " + VIA6_R_4_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA6_R_4_W + " um (L) and width > " + VIA6_R_4_W + " um (W).)"; 
          sLAYER_779 = size( M7WIDE_0_p_7_VIA6, clip_acute = NONE, distance = VIA6_R_4_D + GRID ); 
          sLAYER_778 = sLAYER_779 not M7WIDE_0_p_7_VIA6; 
          BRANCH1 = sLAYER_778 and M7; 
          sLAYER_780 = interacting( BRANCH1, M7WIDE_0_p_7_VIA6 ); 
          BRANCH1HASVIA = interacting( sLAYER_780, VIA6 ); 
          BRANCH1EDGE = M7WIDE_0_p_7_VIA6 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA6_R_4_D, increment = M7_S_1 * 0.5 ); 
          sLAYER_781 = BRANCH and M6; 
          GOODBRANCH = interacting( sLAYER_781, VIA6, > 1 ); 
          sLAYER_782 = VIA6 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_782 outside GOODBRANCH; 
          sLAYER_785 = interacting( M6, BRANCHSINGLEVIA ); 
          sLAYER_784 = sLAYER_785 and M7; 
          sLAYER_783 = interacting( sLAYER_784, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_783, VIA6, == 1 ); 
          sLAYER_786 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_786 not VIA_EXD; 
      } /* end of rule : VIA6.R.4:M7 */
      
      //VIA6.R.5 is checked by VIA6.R.5:M6 and VIA6.R.5:M7
      
      //VIA6.R.5.S is checked by VIA6.R.5:M6 and VIA6.R.5:M7
      rVIA6_R_5_M6 @= { @ "VIA6.R.5:M6 : At least two VIAx must be used for a connection that is <= " + VIA6_R_5_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA6_R_5_W + " um (L) and width > " + VIA6_R_5_W + " um (W). It is allowed to use one VIAx for a connection that is > " + VIA6_R_5_D + " um (D) away from a metal plate (either Mx or Mx+1) with length> " + VIA6_R_5_W + " um (L) and width > " + VIA6_R_5_W + " um (W)."; 
          sLAYER_788 = size( M6WIDE_2_VIA6, clip_acute = NONE, distance = VIA6_R_5_D + GRID ); 
          sLAYER_787 = sLAYER_788 not M6WIDE_2_VIA6; 
          BRANCH1 = sLAYER_787 and M6; 
          sLAYER_789 = interacting( BRANCH1, M6WIDE_2_VIA6 ); 
          BRANCH1HASVIA = interacting( sLAYER_789, VIA6 ); 
          BRANCH1EDGE = M6WIDE_2_VIA6 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA6_R_5_D, increment = M6_S_1 * 0.7 ); 
          sLAYER_790 = BRANCH and M7; 
          GOODBRANCH = interacting( sLAYER_790, VIA6, > 1 ); 
          sLAYER_791 = VIA6 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_791 outside GOODBRANCH; 
          sLAYER_794 = interacting( M7, BRANCHSINGLEVIA ); 
          sLAYER_793 = sLAYER_794 and M6; 
          sLAYER_792 = interacting( sLAYER_793, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_792, VIA6, == 1 ); 
          sLAYER_795 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_795 not VIA_EXD; 
      } /* end of rule : VIA6.R.5:M6 */
      rVIA6_R_5_M7 @= { @ "VIA6.R.5:M7 : At least two VIAx must be used for a connection that is <= " + VIA6_R_5_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA6_R_5_W + " um (L) and width > " + VIA6_R_5_W + " um (W). It is allowed to use one VIAx for a connection that is > " + VIA6_R_5_D + " um (D) away from a metal plate (either Mx or Mx+1) with length> " + VIA6_R_5_W + " um (L) and width > " + VIA6_R_5_W + " um (W)."; 
          sLAYER_797 = size( M7WIDE_2_VIA6, clip_acute = NONE, distance = VIA6_R_5_D + GRID ); 
          sLAYER_796 = sLAYER_797 not M7WIDE_2_VIA6; 
          BRANCH1 = sLAYER_796 and M7; 
          sLAYER_798 = interacting( BRANCH1, M7WIDE_2_VIA6 ); 
          BRANCH1HASVIA = interacting( sLAYER_798, VIA6 ); 
          BRANCH1EDGE = M7WIDE_2_VIA6 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA6_R_5_D, increment = M7_S_1 * 0.7 ); 
          sLAYER_799 = BRANCH and M6; 
          GOODBRANCH = interacting( sLAYER_799, VIA6, > 1 ); 
          sLAYER_800 = VIA6 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_800 outside GOODBRANCH; 
          sLAYER_803 = interacting( M6, BRANCHSINGLEVIA ); 
          sLAYER_802 = sLAYER_803 and M7; 
          sLAYER_801 = interacting( sLAYER_802, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_801, VIA6, == 1 ); 
          sLAYER_804 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_804 not VIA_EXD; 
      } /* end of rule : VIA6.R.5:M7 */
      M6BIG_3_VIA6 = contains( M6WIDE_3_VIA6, { VIA6_R_6_W, VIA6_R_6_L + GRID }, FORTY_FIVE ); 
      
      //VIA6.R.6 is checked by VIA6.R.6:M6 and VIA6.R.6:M7
      //VIA6.R.6.S is checked by VIA6.R.6:M6 and VIA6.R.6:M7
      rVIA6_R_6_M6 @= { @ "VIA6.R.6:M6 : At least two VIAx must be used for a connection that is <= " + VIA6_R_6_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA6_R_6_L + " um (L) and width > " + VIA6_R_6_W + " um (W). (It is allowed to use one VIAx for a connection that is > " + VIA6_R_6_D + " um (D) away from a metal plate (either Mx or Mx+1) with length> " + VIA6_R_6_L + " um (L) and width > " + VIA6_R_6_W + " um (W))."; 
          sLAYER_806 = size( M6BIG_3_VIA6, clip_acute = NONE, distance = VIA6_R_6_D + GRID ); 
          sLAYER_805 = sLAYER_806 not M6BIG_3_VIA6; 
          BRANCH1 = sLAYER_805 and M6; 
          sLAYER_807 = interacting( BRANCH1, M6BIG_3_VIA6 ); 
          BRANCH1HASVIA = interacting( sLAYER_807, VIA6 ); 
          BRANCH1EDGE = M6BIG_3_VIA6 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA6_R_6_D, increment = M6_S_1 * 0.7 ); 
          sLAYER_808 = BRANCH and M7; 
          GOODBRANCH = interacting( sLAYER_808, VIA6, > 1 ); 
          sLAYER_809 = VIA6 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_809 outside GOODBRANCH; 
          sLAYER_812 = interacting( M7, BRANCHSINGLEVIA ); 
          sLAYER_811 = sLAYER_812 and M6; 
          sLAYER_810 = interacting( sLAYER_811, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_810, VIA6, == 1 ); 
          sLAYER_813 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_813 not VIA_EXD; 
      } /* end of rule : VIA6.R.6:M6 */
      M7BIG_3_VIA6 = contains( M7WIDE_3_VIA6, { VIA6_R_6_W, VIA6_R_6_L + GRID }, FORTY_FIVE ); 
      rVIA6_R_6_M7 @= { @ "VIA6.R.6:M7 : At least two VIAx must be used for a connection that is <= " + VIA6_R_6_D + " um (D) away from a metal plate (either Mx or Mx+1) with length > " + VIA6_R_6_L + " um (L) and width > " + VIA6_R_6_W + " um (W). (It is allowed to use one VIAx for a connection that is > " + VIA6_R_6_D + " um (D) away from a metal plate (either Mx or Mx+1) with length> " + VIA6_R_6_L + " um (L) and width > " + VIA6_R_6_W + " um (W))."; 
          sLAYER_815 = size( M7BIG_3_VIA6, clip_acute = NONE, distance = VIA6_R_6_D + GRID ); 
          sLAYER_814 = sLAYER_815 not M7BIG_3_VIA6; 
          BRANCH1 = sLAYER_814 and M7; 
          sLAYER_816 = interacting( BRANCH1, M7BIG_3_VIA6 ); 
          BRANCH1HASVIA = interacting( sLAYER_816, VIA6 ); 
          BRANCH1EDGE = M7BIG_3_VIA6 coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA6_R_6_D, increment = M7_S_1 * 0.7 ); 
          sLAYER_817 = BRANCH and M6; 
          GOODBRANCH = interacting( sLAYER_817, VIA6, > 1 ); 
          sLAYER_818 = VIA6 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_818 outside GOODBRANCH; 
          sLAYER_821 = interacting( M6, BRANCHSINGLEVIA ); 
          sLAYER_820 = sLAYER_821 and M7; 
          sLAYER_819 = interacting( sLAYER_820, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_819, VIA6, == 1 ); 
          sLAYER_822 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_822 not VIA_EXD; 
      } /* end of rule : VIA6.R.6:M7 */
      
      // VIA6.R.7 is checked by VIA6.EN.1 and M7.EN.1
      rVIA6_R_11 @= { @ "VIA6.R.11 : Single VIAx is not allowed for H-shape  Mx+1 when all of the following conditions come into existence: "
                                    "1. The Mx+1 has H-shape interact with two metal holes : both two metal hole area <= " + VIA6_R_11_A + " um2 and two metal hole length(L2) <= " + VIA6_R_11_L2 + " um " 
                                    "2. The VIAx overlaps on the center metal bar of this H-shape Mx+1 "
                                    "3. The length (L) of the center metal bar <= " + VIA6_R_11_L + " um and the width of metal bar is <= " + VIA6_R_11_W + " um."; 
          W = not( M7I, wide( M7I, > VIA6_R_11_W, forty_five = INTERNAL ) ); 
          sLAYER_823 = donut_holes( M7I, area = <= VIA6_R_11_A, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          H_HOLE = interacting( sLAYER_823, W ); 
          A0 = interacting( M7I, H_HOLE ); 
          A = A0 coincident_outside_edge H_HOLE; 
          sLAYER_825 = internal1( A, <= VIA6_R_11_W, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_824 = sLAYER_825 inside A0; 
          B0 = interacting( sLAYER_824, H_HOLE, == 2 ); 
          sLAYER_828 = internal1( A, <= VIA6_R_11_L, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_827 = sLAYER_828 inside A0; 
          sLAYER_826 = sLAYER_827 and W; 
          B1 = interacting( sLAYER_826, H_HOLE, == 2 ); 
          HOLE_NOTCH = external1( H_HOLE, <= VIA6_R_11_W, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          sLAYER_829 = B1 not HOLE_NOTCH; 
          B2 = sLAYER_829 or B0; 
          sLAYER_831 = external1( B2, <= VIA6_R_11_W, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_ADJACENT, orientation = { }, output_type = EXTENTS ); 
          sLAYER_830 = outside_touching( sLAYER_831, B2, == 2 ); 
          CORNER_M = sLAYER_830 and W; 
          B = B2 or CORNER_M; 
          CENTER_BAR1 = not_contains( B, { GRID, VIA6_R_11_L + GRID }, FORTY_FIVE ); 
          sLAYER_832 = interacting( CENTER_BAR1, H_HOLE, == 2 ); 
          CENTER_BAR2 = interacting( sLAYER_832, VIA6I ); 
          C = CENTER_BAR2 coincident_outside_edge H_HOLE; 
          D = external2_edge( C, A, <= VIA6_R_11_L2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          E = C not_coincident_inside_edge D; 
          CENTER_BAR3 = CENTER_BAR2 not_touching E; 
          CHECK_VIA = VIA6I not_outside CENTER_BAR3; 
          sLAYER_835 = interacting( A0, CHECK_VIA ); 
          sLAYER_836 = interacting( M6I, CHECK_VIA ); 
          sLAYER_834 = sLAYER_835 and sLAYER_836;
          sLAYER_833 = interacting( sLAYER_834, VIA6I, == 1 ); 
          CHECK_VIA and sLAYER_833; 
      } /* end of rule : VIA6.R.11 */
      
      //M7 CHECKS
      //=========
      M71 = M7WIDE_FIRST not CB_NON_CUP; 
      M711 = M7WIDE_0_p_4 not CB_NON_CUP; 
      #ifdef HALF_NODE 
         M712 = M7WIDE_0_p_2 not CB_NON_CUP; 
         M713 = M7WIDE_0_p_4S not CB_NON_CUP; 
      #endif /* end of #ifdef HALF_NODE  */ 
      M72 = M7WIDE_1_p_5 not CB_NON_CUP; 
      M73 = M7WIDE_4_p_5 not CB_NON_CUP; 
      M7AS3 = area( M7, > ( M7_S_3_L * M7_W_1 ) );    /* filter small metal for M7.S.3 */ 
      M7AS4 = area( M7AS3, > ( M7_S_4_L * M7_W_1 ) );    /* filter small metal for M7.S.4 */ 
      M7_EDGE_45 = angle_edge( M7, == 45 ); 
      rM7_W_1 @= { @ "M7.W.1 : Width >= " + M7_W_1 + " um"; 
          internal1( M7, < M7_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : M7.W.1 */
      rM7_W_2 @= { @ "M7.W.2 : Width of 45-degree bent Mx Please make sure the vertex of 45 degree pattern is on 5nm grid >= " + M7_W_2 + " um"; 
          internal1( M7_EDGE_45, < M7_W_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
      } /* end of rule : M7.W.2 */
      rM7_W_3 @= { @ "M7.W.3 : Maximum width <= " + M7_W_3 + " um"; 
          size( size( M7, - ( M7_W_3 / 2 ), clip_acute = BISECTOR ), M7_W_3 / 2, clip_acute = BISECTOR ); 
      } /* end of rule : M7.W.3 */
      rM7_S_1 @= { @ "M7.S.1 : Spacing >= " + M7_S_1 + " um"; 
          external1( M7, < M7_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : M7.S.1 */
      
      //M7.S.2.S is checked by M7.S.2 
      rM7_S_2 @= { @ "M7.S.2 : Space [at least one metal line width > " + M7_S_2_W + " um  and the parallel metal run length > " + M7_S_2_L + " um ] (union projection) >= " + M7_S_2; 
          X = external2( M71, M7, < M7_S_2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M7; 
          contains( Y, { GRID, M7_S_2_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M7.S.2 */
      
      //M7.S.2.1.S is checked by M7.S.2.1
      rM7_S_2_1 @= { @ "M7.S.2.1 : Space [at least one metal line width > " + M7_S_2_1_W + " um  and the parallel metal run length > " + M7_S_2_1_L + " um ] (union projection) >= " + M7_S_2_1; 
          X = external2( M711, M7, < M7_S_2_1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M7; 
          contains( Y, { GRID, M7_S_2_1_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M7.S.2.1 */
      #ifdef HALF_NODE 
         
         //M7.S.2.2.S is checked by M7.S.2.2
         rM7_S_2_2 @= { @ "M7.S.2.2 : Space [at least one metal line width > " + M7_S_2_2_W + " um  and the parallel metal run length > " + M7_S_2_2_L + " um ] (union projection) >= " + M7_S_2_2; 
             X = external2( M712, M7, < M7_S_2_2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
             Y = X not M7; 
             contains( Y, { GRID, M7_S_2_2_L + GRID }, FORTY_FIVE ); 
         } /* end of rule : M7.S.2.2 */
         
         //M7.S.2.3.S is checked by M7.S.2.3
         rM7_S_2_3 @= { @ "M7.S.2.3 : Space [at least one metal line width > " + M7_S_2_3_W + " um  and the parallel metal run length > " + M7_S_2_3_L + " um ] (union projection) >= " + M7_S_2_3; 
             X = external2( M713, M7, < M7_S_2_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
             Y = X not M7; 
             contains( Y, { GRID, M7_S_2_3_L + GRID }, FORTY_FIVE ); 
         } /* end of rule : M7.S.2.3 */
      #endif /* end of #ifdef HALF_NODE  */ 
      
      //M7.S.3.S is checked by M7.S.3
      rM7_S_3 @= { @ "M7.S.3 : Space [at least one metal line width > " + M7_S_3_W + " um  and the parallel metal run length > " + M7_S_3_L + " um ] (union projection) >= " + M7_S_3; 
          X = external2( M72, M7AS3, < M7_S_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M7; 
          contains( Y, { GRID, M7_S_3_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M7.S.3 */
      
      //M7.S.4.S is checked by M7.S.4
      rM7_S_4 @= { @ "M7.S.4 : Space [at least one metal line width > " + M7_S_4_W + " um  and the parallel metal run length > " + M7_S_4_L + " um ] (union projection) >= " + M7_S_4; 
          X = external2( M73, M7AS4, < M7_S_4, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M7; 
          contains( Y, { GRID, M7_S_4_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M7.S.4 */
      rM7_S_5 @= { @ "M7.S.5 : Space at Mx line-end (W<Q=0.120) in a dense-line-end configuration: If Mx has parallel run length with opposite Mx (measured with T=0.035 extension) along 2 adjacent edges of Mx [any one edge <Q distance from the corner of the two edges], then one of the space (S1 or S2) needs to be at least this value (except for small jog with edge length < 0.10 um (R)) >= " + M7_S_5 + " um."; 
          A = adjacent_edge( M7, angle1 = == 90, angle2 = == 90, length = < M7_S_5_Q ); 
          B = external2_edge( A, M7, < M7_S_5, extension = EDGE, extension_distance = M7_S_5_E, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1 ); 
          C = A inside_touching_edge B; 
          D = internal2_edge( C, M7, < M7_S_5_Q, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 90, look_thru = RELATED_COINCIDENT, orientation = { }, output_layer = LAYER2 ); 
          I = length_edge( D, >= M7_W_1 ); 
          sLAYER_1330 = extend_edge( I, start = M7_S_5_E, end = M7_S_5_E ); 
          J = edge_size( sLAYER_1330, inside = 0.001 ); 
          K = edge_size( I, inside = 0.001 ); 
          L = J not K; 
          M = L touching A; 
          N = M or K; 
          O = N touching_edge I; 
          external2( O, M7, < M7_S_5, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
      } /* end of rule : M7.S.5 */
      
      //M7.EN.0 is checked by either {M7.EN.1/M7.EN.2} or M7.EN.3
      rM7_EN_1 @= { @ "M7.EN.1 : Enclosure of VIA6 >= 0 um";
          VIA6 not M7; 
      } /* end of rule : M7.EN.1 */
      
      // M7.EN.2 is checked by M7.EN.2__M7.EN.3
      // M7.EN.3 is checked by M7.EN.2__M7.EN.3
      rM7_EN_2__M7_EN_3 @= { @ "M7.EN.2__M7.EN.3 : Enclosure of VIA6 [at least two opposite sides] >= " + M7_EN_2 + " ,or [all sides] >= " + M7_EN_3; 
          X = not_enclosed_by( VIA6, M7, distances = { { { 0, RADIAL }, { M7_EN_2, NONE }, { 0, RADIAL }, { M7_EN_2, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          enclose( X, M7, < M7_EN_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : M7.EN.2__M7.EN.3 */
      rM7_A_1 @= { @ "M7.A.1 : Area >= " + M7_A_1 + " um2"; 
          area( M7, < M7_A_1 ); 
      } /* end of rule : M7.A.1 */
      rM7_A_2 @= { @ "M7.A.2 : Enclosed area >= " + M7_A_2 + " um"; 
          X = donut_holes( M7, area = < M7_A_2PRE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          sLAYER_837 = X not M7; 
          area( sLAYER_837, < M7_A_2 ); 
      } /* end of rule : M7.A.2 */
      rM7_S_6 @= { @ "M7.S.6 : Space to 45 degree bent M7 >= " + M7_S_6 + " um"; 
          X = edge_size( M7_EDGE_45, outside = M7_S_6 ); 
          X and M7; 
      } /* end of rule : M7.S.6 */
      M7DN1H_EXC = copy( M7_EXC ); 
      M7DN1L_EXC = copy( M7_EXC_LOW ); 
      #ifdef CHECK_LOW_DENSITY 
         rM7_DN_1 @= { @ "M7.DN.1 : M7 local density must be >= " + M7_DN_1L + " range over " + M7_DN_1L_W + " um x " + M7_DN_1L_W + " um step " + M7_DN_1L_S + " um"; 
             M7_CHECK = M7X not M7DN1L_EXC; 
             CHIP_CHECK = gCHIP not M7DN1L_EXC; 
         _den_con = < M7_DN_1L; 
         _den_polygon_area_clip = false;
         _den_print = false;
         _den_print_only = false;
             ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M7_CHECK, "layer2" => CHIP_CHECK }, delta_window = { M7_DN_1L_W, M7_DN_1L_W }, delta_x = M7_DN_1L_S, delta_y = M7_DN_1L_S, boundary = BACKUP, window_function = den_save_window_1 ); 
             sLAYER_838 = ERR_WIN not M7DN1L_EXC; 
             F = wide( sLAYER_838, >= M7_DN_1L_E, forty_five = INTERNAL ); 
             VAR_41 = density_statistics_file( file = "M7.DN.1.density" ); 
         _den_con = < M7_DN_1L; 
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M7_CHECK, "layer3" => CHIP_CHECK }, delta_window = { M7_DN_1L_W, M7_DN_1L_W }, delta_x = M7_DN_1L_S, delta_y = M7_DN_1L_S, boundary = BACKUP, statistics_files = { VAR_41 }, window_function = den_save_window_2 ); 
         } /* end of rule : M7.DN.1 */
      #endif /* end of #ifdef CHECK_LOW_DENSITY  */ 
      rM7_DN_1_1 @= { @ "M7.DN.1.1 : M7 local density must be <= " + M7_DN_1H + " range over " + M7_DN_1H_W + " um x " + M7_DN_1H_W + " um step " + M7_DN_1H_S + " um"; 
          M7_CHECK = M7X not M7DN1H_EXC; 
          CHIP_CHECK = gCHIP not M7DN1H_EXC; 
      _den_con = > M7_DN_1H; 
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M7_CHECK, "layer2" => CHIP_CHECK }, delta_window = { M7_DN_1H_W, M7_DN_1H_W }, delta_x = M7_DN_1H_S, delta_y = M7_DN_1H_S, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_839 = ERR_WIN not M7DN1H_EXC; 
          F = wide( sLAYER_839, >= M7_DN_1H_E, forty_five = INTERNAL ); 
          VAR_42 = density_statistics_file( file = "M7.DN.1.1.density" ); 
      _den_con = > M7_DN_1H; 
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M7_CHECK, "layer3" => CHIP_CHECK }, delta_window = { M7_DN_1H_W, M7_DN_1H_W }, delta_x = M7_DN_1H_S, delta_y = M7_DN_1H_S, boundary = BACKUP, statistics_files = { VAR_42 }, window_function = den_save_window_3 ); 
      } /* end of rule : M7.DN.1.1 */
      M7DN2_EXC = copy( EMPTYI ); 
      rM7_DN_2 @= { @ "M7.DN.2 : M7 local density must be <= " + M7_DN_2 + " range over " + M7_DN_2_W + " um x " + M7_DN_2_W + " um step " + M7_DN_2_S + " um"; 
          M7_CHECK = M7X not M7DN2_EXC; 
      _den_con = > M7_DN_2; 
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M7_CHECK, "layer2" => gCHIP }, delta_window = { M7_DN_2_W, M7_DN_2_W }, delta_x = M7_DN_2_S, delta_y = M7_DN_2_S, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_840 = ERR_WIN not M7DN2_EXC; 
          F = wide( sLAYER_840, >= M7_DN_2_E, forty_five = INTERNAL ); 
          VAR_43 = density_statistics_file( file = "M7.DN.2.density" ); 
      _den_con = > M7_DN_2; 
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M7_CHECK, "layer3" => gCHIP }, delta_window = { M7_DN_2_W, M7_DN_2_W }, delta_x = M7_DN_2_S, delta_y = M7_DN_2_S, boundary = BACKUP, statistics_files = { VAR_43 }, window_function = den_save_window_3 ); 
      } /* end of rule : M7.DN.2 */
      rM7_DN_4 @= { @ "M7.DN.4 : The metal density difference between any two " + M7_DN_4_W + " um x " + M7_DN_4_W + " um neighboring checking windows including DM7EXCL <= " + M7_DN_4; 
          sLAYER_1331 = chip_extent();
          VAR_44 = density_statistics_file( file = "M7.DN.4.density" ); 
      _gden_con = <= 1;
      _gden_gcon = > M7_DN_4; 
      _gden_absolute = true;
      _gden_corner = true;
      _gden_corner_value = -1.0;
      _gden_polygon_area_clip = true;
      _gden_print = true;
      _gden_print_only = false;
          sLAYER_1331 = sLAYER_1331 or gCHIP;
gradient_density( window_layer = sLAYER_1331, layer_hash = { "layer1" => M7X, "layer2" => gCHIP }, delta_window = { M7_DN_4_W, M7_DN_4_W }, delta_x = M7_DN_4_W, delta_y = M7_DN_4_W, boundary = BACKUP, statistics_files = { VAR_44 }, window_function = gden_save_window_7 ); 
      } /* end of rule : M7.DN.4 */
      
      //M7.R.1U is not necessary to check
      
      // Mx.DN.5
      //===========
      M7_CORE = M7X not SRCSR; 
      rM5_DN_5 @= { @ "M5.DN.5 : It is not allowed to have local density > " + MX_DN_5 + " of all 3 consecutive metal (M5,M6,M7) over any " + MX_DN_5_W + " um x " + MX_DN_5_W + " um window (stepping " + MX_DN_5_S + " um)"; 
          sLAYER_1332 = chip_extent();
          VAR_45 = density_statistics_file( file = "M5.DN.5.density" ); 
      _den_con = > 0;
      _den_polygon_area_clip = true;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( window_layer = sLAYER_1332, layer_hash = { "layer1" => M5_CORE, "layer2" => M6_CORE, "layer3" => M7_CORE }, delta_window = { MX_DN_5_W, MX_DN_5_W }, delta_x = MX_DN_5_S, delta_y = MX_DN_5_S, boundary = BACKUP, statistics_files = { VAR_45 }, window_function = den_save_window_8 ); 
      } /* end of rule : M5.DN.5 */
      
      //Mx.DN.6 is checked by M5.DN.6    
      rM5_DN_6 @= { @ "M5.DN.6 : It is not allowed to have local density < " + M5_DN_6 + " of all 3 consecutive metal (M5,M6,M7) under ((CBM SIZING 25) SIZING -25) whose size is >= 200um X 200um"; 
          A = net_area_ratio( CONNECT_DB, < M5_DN_6, { "layer1" => M5DN6_CHECK_CBM, "layer2" => M5DN6_M5_CHECK }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
          B = net_area_ratio( CONNECT_DB, < M5_DN_6, { "layer1" => M5DN6_CHECK_CBM, "layer2" => M5DN6_M6_CHECK }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
          C = net_area_ratio( CONNECT_DB, < M5_DN_6, { "layer1" => M5DN6_CHECK_CBM, "layer2" => M5DN6_M7_CHECK }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
          sLAYER_841 = A and B; 
          sLAYER_841 and C; 
      } /* end of rule : M5.DN.6 */
      
      //M6.DN.5 is not necessary to check
      
      //M7.DN.5 is not necessary to check
      
      //VIA7 CHECKS
      //===========
      rVIA7_W_1 @= { @ "VIA7.W.1 : Width (maximum = minimum except for seal-ring and fuse protection ring) = " + VIA7_W_1 + " " 
                                  "VIA7.R.1 45-degree rotated VIA is not allowed";
          A = not_rectangles( VIA7, orientation = ORTHOGONAL, sides = { == VIA7_W_1, == VIA7_W_1 } ); 
          A not VIA_EXD; 
      } /* end of rule : VIA7.W.1 */
      
      // CSR.W.3 is checked by VIA7.W.2
      rVIA7_W_2 @= { @ "VIA7.W.2 : VIA7 bar width = " + VIA7_W_2 + " (VIA7 bar is covered by SEALRING layer and only allowed in seal-ring and fuse protecion ring)"; 
          internal1( VIA7_BAR, < VIA7_W_2, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          A = wide( VIA7_BAR, > VIA7_W_2, forty_five = INTERNAL ); 
          B = angle_edge( VIA7_BAR, == 45 ); 
          C = internal1( B, < ( VIA7_W_2 + GRID ), extension = RADIAL, intersecting = {  } ); 
          D = A not C; 
          contains( D, { 2, 0.005 }, FORTY_FIVE ); 
      } /* end of rule : VIA7.W.2 */
      rVIA7_S_1 @= { @ "VIA7.S.1 : Space >= " + VIA7_S_1 + " um"; 
          external1( VIA7, < VIA7_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : VIA7.S.1 */
      rVIA7_S_2 @= { @ "VIA7.S.2 : Space to 3-neighboring VIAz (<0.56 um distance) >= " + VIA7_S_2 + " um"; 
          X = rectangle_spacing1( VIA7, count = > 2, distance = < VIA7_S_2_S ); 
          external2( X, VIA7, < VIA7_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : VIA7.S.2 */
      rVIA7_EN_1 @= { @ "VIA7.EN.1 : Enclosure by M7 >= " + VIA7_EN_1 + " um"; 
          enclose( VIA7, M7, < VIA7_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          sLAYER_842 = VIA7 not M7; 
          sLAYER_842 not CBM; 
      } /* end of rule : VIA7.EN.1 */
      rVIA7_EN_2 @= { @ "VIA7.EN.2 : Enclosure by M7 [at least two opposite sides] >= " + VIA7_EN_2 + " um"; 
          X = not_enclosed_by( VIA7, M7, distances = { { { VIA7_EN_1, RADIAL }, { VIA7_EN_2, NONE }, { VIA7_EN_1, RADIAL }, { VIA7_EN_2, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          Y = enclose_edge( X, M7, < VIA7_EN_2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Z = X touching_edge Y; 
          vertex( Z, angles = { 90 }, shape = TRIANGLE, shape_size = VIA7_W_1 );    /* adjacent narrow sides */ 
      } /* end of rule : VIA7.EN.2 */
      
      // VIA7.R.1 is checked by VIA7.W.1
      gLAYER_328 = size( size( M8, - ( VIA7_R_2_W / 2 ), clip_acute = BISECTOR ), VIA7_R_2_W / 2, clip_acute = BISECTOR ); 
      M8WIDE_1_p_8_VIA7T = gLAYER_328 and M8; 
      gLAYER_329 = size( size( M7, - ( VIA7_R_2_W / 2 ), clip_acute = BISECTOR ), VIA7_R_2_W / 2, clip_acute = BISECTOR ); 
      M7WIDE_1_p_8_VIA7T = gLAYER_329 and M7; 
      gLAYER_330 = size( size( M8WIDE_1_p_8_VIA7T, - ( VIA7_R_3_W / 2 ), clip_acute = BISECTOR ), VIA7_R_3_W / 2, clip_acute = BISECTOR ); 
      M8WIDE_3_VIA7T = gLAYER_330 and M8WIDE_1_p_8_VIA7T; 
      gLAYER_331 = size( size( M7WIDE_1_p_8_VIA7T, - ( VIA7_R_3_W / 2 ), clip_acute = BISECTOR ), VIA7_R_3_W / 2, clip_acute = BISECTOR ); 
      M7WIDE_3_VIA7T = gLAYER_331 and M7WIDE_1_p_8_VIA7T; 
      
      //VIA7.R.2.S is checked by VIA7.R.2
      rVIA7_R_2 @= { @ "VIA7.R.2 : At least two VIA7 with spacing <= " + VIA7_R_2_S + " um are required to connect M7 and M8 when one of these metals has a width and length > " + VIA7_R_2_W + " um."; 
          sLAYER_843 = M8 and M7WIDE_1_p_8_VIA7T; 
          sLAYER_844 = M7 and M8WIDE_1_p_8_VIA7T; 
          M8OVPM7W = sLAYER_843 or sLAYER_844; 
          CHECKED_VIA7 = VIA7_EXD not_outside M8OVPM7W; 
          M7_EFFECT = interacting( M7I, M8OVPM7W ); 
          M8_EFFECT = interacting( M8I, M8OVPM7W ); 
          EFFECT_M8OVPM7_ = M7_EFFECT and M8_EFFECT; 
          EFFECT_M8OVPM7 = interacting( EFFECT_M8OVPM7_, M8OVPM7W ); 
          EFFECT_VIA7 = interacting( VIA7_EXD, EFFECT_M8OVPM7 ); 
          VIA7MERGED = size_inside_wrapper( EFFECT_VIA7, EFFECT_M8OVPM7, distance = VIA7_R_2_S / 2, increment = M7_S_1 * 0.7 ); 
          VIA7MERGED2 = enclosing( VIA7MERGED, EFFECT_VIA7, >= 2 ); 
          GVIA = interacting( CHECKED_VIA7, VIA7MERGED2 ); 
          GM8OVPM7W = interacting( M8OVPM7W, GVIA ); 
          CHECKED_VIA7 outside GM8OVPM7W; 
      } /* end of rule : VIA7.R.2 */
      M7BIG_3_VIA7T = contains( M7WIDE_3_VIA7T, { VIA7_R_3_W, VIA7_R_3_L + GRID }, FORTY_FIVE ); 
      
      // VIA7.R.3 is checked by VIA7.R.3:M7 and VIA7.R.3:M8
      
      // VIA7.R.3.S is checked by VIA7.R.3:M7 and VIA7.R.3:M8
      rVIA7_R_3_M7 @= { @ "VIA7.R.3:M7 : At least two VIA7 must be used for a connection that is <= " + VIA7_R_3_D + " um (D) away from a metal plate (either M7 or M8) with length > " + VIA7_R_3_L + " um (L) and width > " + VIA7_R_3_W + " um (W). (It is allowed to use one VIA7 for a connection that is > " + VIA7_R_3_D + " um (D) away from a metal plate (either M7 or M8) with length> " + VIA7_R_3_L + " um (L) and width > " + VIA7_R_3_W + " um (W))."; 
          sLAYER_846 = size( M7BIG_3_VIA7T, clip_acute = NONE, distance = VIA7_R_3_D + GRID ); 
          sLAYER_845 = sLAYER_846 not M7BIG_3_VIA7T; 
          BRANCH1 = sLAYER_845 and M7; 
          sLAYER_847 = interacting( BRANCH1, M7BIG_3_VIA7T ); 
          BRANCH1HASVIA = interacting( sLAYER_847, VIA7 ); 
          BRANCH1EDGE = M7BIG_3_VIA7T coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA7_R_3_D, increment = M7_S_1 * 0.7 ); 
          sLAYER_848 = BRANCH and M8; 
          GOODBRANCH = interacting( sLAYER_848, VIA7, > 1 ); 
          sLAYER_849 = VIA7 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_849 outside GOODBRANCH; 
          sLAYER_852 = interacting( M8, BRANCHSINGLEVIA ); 
          sLAYER_851 = sLAYER_852 and M7; 
          sLAYER_850 = interacting( sLAYER_851, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_850, VIA7, == 1 ); 
          sLAYER_853 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_853 not VIA_EXD; 
      } /* end of rule : VIA7.R.3:M7 */
      M8BIG_3_VIA7T = contains( M8WIDE_3_VIA7T, { VIA7_R_3_W, VIA7_R_3_L + GRID }, FORTY_FIVE ); 
      rVIA7_R_3_M8 @= { @ "VIA7.R.3:M8 : At least two VIA7 must be used for a connection that is <= " + VIA7_R_3_D + " um (D) away from a metal plate (either M7 or M8) with length > " + VIA7_R_3_L + " um (L) and width > " + VIA7_R_3_W + " um (W). (It is allowed to use one VIA7 for a connection that is > " + VIA7_R_3_D + " um (D) away from a metal plate (either M7 or M8) with length> " + VIA7_R_3_L + " um (L) and width > " + VIA7_R_3_W + " um (W))."; 
          sLAYER_855 = size( M8BIG_3_VIA7T, clip_acute = NONE, distance = VIA7_R_3_D + GRID ); 
          sLAYER_854 = sLAYER_855 not M8BIG_3_VIA7T; 
          BRANCH1 = sLAYER_854 and M8; 
          sLAYER_856 = interacting( BRANCH1, M8BIG_3_VIA7T ); 
          BRANCH1HASVIA = interacting( sLAYER_856, VIA7 ); 
          BRANCH1EDGE = M8BIG_3_VIA7T coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA7_R_3_D, increment = M8_S_1 * 0.7 ); 
          sLAYER_857 = BRANCH and M7; 
          GOODBRANCH = interacting( sLAYER_857, VIA7, > 1 ); 
          sLAYER_858 = VIA7 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_858 outside GOODBRANCH; 
          sLAYER_861 = interacting( M7, BRANCHSINGLEVIA ); 
          sLAYER_860 = sLAYER_861 and M8; 
          sLAYER_859 = interacting( sLAYER_860, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_859, VIA7, == 1 ); 
          sLAYER_862 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_862 not VIA_EXD; 
      } /* end of rule : VIA7.R.3:M8 */
      
      // VIA7.R.4 is checked by related rules (VIA7.EN.1 and M8.EN.1)
      // VIA7.R.5 can not be checked by DRC
      VCAP = copy( VIA7 ); 
      MCAP = copy( M8 ); 
      MCAPX = copy( M8X ); 
      MBOT = copy( M7 );                  /* Mcap-1 */ 
      MBOTX = copy( M7X ); 
      VCAP_CTMDMY = VCAP and CTMDMY; 
      VCAP_ICTMDMY = VCAP inside CTMDMY; 
      MCAP_CTMDMY = MCAP and CTMDMY; 
      MCAPX_CTMDMY = MCAPX and CTMDMY; 
      MBOT_ICTMDMY = MBOT not_outside CTMDMY; 
      MBOTX_ICTMDMY = MBOTX not_outside CTMDMY; 
      MCAP_ICTMDMY = MCAP not_outside CTMDMY; 
      MCAPX_ICTMDMY = MCAPX not_outside CTMDMY; 
      VCAP_CTM = VCAP and CTM; 
      gLAYER_332 = VCAP and CBM; 
      VCAP_CBM = gLAYER_332 not CTM; 
      rVIA7_EN_3 @= { @ "VIA7.EN.3 : Enclosure by CTM (cut is not allowed) >= " + VIA7_EN_3; 
          enclose( VCAP_CTM, CTM, < VIA7_EN_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          cutting( VCAP, CTM ); 
      } /* end of rule : VIA7.EN.3 */
      rVIA7_EN_4 @= { @ "VIA7.EN.4 : Enclosure by CBM (cut is not allowed) >= " + VIA7_EN_4; 
          enclose( VCAP_CBM, CBM, < VIA7_EN_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          cutting( VCAP, CBM ); 
      } /* end of rule : VIA7.EN.4 */
      rVIA7_S_3 @= { @ "VIA7.S.3 : [VIA7 inside CBM but outside CTM] space to CTM >= " + VIA7_S_3; 
          external2( CTM, VCAP_CBM, < VIA7_S_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : VIA7.S.3 */
      rVIA7_S_4 @= { @ "VIA7.S.4 : Space of VIA7 inside CTM  >= " + VIA7_S_4; 
          external1( VCAP_CTM, < VIA7_S_4, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : VIA7.S.4 */
      rVIA7_S_5 @= { @ "VIA7.S.5 : Space of VIA7 inside CBM >= " + VIA7_S_5; 
          external1( VCAP_CBM, < VIA7_S_5, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : VIA7.S.5 */
      
      //VIA7.R.6g is un-checkable.
      rVIA7_R_7 @= { @ "VIA7.R.7 : Single VIA7 for in a CTM or [CBM NOT CTM] or connect to [M7 (top Mx) layer inside a CTMDMY] is not allowed.";
          enclosing( CTM, VCAP, == 1 ); 
          enclosing( CBM, VCAP_CBM, == 1 ); 
          sLAYER_863 = MCAP and CTM; 
          enclosing( sLAYER_863, VCAP, == 1 ); 
          sLAYER_864 = MCAP and CBM; 
          enclosing( sLAYER_864, VCAP_CBM, == 1 ); 
          sLAYER_865 = MCAP_ICTMDMY and MBOT_ICTMDMY; 
          A = enclosing( sLAYER_865, VCAP, == 1 ); 
          interacting( VCAP_ICTMDMY, A ); 
      } /* end of rule : VIA7.R.7 */
      
      //M8 CHECKS
      //=============
      gLAYER_333 = size( size( M8, - ( M8_S_2_W / 2 ), clip_acute = BISECTOR ), M8_S_2_W / 2, clip_acute = BISECTOR ); 
      M8WIDE_1_p_5 = gLAYER_333 and M8; 
      gLAYER_334 = size( size( M8WIDE_1_p_5, - ( M8_S_3_W / 2 ), clip_acute = BISECTOR ), M8_S_3_W / 2, clip_acute = BISECTOR ); 
      M8WIDE_4_p_5 = gLAYER_334 and M8WIDE_1_p_5; 
      M81 = M8WIDE_1_p_5 not CB; 
      M82 = M8WIDE_4_p_5 not CB; 
      M8NAS2 = area( M8, > ( M8_S_2_L * M8_W_1 ) );    /* filter small metal for M8.S.2 */ 
      M8NAS3 = area( M8NAS2, > ( M8_S_3_L * M8_W_1 ) );    /* filter small metal for M8.S.3 */ 
      rM8_W_1 @= { @ "M8.W.1 : Width >= " + M8_W_1 + " um"; 
          internal1( M8, < M8_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : M8.W.1 */
      rM8_W_2 @= { @ "M8.W.2 : Maximum width [except bond pad] <= " + M8_W_2 + " um"; 
          size( size( M8_MAX_WIDTH_M, - ( M8_W_2 / 2 ), clip_acute = BISECTOR ), M8_W_2 / 2, clip_acute = BISECTOR ); 
      } /* end of rule : M8.W.2 */
      rM8_S_1 @= { @ "M8.S.1 : Space >= " + M8_S_1 + " um"; 
          external1( M8, < M8_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : M8.S.1 */
      
      //M8.S.2.S is checked by M8.S.2 
      rM8_S_2 @= { @ "M8.S.2 : Space [at least one metal line width > " + M8_S_2_W + " um (W1) and the parallel metal run length > " + M8_S_2_L + " um (L1)] >= " + M8_S_2; 
          X = external2( M81, M8NAS2, < M8_S_2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M8; 
          contains( Y, { GRID, M8_S_2_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M8.S.2 */
      
      //M8.S.3.S is checked by M8.S.3 
      rM8_S_3 @= { @ "M8.S.3 : Space [at least one metal line width > " + M8_S_3_W + " um (W1) and the parallel metal run length > " + M8_S_3_L + " um (L1)] >= " + M8_S_3; 
          X = external2( M82, M8NAS3, < M8_S_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M8; 
          contains( Y, { GRID, M8_S_3_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M8.S.3 */
      rM8_EN_1 @= { @ "M8.EN.1 : Enclosure of VIA7 >= " + M8_EN_1; 
          enclose( VIA7, M8, < M8_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          VIA7 not M8; 
      } /* end of rule : M8.EN.1 */
      rM8_EN_2 @= { @ "M8.EN.2 : Enclosure of VIA7 [at least two opposite sides] >= " + M8_EN_2; 
          X = not_enclosed_by( VIA7, M8, distances = { { { M8_EN_1, RADIAL }, { M8_EN_2, NONE }, { M8_EN_1, RADIAL }, { M8_EN_2, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          Y = enclose_edge( X, M8, < M8_EN_2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Z = X touching_edge Y; 
          vertex( Z, angles = { 90 }, shape = TRIANGLE, shape_size = VIA7_W_1 );    /* adjacent narrow sides */ 
      } /* end of rule : M8.EN.2 */
      rM8_A_1 @= { @ "M8.A.1 : Area >= " + M8_A_1 + " um2"; 
          area( M8, < M8_A_1 ); 
      } /* end of rule : M8.A.1 */
      rM8_A_2 @= { @ "M8.A.2 : Enclosed area >= " + M8_A_2 + " um2"; 
          X = donut_holes( M8, area = < M8_A_2PRE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          sLAYER_866 = X not M8; 
          area( sLAYER_866, < M8_A_2 ); 
      } /* end of rule : M8.A.2 */
      gLAYER_335 = M8_EXC or WBDMY; 
      M8DN1H_EXC = gLAYER_335 or CBMT2; 
      M8DN1L_EXC = copy( M8_EXC_LOW ); 
      #ifdef CHECK_LOW_DENSITY 
         rM8_DN_1 @= { @ "M8.DN.1 : M8 local density must be >= " + M8_DN_1L + " range over " + M8_DN_1L_W + " um x " + M8_DN_1L_W + " um step " + M8_DN_1L_S + " um"; 
             M8_CHECK = M8X not M8DN1L_EXC; 
             CHIP_CHECK = gCHIP not M8DN1L_EXC; 
         _den_con = < M8_DN_1L; 
         _den_polygon_area_clip = false;
         _den_print = false;
         _den_print_only = false;
             ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M8_CHECK, "layer2" => CHIP_CHECK }, delta_window = { M8_DN_1L_W, M8_DN_1L_W }, delta_x = M8_DN_1L_S, delta_y = M8_DN_1L_S, boundary = BACKUP, window_function = den_save_window_1 ); 
             sLAYER_867 = ERR_WIN not M8DN1L_EXC; 
             F = wide( sLAYER_867, >= M8_DN_1L_E, forty_five = INTERNAL ); 
             VAR_46 = density_statistics_file( file = "M8.DN.1.density" ); 
         _den_con = < M8_DN_1L; 
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M8_CHECK, "layer3" => CHIP_CHECK }, delta_window = { M8_DN_1L_W, M8_DN_1L_W }, delta_x = M8_DN_1L_S, delta_y = M8_DN_1L_S, boundary = BACKUP, statistics_files = { VAR_46 }, window_function = den_save_window_2 ); 
         } /* end of rule : M8.DN.1 */
      #endif /* end of #ifdef CHECK_LOW_DENSITY  */ 
      rM8_DN_1_1 @= { @ "M8.DN.1.1 : M8 local density must be <= " + M8_DN_1H + " range over " + M8_DN_1H_W + " um x " + M8_DN_1H_W + " um step " + M8_DN_1H_S + " um"; 
          M8_CHECK = M8X not M8DN1H_EXC; 
          CHIP_CHECK = gCHIP not M8DN1H_EXC; 
      _den_con = > M8_DN_1H; 
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M8_CHECK, "layer2" => CHIP_CHECK }, delta_window = { M8_DN_1H_W, M8_DN_1H_W }, delta_x = M8_DN_1H_S, delta_y = M8_DN_1H_S, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_868 = ERR_WIN not M8DN1H_EXC; 
          F = wide( sLAYER_868, >= M8_DN_1H_E, forty_five = INTERNAL ); 
          VAR_47 = density_statistics_file( file = "M8.DN.1.1.density" ); 
      _den_con = > M8_DN_1H; 
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M8_CHECK, "layer3" => CHIP_CHECK }, delta_window = { M8_DN_1H_W, M8_DN_1H_W }, delta_x = M8_DN_1H_S, delta_y = M8_DN_1H_S, boundary = BACKUP, statistics_files = { VAR_47 }, window_function = den_save_window_3 ); 
      } /* end of rule : M8.DN.1.1 */
      gLAYER_336 = WBDMY or IND_EXD; 
      M8DN2_EXC = gLAYER_336 or CBMT2; 
      rM8_DN_2 @= { @ "M8.DN.2 : M8 local density must be <= " + M8_DN_2 + " range over " + M8_DN_2_W + " um x " + M8_DN_2_W + " um step " + M8_DN_2_S + " um"; 
          M8_CHECK = M8X not M8DN2_EXC; 
      _den_con = > M8_DN_2; 
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M8_CHECK, "layer2" => gCHIP }, delta_window = { M8_DN_2_W, M8_DN_2_W }, delta_x = M8_DN_2_S, delta_y = M8_DN_2_S, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_869 = ERR_WIN not M8DN2_EXC; 
          F = wide( sLAYER_869, >= M8_DN_2_E, forty_five = INTERNAL ); 
          VAR_48 = density_statistics_file( file = "M8.DN.2.density" ); 
      _den_con = > M8_DN_2; 
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M8_CHECK, "layer3" => gCHIP }, delta_window = { M8_DN_2_W, M8_DN_2_W }, delta_x = M8_DN_2_S, delta_y = M8_DN_2_S, boundary = BACKUP, statistics_files = { VAR_48 }, window_function = den_save_window_3 ); 
      } /* end of rule : M8.DN.2 */
      rM8_DN_4 @= { @ "M8.DN.4 : The metal density difference between any two " + M8_DN_4_W + " um x " + M8_DN_4_W + " um neighboring checking windows including DM8EXCL <= " + M8_DN_4; 
          sLAYER_1333 = chip_extent();
          VAR_49 = density_statistics_file( file = "M8.DN.4.density" ); 
      _gden_con = <= 1;
      _gden_gcon = > M8_DN_4; 
      _gden_absolute = true;
      _gden_corner = true;
      _gden_corner_value = -1.0;
      _gden_polygon_area_clip = true;
      _gden_print = true;
      _gden_print_only = false;
          sLAYER_1333 = sLAYER_1333 or gCHIP;
gradient_density( window_layer = sLAYER_1333, layer_hash = { "layer1" => M8X, "layer2" => gCHIP }, delta_window = { M8_DN_4_W, M8_DN_4_W }, delta_x = M8_DN_4_W, delta_y = M8_DN_4_W, boundary = BACKUP, statistics_files = { VAR_49 }, window_function = gden_save_window_7 ); 
      } /* end of rule : M8.DN.4 */
      
      //M8.R.1U is not necessary to check
      rM8_EN_3 @= { @ "M8.EN.3 : M8 enclosure of [VIA7 inside CTMDMY] >= " + M8_EN_3; 
          enclose( VCAP_ICTMDMY, MCAP_ICTMDMY, < M8_EN_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { OUTSIDE, POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : M8.EN.3 */
      
      //M8.DN.5.1  is checked by M8.DN.5:LW 
      //M8.DN.5.1  is checked by M8.DN.5:LR
      //M8.DN.5.2  is checked by M8.DN.5:H 
      rM8_DN_5_LW @= { @ "M8.DN.5:LW : Mz [1st metal above MIM capacitor connect to CTM or CBM] density [in window 200 um x 200 um, stepping 100 um] range inside a CTMDMY* [the overlapped area of {checking window AND CTMDMY} >= 2500 um2] DRC also flag: {CTMDMY NOT {Mz OR DMz}} [width and length >= 8 um] in the violated region >= 50%";
          sLAYER_870 = CTMDMY not M8X; 
          CTMDMY_CHECK = wide( sLAYER_870, >= 8, forty_five = INTERNAL ); 
          VAR_50 = density_statistics_file( file = "M8.DN.5L.density" ); 
      _den_con = < M8_DN_5L; 
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          A = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => MCAPX_CTMDMY, "layer2" => CTMDMY, "layer3" => CTMDMY_CHECK }, delta_window = { M8_DN_5L_W, M8_DN_5L_W }, delta_x = M8_DN_5L_S, delta_y = M8_DN_5L_S, boundary = BACKUP, statistics_files = { VAR_50 }, window_function = den_save_window_10 ); 
          copy( A ); 
      } /* end of rule : M8.DN.5:LW */
      rM8_DN_5_LR @= { @ "M8.DN.5:LR : Mz [1st metal above MIM capacitor connect to CTM or CBM] density [in window 200 um x 200 um, stepping 100 um] range inside a CTMDMY* [the overlapped area of {checking window AND CTMDMY} >= 2500 um2] DRC also flag: {CTMDMY NOT {Mz OR DMz}} [width and length >= 8 um] in the violated region >= 50% "
                                      "DRC also flag: DRC also flag {CTMDMY NOT (Mz or DMz)} [width and length >=8] in the violatd region";
          sLAYER_871 = CTMDMY not M8X; 
          CTMDMY_CHECK = wide( sLAYER_871, >= 8, forty_five = INTERNAL ); 
      _den_con = < M8_DN_5L; 
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          A = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => MCAPX_CTMDMY, "layer2" => CTMDMY, "layer3" => CTMDMY_CHECK }, delta_window = { M8_DN_5L_W, M8_DN_5L_W }, delta_x = M8_DN_5L_S, delta_y = M8_DN_5L_S, boundary = BACKUP, window_function = den_save_window_10 ); 
          CTMDMY_CHECK and A; 
      } /* end of rule : M8.DN.5:LR */
      rM8_DN_5_H @= { @ "M8.DN.5:H : Mz [1st metal above MIM capacitor connect to CTM or CBM] density [in window 100 um x 100 um, stepping 50 um] range inside a CTMDMY* [the overlapped area of {checking window AND CTMDMY} >= 2500 um2] <= 80%";
          VAR_51 = density_statistics_file( file = "M8.DN.5H.density" ); 
      _den_con = > M8_DN_5H; 
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => MCAPX_CTMDMY, "layer2" => CTMDMY }, delta_window = { M8_DN_5H_W, M8_DN_5H_W }, delta_x = M8_DN_5H_S, delta_y = M8_DN_5H_S, boundary = BACKUP, statistics_files = { VAR_51 }, window_function = den_save_window_11 ); 
      } /* end of rule : M8.DN.5:H */
      rM8_W_4 @= { @ "M8.W.4 : Width of {M8 inside CTMDMY} >= " + M8_W_4; 
          A = internal1( MCAPX_ICTMDMY, < M8_W_4, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          A not_outside CTMDMY; 
      } /* end of rule : M8.W.4 */
      rM8_S_4 @= { @ "M8.S.4 : Space of {M8 inside CTMDMY} >= " + M8_S_4; 
          A = external1( MCAPX_ICTMDMY, < M8_S_4, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          A not_outside CTMDMY; 
      } /* end of rule : M8.S.4 */
      
      //VIA8 CHECKS
      //===========
      rVIA8_W_1 @= { @ "VIA8.W.1 : Width (maximum = minimum except for seal-ring and fuse protection ring) = " + VIA8_W_1 + " " 
                                  "VIA8.R.1 45-degree rotated VIA is not allowed";
          A = not_rectangles( VIA8, orientation = ORTHOGONAL, sides = { == VIA8_W_1, == VIA8_W_1 } ); 
          A not VIA_EXD; 
      } /* end of rule : VIA8.W.1 */
      
      // CSR.W.3 is checked by VIA8.W.2
      rVIA8_W_2 @= { @ "VIA8.W.2 : VIA8 bar width = " + VIA8_W_2 + " (VIA8 bar is covered by SEALRING layer and only allowed in seal-ring and fuse protecion ring)"; 
          internal1( VIA8_BAR, < VIA8_W_2, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          A = wide( VIA8_BAR, > VIA8_W_2, forty_five = INTERNAL ); 
          B = angle_edge( VIA8_BAR, == 45 ); 
          C = internal1( B, < ( VIA8_W_2 + GRID ), extension = RADIAL, intersecting = {  } ); 
          D = A not C; 
          contains( D, { 2, 0.005 }, FORTY_FIVE ); 
      } /* end of rule : VIA8.W.2 */
      rVIA8_S_1 @= { @ "VIA8.S.1 : Space >= " + VIA8_S_1 + " um"; 
          external1( VIA8, < VIA8_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : VIA8.S.1 */
      rVIA8_S_2 @= { @ "VIA8.S.2 : Space to 3-neighboring VIAz (<0.56 um distance) >= " + VIA8_S_2 + " um"; 
          X = rectangle_spacing1( VIA8, count = > 2, distance = < VIA8_S_2_S ); 
          external2( X, VIA8, < VIA8_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : VIA8.S.2 */
      rVIA8_EN_1 @= { @ "VIA8.EN.1 : Enclosure by M8 >= " + VIA8_EN_1 + " um"; 
          enclose( VIA8, M8, < VIA8_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          VIA8 not M8; 
      } /* end of rule : VIA8.EN.1 */
      rVIA8_EN_2 @= { @ "VIA8.EN.2 : Enclosure by M8 [at least two opposite sides] >= " + VIA8_EN_2 + " um"; 
          X = not_enclosed_by( VIA8, M8, distances = { { { VIA8_EN_1, RADIAL }, { VIA8_EN_2, NONE }, { VIA8_EN_1, RADIAL }, { VIA8_EN_2, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          Y = enclose_edge( X, M8, < VIA8_EN_2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Z = X touching_edge Y; 
          vertex( Z, angles = { 90 }, shape = TRIANGLE, shape_size = VIA8_W_1 );    /* adjacent narrow sides */ 
      } /* end of rule : VIA8.EN.2 */
      
      // VIA8.R.1 is checked by VIA8.W.1
      gLAYER_337 = size( size( M9, - ( VIA8_R_2_W / 2 ), clip_acute = BISECTOR ), VIA8_R_2_W / 2, clip_acute = BISECTOR ); 
      M9WIDE_1_p_8_VIA8T = gLAYER_337 and M9; 
      gLAYER_338 = size( size( M8, - ( VIA8_R_2_W / 2 ), clip_acute = BISECTOR ), VIA8_R_2_W / 2, clip_acute = BISECTOR ); 
      M8WIDE_1_p_8_VIA8T = gLAYER_338 and M8; 
      gLAYER_339 = size( size( M9WIDE_1_p_8_VIA8T, - ( VIA8_R_3_W / 2 ), clip_acute = BISECTOR ), VIA8_R_3_W / 2, clip_acute = BISECTOR ); 
      M9WIDE_3_VIA8T = gLAYER_339 and M9WIDE_1_p_8_VIA8T; 
      gLAYER_340 = size( size( M8WIDE_1_p_8_VIA8T, - ( VIA8_R_3_W / 2 ), clip_acute = BISECTOR ), VIA8_R_3_W / 2, clip_acute = BISECTOR ); 
      M8WIDE_3_VIA8T = gLAYER_340 and M8WIDE_1_p_8_VIA8T; 
      
      //VIA8.R.2.S is checked by VIA8.R.2
      rVIA8_R_2 @= { @ "VIA8.R.2 : At least two VIA8 with spacing <= " + VIA8_R_2_S + " um are required to connect M8 and M9 when one of these metals has a width and length > " + VIA8_R_2_W + " um."; 
          sLAYER_872 = M9 and M8WIDE_1_p_8_VIA8T; 
          sLAYER_873 = M8 and M9WIDE_1_p_8_VIA8T; 
          M9OVPM8W = sLAYER_872 or sLAYER_873; 
          CHECKED_VIA8 = VIA8_EXD not_outside M9OVPM8W; 
          M8_EFFECT = interacting( M8I, M9OVPM8W ); 
          M9_EFFECT = interacting( M9I, M9OVPM8W ); 
          EFFECT_M9OVPM8_ = M8_EFFECT and M9_EFFECT; 
          EFFECT_M9OVPM8 = interacting( EFFECT_M9OVPM8_, M9OVPM8W ); 
          EFFECT_VIA8 = interacting( VIA8_EXD, EFFECT_M9OVPM8 ); 
          VIA8MERGED = size_inside_wrapper( EFFECT_VIA8, EFFECT_M9OVPM8, distance = VIA8_R_2_S / 2, increment = M8_S_1 * 0.7 ); 
          VIA8MERGED2 = enclosing( VIA8MERGED, EFFECT_VIA8, >= 2 ); 
          GVIA = interacting( CHECKED_VIA8, VIA8MERGED2 ); 
          GM9OVPM8W = interacting( M9OVPM8W, GVIA ); 
          CHECKED_VIA8 outside GM9OVPM8W; 
      } /* end of rule : VIA8.R.2 */
      M8BIG_3_VIA8T = contains( M8WIDE_3_VIA8T, { VIA8_R_3_W, VIA8_R_3_L + GRID }, FORTY_FIVE ); 
      
      // VIA8.R.3 is checked by VIA8.R.3:M8 and VIA8.R.3:M9
      
      // VIA8.R.3.S is checked by VIA8.R.3:M8 and VIA8.R.3:M9
      rVIA8_R_3_M8 @= { @ "VIA8.R.3:M8 : At least two VIA8 must be used for a connection that is <= " + VIA8_R_3_D + " um (D) away from a metal plate (either M8 or M9) with length > " + VIA8_R_3_L + " um (L) and width > " + VIA8_R_3_W + " um (W). (It is allowed to use one VIA8 for a connection that is > " + VIA8_R_3_D + " um (D) away from a metal plate (either M8 or M9) with length> " + VIA8_R_3_L + " um (L) and width > " + VIA8_R_3_W + " um (W))."; 
          sLAYER_875 = size( M8BIG_3_VIA8T, clip_acute = NONE, distance = VIA8_R_3_D + GRID ); 
          sLAYER_874 = sLAYER_875 not M8BIG_3_VIA8T; 
          BRANCH1 = sLAYER_874 and M8; 
          sLAYER_876 = interacting( BRANCH1, M8BIG_3_VIA8T ); 
          BRANCH1HASVIA = interacting( sLAYER_876, VIA8 ); 
          BRANCH1EDGE = M8BIG_3_VIA8T coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA8_R_3_D, increment = M8_S_1 * 0.7 ); 
          sLAYER_877 = BRANCH and M9; 
          GOODBRANCH = interacting( sLAYER_877, VIA8, > 1 ); 
          sLAYER_878 = VIA8 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_878 outside GOODBRANCH; 
          sLAYER_881 = interacting( M9, BRANCHSINGLEVIA ); 
          sLAYER_880 = sLAYER_881 and M8; 
          sLAYER_879 = interacting( sLAYER_880, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_879, VIA8, == 1 ); 
          sLAYER_882 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_882 not VIA_EXD; 
      } /* end of rule : VIA8.R.3:M8 */
      M9BIG_3_VIA8T = contains( M9WIDE_3_VIA8T, { VIA8_R_3_W, VIA8_R_3_L + GRID }, FORTY_FIVE ); 
      rVIA8_R_3_M9 @= { @ "VIA8.R.3:M9 : At least two VIA8 must be used for a connection that is <= " + VIA8_R_3_D + " um (D) away from a metal plate (either M8 or M9) with length > " + VIA8_R_3_L + " um (L) and width > " + VIA8_R_3_W + " um (W). (It is allowed to use one VIA8 for a connection that is > " + VIA8_R_3_D + " um (D) away from a metal plate (either M8 or M9) with length> " + VIA8_R_3_L + " um (L) and width > " + VIA8_R_3_W + " um (W))."; 
          sLAYER_884 = size( M9BIG_3_VIA8T, clip_acute = NONE, distance = VIA8_R_3_D + GRID ); 
          sLAYER_883 = sLAYER_884 not M9BIG_3_VIA8T; 
          BRANCH1 = sLAYER_883 and M9; 
          sLAYER_885 = interacting( BRANCH1, M9BIG_3_VIA8T ); 
          BRANCH1HASVIA = interacting( sLAYER_885, VIA8 ); 
          BRANCH1EDGE = M9BIG_3_VIA8T coincident_outside_edge BRANCH1HASVIA; 
          BRANCH1REC = edge_size( BRANCH1EDGE, outside = GRID ); 
          BRANCH = size_inside_wrapper( BRANCH1REC, BRANCH1HASVIA, distance = VIA8_R_3_D, increment = M9_S_1 * 0.7 ); 
          sLAYER_886 = BRANCH and M8; 
          GOODBRANCH = interacting( sLAYER_886, VIA8, > 1 ); 
          sLAYER_887 = VIA8 not_outside BRANCH; 
          BRANCHSINGLEVIA = sLAYER_887 outside GOODBRANCH; 
          sLAYER_890 = interacting( M8, BRANCHSINGLEVIA ); 
          sLAYER_889 = sLAYER_890 and M9; 
          sLAYER_888 = interacting( sLAYER_889, BRANCHSINGLEVIA ); 
          BAD_REGION = interacting( sLAYER_888, VIA8, == 1 ); 
          sLAYER_891 = interacting( BRANCHSINGLEVIA, BAD_REGION ); 
          sLAYER_891 not VIA_EXD; 
      } /* end of rule : VIA8.R.3:M9 */
      
      // VIA8.R.4 is checked by related rules (VIA8.EN.1 and M9.EN.1)
      // VIA8.R.5 can not be checked by DRC
      
      //M9 CHECKS
      //=============
      gLAYER_341 = size( size( M9, - ( M9_S_2_W / 2 ), clip_acute = BISECTOR ), M9_S_2_W / 2, clip_acute = BISECTOR ); 
      M9WIDE_1_p_5 = gLAYER_341 and M9; 
      gLAYER_342 = size( size( M9WIDE_1_p_5, - ( M9_S_3_W / 2 ), clip_acute = BISECTOR ), M9_S_3_W / 2, clip_acute = BISECTOR ); 
      M9WIDE_4_p_5 = gLAYER_342 and M9WIDE_1_p_5; 
      M91 = M9WIDE_1_p_5 not MTOP_EXC; 
      M92 = M9WIDE_4_p_5 not MTOP_EXC; 
      M9NAS2 = area( M9, > ( M9_S_2_L * M9_W_1 ) );    /* filter small metal for M9.S.2 */ 
      M9NAS3 = area( M9NAS2, > ( M9_S_3_L * M9_W_1 ) );    /* filter small metal for M9.S.3 */ 
      rM9_W_1 @= { @ "M9.W.1 : Width >= " + M9_W_1 + " um"; 
          internal1( M9, < M9_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : M9.W.1 */
      rM9_W_2 @= { @ "M9.W.2 : Maximum width [except bond pad] <= " + M9_W_2 + " um"; 
          size( size( M9_MAX_WIDTH_M, - ( M9_W_2 / 2 ), clip_acute = BISECTOR ), M9_W_2 / 2, clip_acute = BISECTOR ); 
      } /* end of rule : M9.W.2 */
      rM9_S_1 @= { @ "M9.S.1 : Space >= " + M9_S_1 + " um"; 
          external1( M9, < M9_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : M9.S.1 */
      
      //M9.S.2.S is checked by M9.S.2 
      rM9_S_2 @= { @ "M9.S.2 : Space [at least one metal line width > " + M9_S_2_W + " um (W1) and the parallel metal run length > " + M9_S_2_L + " um (L1)] >= " + M9_S_2; 
          X = external2( M91, M9NAS2, < M9_S_2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M9; 
          contains( Y, { GRID, M9_S_2_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M9.S.2 */
      
      //M9.S.3.S is checked by M9.S.3 
      rM9_S_3 @= { @ "M9.S.3 : Space [at least one metal line width > " + M9_S_3_W + " um (W1) and the parallel metal run length > " + M9_S_3_L + " um (L1)] >= " + M9_S_3; 
          X = external2( M92, M9NAS3, < M9_S_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M9; 
          contains( Y, { GRID, M9_S_3_L + GRID }, FORTY_FIVE ); 
      } /* end of rule : M9.S.3 */
      rM9_EN_1 @= { @ "M9.EN.1 : Enclosure of VIA8 >= " + M9_EN_1; 
          enclose( VIA8, M9, < M9_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          VIA8 not M9; 
      } /* end of rule : M9.EN.1 */
      rM9_EN_2 @= { @ "M9.EN.2 : Enclosure of VIA8 [at least two opposite sides] >= " + M9_EN_2; 
          X = not_enclosed_by( VIA8, M9, distances = { { { M9_EN_1, RADIAL }, { M9_EN_2, NONE }, { M9_EN_1, RADIAL }, { M9_EN_2, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          Y = enclose_edge( X, M9, < M9_EN_2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Z = X touching_edge Y; 
          vertex( Z, angles = { 90 }, shape = TRIANGLE, shape_size = VIA8_W_1 );    /* adjacent narrow sides */ 
      } /* end of rule : M9.EN.2 */
      rM9_A_1 @= { @ "M9.A.1 : Area >= " + M9_A_1 + " um2"; 
          area( M9, < M9_A_1 ); 
      } /* end of rule : M9.A.1 */
      rM9_A_2 @= { @ "M9.A.2 : Enclosed area >= " + M9_A_2 + " um2"; 
          X = donut_holes( M9, area = < M9_A_2PRE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          sLAYER_892 = X not M9; 
          area( sLAYER_892, < M9_A_2 ); 
      } /* end of rule : M9.A.2 */
      M9DN1H_EXC = M9_EXC or MTOP_EXC; 
      M9DN1L_EXC = copy( M9_EXC_LOW ); 
      #ifdef CHECK_LOW_DENSITY 
         rM9_DN_1 @= { @ "M9.DN.1 : M9 local density must be >= " + M9_DN_1L + " range over " + M9_DN_1L_W + " um x " + M9_DN_1L_W + " um step " + M9_DN_1L_S + " um"; 
             M9_CHECK = M9X not M9DN1L_EXC; 
             CHIP_CHECK = gCHIP not M9DN1L_EXC; 
         _den_con = < M9_DN_1L; 
         _den_polygon_area_clip = false;
         _den_print = false;
         _den_print_only = false;
             ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M9_CHECK, "layer2" => CHIP_CHECK }, delta_window = { M9_DN_1L_W, M9_DN_1L_W }, delta_x = M9_DN_1L_S, delta_y = M9_DN_1L_S, boundary = BACKUP, window_function = den_save_window_1 ); 
             sLAYER_893 = ERR_WIN not M9DN1L_EXC; 
             F = wide( sLAYER_893, >= M9_DN_1L_E, forty_five = INTERNAL ); 
             VAR_52 = density_statistics_file( file = "M9.DN.1.density" ); 
         _den_con = < M9_DN_1L; 
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M9_CHECK, "layer3" => CHIP_CHECK }, delta_window = { M9_DN_1L_W, M9_DN_1L_W }, delta_x = M9_DN_1L_S, delta_y = M9_DN_1L_S, boundary = BACKUP, statistics_files = { VAR_52 }, window_function = den_save_window_2 ); 
         } /* end of rule : M9.DN.1 */
      #endif /* end of #ifdef CHECK_LOW_DENSITY  */ 
      rM9_DN_1_1 @= { @ "M9.DN.1.1 : M9 local density must be <= " + M9_DN_1H + " range over " + M9_DN_1H_W + " um x " + M9_DN_1H_W + " um step " + M9_DN_1H_S + " um"; 
          M9_CHECK = M9X not M9DN1H_EXC; 
          CHIP_CHECK = gCHIP not M9DN1H_EXC; 
      _den_con = > M9_DN_1H; 
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M9_CHECK, "layer2" => CHIP_CHECK }, delta_window = { M9_DN_1H_W, M9_DN_1H_W }, delta_x = M9_DN_1H_S, delta_y = M9_DN_1H_S, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_894 = ERR_WIN not M9DN1H_EXC; 
          F = wide( sLAYER_894, >= M9_DN_1H_E, forty_five = INTERNAL ); 
          VAR_53 = density_statistics_file( file = "M9.DN.1.1.density" ); 
      _den_con = > M9_DN_1H; 
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M9_CHECK, "layer3" => CHIP_CHECK }, delta_window = { M9_DN_1H_W, M9_DN_1H_W }, delta_x = M9_DN_1H_S, delta_y = M9_DN_1H_S, boundary = BACKUP, statistics_files = { VAR_53 }, window_function = den_save_window_3 ); 
      } /* end of rule : M9.DN.1.1 */
      gLAYER_343 = MTOP_EXC or LMARK; 
      M9DN2_EXC = gLAYER_343 or IND_EXD; 
      rM9_DN_2 @= { @ "M9.DN.2 : M9 local density must be <= " + M9_DN_2 + " range over " + M9_DN_2_W + " um x " + M9_DN_2_W + " um step " + M9_DN_2_S + " um"; 
          M9_CHECK = M9X not M9DN2_EXC; 
      _den_con = > M9_DN_2; 
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => M9_CHECK, "layer2" => gCHIP }, delta_window = { M9_DN_2_W, M9_DN_2_W }, delta_x = M9_DN_2_S, delta_y = M9_DN_2_S, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_895 = ERR_WIN not M9DN2_EXC; 
          F = wide( sLAYER_895, >= M9_DN_2_E, forty_five = INTERNAL ); 
          VAR_54 = density_statistics_file( file = "M9.DN.2.density" ); 
      _den_con = > M9_DN_2; 
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => F, "layer2" => M9_CHECK, "layer3" => gCHIP }, delta_window = { M9_DN_2_W, M9_DN_2_W }, delta_x = M9_DN_2_S, delta_y = M9_DN_2_S, boundary = BACKUP, statistics_files = { VAR_54 }, window_function = den_save_window_3 ); 
      } /* end of rule : M9.DN.2 */
      rM9_DN_4 @= { @ "M9.DN.4 : The metal density difference between any two " + M9_DN_4_W + " um x " + M9_DN_4_W + " um neighboring checking windows including DM9EXCL <= " + M9_DN_4; 
          sLAYER_1334 = chip_extent();
          VAR_55 = density_statistics_file( file = "M9.DN.4.density" ); 
      _gden_con = <= 1;
      _gden_gcon = > M9_DN_4; 
      _gden_absolute = true;
      _gden_corner = true;
      _gden_corner_value = -1.0;
      _gden_polygon_area_clip = true;
      _gden_print = true;
      _gden_print_only = false;
          sLAYER_1334 = sLAYER_1334 or gCHIP;
gradient_density( window_layer = sLAYER_1334, layer_hash = { "layer1" => M9X, "layer2" => gCHIP }, delta_window = { M9_DN_4_W, M9_DN_4_W }, delta_x = M9_DN_4_W, delta_y = M9_DN_4_W, boundary = BACKUP, statistics_files = { VAR_55 }, window_function = gden_save_window_7 ); 
      } /* end of rule : M9.DN.4 */
      
      //M9.R.1U is not necessary to check
      
      //CTM CHECKS
      //==========
      #ifdef HALF_NODE 
         rCTM_R_3 @= { @ "CTM.R.3 : CTM/CBM is not allowed in N55 technology, DRC will flag CTM layer";
             copy( CTM ); 
             copy( CBM ); 
         } /* end of rule : CTM.R.3 */
      #else /* the reverse of #ifdef HALF_NODE  */ 
         rCTM_W_1 @= { @ "CTM.W.1 : Width >= " + CTM_W_1 + " um"; 
             internal1( CTM, < CTM_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
         } /* end of rule : CTM.W.1 */
         rCTM_W_2 @= { @ "CTM.W.2 : Maximum length and width <= " + CTM_W_2 + " um"; 
             contains( CTM, { CTM_W_1, CTM_W_2 + GRID } ); 
         } /* end of rule : CTM.W.2 */
         rCTM_S_1 @= { @ "CTM.S.1 : Space >= " + CTM_S_1 + " um"; 
             external1( CTM, < CTM_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
         } /* end of rule : CTM.S.1 */
         rCTM_EN_1 @= { @ "CTM.EN.1 : Enclosure by CBM  >= " + CTM_EN_1 + " um (CTM must be fully inside CBM)"; 
             enclose( CTM, CBM, < CTM_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
             CTM not CBM; 
         } /* end of rule : CTM.EN.1 */
         rCTM_R_1 @= { @ "CTM.R.1 : The different unit capacitance can not co-exist on same product";
             X = interacting( CHIPX, CTMDMY_10 ); 
             interacting( X, CTMDMY_15 ); 
             interacting( X, CTMDMY_20 ); 
             Y = interacting( CHIPX, CTMDMY_15 ); 
             interacting( Y, CTMDMY_20 ); 
         } /* end of rule : CTM.R.1 */
         rCTM_R_4 @= { @ "CTM.R.4 : Two metals connect to the CTM without the same connection is not allowed V";
             interacting( CTM_M, VCAP_CTM7_M, > 1, connect_sequence = CONNECT_DB, count_by = NET ); 
         } /* end of rule : CTM.R.4 */
      #endif /* end of #ifdef HALF_NODE  */ 
      
      //CBM CHECKS
      //==========
      #ifdef HALF_NODE 
         rCBM_WARN @= { @ "CBM:WARN : N55 process does not support MIM device";
             copy( CBM ); 
         } /* end of rule : CBM:WARN */
      #else /* the reverse of #ifdef HALF_NODE  */ 
         rCBM_W_1 @= { @ "CBM.W.1 : Width >= " + CBM_W_1 + " um"; 
             internal1( CBM, < CBM_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
         } /* end of rule : CBM.W.1 */
         rCBM_W_2 @= { @ "CBM.W.2 : Maximum length and width <= " + CBM_W_2 + " um"; 
             contains( CBM, { CBM_W_1, CBM_W_2 + GRID } ); 
         } /* end of rule : CBM.W.2 */
         rCBM_S_1 @= { @ "CBM.S.1 : Space (For CTMDMY area <= " + CBM_S_1_A + " um2) >= " + CBM_S_1 + " um"; 
             CTMDMY_S = area( CTMDMY, <= CBM_S_1_A ); 
             CBM_S = CBM and CTMDMY_S; 
             external1( CBM_S, < CBM_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
         } /* end of rule : CBM.S.1 */
         rCBM_S_2 @= { @ "CBM.S.2 : Space (For CTMDMY area > " + CBM_S_2_A + " um2)  >= " + CBM_S_2 + " um"; 
             CTMDMY_W = area( CTMDMY, > CBM_S_2_A ); 
             CBM_W = CBM and CTMDMY_W; 
             external1( CBM_W, < CBM_S_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
         } /* end of rule : CBM.S.2 */
         rCBM_S_3 @= { @ "CBM.S.3 : Space to the top Mx (M7) >= " + CBM_S_3 + " um."; 
             external2( MBOT, CBM, < CBM_S_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
         } /* end of rule : CBM.S.3 */
         rCBM_EN_2 @= { @ "CBM.EN.2 : CTMDMY is equal to CBM layer sizing up " + CBM_EN_2 + " um for each side. " 
                                     "DRC checking layer(CTMDMY,GDS layer 148) is needed to specify MiM capacitor region.";
             A = size( CBM, clip_acute = NONE, distance = CBM_EN_2 ); 
             A xor CTMDMY; 
             sLAYER_896 = interacting( CTMDMY, CTMDMY_10 ); 
             sLAYER_896 xor CTMDMY_10; 
             sLAYER_897 = interacting( CTMDMY, CTMDMY_15 ); 
             sLAYER_897 xor CTMDMY_15; 
             sLAYER_898 = interacting( CTMDMY, CTMDMY_20 ); 
             sLAYER_898 xor CTMDMY_20; 
         } /* end of rule : CBM.EN.2 */
         rCBM_R_1 @= { @ "CBM.R.1 : The top Mx (M7) layer (including the top dummy Mx) interacting with CBM is not allowed.";
             MBOTX and CBM; 
         } /* end of rule : CBM.R.1 */
         rCBM_R_4 @= { @ "CBM.R.4 : Two metals connect to the CBM without the same connection is not allowed V";
             interacting( CBM_M, VCAP_CBM7_M, > 1, connect_sequence = CONNECT_DB, count_by = NET ); 
         } /* end of rule : CBM.R.4 */
         
         //CBM.R.2gU can't be checked by DRC 
      #endif /* end of #ifdef HALF_NODE  */ 
      CHIP_MOM = copy( CHIPX ); 
      MOM_M1 = MOMDMY_1 and M1; 
      MOM_M1_EDGE = M1 coincident_inside_edge MOM_M1; 
      MOM_M1_LINE_END = adjacent_edge( MOM_M1_EDGE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M1_SIDE_EDGE = MOM_M1_EDGE not_coincident_inside_edge MOM_M1_LINE_END; 
      MOM_M1_SIDE_EDGE_FULL = M1I inside_touching_edge MOM_M1_SIDE_EDGE; 
      gLAYER_344 = MOMDMY_1 not_outside_touching_edge M1; 
      MOM_M1_SPACE_PRE = edge_size( gLAYER_344, corner_extension = INTERSECTION, outside = GRID ); 
      gLAYER_345 = MOMDMY_1 or MOM_M1_SPACE_PRE; 
      MOM_M1_SPACE = gLAYER_345 not M1; 
      MOM_M1_SPACE_90_90 = adjacent_edge( MOM_M1_SPACE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M1_SPACE_90_90_1 = adjacent_edge( MOM_M1_SPACE_90_90, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M1_SPACE_90_90_2 = adjacent_edge( MOM_M1_SPACE_90_90, adjacent2 = MISSING, angle1 = == 90, length = > 0 );
      gLAYER_347 = enclose_edge( MOM_M1_SIDE_EDGE_FULL, MOM_M1_SPACE_90_90_2, < GRID, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_CONTAINED, orientation = { }, output_layer = LAYER1 ); 
      gLAYER_346 = MOM_M1_SIDE_EDGE_FULL inside_touching_edge gLAYER_347; 
      LAST_M1_METAL_EDGE_PRE = MOM_M1_SIDE_EDGE coincident_inside_edge gLAYER_346; 
      gLAYER_350 = MOM_M1_SPACE_90_90_1 or_edge MOM_M1_SPACE_90_90_2; 
      gLAYER_349 = edge_size( gLAYER_350, inside = GRID ); 
      gLAYER_348 = polygon_extents( gLAYER_349 );
      LAST_M1_METAL_EDGE = and_edge( LAST_M1_METAL_EDGE_PRE, gLAYER_348, false ); 
      MOM_M1_SPACE_90_90_3 = MOM_M1_SPACE_90_90 not_coincident_edge MOM_M1_SPACE_90_90_1; 
      MOM_M1_SPACE_90_270 = adjacent_edge( MOM_M1_SPACE, angle1 = == 90, angle2 = == 270, length = > 0 ); 
      gLAYER_353 = MOM_M1_SPACE_90_90_3 or_edge MOM_M1_SPACE_90_270; 
      gLAYER_352 = edge_size( gLAYER_353, inside = GRID ); 
      gLAYER_351 = polygon_extents( gLAYER_352 );
      MOM_M1_METAL = and_edge( MOM_M1_SIDE_EDGE, gLAYER_351, false ); 
      MOM_M1_CAP_EDGE = MOM_M1_METAL not_coincident_edge LAST_M1_METAL_EDGE; 
      MOM_M2 = MOMDMY_2 and M2; 
      MOM_M2_EDGE = M2 coincident_inside_edge MOM_M2; 
      MOM_M2_LINE_END = adjacent_edge( MOM_M2_EDGE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M2_SIDE_EDGE = MOM_M2_EDGE not_coincident_inside_edge MOM_M2_LINE_END; 
      MOM_M2_SIDE_EDGE_FULL = M2I inside_touching_edge MOM_M2_SIDE_EDGE; 
      gLAYER_354 = MOMDMY_2 not_outside_touching_edge M2; 
      MOM_M2_SPACE_PRE = edge_size( gLAYER_354, corner_extension = INTERSECTION, outside = GRID ); 
      gLAYER_355 = MOMDMY_2 or MOM_M2_SPACE_PRE; 
      MOM_M2_SPACE = gLAYER_355 not M2; 
      MOM_M2_SPACE_90_90 = adjacent_edge( MOM_M2_SPACE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M2_SPACE_90_90_1 = adjacent_edge( MOM_M2_SPACE_90_90, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M2_SPACE_90_90_2 = adjacent_edge( MOM_M2_SPACE_90_90, adjacent2 = MISSING, angle1 = == 90, length = > 0 );
      gLAYER_357 = enclose_edge( MOM_M2_SIDE_EDGE_FULL, MOM_M2_SPACE_90_90_2, < GRID, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_CONTAINED, orientation = { }, output_layer = LAYER1 ); 
      gLAYER_356 = MOM_M2_SIDE_EDGE_FULL inside_touching_edge gLAYER_357; 
      LAST_M2_METAL_EDGE_PRE = MOM_M2_SIDE_EDGE coincident_inside_edge gLAYER_356; 
      gLAYER_360 = MOM_M2_SPACE_90_90_1 or_edge MOM_M2_SPACE_90_90_2; 
      gLAYER_359 = edge_size( gLAYER_360, inside = GRID ); 
      gLAYER_358 = polygon_extents( gLAYER_359 );
      LAST_M2_METAL_EDGE = and_edge( LAST_M2_METAL_EDGE_PRE, gLAYER_358, false ); 
      MOM_M2_SPACE_90_90_3 = MOM_M2_SPACE_90_90 not_coincident_edge MOM_M2_SPACE_90_90_1; 
      MOM_M2_SPACE_90_270 = adjacent_edge( MOM_M2_SPACE, angle1 = == 90, angle2 = == 270, length = > 0 ); 
      gLAYER_363 = MOM_M2_SPACE_90_90_3 or_edge MOM_M2_SPACE_90_270; 
      gLAYER_362 = edge_size( gLAYER_363, inside = GRID ); 
      gLAYER_361 = polygon_extents( gLAYER_362 );
      MOM_M2_METAL = and_edge( MOM_M2_SIDE_EDGE, gLAYER_361, false ); 
      MOM_M2_CAP_EDGE = MOM_M2_METAL not_coincident_edge LAST_M2_METAL_EDGE; 
      MOM_M3 = MOMDMY_3 and M3; 
      MOM_M3_EDGE = M3 coincident_inside_edge MOM_M3; 
      MOM_M3_LINE_END = adjacent_edge( MOM_M3_EDGE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M3_SIDE_EDGE = MOM_M3_EDGE not_coincident_inside_edge MOM_M3_LINE_END; 
      MOM_M3_SIDE_EDGE_FULL = M3I inside_touching_edge MOM_M3_SIDE_EDGE; 
      gLAYER_364 = MOMDMY_3 not_outside_touching_edge M3; 
      MOM_M3_SPACE_PRE = edge_size( gLAYER_364, corner_extension = INTERSECTION, outside = GRID ); 
      gLAYER_365 = MOMDMY_3 or MOM_M3_SPACE_PRE; 
      MOM_M3_SPACE = gLAYER_365 not M3; 
      MOM_M3_SPACE_90_90 = adjacent_edge( MOM_M3_SPACE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M3_SPACE_90_90_1 = adjacent_edge( MOM_M3_SPACE_90_90, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M3_SPACE_90_90_2 = adjacent_edge( MOM_M3_SPACE_90_90, adjacent2 = MISSING, angle1 = == 90, length = > 0 );
      gLAYER_367 = enclose_edge( MOM_M3_SIDE_EDGE_FULL, MOM_M3_SPACE_90_90_2, < GRID, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_CONTAINED, orientation = { }, output_layer = LAYER1 ); 
      gLAYER_366 = MOM_M3_SIDE_EDGE_FULL inside_touching_edge gLAYER_367; 
      LAST_M3_METAL_EDGE_PRE = MOM_M3_SIDE_EDGE coincident_inside_edge gLAYER_366; 
      gLAYER_370 = MOM_M3_SPACE_90_90_1 or_edge MOM_M3_SPACE_90_90_2; 
      gLAYER_369 = edge_size( gLAYER_370, inside = GRID ); 
      gLAYER_368 = polygon_extents( gLAYER_369 );
      LAST_M3_METAL_EDGE = and_edge( LAST_M3_METAL_EDGE_PRE, gLAYER_368, false ); 
      MOM_M3_SPACE_90_90_3 = MOM_M3_SPACE_90_90 not_coincident_edge MOM_M3_SPACE_90_90_1; 
      MOM_M3_SPACE_90_270 = adjacent_edge( MOM_M3_SPACE, angle1 = == 90, angle2 = == 270, length = > 0 ); 
      gLAYER_373 = MOM_M3_SPACE_90_90_3 or_edge MOM_M3_SPACE_90_270; 
      gLAYER_372 = edge_size( gLAYER_373, inside = GRID ); 
      gLAYER_371 = polygon_extents( gLAYER_372 );
      MOM_M3_METAL = and_edge( MOM_M3_SIDE_EDGE, gLAYER_371, false ); 
      MOM_M3_CAP_EDGE = MOM_M3_METAL not_coincident_edge LAST_M3_METAL_EDGE; 
      MOM_M4 = MOMDMY_4 and M4; 
      MOM_M4_EDGE = M4 coincident_inside_edge MOM_M4; 
      MOM_M4_LINE_END = adjacent_edge( MOM_M4_EDGE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M4_SIDE_EDGE = MOM_M4_EDGE not_coincident_inside_edge MOM_M4_LINE_END; 
      MOM_M4_SIDE_EDGE_FULL = M4I inside_touching_edge MOM_M4_SIDE_EDGE; 
      gLAYER_374 = MOMDMY_4 not_outside_touching_edge M4; 
      MOM_M4_SPACE_PRE = edge_size( gLAYER_374, corner_extension = INTERSECTION, outside = GRID ); 
      gLAYER_375 = MOMDMY_4 or MOM_M4_SPACE_PRE; 
      MOM_M4_SPACE = gLAYER_375 not M4; 
      MOM_M4_SPACE_90_90 = adjacent_edge( MOM_M4_SPACE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M4_SPACE_90_90_1 = adjacent_edge( MOM_M4_SPACE_90_90, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M4_SPACE_90_90_2 = adjacent_edge( MOM_M4_SPACE_90_90, adjacent2 = MISSING, angle1 = == 90, length = > 0 );
      gLAYER_377 = enclose_edge( MOM_M4_SIDE_EDGE_FULL, MOM_M4_SPACE_90_90_2, < GRID, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_CONTAINED, orientation = { }, output_layer = LAYER1 ); 
      gLAYER_376 = MOM_M4_SIDE_EDGE_FULL inside_touching_edge gLAYER_377; 
      LAST_M4_METAL_EDGE_PRE = MOM_M4_SIDE_EDGE coincident_inside_edge gLAYER_376; 
      gLAYER_380 = MOM_M4_SPACE_90_90_1 or_edge MOM_M4_SPACE_90_90_2; 
      gLAYER_379 = edge_size( gLAYER_380, inside = GRID ); 
      gLAYER_378 = polygon_extents( gLAYER_379 );
      LAST_M4_METAL_EDGE = and_edge( LAST_M4_METAL_EDGE_PRE, gLAYER_378, false ); 
      MOM_M4_SPACE_90_90_3 = MOM_M4_SPACE_90_90 not_coincident_edge MOM_M4_SPACE_90_90_1; 
      MOM_M4_SPACE_90_270 = adjacent_edge( MOM_M4_SPACE, angle1 = == 90, angle2 = == 270, length = > 0 ); 
      gLAYER_383 = MOM_M4_SPACE_90_90_3 or_edge MOM_M4_SPACE_90_270; 
      gLAYER_382 = edge_size( gLAYER_383, inside = GRID ); 
      gLAYER_381 = polygon_extents( gLAYER_382 );
      MOM_M4_METAL = and_edge( MOM_M4_SIDE_EDGE, gLAYER_381, false ); 
      MOM_M4_CAP_EDGE = MOM_M4_METAL not_coincident_edge LAST_M4_METAL_EDGE; 
      MOM_M5 = MOMDMY_5 and M5; 
      MOM_M5_EDGE = M5 coincident_inside_edge MOM_M5; 
      MOM_M5_LINE_END = adjacent_edge( MOM_M5_EDGE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M5_SIDE_EDGE = MOM_M5_EDGE not_coincident_inside_edge MOM_M5_LINE_END; 
      MOM_M5_SIDE_EDGE_FULL = M5I inside_touching_edge MOM_M5_SIDE_EDGE; 
      gLAYER_384 = MOMDMY_5 not_outside_touching_edge M5; 
      MOM_M5_SPACE_PRE = edge_size( gLAYER_384, corner_extension = INTERSECTION, outside = GRID ); 
      gLAYER_385 = MOMDMY_5 or MOM_M5_SPACE_PRE; 
      MOM_M5_SPACE = gLAYER_385 not M5; 
      MOM_M5_SPACE_90_90 = adjacent_edge( MOM_M5_SPACE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M5_SPACE_90_90_1 = adjacent_edge( MOM_M5_SPACE_90_90, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M5_SPACE_90_90_2 = adjacent_edge( MOM_M5_SPACE_90_90, adjacent2 = MISSING, angle1 = == 90, length = > 0 );
      gLAYER_387 = enclose_edge( MOM_M5_SIDE_EDGE_FULL, MOM_M5_SPACE_90_90_2, < GRID, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_CONTAINED, orientation = { }, output_layer = LAYER1 ); 
      gLAYER_386 = MOM_M5_SIDE_EDGE_FULL inside_touching_edge gLAYER_387; 
      LAST_M5_METAL_EDGE_PRE = MOM_M5_SIDE_EDGE coincident_inside_edge gLAYER_386; 
      gLAYER_390 = MOM_M5_SPACE_90_90_1 or_edge MOM_M5_SPACE_90_90_2; 
      gLAYER_389 = edge_size( gLAYER_390, inside = GRID ); 
      gLAYER_388 = polygon_extents( gLAYER_389 );
      LAST_M5_METAL_EDGE = and_edge( LAST_M5_METAL_EDGE_PRE, gLAYER_388, false ); 
      MOM_M5_SPACE_90_90_3 = MOM_M5_SPACE_90_90 not_coincident_edge MOM_M5_SPACE_90_90_1; 
      MOM_M5_SPACE_90_270 = adjacent_edge( MOM_M5_SPACE, angle1 = == 90, angle2 = == 270, length = > 0 ); 
      gLAYER_393 = MOM_M5_SPACE_90_90_3 or_edge MOM_M5_SPACE_90_270; 
      gLAYER_392 = edge_size( gLAYER_393, inside = GRID ); 
      gLAYER_391 = polygon_extents( gLAYER_392 );
      MOM_M5_METAL = and_edge( MOM_M5_SIDE_EDGE, gLAYER_391, false ); 
      MOM_M5_CAP_EDGE = MOM_M5_METAL not_coincident_edge LAST_M5_METAL_EDGE; 
      MOM_M6 = MOMDMY_6 and M6; 
      MOM_M6_EDGE = M6 coincident_inside_edge MOM_M6; 
      MOM_M6_LINE_END = adjacent_edge( MOM_M6_EDGE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M6_SIDE_EDGE = MOM_M6_EDGE not_coincident_inside_edge MOM_M6_LINE_END; 
      MOM_M6_SIDE_EDGE_FULL = M6I inside_touching_edge MOM_M6_SIDE_EDGE; 
      gLAYER_394 = MOMDMY_6 not_outside_touching_edge M6; 
      MOM_M6_SPACE_PRE = edge_size( gLAYER_394, corner_extension = INTERSECTION, outside = GRID ); 
      gLAYER_395 = MOMDMY_6 or MOM_M6_SPACE_PRE; 
      MOM_M6_SPACE = gLAYER_395 not M6; 
      MOM_M6_SPACE_90_90 = adjacent_edge( MOM_M6_SPACE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M6_SPACE_90_90_1 = adjacent_edge( MOM_M6_SPACE_90_90, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M6_SPACE_90_90_2 = adjacent_edge( MOM_M6_SPACE_90_90, adjacent2 = MISSING, angle1 = == 90, length = > 0 );
      gLAYER_397 = enclose_edge( MOM_M6_SIDE_EDGE_FULL, MOM_M6_SPACE_90_90_2, < GRID, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_CONTAINED, orientation = { }, output_layer = LAYER1 ); 
      gLAYER_396 = MOM_M6_SIDE_EDGE_FULL inside_touching_edge gLAYER_397; 
      LAST_M6_METAL_EDGE_PRE = MOM_M6_SIDE_EDGE coincident_inside_edge gLAYER_396; 
      gLAYER_400 = MOM_M6_SPACE_90_90_1 or_edge MOM_M6_SPACE_90_90_2; 
      gLAYER_399 = edge_size( gLAYER_400, inside = GRID ); 
      gLAYER_398 = polygon_extents( gLAYER_399 );
      LAST_M6_METAL_EDGE = and_edge( LAST_M6_METAL_EDGE_PRE, gLAYER_398, false ); 
      MOM_M6_SPACE_90_90_3 = MOM_M6_SPACE_90_90 not_coincident_edge MOM_M6_SPACE_90_90_1; 
      MOM_M6_SPACE_90_270 = adjacent_edge( MOM_M6_SPACE, angle1 = == 90, angle2 = == 270, length = > 0 ); 
      gLAYER_403 = MOM_M6_SPACE_90_90_3 or_edge MOM_M6_SPACE_90_270; 
      gLAYER_402 = edge_size( gLAYER_403, inside = GRID ); 
      gLAYER_401 = polygon_extents( gLAYER_402 );
      MOM_M6_METAL = and_edge( MOM_M6_SIDE_EDGE, gLAYER_401, false ); 
      MOM_M6_CAP_EDGE = MOM_M6_METAL not_coincident_edge LAST_M6_METAL_EDGE; 
      MOM_M7 = MOMDMY_7 and M7; 
      MOM_M7_EDGE = M7 coincident_inside_edge MOM_M7; 
      MOM_M7_LINE_END = adjacent_edge( MOM_M7_EDGE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M7_SIDE_EDGE = MOM_M7_EDGE not_coincident_inside_edge MOM_M7_LINE_END; 
      MOM_M7_SIDE_EDGE_FULL = M7I inside_touching_edge MOM_M7_SIDE_EDGE; 
      gLAYER_404 = MOMDMY_7 not_outside_touching_edge M7; 
      MOM_M7_SPACE_PRE = edge_size( gLAYER_404, corner_extension = INTERSECTION, outside = GRID ); 
      gLAYER_405 = MOMDMY_7 or MOM_M7_SPACE_PRE; 
      MOM_M7_SPACE = gLAYER_405 not M7; 
      MOM_M7_SPACE_90_90 = adjacent_edge( MOM_M7_SPACE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M7_SPACE_90_90_1 = adjacent_edge( MOM_M7_SPACE_90_90, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M7_SPACE_90_90_2 = adjacent_edge( MOM_M7_SPACE_90_90, adjacent2 = MISSING, angle1 = == 90, length = > 0 );
      gLAYER_407 = enclose_edge( MOM_M7_SIDE_EDGE_FULL, MOM_M7_SPACE_90_90_2, < GRID, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_CONTAINED, orientation = { }, output_layer = LAYER1 ); 
      gLAYER_406 = MOM_M7_SIDE_EDGE_FULL inside_touching_edge gLAYER_407; 
      LAST_M7_METAL_EDGE_PRE = MOM_M7_SIDE_EDGE coincident_inside_edge gLAYER_406; 
      gLAYER_410 = MOM_M7_SPACE_90_90_1 or_edge MOM_M7_SPACE_90_90_2; 
      gLAYER_409 = edge_size( gLAYER_410, inside = GRID ); 
      gLAYER_408 = polygon_extents( gLAYER_409 );
      LAST_M7_METAL_EDGE = and_edge( LAST_M7_METAL_EDGE_PRE, gLAYER_408, false ); 
      MOM_M7_SPACE_90_90_3 = MOM_M7_SPACE_90_90 not_coincident_edge MOM_M7_SPACE_90_90_1; 
      MOM_M7_SPACE_90_270 = adjacent_edge( MOM_M7_SPACE, angle1 = == 90, angle2 = == 270, length = > 0 ); 
      gLAYER_413 = MOM_M7_SPACE_90_90_3 or_edge MOM_M7_SPACE_90_270; 
      gLAYER_412 = edge_size( gLAYER_413, inside = GRID ); 
      gLAYER_411 = polygon_extents( gLAYER_412 );
      MOM_M7_METAL = and_edge( MOM_M7_SIDE_EDGE, gLAYER_411, false ); 
      MOM_M7_CAP_EDGE = MOM_M7_METAL not_coincident_edge LAST_M7_METAL_EDGE; 
      MOM_M8 = MOMDMY_8 and M8; 
      MOM_M8_EDGE = M8 coincident_inside_edge MOM_M8; 
      MOM_M8_LINE_END = adjacent_edge( MOM_M8_EDGE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M8_SIDE_EDGE = MOM_M8_EDGE not_coincident_inside_edge MOM_M8_LINE_END; 
      MOM_M8_SIDE_EDGE_FULL = M8I inside_touching_edge MOM_M8_SIDE_EDGE; 
      gLAYER_414 = MOMDMY_8 not_outside_touching_edge M8; 
      MOM_M8_SPACE_PRE = edge_size( gLAYER_414, corner_extension = INTERSECTION, outside = GRID ); 
      gLAYER_415 = MOMDMY_8 or MOM_M8_SPACE_PRE; 
      MOM_M8_SPACE = gLAYER_415 not M8; 
      MOM_M8_SPACE_90_90 = adjacent_edge( MOM_M8_SPACE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M8_SPACE_90_90_1 = adjacent_edge( MOM_M8_SPACE_90_90, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M8_SPACE_90_90_2 = adjacent_edge( MOM_M8_SPACE_90_90, adjacent2 = MISSING, angle1 = == 90, length = > 0 );
      gLAYER_417 = enclose_edge( MOM_M8_SIDE_EDGE_FULL, MOM_M8_SPACE_90_90_2, < GRID, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_CONTAINED, orientation = { }, output_layer = LAYER1 ); 
      gLAYER_416 = MOM_M8_SIDE_EDGE_FULL inside_touching_edge gLAYER_417; 
      LAST_M8_METAL_EDGE_PRE = MOM_M8_SIDE_EDGE coincident_inside_edge gLAYER_416; 
      gLAYER_420 = MOM_M8_SPACE_90_90_1 or_edge MOM_M8_SPACE_90_90_2; 
      gLAYER_419 = edge_size( gLAYER_420, inside = GRID ); 
      gLAYER_418 = polygon_extents( gLAYER_419 );
      LAST_M8_METAL_EDGE = and_edge( LAST_M8_METAL_EDGE_PRE, gLAYER_418, false ); 
      MOM_M8_SPACE_90_90_3 = MOM_M8_SPACE_90_90 not_coincident_edge MOM_M8_SPACE_90_90_1; 
      MOM_M8_SPACE_90_270 = adjacent_edge( MOM_M8_SPACE, angle1 = == 90, angle2 = == 270, length = > 0 ); 
      gLAYER_423 = MOM_M8_SPACE_90_90_3 or_edge MOM_M8_SPACE_90_270; 
      gLAYER_422 = edge_size( gLAYER_423, inside = GRID ); 
      gLAYER_421 = polygon_extents( gLAYER_422 );
      MOM_M8_METAL = and_edge( MOM_M8_SIDE_EDGE, gLAYER_421, false ); 
      MOM_M8_CAP_EDGE = MOM_M8_METAL not_coincident_edge LAST_M8_METAL_EDGE; 
      MOM_M9 = MOMDMY_9 and M9; 
      MOM_M9_EDGE = M9 coincident_inside_edge MOM_M9; 
      MOM_M9_LINE_END = adjacent_edge( MOM_M9_EDGE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M9_SIDE_EDGE = MOM_M9_EDGE not_coincident_inside_edge MOM_M9_LINE_END; 
      MOM_M9_SIDE_EDGE_FULL = M9I inside_touching_edge MOM_M9_SIDE_EDGE; 
      gLAYER_424 = MOMDMY_9 not_outside_touching_edge M9; 
      MOM_M9_SPACE_PRE = edge_size( gLAYER_424, corner_extension = INTERSECTION, outside = GRID ); 
      gLAYER_425 = MOMDMY_9 or MOM_M9_SPACE_PRE; 
      MOM_M9_SPACE = gLAYER_425 not M9; 
      MOM_M9_SPACE_90_90 = adjacent_edge( MOM_M9_SPACE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M9_SPACE_90_90_1 = adjacent_edge( MOM_M9_SPACE_90_90, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_M9_SPACE_90_90_2 = adjacent_edge( MOM_M9_SPACE_90_90, adjacent2 = MISSING, angle1 = == 90, length = > 0 );
      gLAYER_427 = enclose_edge( MOM_M9_SIDE_EDGE_FULL, MOM_M9_SPACE_90_90_2, < GRID, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_CONTAINED, orientation = { }, output_layer = LAYER1 ); 
      gLAYER_426 = MOM_M9_SIDE_EDGE_FULL inside_touching_edge gLAYER_427; 
      LAST_M9_METAL_EDGE_PRE = MOM_M9_SIDE_EDGE coincident_inside_edge gLAYER_426; 
      gLAYER_430 = MOM_M9_SPACE_90_90_1 or_edge MOM_M9_SPACE_90_90_2; 
      gLAYER_429 = edge_size( gLAYER_430, inside = GRID ); 
      gLAYER_428 = polygon_extents( gLAYER_429 );
      LAST_M9_METAL_EDGE = and_edge( LAST_M9_METAL_EDGE_PRE, gLAYER_428, false ); 
      MOM_M9_SPACE_90_90_3 = MOM_M9_SPACE_90_90 not_coincident_edge MOM_M9_SPACE_90_90_1; 
      MOM_M9_SPACE_90_270 = adjacent_edge( MOM_M9_SPACE, angle1 = == 90, angle2 = == 270, length = > 0 ); 
      gLAYER_433 = MOM_M9_SPACE_90_90_3 or_edge MOM_M9_SPACE_90_270; 
      gLAYER_432 = edge_size( gLAYER_433, inside = GRID ); 
      gLAYER_431 = polygon_extents( gLAYER_432 );
      MOM_M9_METAL = and_edge( MOM_M9_SIDE_EDGE, gLAYER_431, false ); 
      MOM_M9_CAP_EDGE = MOM_M9_METAL not_coincident_edge LAST_M9_METAL_EDGE; 
      gLAYER_435 = MOMDMY_1 and MOMDMY_2; 
      gLAYER_434 = enclosing( gLAYER_435, VIA1, > 4 ); 
      MOM_VIA1 = VIA1 and gLAYER_434; 
      MOM_VIA1_C = copy( MOM_VIA1 ); 
      gLAYER_437 = MOMDMY_2 and MOMDMY_3; 
      gLAYER_436 = enclosing( gLAYER_437, VIA2, > 4 ); 
      MOM_VIA2 = VIA2 and gLAYER_436; 
      MOM_VIA2_C = copy( MOM_VIA2 ); 
      gLAYER_439 = MOMDMY_3 and MOMDMY_4; 
      gLAYER_438 = enclosing( gLAYER_439, VIA3, > 4 ); 
      MOM_VIA3 = VIA3 and gLAYER_438; 
      MOM_VIA3_C = copy( MOM_VIA3 ); 
      gLAYER_441 = MOMDMY_4 and MOMDMY_5; 
      gLAYER_440 = enclosing( gLAYER_441, VIA4, > 4 ); 
      MOM_VIA4 = VIA4 and gLAYER_440; 
      MOM_VIA4_C = copy( MOM_VIA4 ); 
      gLAYER_443 = MOMDMY_5 and MOMDMY_6; 
      gLAYER_442 = enclosing( gLAYER_443, VIA5, > 4 ); 
      MOM_VIA5 = VIA5 and gLAYER_442; 
      MOM_VIA5_C = copy( MOM_VIA5 ); 
      gLAYER_445 = MOMDMY_6 and MOMDMY_7; 
      gLAYER_444 = enclosing( gLAYER_445, VIA6, > 4 ); 
      MOM_VIA6 = VIA6 and gLAYER_444; 
      MOM_VIA6_C = copy( MOM_VIA6 ); 
      gLAYER_447 = MOMDMY_7 and MOMDMY_8; 
      gLAYER_446 = enclosing( gLAYER_447, VIA7, > 4 ); 
      MOM_VIA7 = VIA7 and gLAYER_446; 
      MOM_VIA7_C = copy( MOM_VIA7 ); 
      gLAYER_449 = MOMDMY_8 and MOMDMY_9; 
      gLAYER_448 = enclosing( gLAYER_449, VIA8, > 4 ); 
      MOM_VIA8 = VIA8 and gLAYER_448; 
      MOM_VIA8_C = copy( MOM_VIA8 ); 
      gLAYER_451 = MOMDMY_9 and MOMDMY_AP; 
      gLAYER_450 = enclosing( gLAYER_451, RV, > 4 ); 
      MOM_RV = RV and gLAYER_450; 
      MOM_RV_C = copy( MOM_RV ); 
      MOMDMY_1_WIVIA = enclosing( MOMDMY_1, MOM_VIA1 ); 
      MOMDMY_1_WOVIA = MOMDMY_1 not MOMDMY_1_WIVIA; 
      MOM_M1_WIVIA = MOMDMY_1_WIVIA and M1; 
      MOM_M1_WOVIA = MOMDMY_1_WOVIA and M1; 
      gLAYER_452 = enclosing( MOMDMY_2, MOM_VIA1 ); 
      gLAYER_453 = enclosing( MOMDMY_2, MOM_VIA2 ); 
      MOMDMY_2_WIVIA = gLAYER_452 or gLAYER_453; 
      MOMDMY_2_WOVIA = MOMDMY_2 not MOMDMY_2_WIVIA; 
      MOM_M2_WIVIA = MOMDMY_2_WIVIA and M2; 
      MOM_M2_WOVIA = MOMDMY_2_WOVIA and M2; 
      gLAYER_454 = enclosing( MOMDMY_3, MOM_VIA2 ); 
      gLAYER_455 = enclosing( MOMDMY_3, MOM_VIA3 ); 
      MOMDMY_3_WIVIA = gLAYER_454 or gLAYER_455; 
      MOMDMY_3_WOVIA = MOMDMY_3 not MOMDMY_3_WIVIA; 
      MOM_M3_WIVIA = MOMDMY_3_WIVIA and M3; 
      MOM_M3_WOVIA = MOMDMY_3_WOVIA and M3; 
      gLAYER_456 = enclosing( MOMDMY_4, MOM_VIA3 ); 
      gLAYER_457 = enclosing( MOMDMY_4, MOM_VIA4 ); 
      MOMDMY_4_WIVIA = gLAYER_456 or gLAYER_457; 
      MOMDMY_4_WOVIA = MOMDMY_4 not MOMDMY_4_WIVIA; 
      MOM_M4_WIVIA = MOMDMY_4_WIVIA and M4; 
      MOM_M4_WOVIA = MOMDMY_4_WOVIA and M4; 
      gLAYER_458 = enclosing( MOMDMY_5, MOM_VIA4 ); 
      gLAYER_459 = enclosing( MOMDMY_5, MOM_VIA5 ); 
      MOMDMY_5_WIVIA = gLAYER_458 or gLAYER_459; 
      MOMDMY_5_WOVIA = MOMDMY_5 not MOMDMY_5_WIVIA; 
      MOM_M5_WIVIA = MOMDMY_5_WIVIA and M5; 
      MOM_M5_WOVIA = MOMDMY_5_WOVIA and M5; 
      gLAYER_460 = enclosing( MOMDMY_6, MOM_VIA5 ); 
      gLAYER_461 = enclosing( MOMDMY_6, MOM_VIA6 ); 
      MOMDMY_6_WIVIA = gLAYER_460 or gLAYER_461; 
      MOMDMY_6_WOVIA = MOMDMY_6 not MOMDMY_6_WIVIA; 
      MOM_M6_WIVIA = MOMDMY_6_WIVIA and M6; 
      MOM_M6_WOVIA = MOMDMY_6_WOVIA and M6; 
      gLAYER_462 = enclosing( MOMDMY_7, MOM_VIA6 ); 
      gLAYER_463 = enclosing( MOMDMY_7, MOM_VIA7 ); 
      MOMDMY_7_WIVIA = gLAYER_462 or gLAYER_463; 
      MOMDMY_7_WOVIA = MOMDMY_7 not MOMDMY_7_WIVIA; 
      MOM_M7_WIVIA = MOMDMY_7_WIVIA and M7; 
      MOM_M7_WOVIA = MOMDMY_7_WOVIA and M7; 
      gLAYER_464 = enclosing( MOMDMY_8, MOM_VIA7 ); 
      gLAYER_465 = enclosing( MOMDMY_8, MOM_VIA8 ); 
      MOMDMY_8_WIVIA = gLAYER_464 or gLAYER_465; 
      MOMDMY_8_WOVIA = MOMDMY_8 not MOMDMY_8_WIVIA; 
      MOM_M8_WIVIA = MOMDMY_8_WIVIA and M8; 
      MOM_M8_WOVIA = MOMDMY_8_WOVIA and M8; 
      gLAYER_466 = enclosing( MOMDMY_9, MOM_VIA8 ); 
      gLAYER_467 = enclosing( MOMDMY_9, MOM_RV ); 
      MOMDMY_9_WIVIA = gLAYER_466 or gLAYER_467; 
      MOMDMY_9_WOVIA = MOMDMY_9 not MOMDMY_9_WIVIA; 
      MOM_M9_WIVIA = MOMDMY_9_WIVIA and M9; 
      MOM_M9_WOVIA = MOMDMY_9_WOVIA and M9; 
      MOM_AP = MOMDMY_AP and AP; 
      MOM_AP_EDGE = AP coincident_inside_edge MOM_AP; 
      MOM_AP_LINE_END = adjacent_edge( MOM_AP_EDGE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_AP_SIDE_EDGE = MOM_AP_EDGE not_coincident_inside_edge MOM_AP_LINE_END; 
      MOM_AP_SIDE_EDGE_FULL = API inside_touching_edge MOM_AP_SIDE_EDGE; 
      gLAYER_468 = MOMDMY_AP not_outside_touching_edge AP; 
      MOM_AP_SPACE_PRE = edge_size( gLAYER_468, corner_extension = INTERSECTION, outside = GRID ); 
      gLAYER_469 = MOMDMY_AP or MOM_AP_SPACE_PRE; 
      MOM_AP_SPACE = gLAYER_469 not AP; 
      MOM_AP_SPACE_90_90 = adjacent_edge( MOM_AP_SPACE, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_AP_SPACE_90_90_1 = adjacent_edge( MOM_AP_SPACE_90_90, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MOM_AP_SPACE_90_90_2 = adjacent_edge( MOM_AP_SPACE_90_90, adjacent2 = MISSING, angle1 = == 90, length = > 0 );
      gLAYER_471 = enclose_edge( MOM_AP_SIDE_EDGE_FULL, MOM_AP_SPACE_90_90_2, < GRID, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 90, look_thru = NOT_CONTAINED, orientation = { }, output_layer = LAYER1 ); 
      gLAYER_470 = MOM_AP_SIDE_EDGE_FULL inside_touching_edge gLAYER_471; 
      LAST_AP_METAL_EDGE_PRE = MOM_AP_SIDE_EDGE coincident_inside_edge gLAYER_470; 
      gLAYER_474 = MOM_AP_SPACE_90_90_1 or_edge MOM_AP_SPACE_90_90_2; 
      gLAYER_473 = edge_size( gLAYER_474, inside = GRID ); 
      gLAYER_472 = polygon_extents( gLAYER_473 );
      LAST_AP_METAL_EDGE = and_edge( LAST_AP_METAL_EDGE_PRE, gLAYER_472, false ); 
      MOM_AP_SPACE_90_90_3 = MOM_AP_SPACE_90_90 not_coincident_edge MOM_AP_SPACE_90_90_1; 
      MOM_AP_SPACE_90_270 = adjacent_edge( MOM_AP_SPACE, angle1 = == 90, angle2 = == 270, length = > 0 ); 
      gLAYER_477 = MOM_AP_SPACE_90_90_3 or_edge MOM_AP_SPACE_90_270; 
      gLAYER_476 = edge_size( gLAYER_477, inside = GRID ); 
      gLAYER_475 = polygon_extents( gLAYER_476 );
      MOM_AP_METAL = and_edge( MOM_AP_SIDE_EDGE, gLAYER_475, false ); 
      MOM_AP_CAP_EDGE = MOM_AP_METAL not_coincident_edge LAST_AP_METAL_EDGE; 
      MOMDMY_AP_WIVIA = enclosing( MOMDMY_AP, MOM_RV ); 
      MOMDMY_AP_WOVIA = MOMDMY_AP not MOMDMY_AP_WIVIA; 
      MOM_AP_WIVIA = MOMDMY_AP_WIVIA and AP; 
      MOM_AP_WOVIA = MOMDMY_AP_WOVIA and AP; 
      MOM_M1_CAP_EDGE_WOVIA = MOM_M1_CAP_EDGE touching_edge MOM_M1_WOVIA; 
      MOM_M1_CAP_EDGE_WIVIA = MOM_M1_CAP_EDGE touching_edge MOM_M1_WIVIA; 
      MOM_M2_CAP_EDGE_WOVIA = MOM_M2_CAP_EDGE touching_edge MOM_M2_WOVIA; 
      MOM_M2_CAP_EDGE_WIVIA = MOM_M2_CAP_EDGE touching_edge MOM_M2_WIVIA; 
      MOM_M3_CAP_EDGE_WOVIA = MOM_M3_CAP_EDGE touching_edge MOM_M3_WOVIA; 
      MOM_M3_CAP_EDGE_WIVIA = MOM_M3_CAP_EDGE touching_edge MOM_M3_WIVIA; 
      MOM_M4_CAP_EDGE_WOVIA = MOM_M4_CAP_EDGE touching_edge MOM_M4_WOVIA; 
      MOM_M4_CAP_EDGE_WIVIA = MOM_M4_CAP_EDGE touching_edge MOM_M4_WIVIA; 
      MOM_M5_CAP_EDGE_WOVIA = MOM_M5_CAP_EDGE touching_edge MOM_M5_WOVIA; 
      MOM_M5_CAP_EDGE_WIVIA = MOM_M5_CAP_EDGE touching_edge MOM_M5_WIVIA; 
      MOM_M6_CAP_EDGE_WOVIA = MOM_M6_CAP_EDGE touching_edge MOM_M6_WOVIA; 
      MOM_M6_CAP_EDGE_WIVIA = MOM_M6_CAP_EDGE touching_edge MOM_M6_WIVIA; 
      MOM_M7_CAP_EDGE_WOVIA = MOM_M7_CAP_EDGE touching_edge MOM_M7_WOVIA; 
      MOM_M7_CAP_EDGE_WIVIA = MOM_M7_CAP_EDGE touching_edge MOM_M7_WIVIA; 
      MOM_M8_CAP_EDGE_WOVIA = MOM_M8_CAP_EDGE touching_edge MOM_M8_WOVIA; 
      MOM_M8_CAP_EDGE_WIVIA = MOM_M8_CAP_EDGE touching_edge MOM_M8_WIVIA; 
      MOM_M9_CAP_EDGE_WOVIA = MOM_M9_CAP_EDGE touching_edge MOM_M9_WOVIA; 
      MOM_M9_CAP_EDGE_WIVIA = MOM_M9_CAP_EDGE touching_edge MOM_M9_WIVIA; 
      MOM_AP_CAP_EDGE_WOVIA = MOM_AP_CAP_EDGE touching_edge MOM_AP_WOVIA; 
      MOM_AP_CAP_EDGE_WIVIA = MOM_AP_CAP_EDGE touching_edge MOM_AP_WIVIA; 
      rMOM_A_1 @= { @ "MOM.A.1 : Maximum sidewall area of total metals in MOM without Via <= " + MOM_A_1; 
          MOM_SA = drc_features( primary_layer = CHIP_MOM, secondary_layers = { "layer2" => MOM_M1_CAP_EDGE_WOVIA, "layer3" => MOM_M2_CAP_EDGE_WOVIA, "layer4" => MOM_M3_CAP_EDGE_WOVIA, "layer5" => MOM_M4_CAP_EDGE_WOVIA, "layer6" => MOM_M5_CAP_EDGE_WOVIA, "layer7" => MOM_M6_CAP_EDGE_WOVIA, "layer8" => MOM_M7_CAP_EDGE_WOVIA, "layer9" => MOM_M8_CAP_EDGE_WOVIA, "layer10" => MOM_M9_CAP_EDGE_WOVIA, "layer11" => MOM_AP_CAP_EDGE_WOVIA }, output_from_layer = CHIP_MOM, include_touch = EDGE, drc_function = dfm_property_func_12 ); 
          copy( MOM_SA ); 
          VAR_56 = fopen("MOM.A.1.rep"); 
          drc_features( primary_layer = MOM_SA, secondary_layers = { }, output_from_layer = MOM_SA, drc_function = dfm_property_func_12_rdb, files = { VAR_56 } ); 
      } /* end of rule : MOM.A.1 */
      rMOM_A_2 @= { @ "MOM.A.2 : Maximum sidewall area of {total metals+ total Vias} in MOM with Via. <= " + MOM_A_2; 
          MOM_SA = drc_features( primary_layer = CHIP_MOM, secondary_layers = { "layer2" => MOM_M1_CAP_EDGE_WIVIA, "layer3" => MOM_VIA1_C, "layer4" => MOM_M2_CAP_EDGE_WIVIA, "layer5" => MOM_VIA2_C, "layer6" => MOM_M3_CAP_EDGE_WIVIA, "layer7" => MOM_VIA3_C, "layer8" => MOM_M4_CAP_EDGE_WIVIA, "layer9" => MOM_VIA4_C, "layer10" => MOM_M5_CAP_EDGE_WIVIA, "layer11" => MOM_VIA5_C, "layer12" => MOM_M6_CAP_EDGE_WIVIA, "layer13" => MOM_VIA6_C, "layer14" => MOM_M7_CAP_EDGE_WIVIA, "layer15" => MOM_VIA7_C, "layer16" => MOM_M8_CAP_EDGE_WIVIA, "layer17" => MOM_VIA8_C, "layer18" => MOM_M9_CAP_EDGE_WIVIA, "layer19" => MOM_RV_C, "layer20" => MOM_AP_CAP_EDGE_WIVIA }, output_from_layer = CHIP_MOM, include_touch = EDGE, drc_function = dfm_property_func_13 ); 
          copy( MOM_SA ); 
          VAR_57 = fopen("MOM.A.2.rep"); 
          drc_features( primary_layer = MOM_SA, secondary_layers = { }, output_from_layer = MOM_SA, drc_function = dfm_property_func_13_rdb, files = { VAR_57 } ); 
      } /* end of rule : MOM.A.2 */
      rMOM_S_1 @= { @ "MOM.S.1 : Space of M1 in MOMDMY_1 >= 0.1 um";
          external1( MOM_M1, < MOM_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : MOM.S.1 */
      
      //MOM.S.2 is checked by MOM.S.2:M1
      rMOM_S_2_M1 @= { @ "MOM.S.2:M1 : Space of metal (M1/Mx) line end in MOMDMY_n >= 0.12";
          external2( MOM_M1_LINE_END, M1, < MOM_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
      } /* end of rule : MOM.S.2:M1 */
      
      //MOM.S.2 is checked by MOM.S.2:M2
      rMOM_S_2_M2 @= { @ "MOM.S.2:M2 : Space of metal (M1/Mx) line end in MOMDMY_n >= 0.12";
          external2( MOM_M2_LINE_END, M2, < MOM_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
      } /* end of rule : MOM.S.2:M2 */
      
      //MOM.S.2 is checked by MOM.S.2:M3
      rMOM_S_2_M3 @= { @ "MOM.S.2:M3 : Space of metal (M1/Mx) line end in MOMDMY_n >= 0.12";
          external2( MOM_M3_LINE_END, M3, < MOM_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
      } /* end of rule : MOM.S.2:M3 */
      
      //MOM.S.2 is checked by MOM.S.2:M4
      rMOM_S_2_M4 @= { @ "MOM.S.2:M4 : Space of metal (M1/Mx) line end in MOMDMY_n >= 0.12";
          external2( MOM_M4_LINE_END, M4, < MOM_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
      } /* end of rule : MOM.S.2:M4 */
      
      //MOM.S.2 is checked by MOM.S.2:M5
      rMOM_S_2_M5 @= { @ "MOM.S.2:M5 : Space of metal (M1/Mx) line end in MOMDMY_n >= 0.12";
          external2( MOM_M5_LINE_END, M5, < MOM_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
      } /* end of rule : MOM.S.2:M5 */
      
      //MOM.S.2 is checked by MOM.S.2:M6
      rMOM_S_2_M6 @= { @ "MOM.S.2:M6 : Space of metal (M1/Mx) line end in MOMDMY_n >= 0.12";
          external2( MOM_M6_LINE_END, M6, < MOM_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
      } /* end of rule : MOM.S.2:M6 */
      
      //MOM.S.2 is checked by MOM.S.2:M7
      rMOM_S_2_M7 @= { @ "MOM.S.2:M7 : Space of metal (M1/Mx) line end in MOMDMY_n >= 0.12";
          external2( MOM_M7_LINE_END, M7, < MOM_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
      } /* end of rule : MOM.S.2:M7 */
      
      //MOM.S.3 is checked by MOM.S.3:M1
      rMOM_S_3_M1 @= { @ "MOM.S.3:M1 : Space of Metal (M1/Mx) in MOM with Via >= 0.13 um";
          external1( MOM_M1_WIVIA, < MOM_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : MOM.S.3:M1 */
      
      //MOM.S.3 is checked by MOM.S.3:M2
      rMOM_S_3_M2 @= { @ "MOM.S.3:M2 : Space of Metal (M1/Mx) in MOM with Via >= 0.13 um";
          external1( MOM_M2_WIVIA, < MOM_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : MOM.S.3:M2 */
      
      //MOM.S.3 is checked by MOM.S.3:M3
      rMOM_S_3_M3 @= { @ "MOM.S.3:M3 : Space of Metal (M1/Mx) in MOM with Via >= 0.13 um";
          external1( MOM_M3_WIVIA, < MOM_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : MOM.S.3:M3 */
      
      //MOM.S.3 is checked by MOM.S.3:M4
      rMOM_S_3_M4 @= { @ "MOM.S.3:M4 : Space of Metal (M1/Mx) in MOM with Via >= 0.13 um";
          external1( MOM_M4_WIVIA, < MOM_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : MOM.S.3:M4 */
      
      //MOM.S.3 is checked by MOM.S.3:M5
      rMOM_S_3_M5 @= { @ "MOM.S.3:M5 : Space of Metal (M1/Mx) in MOM with Via >= 0.13 um";
          external1( MOM_M5_WIVIA, < MOM_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : MOM.S.3:M5 */
      
      //MOM.S.3 is checked by MOM.S.3:M6
      rMOM_S_3_M6 @= { @ "MOM.S.3:M6 : Space of Metal (M1/Mx) in MOM with Via >= 0.13 um";
          external1( MOM_M6_WIVIA, < MOM_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : MOM.S.3:M6 */
      
      //MOM.S.3 is checked by MOM.S.3:M7
      rMOM_S_3_M7 @= { @ "MOM.S.3:M7 : Space of Metal (M1/Mx) in MOM with Via >= 0.13 um";
          external1( MOM_M7_WIVIA, < MOM_S_3, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : MOM.S.3:M7 */
      
      //MOM.S.4 is checked by MOM.S.4:VIA1
      rMOM_S_4_VIA1 @= { @ "MOM.S.4:VIA1 : Space of VIAx in MOM with Via in different net >= 0.13 um";
          A = stamp( MOM_VIA1, VIA1I, CONNECT_DB, CONNECT_DB_MOM_S_4_VIA1, include_touch = NONE ); 
          external1( A, < MOM_S_4, connect_sequence = CONNECT_DB_MOM_S_4_VIA1, connectivity = DIFFERENT_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : MOM.S.4:VIA1 */
      
      //MOM.S.4 is checked by MOM.S.4:VIA2
      rMOM_S_4_VIA2 @= { @ "MOM.S.4:VIA2 : Space of VIAx in MOM with Via in different net >= 0.13 um";
          A = stamp( MOM_VIA2, VIA2I, CONNECT_DB, CONNECT_DB_MOM_S_4_VIA2, include_touch = NONE ); 
          external1( A, < MOM_S_4, connect_sequence = CONNECT_DB_MOM_S_4_VIA2, connectivity = DIFFERENT_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : MOM.S.4:VIA2 */
      
      //MOM.S.4 is checked by MOM.S.4:VIA3
      rMOM_S_4_VIA3 @= { @ "MOM.S.4:VIA3 : Space of VIAx in MOM with Via in different net >= 0.13 um";
          A = stamp( MOM_VIA3, VIA3I, CONNECT_DB, CONNECT_DB_MOM_S_4_VIA3, include_touch = NONE ); 
          external1( A, < MOM_S_4, connect_sequence = CONNECT_DB_MOM_S_4_VIA3, connectivity = DIFFERENT_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : MOM.S.4:VIA3 */
      
      //MOM.S.4 is checked by MOM.S.4:VIA4
      rMOM_S_4_VIA4 @= { @ "MOM.S.4:VIA4 : Space of VIAx in MOM with Via in different net >= 0.13 um";
          A = stamp( MOM_VIA4, VIA4I, CONNECT_DB, CONNECT_DB_MOM_S_4_VIA4, include_touch = NONE ); 
          external1( A, < MOM_S_4, connect_sequence = CONNECT_DB_MOM_S_4_VIA4, connectivity = DIFFERENT_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : MOM.S.4:VIA4 */
      
      //MOM.S.4 is checked by MOM.S.4:VIA5
      rMOM_S_4_VIA5 @= { @ "MOM.S.4:VIA5 : Space of VIAx in MOM with Via in different net >= 0.13 um";
          A = stamp( MOM_VIA5, VIA5I, CONNECT_DB, CONNECT_DB_MOM_S_4_VIA5, include_touch = NONE ); 
          external1( A, < MOM_S_4, connect_sequence = CONNECT_DB_MOM_S_4_VIA5, connectivity = DIFFERENT_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : MOM.S.4:VIA5 */
      
      //MOM.S.4 is checked by MOM.S.4:VIA6
      rMOM_S_4_VIA6 @= { @ "MOM.S.4:VIA6 : Space of VIAx in MOM with Via in different net >= 0.13 um";
          A = stamp( MOM_VIA6, VIA6I, CONNECT_DB, CONNECT_DB_MOM_S_4_VIA6, include_touch = NONE ); 
          external1( A, < MOM_S_4, connect_sequence = CONNECT_DB_MOM_S_4_VIA6, connectivity = DIFFERENT_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : MOM.S.4:VIA6 */
      rMOM_R_1 @= { @ "MOM.R.1 : Poly shielding and underneath NW or PW must bias at same potential for reliability consideration. If poly shielding terminal could not be tied to the underneath NW or PW, customer should keep bias between poly terminal and underneath well within thin gate oxide (Without OD2) or thick gate oxide (With OD2) maximum applied voltage for reliability consideration. "
                                "DRC only check following conditions: "
                                "(1) {(MOM_PO INTERACT (MOM_OD NOT INSIDE OD2)) INTERACT ((MOMDMY(155;100) OR MOMDMY(155;0)) NOT (MOMDMY(155;27))} [Poly shielding MOM with dummy OD underneath] and underneath NW or PW must bias at same potential through metal connection.";
          MOM_OD = copy( ODI ); 
          sLAYER_900 = MOM_OD not_inside OD2; 
          sLAYER_899 = interacting( ILP1I, sLAYER_900 ); 
          sLAYER_902 = MOMDMY or MOMDMY_100; 
          sLAYER_901 = sLAYER_902 not MOMDMY_2T; 
          PO_MOMI = interacting( sLAYER_899, sLAYER_901 ); 
          CONNECT_DB_MOM_R_1 = incremental_connect( CONNECT_DB, {{{ PO_MOMI }, ILP1I }} ); 
          NW_NOT_POI = NWI not PO_MOMI; 
          CONNECT_DB_MOM_R_1 = incremental_connect( CONNECT_DB_MOM_R_1, {{{ NW_NOT_POI }, NWI }} ); 
          PW_NOT_POI = PWELI not PO_MOMI; 
          CONNECT_DB_MOM_R_1 = incremental_connect( CONNECT_DB_MOM_R_1, {{{ PW_NOT_POI }, PWELI }} ); 
          external2( PO_MOMI, NW_NOT_POI, < 0.001, connect_sequence = CONNECT_DB_MOM_R_1, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 0, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
          external2( PO_MOMI, PW_NOT_POI, < 0.001, connect_sequence = CONNECT_DB_MOM_R_1, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = == 0, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
      } /* end of rule : MOM.R.1 */
      rRM_WARN_1 @= { @ "RM.WARN.1 : CO overlap (NWDMY AND NW) is not allowed";
          sLAYER_903 = NWDMY and NWEL; 
          sLAYER_903 and CO; 
      } /* end of rule : RM.WARN.1 */
      rRM_WARN_2 @= { @ "RM.WARN.2 : CO overlap (RH AND RPDMY) AND (OD OR PO) is not allowed.";
          sLAYER_905 = OD or POLY; 
          sLAYER_906 = RH and RPDMY; 
          sLAYER_904 = sLAYER_905 and sLAYER_906;
          sLAYER_904 and CO; 
      } /* end of rule : RM.WARN.2 */
      rRM_WARN_3 @= { @ "RM.WARN.3 : CO overlap (RMDMY1 AND M1) is not allowed";
          sLAYER_907 = RMDMY1 and M1; 
          sLAYER_907 and CO; 
      } /* end of rule : RM.WARN.3 */
      
      // RM.WARN.4 is checked by RM.WARN.4:M1
      rRM_WARN_4_M1 @= { @ "RM.WARN.4:M1 : VIA1 overlap (RMDMY1 AND M1) is not allowed";
          sLAYER_908 = RMDMY1 and M1; 
          sLAYER_908 and VIA1; 
      } /* end of rule : RM.WARN.4:M1 */
      
      // RM.WARN.4 is checked by RM.WARN.4:M2
      rRM_WARN_4_M2 @= { @ "RM.WARN.4:M2 : (VIA2 OR VIA1) overlap (RMDMY2 AND M2) is not allowed";
          sLAYER_909 = RMDMY2 and M2; 
          sLAYER_909 and VIA2; 
          sLAYER_910 = RMDMY2 and M2; 
          sLAYER_910 and VIA1; 
      } /* end of rule : RM.WARN.4:M2 */
      
      // RM.WARN.4 is checked by RM.WARN.4:M3
      rRM_WARN_4_M3 @= { @ "RM.WARN.4:M3 : (VIA3 OR VIA2) overlap (RMDMY3 AND M3) is not allowed";
          sLAYER_911 = RMDMY3 and M3; 
          sLAYER_911 and VIA3; 
          sLAYER_912 = RMDMY3 and M3; 
          sLAYER_912 and VIA2; 
      } /* end of rule : RM.WARN.4:M3 */
      
      // RM.WARN.4 is checked by RM.WARN.4:M4
      rRM_WARN_4_M4 @= { @ "RM.WARN.4:M4 : (VIA4 OR VIA3) overlap (RMDMY4 AND M4) is not allowed";
          sLAYER_913 = RMDMY4 and M4; 
          sLAYER_913 and VIA4; 
          sLAYER_914 = RMDMY4 and M4; 
          sLAYER_914 and VIA3; 
      } /* end of rule : RM.WARN.4:M4 */
      
      // RM.WARN.4 is checked by RM.WARN.4:M5
      rRM_WARN_4_M5 @= { @ "RM.WARN.4:M5 : (VIA5 OR VIA4) overlap (RMDMY5 AND M5) is not allowed";
          sLAYER_915 = RMDMY5 and M5; 
          sLAYER_915 and VIA5; 
          sLAYER_916 = RMDMY5 and M5; 
          sLAYER_916 and VIA4; 
      } /* end of rule : RM.WARN.4:M5 */
      
      // RM.WARN.4 is checked by RM.WARN.4:M6
      rRM_WARN_4_M6 @= { @ "RM.WARN.4:M6 : (VIA6 OR VIA5) overlap (RMDMY6 AND M6) is not allowed";
          sLAYER_917 = RMDMY6 and M6; 
          sLAYER_917 and VIA6; 
          sLAYER_918 = RMDMY6 and M6; 
          sLAYER_918 and VIA5; 
      } /* end of rule : RM.WARN.4:M6 */
      
      // RM.WARN.4 is checked by RM.WARN.4:M7
      rRM_WARN_4_M7 @= { @ "RM.WARN.4:M7 : (VIA7 OR VIA6) overlap (RMDMY7 AND M7) is not allowed";
          sLAYER_919 = RMDMY7 and M7; 
          sLAYER_919 and VIA7; 
          sLAYER_920 = RMDMY7 and M7; 
          sLAYER_920 and VIA6; 
      } /* end of rule : RM.WARN.4:M7 */
      
      // RM.WARN.4 is checked by RM.WARN.4:M8
      rRM_WARN_4_M8 @= { @ "RM.WARN.4:M8 : (VIA8 OR VIA7) overlap (RMDMY8 AND M8) is not allowed";
          sLAYER_921 = RMDMY8 and M8; 
          sLAYER_921 and VIA8; 
          sLAYER_922 = RMDMY8 and M8; 
          sLAYER_922 and VIA7; 
      } /* end of rule : RM.WARN.4:M8 */
      
      // RM.WARN.4 is checked by RM.WARN.4:M9
      rRM_WARN_4_M9 @= { @ "RM.WARN.4:M9 : VIA8 overlap (RMDMY9 AND M9) is not allowed";
          sLAYER_923 = RMDMY9 and M9; 
          sLAYER_923 and VIA8; 
      } /* end of rule : RM.WARN.4:M9 */
      
      // RM.WARN.5 is checked by RM.WARN.5:M9
      rRM_WARN_5_M9 @= { @ "RM.WARN.5:M9 : RV overlap (RMDMY9 AND M9) is not allowed";
          sLAYER_924 = RMDMY9 and M9; 
          sLAYER_924 and RV; 
      } /* end of rule : RM.WARN.5:M9 */
      
      // RM.WARN.5 is checked by RM.WARN.5:AP
      rRM_WARN_5_AP @= { @ "RM.WARN.5:AP : RV overlap (RMDMYAP AND AP) is not allowed";
          sLAYER_925 = RMDMYAP and AP; 
          sLAYER_925 and RV; 
      } /* end of rule : RM.WARN.5:AP */
      rRM_WARN_6 @= { @ "RM.WARN.6 : RPDMY intersecting (PO OR OD) must form two or more (PO OR OD)s (Except unsilicided OD/PO resistor)";
          sLAYER_926 = interacting( POLY, RPDMY ); 
          A_END = sLAYER_926 not RPDMY; 
          sLAYER_927 = not_interacting( RPDMY, RPO ); 
          A_BODY = interacting( POLY, sLAYER_927 ); 
          not_interacting( A_BODY, A_END, >= 2 ); 
          sLAYER_928 = interacting( OD, RPDMY ); 
          B_END = sLAYER_928 not RPDMY; 
          sLAYER_929 = not_interacting( RPDMY, RPO ); 
          B_BODY = interacting( OD, sLAYER_929 ); 
          not_interacting( B_BODY, B_END, >= 2 ); 
      } /* end of rule : RM.WARN.6 */
      rRM_WARN_7 @= { @ "RM.WARN.7 : NWDMY intersecting NW must form two or more NWs";
          sLAYER_930 = interacting( NWEL, NWDMY ); 
          A_END = sLAYER_930 not NWDMY; 
          A_BODY = interacting( NWEL, NWDMY ); 
          not_interacting( A_BODY, A_END, >= 2 ); 
      } /* end of rule : RM.WARN.7 */
      IND_REGION = size( INDDMY, clip_acute = NONE, distance = 12 ); 
      IND_MD_REGION = size( INDDMY_MD, clip_acute = NONE, distance = 12 ); 
      IND_MD_EXD = size( INDDMY_MD, clip_acute = NONE, distance = 18 ); 
      IND_HD_EXD = size( INDDMY_HD, clip_acute = NONE, distance = 18 ); 
      IND_COIL_REGION = size( INDDMY_COIL, clip_acute = NONE, distance = 16 ); 
      IND_M1 = M1 and IND_REGION; 
      IND_WIDEM11_p_5 = wide( IND_M1, > 1.5, forty_five = INTERNAL ); 
      IND_WIDEM14_p_5 = wide( IND_WIDEM11_p_5, > 4.5, forty_five = INTERNAL ); 
      IND_M2 = M2 and IND_REGION; 
      IND_WIDEM21_p_5 = wide( IND_M2, > 1.5, forty_five = INTERNAL ); 
      IND_WIDEM24_p_5 = wide( IND_WIDEM21_p_5, > 4.5, forty_five = INTERNAL ); 
      IND_M3 = M3 and IND_REGION; 
      IND_WIDEM31_p_5 = wide( IND_M3, > 1.5, forty_five = INTERNAL ); 
      IND_WIDEM34_p_5 = wide( IND_WIDEM31_p_5, > 4.5, forty_five = INTERNAL ); 
      IND_M4 = M4 and IND_REGION; 
      IND_WIDEM41_p_5 = wide( IND_M4, > 1.5, forty_five = INTERNAL ); 
      IND_WIDEM44_p_5 = wide( IND_WIDEM41_p_5, > 4.5, forty_five = INTERNAL ); 
      IND_M5 = M5 and IND_REGION; 
      IND_WIDEM51_p_5 = wide( IND_M5, > 1.5, forty_five = INTERNAL ); 
      IND_WIDEM54_p_5 = wide( IND_WIDEM51_p_5, > 4.5, forty_five = INTERNAL ); 
      IND_M6 = M6 and IND_REGION; 
      IND_WIDEM61_p_5 = wide( IND_M6, > 1.5, forty_five = INTERNAL ); 
      IND_WIDEM64_p_5 = wide( IND_WIDEM61_p_5, > 4.5, forty_five = INTERNAL ); 
      IND_M7 = M7 and IND_REGION; 
      IND_WIDEM71_p_5 = wide( IND_M7, > 1.5, forty_five = INTERNAL ); 
      IND_WIDEM74_p_5 = wide( IND_WIDEM71_p_5, > 4.5, forty_five = INTERNAL ); 
      IND_M8 = M8 and IND_REGION; 
      IND_WIDEM81_p_5 = wide( IND_M8, > 1.5, forty_five = INTERNAL ); 
      IND_WIDEM84_p_5 = wide( IND_WIDEM81_p_5, > 4.5, forty_five = INTERNAL ); 
      IND_M9 = M9 and IND_REGION; 
      IND_WIDEM91_p_5 = wide( IND_M9, > 1.5, forty_five = INTERNAL ); 
      IND_WIDEM94_p_5 = wide( IND_WIDEM91_p_5, > 4.5, forty_five = INTERNAL ); 
      rIND_W_1 @= { @ "IND.W.1 : M1 width in (INDDMY SIZING 12um) >= 0.4";
          A = M1 not_outside IND_REGION; 
          sLAYER_931 = internal1( A, < ( IND_W_1 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          sLAYER_931 not_outside IND_REGION; 
      } /* end of rule : IND.W.1 */
      
      // 0.01 um checking tolerance is allowed
      rIND_W_2_M2 @= { @ "IND.W.2:M2 : Mx width in (INDDMY SIZING 12um) >= 0.I6";
          A = M2 not_outside IND_REGION; 
          sLAYER_932 = internal1( A, < ( IND_W_2 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          sLAYER_932 not_outside IND_REGION; 
      } /* end of rule : IND.W.2:M2 */
      rIND_W_2_M3 @= { @ "IND.W.2:M3 : Mx width in (INDDMY SIZING 12um) >= 0.I6";
          A = M3 not_outside IND_REGION; 
          sLAYER_933 = internal1( A, < ( IND_W_2 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          sLAYER_933 not_outside IND_REGION; 
      } /* end of rule : IND.W.2:M3 */
      rIND_W_2_M4 @= { @ "IND.W.2:M4 : Mx width in (INDDMY SIZING 12um) >= 0.I6";
          A = M4 not_outside IND_REGION; 
          sLAYER_934 = internal1( A, < ( IND_W_2 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          sLAYER_934 not_outside IND_REGION; 
      } /* end of rule : IND.W.2:M4 */
      rIND_W_2_M5 @= { @ "IND.W.2:M5 : Mx width in (INDDMY SIZING 12um) >= 0.I6";
          A = M5 not_outside IND_REGION; 
          sLAYER_935 = internal1( A, < ( IND_W_2 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          sLAYER_935 not_outside IND_REGION; 
      } /* end of rule : IND.W.2:M5 */
      rIND_W_2_M6 @= { @ "IND.W.2:M6 : Mx width in (INDDMY SIZING 12um) >= 0.I6";
          A = M6 not_outside IND_REGION; 
          sLAYER_936 = internal1( A, < ( IND_W_2 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          sLAYER_936 not_outside IND_REGION; 
      } /* end of rule : IND.W.2:M6 */
      rIND_W_2_M7 @= { @ "IND.W.2:M7 : Mx width in (INDDMY SIZING 12um) >= 0.I6";
          A = M7 not_outside IND_REGION; 
          sLAYER_937 = internal1( A, < ( IND_W_2 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          sLAYER_937 not_outside IND_REGION; 
      } /* end of rule : IND.W.2:M7 */
      
      // 0.01 um checking tolerance is allowed
      rIND_W_3_M8 @= { @ "IND.W.3:M8 : Mz width in (INDDMY SIZING 12um) >= 0.8";
          A = M8 not_outside IND_REGION; 
          sLAYER_938 = internal1( A, < ( IND_W_3 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          sLAYER_938 not_outside IND_REGION; 
      } /* end of rule : IND.W.3:M8 */
      rIND_W_3_M9 @= { @ "IND.W.3:M9 : Mz width in (INDDMY SIZING 12um) >= 0.8";
          A = M9 not_outside IND_REGION; 
          sLAYER_939 = internal1( A, < ( IND_W_3 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          sLAYER_939 not_outside IND_REGION; 
      } /* end of rule : IND.W.3:M9 */
      
      // 0.01 um checking tolerance is allowed
      rIND_S_1 @= { @ "IND.S.1 : M1 space in (INDDMY SIZING 12um) >= 0.4";
          A = M1 not_outside IND_REGION; 
          sLAYER_940 = external1( A, < ( IND_S_1 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_940 not_outside IND_REGION; 
      } /* end of rule : IND.S.1 */
      
      // 0.01 um checking tolerance is allowed
      rIND_S_2_M2 @= { @ "IND.S.2:M2 : Mx space in (INDDMY SIZING 12um) >= 0.6";
          A = M2 not_outside IND_REGION; 
          sLAYER_941 = external1( A, < ( IND_S_2 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_941 not_outside IND_REGION; 
      } /* end of rule : IND.S.2:M2 */
      rIND_S_2_M3 @= { @ "IND.S.2:M3 : Mx space in (INDDMY SIZING 12um) >= 0.6";
          A = M3 not_outside IND_REGION; 
          sLAYER_942 = external1( A, < ( IND_S_2 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_942 not_outside IND_REGION; 
      } /* end of rule : IND.S.2:M3 */
      rIND_S_2_M4 @= { @ "IND.S.2:M4 : Mx space in (INDDMY SIZING 12um) >= 0.6";
          A = M4 not_outside IND_REGION; 
          sLAYER_943 = external1( A, < ( IND_S_2 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_943 not_outside IND_REGION; 
      } /* end of rule : IND.S.2:M4 */
      rIND_S_2_M5 @= { @ "IND.S.2:M5 : Mx space in (INDDMY SIZING 12um) >= 0.6";
          A = M5 not_outside IND_REGION; 
          sLAYER_944 = external1( A, < ( IND_S_2 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_944 not_outside IND_REGION; 
      } /* end of rule : IND.S.2:M5 */
      rIND_S_2_M6 @= { @ "IND.S.2:M6 : Mx space in (INDDMY SIZING 12um) >= 0.6";
          A = M6 not_outside IND_REGION; 
          sLAYER_945 = external1( A, < ( IND_S_2 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_945 not_outside IND_REGION; 
      } /* end of rule : IND.S.2:M6 */
      rIND_S_2_M7 @= { @ "IND.S.2:M7 : Mx space in (INDDMY SIZING 12um) >= 0.6";
          A = M7 not_outside IND_REGION; 
          sLAYER_946 = external1( A, < ( IND_S_2 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_946 not_outside IND_REGION; 
      } /* end of rule : IND.S.2:M7 */
      
      // 0.01 um checking tolerance is allowed
      rIND_S_3_M8 @= { @ "IND.S.3:M8 : Mz space in (INDDMY SIZING 12um) >= 0.8";
          A = M8 not_outside IND_REGION; 
          sLAYER_947 = external1( A, < ( IND_S_3 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_947 not_outside IND_REGION; 
      } /* end of rule : IND.S.3:M8 */
      rIND_S_3_M9 @= { @ "IND.S.3:M9 : Mz space in (INDDMY SIZING 12um) >= 0.8";
          A = M9 not_outside IND_REGION; 
          sLAYER_948 = external1( A, < ( IND_S_3 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_948 not_outside IND_REGION; 
      } /* end of rule : IND.S.3:M9 */
      
      // 0.01 um checking tolerance is allowed
      rIND_S_4_M1 @= { @ "IND.S.4:M1 : M1 space in (INDDMY SIZING 12 um) [at least one metal width > 1.5 um and parallel length > 1.5 um] >= 1.0";
          X = external2( IND_WIDEM11_p_5, M1, < ( IND_S_4 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M1; 
          contains( Y, { GRID, 1.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.S.4:M1 */
      
      // 0.01 um checking tolerance is allowed
      rIND_S_5_M1 @= { @ "IND.S.5:M1 : M1 space in (INDDMY SIZING 12 um) [at least one metal width > 4.5 um and parallel length > 4.5 um] >= 2.0";
          X = external2( IND_WIDEM14_p_5, M1, < ( IND_S_5 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M1; 
          contains( Y, { GRID, 4.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.S.5:M1 */
      rIND_S_4_M2 @= { @ "IND.S.4:M2 : M2 space in (INDDMY SIZING 12 um) [at least one metal width > 1.5 um and parallel length > 1.5 um] >= 1.0";
          X = external2( IND_WIDEM21_p_5, M2, < ( IND_S_4 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M2; 
          contains( Y, { GRID, 1.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.S.4:M2 */
      
      // 0.01 um checking tolerance is allowed
      rIND_S_5_M2 @= { @ "IND.S.5:M2 : M2 space in (INDDMY SIZING 12 um) [at least one metal width > 4.5 um and parallel length > 4.5 um] >= 2.0";
          X = external2( IND_WIDEM24_p_5, M2, < ( IND_S_5 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M2; 
          contains( Y, { GRID, 4.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.S.5:M2 */
      rIND_S_4_M3 @= { @ "IND.S.4:M3 : M3 space in (INDDMY SIZING 12 um) [at least one metal width > 1.5 um and parallel length > 1.5 um] >= 1.0";
          X = external2( IND_WIDEM31_p_5, M3, < ( IND_S_4 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M3; 
          contains( Y, { GRID, 1.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.S.4:M3 */
      
      // 0.01 um checking tolerance is allowed
      rIND_S_5_M3 @= { @ "IND.S.5:M3 : M3 space in (INDDMY SIZING 12 um) [at least one metal width > 4.5 um and parallel length > 4.5 um] >= 2.0";
          X = external2( IND_WIDEM34_p_5, M3, < ( IND_S_5 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M3; 
          contains( Y, { GRID, 4.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.S.5:M3 */
      rIND_S_4_M4 @= { @ "IND.S.4:M4 : M4 space in (INDDMY SIZING 12 um) [at least one metal width > 1.5 um and parallel length > 1.5 um] >= 1.0";
          X = external2( IND_WIDEM41_p_5, M4, < ( IND_S_4 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M4; 
          contains( Y, { GRID, 1.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.S.4:M4 */
      
      // 0.01 um checking tolerance is allowed
      rIND_S_5_M4 @= { @ "IND.S.5:M4 : M4 space in (INDDMY SIZING 12 um) [at least one metal width > 4.5 um and parallel length > 4.5 um] >= 2.0";
          X = external2( IND_WIDEM44_p_5, M4, < ( IND_S_5 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M4; 
          contains( Y, { GRID, 4.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.S.5:M4 */
      rIND_S_4_M5 @= { @ "IND.S.4:M5 : M5 space in (INDDMY SIZING 12 um) [at least one metal width > 1.5 um and parallel length > 1.5 um] >= 1.0";
          X = external2( IND_WIDEM51_p_5, M5, < ( IND_S_4 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M5; 
          contains( Y, { GRID, 1.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.S.4:M5 */
      
      // 0.01 um checking tolerance is allowed
      rIND_S_5_M5 @= { @ "IND.S.5:M5 : M5 space in (INDDMY SIZING 12 um) [at least one metal width > 4.5 um and parallel length > 4.5 um] >= 2.0";
          X = external2( IND_WIDEM54_p_5, M5, < ( IND_S_5 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M5; 
          contains( Y, { GRID, 4.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.S.5:M5 */
      rIND_S_4_M6 @= { @ "IND.S.4:M6 : M6 space in (INDDMY SIZING 12 um) [at least one metal width > 1.5 um and parallel length > 1.5 um] >= 1.0";
          X = external2( IND_WIDEM61_p_5, M6, < ( IND_S_4 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M6; 
          contains( Y, { GRID, 1.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.S.4:M6 */
      
      // 0.01 um checking tolerance is allowed
      rIND_S_5_M6 @= { @ "IND.S.5:M6 : M6 space in (INDDMY SIZING 12 um) [at least one metal width > 4.5 um and parallel length > 4.5 um] >= 2.0";
          X = external2( IND_WIDEM64_p_5, M6, < ( IND_S_5 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M6; 
          contains( Y, { GRID, 4.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.S.5:M6 */
      rIND_S_4_M7 @= { @ "IND.S.4:M7 : M7 space in (INDDMY SIZING 12 um) [at least one metal width > 1.5 um and parallel length > 1.5 um] >= 1.0";
          X = external2( IND_WIDEM71_p_5, M7, < ( IND_S_4 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M7; 
          contains( Y, { GRID, 1.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.S.4:M7 */
      
      // 0.01 um checking tolerance is allowed
      rIND_S_5_M7 @= { @ "IND.S.5:M7 : M7 space in (INDDMY SIZING 12 um) [at least one metal width > 4.5 um and parallel length > 4.5 um] >= 2.0";
          X = external2( IND_WIDEM74_p_5, M7, < ( IND_S_5 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M7; 
          contains( Y, { GRID, 4.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.S.5:M7 */
      
      // 0.01 um checking tolerance is allowed
      rIND_S_4_M8 @= { @ "IND.S.4:M8 : M8 space in (INDDMY SIZING 12 um) [at least one metal width > 1.5 um and parallel length > 1.5 um] >= 1.0";
          X = external2( IND_WIDEM81_p_5, M8, < ( IND_S_4 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M8; 
          contains( Y, { GRID, 1.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.S.4:M8 */
      
      // 0.01 um checking tolerance is allowed
      rIND_S_5_M8 @= { @ "IND.S.5:M8 : M8 space in (INDDMY SIZING 12 um) [at least one metal width > 4.5 um and parallel length > 4.5 um] >= 2.0";
          X = external2( IND_WIDEM84_p_5, M8, < ( IND_S_5 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M8; 
          contains( Y, { GRID, 4.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.S.5:M8 */
      rIND_S_4_M9 @= { @ "IND.S.4:M9 : M9 space in (INDDMY SIZING 12 um) [at least one metal width > 1.5 um and parallel length > 1.5 um] >= 1.0";
          X = external2( IND_WIDEM91_p_5, M9, < ( IND_S_4 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M9; 
          contains( Y, { GRID, 1.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.S.4:M9 */
      
      // 0.01 um checking tolerance is allowed
      rIND_S_5_M9 @= { @ "IND.S.5:M9 : M9 space in (INDDMY SIZING 12 um) [at least one metal width > 4.5 um and parallel length > 4.5 um] >= 2.0";
          X = external2( IND_WIDEM94_p_5, M9, < ( IND_S_5 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M9; 
          contains( Y, { GRID, 4.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.S.5:M9 */
      
      // 0.01 um checking tolerance is allowed
      rIND_W_4_M1 @= { @ "IND.W.4:M1 : M1/Mx maximum width <= 12 um, except WBDMY if Mx is Mtop-1 layer";
          A = M1 not_outside IND_REGION; 
          size( size( A, - ( ( IND_W_4 + 0.01 ) / 2 ), clip_acute = BISECTOR ), ( IND_W_4 + 0.01 ) / 2, clip_acute = BISECTOR ); 
      } /* end of rule : IND.W.4:M1 */
      rIND_W_4_M2 @= { @ "IND.W.4:M2 : M1/Mx maximum width <= 12 um, except WBDMY if Mx is Mtop-1 layer";
          A = M2 not_outside IND_REGION; 
          size( size( A, - ( ( IND_W_4 + 0.01 ) / 2 ), clip_acute = BISECTOR ), ( IND_W_4 + 0.01 ) / 2, clip_acute = BISECTOR ); 
      } /* end of rule : IND.W.4:M2 */
      rIND_W_4_M3 @= { @ "IND.W.4:M3 : M1/Mx maximum width <= 12 um, except WBDMY if Mx is Mtop-1 layer";
          A = M3 not_outside IND_REGION; 
          size( size( A, - ( ( IND_W_4 + 0.01 ) / 2 ), clip_acute = BISECTOR ), ( IND_W_4 + 0.01 ) / 2, clip_acute = BISECTOR ); 
      } /* end of rule : IND.W.4:M3 */
      rIND_W_4_M4 @= { @ "IND.W.4:M4 : M1/Mx maximum width <= 12 um, except WBDMY if Mx is Mtop-1 layer";
          A = M4 not_outside IND_REGION; 
          size( size( A, - ( ( IND_W_4 + 0.01 ) / 2 ), clip_acute = BISECTOR ), ( IND_W_4 + 0.01 ) / 2, clip_acute = BISECTOR ); 
      } /* end of rule : IND.W.4:M4 */
      rIND_W_4_M5 @= { @ "IND.W.4:M5 : M1/Mx maximum width <= 12 um, except WBDMY if Mx is Mtop-1 layer";
          A = M5 not_outside IND_REGION; 
          size( size( A, - ( ( IND_W_4 + 0.01 ) / 2 ), clip_acute = BISECTOR ), ( IND_W_4 + 0.01 ) / 2, clip_acute = BISECTOR ); 
      } /* end of rule : IND.W.4:M5 */
      rIND_W_4_M6 @= { @ "IND.W.4:M6 : M1/Mx maximum width <= 12 um, except WBDMY if Mx is Mtop-1 layer";
          A = M6 not_outside IND_REGION; 
          size( size( A, - ( ( IND_W_4 + 0.01 ) / 2 ), clip_acute = BISECTOR ), ( IND_W_4 + 0.01 ) / 2, clip_acute = BISECTOR ); 
      } /* end of rule : IND.W.4:M6 */
      rIND_W_4_M7 @= { @ "IND.W.4:M7 : M1/Mx maximum width <= 12 um, except WBDMY if Mx is Mtop-1 layer";
          A = M7 not_outside IND_REGION; 
          size( size( A, - ( ( IND_W_4 + 0.01 ) / 2 ), clip_acute = BISECTOR ), ( IND_W_4 + 0.01 ) / 2, clip_acute = BISECTOR ); 
      } /* end of rule : IND.W.4:M7 */
      
      // 0.01 um checking tolerance is allowed
      
      //IND.W.5 is checked by related rules (Mz.W.2/Mu.W.2)
      rIND_W_6_M8 @= { @ "IND.W.6:M8 : Mz/Mu maximum width for inductor application only [inside (INDDMY SIZING 18 um)] <= 30.0";
          A = M8 and IND_EXD; 
          wide( A, > ( IND_W_6 + 0.01 ), forty_five = INTERNAL ); 
      } /* end of rule : IND.W.6:M8 */
      rIND_W_6_M9 @= { @ "IND.W.6:M9 : Mz/Mu maximum width for inductor application only [inside (INDDMY SIZING 18 um)] <= 30.0";
          A = M9 and IND_EXD; 
          wide( A, > ( IND_W_6 + 0.01 ), forty_five = INTERNAL ); 
      } /* end of rule : IND.W.6:M9 */
      
      // 0.01 um checking tolerance is allowed
      rIND_W_7 @= { @ "IND.W.7 : Max. dimension (either width or length) of an INDDMY region <= 600 um";
          contains( INDDMY, { 0.005, 600.005 + 0.01 } ); 
      } /* end of rule : IND.W.7 */
      gLAYER_478 = size( INDDMY, clip_acute = NONE, distance = 6 ); 
      REGION_C = gLAYER_478 not INDDMY; 
      gLAYER_479 = size( INDDMY, clip_acute = NONE, distance = 12 ); 
      gLAYER_480 = size( INDDMY, clip_acute = NONE, distance = 6 ); 
      REGION_D = gLAYER_479 not gLAYER_480; 
      gLAYER_481 = REGION_B or REGION_C; 
      REGION_BCD = gLAYER_481 or REGION_D; 
      IND_JOG_EDGE = adjacent_edge( INDDMY, angle1 = == 90, angle2 = == 270, length = > 0 ); 
      IND_R_EDGE = INDDMY not_coincident_edge IND_JOG_EDGE; 
      PO_ISLAND_PRE = POLY not_outside REGION_BCD; 
      gLAYER_482 = not_interacting( PO_ISLAND_PRE, OD ); 
      PO_ISLAND = not_interacting( gLAYER_482, CO ); 
      M1_ISLAND_PRE = M1 not_outside REGION_BCD; 
      gLAYER_484 = rectangles( M1_ISLAND_PRE, sides = { ( 2.99, 3.01 ), ( 2.99, 3.01 ) } ); 
      gLAYER_483 = not_interacting( gLAYER_484, VIA1 ); 
      M1_ISLAND = not_interacting( gLAYER_483, CO ); 
      M2_ISLAND_PRE = M2 not_outside REGION_BCD; 
      gLAYER_486 = rectangles( M2_ISLAND_PRE, sides = { ( 2.99, 3.01 ), ( 2.99, 3.01 ) } ); 
      gLAYER_485 = not_interacting( gLAYER_486, VIA2 ); 
      M2_ISLAND = not_interacting( gLAYER_485, VIA1 ); 
      M3_ISLAND_PRE = M3 not_outside REGION_BCD; 
      gLAYER_488 = rectangles( M3_ISLAND_PRE, sides = { ( 2.99, 3.01 ), ( 2.99, 3.01 ) } ); 
      gLAYER_487 = not_interacting( gLAYER_488, VIA3 ); 
      M3_ISLAND = not_interacting( gLAYER_487, VIA2 ); 
      M4_ISLAND_PRE = M4 not_outside REGION_BCD; 
      gLAYER_490 = rectangles( M4_ISLAND_PRE, sides = { ( 2.99, 3.01 ), ( 2.99, 3.01 ) } ); 
      gLAYER_489 = not_interacting( gLAYER_490, VIA4 ); 
      M4_ISLAND = not_interacting( gLAYER_489, VIA3 ); 
      M5_ISLAND_PRE = M5 not_outside REGION_BCD; 
      gLAYER_492 = rectangles( M5_ISLAND_PRE, sides = { ( 2.99, 3.01 ), ( 2.99, 3.01 ) } ); 
      gLAYER_491 = not_interacting( gLAYER_492, VIA5 ); 
      M5_ISLAND = not_interacting( gLAYER_491, VIA4 ); 
      M6_ISLAND_PRE = M6 not_outside REGION_BCD; 
      gLAYER_494 = rectangles( M6_ISLAND_PRE, sides = { ( 2.99, 3.01 ), ( 2.99, 3.01 ) } ); 
      gLAYER_493 = not_interacting( gLAYER_494, VIA6 ); 
      M6_ISLAND = not_interacting( gLAYER_493, VIA5 ); 
      M7_ISLAND_PRE = M7 not_outside REGION_BCD; 
      gLAYER_496 = rectangles( M7_ISLAND_PRE, sides = { ( 2.99, 3.01 ), ( 2.99, 3.01 ) } ); 
      gLAYER_495 = not_interacting( gLAYER_496, VIA7 ); 
      M7_ISLAND = not_interacting( gLAYER_495, VIA6 ); 
      M8_ISLAND_PRE = M8 not_outside REGION_BCD; 
      gLAYER_498 = rectangles( M8_ISLAND_PRE, sides = { ( 2.99, 3.01 ), ( 2.99, 3.01 ) } ); 
      gLAYER_497 = not_interacting( gLAYER_498, VIA8 ); 
      M8_ISLAND = not_interacting( gLAYER_497, VIA7 ); 
      M9_ISLAND_PRE = M9 not_outside REGION_BCD; 
      gLAYER_500 = rectangles( M9_ISLAND_PRE, sides = { ( 2.99, 3.01 ), ( 2.99, 3.01 ) } ); 
      gLAYER_499 = not_interacting( gLAYER_500, VIA8 ); 
      M9_ISLAND = not_interacting( gLAYER_499, RV ); 
      gLAYER_501 = M9 and IND_REGION; 
      IND_TM = gLAYER_501 not M9_ISLAND;    /* Top inductor metal inside INDDMY  */ 
      IND_TM_A = external2( IND_TM, INDDMY, < 0.01, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 135 ], look_thru = COINCIDENT, orientation = { } ); 
      IND_TM_B = M9 outside_touching_edge IND_TM_A; 
      IND_TM_B1 = edge_size( IND_TM_B, inside = 0.005 ); 
      gLAYER_502 = and_edge( INDDMY, IND_TM, false ); 
      IND_TM_B2 = edge_size( gLAYER_502, inside = 0.005, outside = 0.005 ); 
      gLAYER_503 = IND_TM_B1 or IND_TM_B2; 
      IND_TM_C = polygon_extents( gLAYER_503 ); 
      gLAYER_504 = internal1( IND_TM_B, < 30.005, extension = NONE, intersecting = {  }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
      IND_TM_LEADING = gLAYER_504 and IND_TM_C; 
      gLAYER_505 = IND_TM not IND_TM_LEADING; 
      IND_TM_SPIRAL = gLAYER_505 and INDDMY;    /* core inductor metal */ 
      LEADING = IND_TM_LEADING and REGION_BCD; 
      LEADING_EXD = size( LEADING, clip_acute = NONE, distance = 20 ); 
      gLAYER_506 = M1 not_outside REGION_B; 
      gLAYER_507 = COOD inside REGION_B; 
      M1_GUARD_RING = interacting( gLAYER_506, gLAYER_507 ); 
      M1_GUARD_RING_P = M1_GUARD_RING and REGION_BCD; 
      M1_GUARD_RING_PX = size( M1_GUARD_RING_P, clip_acute = NONE, distance = 20 ); 
      M1_GUARD_RING_P1 = M1_GUARD_RING and REGION_C; 
      M1_GUARD_RING_P1X = size( M1_GUARD_RING_P1, clip_acute = NONE, distance = 20 ); 
      CTAP_EXD = IND_CTAP and REGION_BCD; 
      CTAP_EXDX = size( CTAP_EXD, clip_acute = NONE, distance = 20 ); 
      gLAYER_510 = edge_size( IND_R_EDGE, inside = 4 ); 
      gLAYER_509 = gLAYER_510 not LEADING_EXD; 
      gLAYER_508 = gLAYER_509 not M1_GUARD_RING_P1X; 
      REGION_BX = gLAYER_508 not CTAP_EXDX; 
      rIND_DN_1_M1 @= { @ "IND.DN.1:M1 : M1 density within ring region b  >= 10%  <= 80%";
          REGION_B_NOT_EXD = REGION_B not LEADING_EXD; 
          CONNECT_DB_IND_DN_1_M1 = incremental_connect( CONNECT_DB, {{{ REGION_B_NOT_EXD }, REGION_B }} ); 
          X = M1X and REGION_B_NOT_EXD; 
          Y = stamp( X, REGION_B_NOT_EXD, CONNECT_DB_IND_DN_1_M1, CONNECT_DB_IND_DN_1_M1, include_touch = NONE ); 
          net_area_ratio( CONNECT_DB_IND_DN_1_M1, < 0.1, { "layer1" => REGION_B_NOT_EXD, "layer2" => Y }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
          net_area_ratio( CONNECT_DB_IND_DN_1_M1, > 0.8, { "layer1" => REGION_B_NOT_EXD, "layer2" => Y }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
      } /* end of rule : IND.DN.1:M1 */
      rIND_DN_1_M2 @= { @ "IND.DN.1:M2 : M2 density within ring region b  >= 10%  <= 80%";
          REGION_B_NOT_EXD = REGION_B not LEADING_EXD; 
          CONNECT_DB_IND_DN_1_M2 = incremental_connect( CONNECT_DB, {{{ REGION_B_NOT_EXD }, REGION_B }} ); 
          X = M2X and REGION_B_NOT_EXD; 
          Y = stamp( X, REGION_B_NOT_EXD, CONNECT_DB_IND_DN_1_M2, CONNECT_DB_IND_DN_1_M2, include_touch = NONE ); 
          net_area_ratio( CONNECT_DB_IND_DN_1_M2, < 0.1, { "layer1" => REGION_B_NOT_EXD, "layer2" => Y }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
          net_area_ratio( CONNECT_DB_IND_DN_1_M2, > 0.8, { "layer1" => REGION_B_NOT_EXD, "layer2" => Y }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
      } /* end of rule : IND.DN.1:M2 */
      rIND_DN_1_M3 @= { @ "IND.DN.1:M3 : M3 density within ring region b  >= 10%  <= 80%";
          REGION_B_NOT_EXD = REGION_B not LEADING_EXD; 
          CONNECT_DB_IND_DN_1_M3 = incremental_connect( CONNECT_DB, {{{ REGION_B_NOT_EXD }, REGION_B }} ); 
          X = M3X and REGION_B_NOT_EXD; 
          Y = stamp( X, REGION_B_NOT_EXD, CONNECT_DB_IND_DN_1_M3, CONNECT_DB_IND_DN_1_M3, include_touch = NONE ); 
          net_area_ratio( CONNECT_DB_IND_DN_1_M3, < 0.1, { "layer1" => REGION_B_NOT_EXD, "layer2" => Y }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
          net_area_ratio( CONNECT_DB_IND_DN_1_M3, > 0.8, { "layer1" => REGION_B_NOT_EXD, "layer2" => Y }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
      } /* end of rule : IND.DN.1:M3 */
      rIND_DN_1_M4 @= { @ "IND.DN.1:M4 : M4 density within ring region b  >= 10%  <= 80%";
          REGION_B_NOT_EXD = REGION_B not LEADING_EXD; 
          CONNECT_DB_IND_DN_1_M4 = incremental_connect( CONNECT_DB, {{{ REGION_B_NOT_EXD }, REGION_B }} ); 
          X = M4X and REGION_B_NOT_EXD; 
          Y = stamp( X, REGION_B_NOT_EXD, CONNECT_DB_IND_DN_1_M4, CONNECT_DB_IND_DN_1_M4, include_touch = NONE ); 
          net_area_ratio( CONNECT_DB_IND_DN_1_M4, < 0.1, { "layer1" => REGION_B_NOT_EXD, "layer2" => Y }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
          net_area_ratio( CONNECT_DB_IND_DN_1_M4, > 0.8, { "layer1" => REGION_B_NOT_EXD, "layer2" => Y }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
      } /* end of rule : IND.DN.1:M4 */
      rIND_DN_1_M5 @= { @ "IND.DN.1:M5 : M5 density within ring region b  >= 10%  <= 80%";
          REGION_B_NOT_EXD = REGION_B not LEADING_EXD; 
          CONNECT_DB_IND_DN_1_M5 = incremental_connect( CONNECT_DB, {{{ REGION_B_NOT_EXD }, REGION_B }} ); 
          X = M5X and REGION_B_NOT_EXD; 
          Y = stamp( X, REGION_B_NOT_EXD, CONNECT_DB_IND_DN_1_M5, CONNECT_DB_IND_DN_1_M5, include_touch = NONE ); 
          net_area_ratio( CONNECT_DB_IND_DN_1_M5, < 0.1, { "layer1" => REGION_B_NOT_EXD, "layer2" => Y }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
          net_area_ratio( CONNECT_DB_IND_DN_1_M5, > 0.8, { "layer1" => REGION_B_NOT_EXD, "layer2" => Y }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
      } /* end of rule : IND.DN.1:M5 */
      rIND_DN_1_M6 @= { @ "IND.DN.1:M6 : M6 density within ring region b  >= 10%  <= 80%";
          REGION_B_NOT_EXD = REGION_B not LEADING_EXD; 
          CONNECT_DB_IND_DN_1_M6 = incremental_connect( CONNECT_DB, {{{ REGION_B_NOT_EXD }, REGION_B }} ); 
          X = M6X and REGION_B_NOT_EXD; 
          Y = stamp( X, REGION_B_NOT_EXD, CONNECT_DB_IND_DN_1_M6, CONNECT_DB_IND_DN_1_M6, include_touch = NONE ); 
          net_area_ratio( CONNECT_DB_IND_DN_1_M6, < 0.1, { "layer1" => REGION_B_NOT_EXD, "layer2" => Y }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
          net_area_ratio( CONNECT_DB_IND_DN_1_M6, > 0.8, { "layer1" => REGION_B_NOT_EXD, "layer2" => Y }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
      } /* end of rule : IND.DN.1:M6 */
      rIND_DN_1_M7 @= { @ "IND.DN.1:M7 : M7 density within ring region b  >= 10%  <= 80%";
          REGION_B_NOT_EXD = REGION_B not LEADING_EXD; 
          CONNECT_DB_IND_DN_1_M7 = incremental_connect( CONNECT_DB, {{{ REGION_B_NOT_EXD }, REGION_B }} ); 
          X = M7X and REGION_B_NOT_EXD; 
          Y = stamp( X, REGION_B_NOT_EXD, CONNECT_DB_IND_DN_1_M7, CONNECT_DB_IND_DN_1_M7, include_touch = NONE ); 
          net_area_ratio( CONNECT_DB_IND_DN_1_M7, < 0.1, { "layer1" => REGION_B_NOT_EXD, "layer2" => Y }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
          net_area_ratio( CONNECT_DB_IND_DN_1_M7, > 0.8, { "layer1" => REGION_B_NOT_EXD, "layer2" => Y }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
      } /* end of rule : IND.DN.1:M7 */
      rIND_DN_1_M8 @= { @ "IND.DN.1:M8 : M8 density within ring region b  >= 10%  <= 80%";
          REGION_B_NOT_EXD = REGION_B not LEADING_EXD; 
          CONNECT_DB_IND_DN_1_M8 = incremental_connect( CONNECT_DB, {{{ REGION_B_NOT_EXD }, REGION_B }} ); 
          X = M8X and REGION_B_NOT_EXD; 
          Y = stamp( X, REGION_B_NOT_EXD, CONNECT_DB_IND_DN_1_M8, CONNECT_DB_IND_DN_1_M8, include_touch = NONE ); 
          net_area_ratio( CONNECT_DB_IND_DN_1_M8, < 0.1, { "layer1" => REGION_B_NOT_EXD, "layer2" => Y }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
          net_area_ratio( CONNECT_DB_IND_DN_1_M8, > 0.8, { "layer1" => REGION_B_NOT_EXD, "layer2" => Y }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
      } /* end of rule : IND.DN.1:M8 */
      rIND_DN_1_M9 @= { @ "IND.DN.1:M9 : M9 density within ring region b  >= 10%  <= 80%";
          REGION_B_NOT_EXD = REGION_B not LEADING_EXD; 
          CONNECT_DB_IND_DN_1_M9 = incremental_connect( CONNECT_DB, {{{ REGION_B_NOT_EXD }, REGION_B }} ); 
          X = M9X and REGION_B_NOT_EXD; 
          Y = stamp( X, REGION_B_NOT_EXD, CONNECT_DB_IND_DN_1_M9, CONNECT_DB_IND_DN_1_M9, include_touch = NONE ); 
          net_area_ratio( CONNECT_DB_IND_DN_1_M9, < 0.1, { "layer1" => REGION_B_NOT_EXD, "layer2" => Y }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
          net_area_ratio( CONNECT_DB_IND_DN_1_M9, > 0.8, { "layer1" => REGION_B_NOT_EXD, "layer2" => Y }, 2, 2, {  }, NAR_SAVE_NET_9, false ); 
      } /* end of rule : IND.DN.1:M9 */
      rIND_R_8_M1 @= { @ "IND.R.8:M1 : Maximun empty area within ring region b <= 4 x 12";
          sLAYER_950 = REGION_BX not M1X; 
          sLAYER_949 = sLAYER_950 not M1_GUARD_RING_PX; 
          A = wide( sLAYER_949, >= ( 4 - GRID ), forty_five = INTERNAL ); 
          contains( A, { 4 - GRID, 12 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.R.8:M1 */
      rIND_R_8_M2 @= { @ "IND.R.8:M2 : Maximun empty area within ring region b <= 4 x 12";
          sLAYER_951 = REGION_BX not M2X; 
          A = wide( sLAYER_951, >= ( 4 - GRID ), forty_five = INTERNAL ); 
          contains( A, { 4 - GRID, 12 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.R.8:M2 */
      rIND_R_8_M3 @= { @ "IND.R.8:M3 : Maximun empty area within ring region b <= 4 x 12";
          sLAYER_952 = REGION_BX not M3X; 
          A = wide( sLAYER_952, >= ( 4 - GRID ), forty_five = INTERNAL ); 
          contains( A, { 4 - GRID, 12 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.R.8:M3 */
      rIND_R_8_M4 @= { @ "IND.R.8:M4 : Maximun empty area within ring region b <= 4 x 12";
          sLAYER_953 = REGION_BX not M4X; 
          A = wide( sLAYER_953, >= ( 4 - GRID ), forty_five = INTERNAL ); 
          contains( A, { 4 - GRID, 12 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.R.8:M4 */
      rIND_R_8_M5 @= { @ "IND.R.8:M5 : Maximun empty area within ring region b <= 4 x 12";
          sLAYER_954 = REGION_BX not M5X; 
          A = wide( sLAYER_954, >= ( 4 - GRID ), forty_five = INTERNAL ); 
          contains( A, { 4 - GRID, 12 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.R.8:M5 */
      rIND_R_8_M6 @= { @ "IND.R.8:M6 : Maximun empty area within ring region b <= 4 x 12";
          sLAYER_955 = REGION_BX not M6X; 
          A = wide( sLAYER_955, >= ( 4 - GRID ), forty_five = INTERNAL ); 
          contains( A, { 4 - GRID, 12 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.R.8:M6 */
      rIND_R_8_M7 @= { @ "IND.R.8:M7 : Maximun empty area within ring region b <= 4 x 12";
          sLAYER_956 = REGION_BX not M7X; 
          A = wide( sLAYER_956, >= ( 4 - GRID ), forty_five = INTERNAL ); 
          contains( A, { 4 - GRID, 12 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.R.8:M7 */
      rIND_R_8_M8 @= { @ "IND.R.8:M8 : Maximun empty area within ring region b <= 4 x 12";
          sLAYER_957 = REGION_BX not M8X; 
          A = wide( sLAYER_957, >= ( 4 - GRID ), forty_five = INTERNAL ); 
          contains( A, { 4 - GRID, 12 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.R.8:M8 */
      rIND_R_8_M9 @= { @ "IND.R.8:M9 : Maximun empty area within ring region b <= 4 x 12";
          sLAYER_958 = REGION_BX not M9X; 
          A = wide( sLAYER_958, >= ( 4 - GRID ), forty_five = INTERNAL ); 
          contains( A, { 4 - GRID, 12 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND.R.8:M9 */
      rIND_R_1 @= { @ "IND.R.1 : In the region of (INDDMY SIZING 12um), inter-via (Vx) is not allowed.";
          VIA1 and IND_REGION; 
          VIA2 and IND_REGION; 
          VIA3 and IND_REGION; 
          VIA4 and IND_REGION; 
          VIA5 and IND_REGION; 
          VIA6 and IND_REGION; 
      } /* end of rule : IND.R.1 */
      
      //IND.R.2 and IND.R.3 are checked by IND.R.2__IND.R.3:VIA7
      rIND_R_2__IND_R_3_VIA7 @= { @ "IND.R.2__IND.R.3:VIA7 : More than 4 VIA7 with space <= 1.7 um is required to connect M8(Mz or Mu) and M7(Mz or Mx) for inductor application only.";
          sLAYER_959 = M8 and M7; 
          M8OVPM7 = sLAYER_959 and IND_REGION; 
          CHECK_VIA7 = interacting( VIA7_EXD, M8OVPM7 ); 
          VIA7MERGE = size_inside_wrapper( CHECK_VIA7, M8OVPM7, distance = ( 1.7 / 2 ), increment = M7_S_1 * 0.7 ); 
          VIA7MERGE2 = enclosing( VIA7MERGE, CHECK_VIA7, >= 4 ); 
          GOOD_VIA7 = CHECK_VIA7 and VIA7MERGE2; 
          GM8OVPM7 = interacting( M8OVPM7, GOOD_VIA7 ); 
          CHECK_VIA7 outside GM8OVPM7; 
      } /* end of rule : IND.R.2__IND.R.3:VIA7 */
      
      //IND.R.2 and IND.R.3 are checked by IND.R.2__IND.R.3:VIA8
      rIND_R_2__IND_R_3_VIA8 @= { @ "IND.R.2__IND.R.3:VIA8 : More than 4 VIA8 with space <= 1.7 um is required to connect M9(Mz or Mu) and M8(Mz or Mx) for inductor application only.";
          sLAYER_960 = M9 and M8; 
          M9OVPM8 = sLAYER_960 and IND_REGION; 
          CHECK_VIA8 = interacting( VIA8_EXD, M9OVPM8 ); 
          VIA8MERGE = size_inside_wrapper( CHECK_VIA8, M9OVPM8, distance = ( 1.7 / 2 ), increment = M8_S_1 * 0.7 ); 
          VIA8MERGE2 = enclosing( VIA8MERGE, CHECK_VIA8, >= 4 ); 
          GOOD_VIA8 = CHECK_VIA8 and VIA8MERGE2; 
          GM9OVPM8 = interacting( M9OVPM8, GOOD_VIA8 ); 
          CHECK_VIA8 outside GM9OVPM8; 
      } /* end of rule : IND.R.2__IND.R.3:VIA8 */
      rIND_R_4 @= { @ "IND.R.4 : In the region a of (INDDMY SIZING -4 um), except the Mx layer directly below [Mz or Mu], any other inter-metal layer (Mx) is not allowed.";
          M2 and REGION_A; 
          M3 and REGION_A; 
          M4 and REGION_A; 
          M5 and REGION_A; 
          M6 and REGION_A; 
      } /* end of rule : IND.R.4 */
      rIND_R_13 @= { @ "IND.R.13 : INDDMY enclosure of top metal(inductor) >= 4 um.";
          INDDMYX45 = angle_edge( INDDMY, == 45 ); 
          INDDMYX090 = INDDMY not_coincident_edge INDDMYX45; 
          IND_TM_CORE_CHECK = IND_TM_SPIRAL not_inside_touching_edge IND_TM_B; 
          enclose( IND_TM_CORE_CHECK, INDDMYX45, < ( 4 - GRID ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.004 ); 
          enclose( IND_TM_CORE_CHECK, INDDMYX090, < 4, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.004 ); 
      } /* end of rule : IND.R.13 */
      
      //IND.R.5U, IND.R.7U  can not be checked by DRC
      rIND_R_6 @= { @ "IND.R.6 : In region b, 3um x 3um metal islands with 3um space from M2~Mtop are required.";
          not_interacting( REGION_B, M2_ISLAND ); 
          not_interacting( REGION_B, M3_ISLAND ); 
          not_interacting( REGION_B, M4_ISLAND ); 
          not_interacting( REGION_B, M5_ISLAND ); 
          not_interacting( REGION_B, M6_ISLAND ); 
          not_interacting( REGION_B, M7_ISLAND ); 
          not_interacting( REGION_B, M8_ISLAND ); 
          not_interacting( REGION_B, M9_ISLAND ); 
      } /* end of rule : IND.R.6 */
      #ifdef FULL_CHIP 
         rIND_DN_6 @= { @ "IND.DN.6 : Maximum density of INDDMY in whole chip <= 5%";
             VAR_58 = density_statistics_file( file = "IND.DN.6.density" ); 
         _den_con = > 0.05;
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => INDDMY, "layer2" => gCHIP }, statistics_files = { VAR_58 }, window_function = den_save_window_1 ); 
         } /* end of rule : IND.DN.6 */
         rIND_DN_9 @= { @ "IND.DN.9 : M1/Mx/Mz. metal density over the whole chip >= 20%";
             CHIP_IND = interacting( CHIPX, INDDMY ); 
             VAR_59 = density_statistics_file( file = "IND.DN.9.M1.density" ); 
         _den_con = < 0.2;
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIP_IND, layer_hash = { "layer1" => M1X, "layer2" => gCHIP }, statistics_files = { VAR_59 }, window_function = den_save_window_1 ); 
             VAR_60 = density_statistics_file( file = "IND.DN.9.M2.density" ); 
         _den_con = < 0.2;
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIP_IND, layer_hash = { "layer1" => M2X, "layer2" => gCHIP }, statistics_files = { VAR_60 }, window_function = den_save_window_1 ); 
             VAR_61 = density_statistics_file( file = "IND.DN.9.M3.density" ); 
         _den_con = < 0.2;
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIP_IND, layer_hash = { "layer1" => M3X, "layer2" => gCHIP }, statistics_files = { VAR_61 }, window_function = den_save_window_1 ); 
             VAR_62 = density_statistics_file( file = "IND.DN.9.M4.density" ); 
         _den_con = < 0.2;
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIP_IND, layer_hash = { "layer1" => M4X, "layer2" => gCHIP }, statistics_files = { VAR_62 }, window_function = den_save_window_1 ); 
             VAR_63 = density_statistics_file( file = "IND.DN.9.M5.density" ); 
         _den_con = < 0.2;
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIP_IND, layer_hash = { "layer1" => M5X, "layer2" => gCHIP }, statistics_files = { VAR_63 }, window_function = den_save_window_1 ); 
             VAR_64 = density_statistics_file( file = "IND.DN.9.M6.density" ); 
         _den_con = < 0.2;
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIP_IND, layer_hash = { "layer1" => M6X, "layer2" => gCHIP }, statistics_files = { VAR_64 }, window_function = den_save_window_1 ); 
             VAR_65 = density_statistics_file( file = "IND.DN.9.M7.density" ); 
         _den_con = < 0.2;
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIP_IND, layer_hash = { "layer1" => M7X, "layer2" => gCHIP }, statistics_files = { VAR_65 }, window_function = den_save_window_1 ); 
             VAR_66 = density_statistics_file( file = "IND.DN.9.M8.density" ); 
         _den_con = < 0.2;
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIP_IND, layer_hash = { "layer1" => M8X, "layer2" => gCHIP }, statistics_files = { VAR_66 }, window_function = den_save_window_1 ); 
             VAR_67 = density_statistics_file( file = "IND.DN.9.M9.density" ); 
         _den_con = < 0.2;
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIP_IND, layer_hash = { "layer1" => M9X, "layer2" => gCHIP }, statistics_files = { VAR_67 }, window_function = den_save_window_1 ); 
         } /* end of rule : IND.DN.9 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      rIND_DN_7_M1 @= { @ "IND.DN.7:M1 : Maximum density within (INDDMY SIZING 12 um) over any 50um x 50um area (stepping in 25um) <= 90%";
          VAR_68 = density_statistics_file( file = "IND.DN.7.M1.density" ); 
      _den_con = > 0.9;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_REGION, layer_hash = { "layer1" => M1X }, delta_window = { 50, 50 }, delta_x = 25, delta_y = 25, boundary = BACKUP, statistics_files = { VAR_68 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND.DN.7:M1 */
      rIND_DN_7_M2 @= { @ "IND.DN.7:M2 : Maximum density within (INDDMY SIZING 12 um) over any 50um x 50um area (stepping in 25um) <= 90%";
          VAR_69 = density_statistics_file( file = "IND.DN.7.M2.density" ); 
      _den_con = > 0.9;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_REGION, layer_hash = { "layer1" => M2X }, delta_window = { 50, 50 }, delta_x = 25, delta_y = 25, boundary = BACKUP, statistics_files = { VAR_69 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND.DN.7:M2 */
      rIND_DN_7_M3 @= { @ "IND.DN.7:M3 : Maximum density within (INDDMY SIZING 12 um) over any 50um x 50um area (stepping in 25um) <= 90%";
          VAR_70 = density_statistics_file( file = "IND.DN.7.M3.density" ); 
      _den_con = > 0.9;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_REGION, layer_hash = { "layer1" => M3X }, delta_window = { 50, 50 }, delta_x = 25, delta_y = 25, boundary = BACKUP, statistics_files = { VAR_70 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND.DN.7:M3 */
      rIND_DN_7_M4 @= { @ "IND.DN.7:M4 : Maximum density within (INDDMY SIZING 12 um) over any 50um x 50um area (stepping in 25um) <= 90%";
          VAR_71 = density_statistics_file( file = "IND.DN.7.M4.density" ); 
      _den_con = > 0.9;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_REGION, layer_hash = { "layer1" => M4X }, delta_window = { 50, 50 }, delta_x = 25, delta_y = 25, boundary = BACKUP, statistics_files = { VAR_71 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND.DN.7:M4 */
      rIND_DN_7_M5 @= { @ "IND.DN.7:M5 : Maximum density within (INDDMY SIZING 12 um) over any 50um x 50um area (stepping in 25um) <= 90%";
          VAR_72 = density_statistics_file( file = "IND.DN.7.M5.density" ); 
      _den_con = > 0.9;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_REGION, layer_hash = { "layer1" => M5X }, delta_window = { 50, 50 }, delta_x = 25, delta_y = 25, boundary = BACKUP, statistics_files = { VAR_72 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND.DN.7:M5 */
      rIND_DN_7_M6 @= { @ "IND.DN.7:M6 : Maximum density within (INDDMY SIZING 12 um) over any 50um x 50um area (stepping in 25um) <= 90%";
          VAR_73 = density_statistics_file( file = "IND.DN.7.M6.density" ); 
      _den_con = > 0.9;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_REGION, layer_hash = { "layer1" => M6X }, delta_window = { 50, 50 }, delta_x = 25, delta_y = 25, boundary = BACKUP, statistics_files = { VAR_73 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND.DN.7:M6 */
      rIND_DN_7_M7 @= { @ "IND.DN.7:M7 : Maximum density within (INDDMY SIZING 12 um) over any 50um x 50um area (stepping in 25um) <= 90%";
          VAR_74 = density_statistics_file( file = "IND.DN.7.M7.density" ); 
      _den_con = > 0.9;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_REGION, layer_hash = { "layer1" => M7X }, delta_window = { 50, 50 }, delta_x = 25, delta_y = 25, boundary = BACKUP, statistics_files = { VAR_74 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND.DN.7:M7 */
      rIND_DN_7_M8 @= { @ "IND.DN.7:M8 : Maximum density within (INDDMY SIZING 12 um) over any 50um x 50um area (stepping in 25um) <= 90%";
          VAR_75 = density_statistics_file( file = "IND.DN.7.M8.density" ); 
      _den_con = > 0.9;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_REGION, layer_hash = { "layer1" => M8X }, delta_window = { 50, 50 }, delta_x = 25, delta_y = 25, boundary = BACKUP, statistics_files = { VAR_75 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND.DN.7:M8 */
      rIND_DN_8_M1 @= { @ "IND.DN.8:M1 : Maximum density within (INDDMY SIZING 12 um) over any 100um x 100um area (stepping in 50um) <= 80%";
          VAR_76 = density_statistics_file( file = "IND.DN.8.M1.density" ); 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_REGION, layer_hash = { "layer1" => M1X }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_76 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND.DN.8:M1 */
      rIND_DN_8_M2 @= { @ "IND.DN.8:M2 : Maximum density within (INDDMY SIZING 12 um) over any 100um x 100um area (stepping in 50um) <= 80%";
          VAR_77 = density_statistics_file( file = "IND.DN.8.M2.density" ); 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_REGION, layer_hash = { "layer1" => M2X }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_77 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND.DN.8:M2 */
      rIND_DN_8_M3 @= { @ "IND.DN.8:M3 : Maximum density within (INDDMY SIZING 12 um) over any 100um x 100um area (stepping in 50um) <= 80%";
          VAR_78 = density_statistics_file( file = "IND.DN.8.M3.density" ); 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_REGION, layer_hash = { "layer1" => M3X }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_78 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND.DN.8:M3 */
      rIND_DN_8_M4 @= { @ "IND.DN.8:M4 : Maximum density within (INDDMY SIZING 12 um) over any 100um x 100um area (stepping in 50um) <= 80%";
          VAR_79 = density_statistics_file( file = "IND.DN.8.M4.density" ); 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_REGION, layer_hash = { "layer1" => M4X }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_79 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND.DN.8:M4 */
      rIND_DN_8_M5 @= { @ "IND.DN.8:M5 : Maximum density within (INDDMY SIZING 12 um) over any 100um x 100um area (stepping in 50um) <= 80%";
          VAR_80 = density_statistics_file( file = "IND.DN.8.M5.density" ); 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_REGION, layer_hash = { "layer1" => M5X }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_80 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND.DN.8:M5 */
      rIND_DN_8_M6 @= { @ "IND.DN.8:M6 : Maximum density within (INDDMY SIZING 12 um) over any 100um x 100um area (stepping in 50um) <= 80%";
          VAR_81 = density_statistics_file( file = "IND.DN.8.M6.density" ); 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_REGION, layer_hash = { "layer1" => M6X }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_81 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND.DN.8:M6 */
      rIND_DN_8_M7 @= { @ "IND.DN.8:M7 : Maximum density within (INDDMY SIZING 12 um) over any 100um x 100um area (stepping in 50um) <= 80%";
          VAR_82 = density_statistics_file( file = "IND.DN.8.M7.density" ); 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_REGION, layer_hash = { "layer1" => M7X }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_82 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND.DN.8:M7 */
      rIND_DN_8_M8 @= { @ "IND.DN.8:M8 : Maximum density within (INDDMY SIZING 12 um) over any 100um x 100um area (stepping in 50um) <= 80%";
          VAR_83 = density_statistics_file( file = "IND.DN.8.M8.density" ); 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_REGION, layer_hash = { "layer1" => M8X }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_83 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND.DN.8:M8 */
      
      //IND.R.15 is checked by [IND.S.1 ~ IND.S.5]
      //IND.R.16 is checked by {RV.S.1.WB/RV.EN.1.WB/AP.W.1.WB/AP.W.2.WB/AP.S.1.WB}
      IND_MD_M1 = M1X and IND_COIL_REGION; 
      IND_MD_WIDEM11_p_5 = wide( IND_MD_M1, > 1.5, forty_five = INTERNAL ); 
      IND_MD_WIDEM14_p_5 = wide( IND_MD_WIDEM11_p_5, > 4.5, forty_five = INTERNAL ); 
      IND_MD_M2 = M2X and IND_COIL_REGION; 
      IND_MD_WIDEM21_p_5 = wide( IND_MD_M2, > 1.5, forty_five = INTERNAL ); 
      IND_MD_WIDEM24_p_5 = wide( IND_MD_WIDEM21_p_5, > 4.5, forty_five = INTERNAL ); 
      IND_MD_M3 = M3X and IND_COIL_REGION; 
      IND_MD_WIDEM31_p_5 = wide( IND_MD_M3, > 1.5, forty_five = INTERNAL ); 
      IND_MD_WIDEM34_p_5 = wide( IND_MD_WIDEM31_p_5, > 4.5, forty_five = INTERNAL ); 
      IND_MD_M4 = M4X and IND_COIL_REGION; 
      IND_MD_WIDEM41_p_5 = wide( IND_MD_M4, > 1.5, forty_five = INTERNAL ); 
      IND_MD_WIDEM44_p_5 = wide( IND_MD_WIDEM41_p_5, > 4.5, forty_five = INTERNAL ); 
      IND_MD_M5 = M5X and IND_COIL_REGION; 
      IND_MD_WIDEM51_p_5 = wide( IND_MD_M5, > 1.5, forty_five = INTERNAL ); 
      IND_MD_WIDEM54_p_5 = wide( IND_MD_WIDEM51_p_5, > 4.5, forty_five = INTERNAL ); 
      IND_MD_M6 = M6X and IND_COIL_REGION; 
      IND_MD_WIDEM61_p_5 = wide( IND_MD_M6, > 1.5, forty_five = INTERNAL ); 
      IND_MD_WIDEM64_p_5 = wide( IND_MD_WIDEM61_p_5, > 4.5, forty_five = INTERNAL ); 
      IND_MD_M7 = M7X and IND_COIL_REGION; 
      IND_MD_WIDEM71_p_5 = wide( IND_MD_M7, > 1.5, forty_five = INTERNAL ); 
      IND_MD_WIDEM74_p_5 = wide( IND_MD_WIDEM71_p_5, > 4.5, forty_five = INTERNAL ); 
      IND_MD_M8 = M8X and IND_COIL_REGION; 
      IND_MD_WIDEM81_p_5 = wide( IND_MD_M8, > 1.5, forty_five = INTERNAL ); 
      IND_MD_WIDEM84_p_5 = wide( IND_MD_WIDEM81_p_5, > 4.5, forty_five = INTERNAL ); 
      IND_MD_M9 = M9X and IND_COIL_REGION; 
      IND_MD_WIDEM91_p_5 = wide( IND_MD_M9, > 1.5, forty_five = INTERNAL ); 
      IND_MD_WIDEM94_p_5 = wide( IND_MD_WIDEM91_p_5, > 4.5, forty_five = INTERNAL ); 
      
      //IND_MD.DN.11 is checked by IND_MD.DN.11:L_M1 and IND_MD.DN.11:H_M1
      rIND_MD_DN_11_L_M1 @= { @ "IND_MD.DN.11:L_M1 : M1 density in the region of (INDDMY_MD NOT (INDDMY_COIL AND INDDMY_MD)) >= 15%, <= 80%";
          sLAYER_961 = INDDMY_COIL and INDDMY_MD; 
          IND_MD_NOT_COIL = INDDMY_MD not sLAYER_961; 
          IND_MD_NOT_COILX = copy( IND_MD_NOT_COIL ); 
          A = M1X and IND_MD_NOT_COIL; 
      _den_con = < 0.15;
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => A, "layer2" => IND_MD_NOT_COIL }, delta_window = { 75, 75 }, delta_x = 37.5, delta_y = 37.5, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_962 = ERR_WIN and IND_MD_NOT_COIL; 
          F = wide( sLAYER_962, >= ( 75 / 4 ), forty_five = INTERNAL ); 
          VAR_84 = density_statistics_file( file = "IND_MD.DN.11L.M1.density" ); 
      _den_con = < 0.15;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => F, "layer2" => A, "layer3" => IND_MD_NOT_COIL }, delta_window = { 75, 75 }, delta_x = 37.5, delta_y = 37.5, boundary = BACKUP, statistics_files = { VAR_84 }, window_function = den_save_window_2 ); 
      } /* end of rule : IND_MD.DN.11:L_M1 */
      rIND_MD_DN_11_H_M1 @= { @ "IND_MD.DN.11:H_M1 : M1 density in the region of (INDDMY_MD NOT (INDDMY_COIL AND INDDMY_MD)) >= 15%, <= 80%";
          sLAYER_963 = INDDMY_COIL and INDDMY_MD; 
          IND_MD_NOT_COIL = INDDMY_MD not sLAYER_963; 
          IND_MD_NOT_COILX = copy( IND_MD_NOT_COIL ); 
          A = M1X and IND_MD_NOT_COIL; 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => A, "layer2" => IND_MD_NOT_COIL }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_964 = ERR_WIN and IND_MD_NOT_COIL; 
          F = wide( sLAYER_964, >= ( 100 / 4 ), forty_five = INTERNAL ); 
          VAR_85 = density_statistics_file( file = "IND_MD.DN.11H.M1.density" ); 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => F, "layer2" => A, "layer3" => IND_MD_NOT_COIL }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_85 }, window_function = den_save_window_3 ); 
      } /* end of rule : IND_MD.DN.11:H_M1 */
      
      //IND_MD.DN.11 is checked by IND_MD.DN.11:L_M2 and IND_MD.DN.11:H_M2
      rIND_MD_DN_11_L_M2 @= { @ "IND_MD.DN.11:L_M2 : M2 density in the region of (INDDMY_MD NOT (INDDMY_COIL AND INDDMY_MD)) >= 15%, <= 80%";
          sLAYER_965 = INDDMY_COIL and INDDMY_MD; 
          IND_MD_NOT_COIL = INDDMY_MD not sLAYER_965; 
          IND_MD_NOT_COILX = copy( IND_MD_NOT_COIL ); 
          A = M2X and IND_MD_NOT_COIL; 
      _den_con = < 0.15;
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => A, "layer2" => IND_MD_NOT_COIL }, delta_window = { 75, 75 }, delta_x = 37.5, delta_y = 37.5, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_966 = ERR_WIN and IND_MD_NOT_COIL; 
          F = wide( sLAYER_966, >= ( 75 / 4 ), forty_five = INTERNAL ); 
          VAR_86 = density_statistics_file( file = "IND_MD.DN.11L.M2.density" ); 
      _den_con = < 0.15;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => F, "layer2" => A, "layer3" => IND_MD_NOT_COIL }, delta_window = { 75, 75 }, delta_x = 37.5, delta_y = 37.5, boundary = BACKUP, statistics_files = { VAR_86 }, window_function = den_save_window_2 ); 
      } /* end of rule : IND_MD.DN.11:L_M2 */
      rIND_MD_DN_11_H_M2 @= { @ "IND_MD.DN.11:H_M2 : M2 density in the region of (INDDMY_MD NOT (INDDMY_COIL AND INDDMY_MD)) >= 15%, <= 80%";
          sLAYER_967 = INDDMY_COIL and INDDMY_MD; 
          IND_MD_NOT_COIL = INDDMY_MD not sLAYER_967; 
          IND_MD_NOT_COILX = copy( IND_MD_NOT_COIL ); 
          A = M2X and IND_MD_NOT_COIL; 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => A, "layer2" => IND_MD_NOT_COIL }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_968 = ERR_WIN and IND_MD_NOT_COIL; 
          F = wide( sLAYER_968, >= ( 100 / 4 ), forty_five = INTERNAL ); 
          VAR_87 = density_statistics_file( file = "IND_MD.DN.11H.M2.density" ); 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => F, "layer2" => A, "layer3" => IND_MD_NOT_COIL }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_87 }, window_function = den_save_window_3 ); 
      } /* end of rule : IND_MD.DN.11:H_M2 */
      
      //IND_MD.DN.11 is checked by IND_MD.DN.11:L_M3 and IND_MD.DN.11:H_M3
      rIND_MD_DN_11_L_M3 @= { @ "IND_MD.DN.11:L_M3 : M3 density in the region of (INDDMY_MD NOT (INDDMY_COIL AND INDDMY_MD)) >= 15%, <= 80%";
          sLAYER_969 = INDDMY_COIL and INDDMY_MD; 
          IND_MD_NOT_COIL = INDDMY_MD not sLAYER_969; 
          IND_MD_NOT_COILX = copy( IND_MD_NOT_COIL ); 
          A = M3X and IND_MD_NOT_COIL; 
      _den_con = < 0.15;
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => A, "layer2" => IND_MD_NOT_COIL }, delta_window = { 75, 75 }, delta_x = 37.5, delta_y = 37.5, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_970 = ERR_WIN and IND_MD_NOT_COIL; 
          F = wide( sLAYER_970, >= ( 75 / 4 ), forty_five = INTERNAL ); 
          VAR_88 = density_statistics_file( file = "IND_MD.DN.11L.M3.density" ); 
      _den_con = < 0.15;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => F, "layer2" => A, "layer3" => IND_MD_NOT_COIL }, delta_window = { 75, 75 }, delta_x = 37.5, delta_y = 37.5, boundary = BACKUP, statistics_files = { VAR_88 }, window_function = den_save_window_2 ); 
      } /* end of rule : IND_MD.DN.11:L_M3 */
      rIND_MD_DN_11_H_M3 @= { @ "IND_MD.DN.11:H_M3 : M3 density in the region of (INDDMY_MD NOT (INDDMY_COIL AND INDDMY_MD)) >= 15%, <= 80%";
          sLAYER_971 = INDDMY_COIL and INDDMY_MD; 
          IND_MD_NOT_COIL = INDDMY_MD not sLAYER_971; 
          IND_MD_NOT_COILX = copy( IND_MD_NOT_COIL ); 
          A = M3X and IND_MD_NOT_COIL; 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => A, "layer2" => IND_MD_NOT_COIL }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_972 = ERR_WIN and IND_MD_NOT_COIL; 
          F = wide( sLAYER_972, >= ( 100 / 4 ), forty_five = INTERNAL ); 
          VAR_89 = density_statistics_file( file = "IND_MD.DN.11H.M3.density" ); 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => F, "layer2" => A, "layer3" => IND_MD_NOT_COIL }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_89 }, window_function = den_save_window_3 ); 
      } /* end of rule : IND_MD.DN.11:H_M3 */
      
      //IND_MD.DN.11 is checked by IND_MD.DN.11:L_M4 and IND_MD.DN.11:H_M4
      rIND_MD_DN_11_L_M4 @= { @ "IND_MD.DN.11:L_M4 : M4 density in the region of (INDDMY_MD NOT (INDDMY_COIL AND INDDMY_MD)) >= 15%, <= 80%";
          sLAYER_973 = INDDMY_COIL and INDDMY_MD; 
          IND_MD_NOT_COIL = INDDMY_MD not sLAYER_973; 
          IND_MD_NOT_COILX = copy( IND_MD_NOT_COIL ); 
          A = M4X and IND_MD_NOT_COIL; 
      _den_con = < 0.15;
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => A, "layer2" => IND_MD_NOT_COIL }, delta_window = { 75, 75 }, delta_x = 37.5, delta_y = 37.5, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_974 = ERR_WIN and IND_MD_NOT_COIL; 
          F = wide( sLAYER_974, >= ( 75 / 4 ), forty_five = INTERNAL ); 
          VAR_90 = density_statistics_file( file = "IND_MD.DN.11L.M4.density" ); 
      _den_con = < 0.15;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => F, "layer2" => A, "layer3" => IND_MD_NOT_COIL }, delta_window = { 75, 75 }, delta_x = 37.5, delta_y = 37.5, boundary = BACKUP, statistics_files = { VAR_90 }, window_function = den_save_window_2 ); 
      } /* end of rule : IND_MD.DN.11:L_M4 */
      rIND_MD_DN_11_H_M4 @= { @ "IND_MD.DN.11:H_M4 : M4 density in the region of (INDDMY_MD NOT (INDDMY_COIL AND INDDMY_MD)) >= 15%, <= 80%";
          sLAYER_975 = INDDMY_COIL and INDDMY_MD; 
          IND_MD_NOT_COIL = INDDMY_MD not sLAYER_975; 
          IND_MD_NOT_COILX = copy( IND_MD_NOT_COIL ); 
          A = M4X and IND_MD_NOT_COIL; 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => A, "layer2" => IND_MD_NOT_COIL }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_976 = ERR_WIN and IND_MD_NOT_COIL; 
          F = wide( sLAYER_976, >= ( 100 / 4 ), forty_five = INTERNAL ); 
          VAR_91 = density_statistics_file( file = "IND_MD.DN.11H.M4.density" ); 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => F, "layer2" => A, "layer3" => IND_MD_NOT_COIL }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_91 }, window_function = den_save_window_3 ); 
      } /* end of rule : IND_MD.DN.11:H_M4 */
      
      //IND_MD.DN.11 is checked by IND_MD.DN.11:L_M5 and IND_MD.DN.11:H_M5
      rIND_MD_DN_11_L_M5 @= { @ "IND_MD.DN.11:L_M5 : M5 density in the region of (INDDMY_MD NOT (INDDMY_COIL AND INDDMY_MD)) >= 15%, <= 80%";
          sLAYER_977 = INDDMY_COIL and INDDMY_MD; 
          IND_MD_NOT_COIL = INDDMY_MD not sLAYER_977; 
          IND_MD_NOT_COILX = copy( IND_MD_NOT_COIL ); 
          A = M5X and IND_MD_NOT_COIL; 
      _den_con = < 0.15;
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => A, "layer2" => IND_MD_NOT_COIL }, delta_window = { 75, 75 }, delta_x = 37.5, delta_y = 37.5, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_978 = ERR_WIN and IND_MD_NOT_COIL; 
          F = wide( sLAYER_978, >= ( 75 / 4 ), forty_five = INTERNAL ); 
          VAR_92 = density_statistics_file( file = "IND_MD.DN.11L.M5.density" ); 
      _den_con = < 0.15;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => F, "layer2" => A, "layer3" => IND_MD_NOT_COIL }, delta_window = { 75, 75 }, delta_x = 37.5, delta_y = 37.5, boundary = BACKUP, statistics_files = { VAR_92 }, window_function = den_save_window_2 ); 
      } /* end of rule : IND_MD.DN.11:L_M5 */
      rIND_MD_DN_11_H_M5 @= { @ "IND_MD.DN.11:H_M5 : M5 density in the region of (INDDMY_MD NOT (INDDMY_COIL AND INDDMY_MD)) >= 15%, <= 80%";
          sLAYER_979 = INDDMY_COIL and INDDMY_MD; 
          IND_MD_NOT_COIL = INDDMY_MD not sLAYER_979; 
          IND_MD_NOT_COILX = copy( IND_MD_NOT_COIL ); 
          A = M5X and IND_MD_NOT_COIL; 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => A, "layer2" => IND_MD_NOT_COIL }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_980 = ERR_WIN and IND_MD_NOT_COIL; 
          F = wide( sLAYER_980, >= ( 100 / 4 ), forty_five = INTERNAL ); 
          VAR_93 = density_statistics_file( file = "IND_MD.DN.11H.M5.density" ); 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => F, "layer2" => A, "layer3" => IND_MD_NOT_COIL }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_93 }, window_function = den_save_window_3 ); 
      } /* end of rule : IND_MD.DN.11:H_M5 */
      
      //IND_MD.DN.11 is checked by IND_MD.DN.11:L_M6 and IND_MD.DN.11:H_M6
      rIND_MD_DN_11_L_M6 @= { @ "IND_MD.DN.11:L_M6 : M6 density in the region of (INDDMY_MD NOT (INDDMY_COIL AND INDDMY_MD)) >= 15%, <= 80%";
          sLAYER_981 = INDDMY_COIL and INDDMY_MD; 
          IND_MD_NOT_COIL = INDDMY_MD not sLAYER_981; 
          IND_MD_NOT_COILX = copy( IND_MD_NOT_COIL ); 
          A = M6X and IND_MD_NOT_COIL; 
      _den_con = < 0.15;
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => A, "layer2" => IND_MD_NOT_COIL }, delta_window = { 75, 75 }, delta_x = 37.5, delta_y = 37.5, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_982 = ERR_WIN and IND_MD_NOT_COIL; 
          F = wide( sLAYER_982, >= ( 75 / 4 ), forty_five = INTERNAL ); 
          VAR_94 = density_statistics_file( file = "IND_MD.DN.11L.M6.density" ); 
      _den_con = < 0.15;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => F, "layer2" => A, "layer3" => IND_MD_NOT_COIL }, delta_window = { 75, 75 }, delta_x = 37.5, delta_y = 37.5, boundary = BACKUP, statistics_files = { VAR_94 }, window_function = den_save_window_2 ); 
      } /* end of rule : IND_MD.DN.11:L_M6 */
      rIND_MD_DN_11_H_M6 @= { @ "IND_MD.DN.11:H_M6 : M6 density in the region of (INDDMY_MD NOT (INDDMY_COIL AND INDDMY_MD)) >= 15%, <= 80%";
          sLAYER_983 = INDDMY_COIL and INDDMY_MD; 
          IND_MD_NOT_COIL = INDDMY_MD not sLAYER_983; 
          IND_MD_NOT_COILX = copy( IND_MD_NOT_COIL ); 
          A = M6X and IND_MD_NOT_COIL; 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => A, "layer2" => IND_MD_NOT_COIL }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_984 = ERR_WIN and IND_MD_NOT_COIL; 
          F = wide( sLAYER_984, >= ( 100 / 4 ), forty_five = INTERNAL ); 
          VAR_95 = density_statistics_file( file = "IND_MD.DN.11H.M6.density" ); 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => F, "layer2" => A, "layer3" => IND_MD_NOT_COIL }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_95 }, window_function = den_save_window_3 ); 
      } /* end of rule : IND_MD.DN.11:H_M6 */
      
      //IND_MD.DN.11 is checked by IND_MD.DN.11:L_M7 and IND_MD.DN.11:H_M7
      rIND_MD_DN_11_L_M7 @= { @ "IND_MD.DN.11:L_M7 : M7 density in the region of (INDDMY_MD NOT (INDDMY_COIL AND INDDMY_MD)) >= 15%, <= 80%";
          sLAYER_985 = INDDMY_COIL and INDDMY_MD; 
          IND_MD_NOT_COIL = INDDMY_MD not sLAYER_985; 
          IND_MD_NOT_COILX = copy( IND_MD_NOT_COIL ); 
          A = M7X and IND_MD_NOT_COIL; 
      _den_con = < 0.15;
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => A, "layer2" => IND_MD_NOT_COIL }, delta_window = { 75, 75 }, delta_x = 37.5, delta_y = 37.5, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_986 = ERR_WIN and IND_MD_NOT_COIL; 
          F = wide( sLAYER_986, >= ( 75 / 4 ), forty_five = INTERNAL ); 
          VAR_96 = density_statistics_file( file = "IND_MD.DN.11L.M7.density" ); 
      _den_con = < 0.15;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => F, "layer2" => A, "layer3" => IND_MD_NOT_COIL }, delta_window = { 75, 75 }, delta_x = 37.5, delta_y = 37.5, boundary = BACKUP, statistics_files = { VAR_96 }, window_function = den_save_window_2 ); 
      } /* end of rule : IND_MD.DN.11:L_M7 */
      rIND_MD_DN_11_H_M7 @= { @ "IND_MD.DN.11:H_M7 : M7 density in the region of (INDDMY_MD NOT (INDDMY_COIL AND INDDMY_MD)) >= 15%, <= 80%";
          sLAYER_987 = INDDMY_COIL and INDDMY_MD; 
          IND_MD_NOT_COIL = INDDMY_MD not sLAYER_987; 
          IND_MD_NOT_COILX = copy( IND_MD_NOT_COIL ); 
          A = M7X and IND_MD_NOT_COIL; 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => A, "layer2" => IND_MD_NOT_COIL }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_988 = ERR_WIN and IND_MD_NOT_COIL; 
          F = wide( sLAYER_988, >= ( 100 / 4 ), forty_five = INTERNAL ); 
          VAR_97 = density_statistics_file( file = "IND_MD.DN.11H.M7.density" ); 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => F, "layer2" => A, "layer3" => IND_MD_NOT_COIL }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_97 }, window_function = den_save_window_3 ); 
      } /* end of rule : IND_MD.DN.11:H_M7 */
      
      //IND_MD.DN.11 is checked by IND_MD.DN.11:L_M8 and IND_MD.DN.11:H_M8
      rIND_MD_DN_11_L_M8 @= { @ "IND_MD.DN.11:L_M8 : M8 density in the region of (INDDMY_MD NOT (INDDMY_COIL AND INDDMY_MD)) >= 15%, <= 80%";
          sLAYER_989 = INDDMY_COIL and INDDMY_MD; 
          IND_MD_NOT_COIL = INDDMY_MD not sLAYER_989; 
          IND_MD_NOT_COILX = copy( IND_MD_NOT_COIL ); 
          A = M8X and IND_MD_NOT_COIL; 
      _den_con = < 0.15;
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => A, "layer2" => IND_MD_NOT_COIL }, delta_window = { 75, 75 }, delta_x = 37.5, delta_y = 37.5, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_990 = ERR_WIN and IND_MD_NOT_COIL; 
          F = wide( sLAYER_990, >= ( 75 / 4 ), forty_five = INTERNAL ); 
          VAR_98 = density_statistics_file( file = "IND_MD.DN.11L.M8.density" ); 
      _den_con = < 0.15;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => F, "layer2" => A, "layer3" => IND_MD_NOT_COIL }, delta_window = { 75, 75 }, delta_x = 37.5, delta_y = 37.5, boundary = BACKUP, statistics_files = { VAR_98 }, window_function = den_save_window_2 ); 
      } /* end of rule : IND_MD.DN.11:L_M8 */
      rIND_MD_DN_11_H_M8 @= { @ "IND_MD.DN.11:H_M8 : M8 density in the region of (INDDMY_MD NOT (INDDMY_COIL AND INDDMY_MD)) >= 15%, <= 80%";
          sLAYER_991 = INDDMY_COIL and INDDMY_MD; 
          IND_MD_NOT_COIL = INDDMY_MD not sLAYER_991; 
          IND_MD_NOT_COILX = copy( IND_MD_NOT_COIL ); 
          A = M8X and IND_MD_NOT_COIL; 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => A, "layer2" => IND_MD_NOT_COIL }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_992 = ERR_WIN and IND_MD_NOT_COIL; 
          F = wide( sLAYER_992, >= ( 100 / 4 ), forty_five = INTERNAL ); 
          VAR_99 = density_statistics_file( file = "IND_MD.DN.11H.M8.density" ); 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => F, "layer2" => A, "layer3" => IND_MD_NOT_COIL }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_99 }, window_function = den_save_window_3 ); 
      } /* end of rule : IND_MD.DN.11:H_M8 */
      
      //IND_MD.DN.11 is checked by IND_MD.DN.11:L_M9 and IND_MD.DN.11:H_M9
      rIND_MD_DN_11_L_M9 @= { @ "IND_MD.DN.11:L_M9 : M9 density in the region of (INDDMY_MD NOT (INDDMY_COIL AND INDDMY_MD)) >= 15%, <= 80%";
          sLAYER_993 = INDDMY_COIL and INDDMY_MD; 
          IND_MD_NOT_COIL = INDDMY_MD not sLAYER_993; 
          IND_MD_NOT_COILX = copy( IND_MD_NOT_COIL ); 
          A = M9X and IND_MD_NOT_COIL; 
      _den_con = < 0.15;
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => A, "layer2" => IND_MD_NOT_COIL }, delta_window = { 75, 75 }, delta_x = 37.5, delta_y = 37.5, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_994 = ERR_WIN and IND_MD_NOT_COIL; 
          F = wide( sLAYER_994, >= ( 75 / 4 ), forty_five = INTERNAL ); 
          VAR_100 = density_statistics_file( file = "IND_MD.DN.11L.M9.density" ); 
      _den_con = < 0.15;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => F, "layer2" => A, "layer3" => IND_MD_NOT_COIL }, delta_window = { 75, 75 }, delta_x = 37.5, delta_y = 37.5, boundary = BACKUP, statistics_files = { VAR_100 }, window_function = den_save_window_2 ); 
      } /* end of rule : IND_MD.DN.11:L_M9 */
      rIND_MD_DN_11_H_M9 @= { @ "IND_MD.DN.11:H_M9 : M9 density in the region of (INDDMY_MD NOT (INDDMY_COIL AND INDDMY_MD)) >= 15%, <= 80%";
          sLAYER_995 = INDDMY_COIL and INDDMY_MD; 
          IND_MD_NOT_COIL = INDDMY_MD not sLAYER_995; 
          IND_MD_NOT_COILX = copy( IND_MD_NOT_COIL ); 
          A = M9X and IND_MD_NOT_COIL; 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      _den_print = false;
      _den_print_only = false;
          ERR_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => A, "layer2" => IND_MD_NOT_COIL }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, window_function = den_save_window_1 ); 
          sLAYER_996 = ERR_WIN and IND_MD_NOT_COIL; 
          F = wide( sLAYER_996, >= ( 100 / 4 ), forty_five = INTERNAL ); 
          VAR_101 = density_statistics_file( file = "IND_MD.DN.11H.M9.density" ); 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_NOT_COILX, layer_hash = { "layer1" => F, "layer2" => A, "layer3" => IND_MD_NOT_COIL }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_101 }, window_function = den_save_window_3 ); 
      } /* end of rule : IND_MD.DN.11:H_M9 */
      gLAYER_512 = VIA1 and IND_MD_REGION; 
      gLAYER_511 = size( gLAYER_512, clip_acute = NONE, distance = IND_MD_DN_10R ); 
      MD_INT_VIA1PRE = gLAYER_511 and IND_MD_REGION; 
      MD_INT_VIA1 = copy( MD_INT_VIA1PRE ); 
      gLAYER_514 = VIA2 and IND_MD_REGION; 
      gLAYER_513 = size( gLAYER_514, clip_acute = NONE, distance = IND_MD_DN_10R ); 
      MD_INT_VIA2PRE = gLAYER_513 and IND_MD_REGION; 
      MD_INT_VIA2 = MD_INT_VIA2PRE or MD_INT_VIA1; 
      gLAYER_516 = VIA3 and IND_MD_REGION; 
      gLAYER_515 = size( gLAYER_516, clip_acute = NONE, distance = IND_MD_DN_10R ); 
      MD_INT_VIA3PRE = gLAYER_515 and IND_MD_REGION; 
      MD_INT_VIA3 = MD_INT_VIA3PRE or MD_INT_VIA2; 
      gLAYER_518 = VIA4 and IND_MD_REGION; 
      gLAYER_517 = size( gLAYER_518, clip_acute = NONE, distance = IND_MD_DN_10R ); 
      MD_INT_VIA4PRE = gLAYER_517 and IND_MD_REGION; 
      MD_INT_VIA4 = MD_INT_VIA4PRE or MD_INT_VIA3; 
      gLAYER_520 = VIA5 and IND_MD_REGION; 
      gLAYER_519 = size( gLAYER_520, clip_acute = NONE, distance = IND_MD_DN_10R ); 
      MD_INT_VIA5PRE = gLAYER_519 and IND_MD_REGION; 
      MD_INT_VIA5 = MD_INT_VIA5PRE or MD_INT_VIA4; 
      gLAYER_522 = VIA6 and IND_MD_REGION; 
      gLAYER_521 = size( gLAYER_522, clip_acute = NONE, distance = IND_MD_DN_10R ); 
      MD_INT_VIA6PRE = gLAYER_521 and IND_MD_REGION; 
      MD_INT_VIA6 = MD_INT_VIA6PRE or MD_INT_VIA5; 
      MD_INT_DEN_CHK = copy( MD_INT_VIA6 ); 
      MD_INT_DEN_CHKX = copy( MD_INT_DEN_CHK ); 
      rIND_MD_DN_10_M1 @= { @ "IND_MD.DN.10:M1 : For the region of (INDDMY_MD SIZING 12um) with VIAx adopted, mim metal density over any 15*15um2 area for all lower mental layer >= 15%";
          VAR_102 = density_statistics_file( file = "IND_MD.DN.10.density_M1.rep" ); 
      _den_con = < IND_MD_DN_10; 
      _den_polygon_area_clip = true;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = MD_INT_DEN_CHKX, layer_hash = { "layer1" => M1X, "layer2" => MD_INT_DEN_CHK }, delta_window = { IND_MD_DN_10W, IND_MD_DN_10W }, delta_x = IND_MD_DN_10W / 2, delta_y = IND_MD_DN_10W / 2, boundary = BACKUP, statistics_files = { VAR_102 }, window_function = den_save_window_1 ); 
      } /* end of rule : IND_MD.DN.10:M1 */
      rIND_MD_DN_10_M2 @= { @ "IND_MD.DN.10:M2 : For the region of (INDDMY_MD SIZING 12um) with VIAx adopted, mim metal density over any 15*15um2 area for all lower mental layer >= 15%";
          VAR_103 = density_statistics_file( file = "IND_MD.DN.10.density_M2.rep" ); 
      _den_con = < IND_MD_DN_10; 
      _den_polygon_area_clip = true;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = MD_INT_DEN_CHKX, layer_hash = { "layer1" => M2X, "layer2" => MD_INT_DEN_CHK }, delta_window = { IND_MD_DN_10W, IND_MD_DN_10W }, delta_x = IND_MD_DN_10W / 2, delta_y = IND_MD_DN_10W / 2, boundary = BACKUP, statistics_files = { VAR_103 }, window_function = den_save_window_1 ); 
      } /* end of rule : IND_MD.DN.10:M2 */
      rIND_MD_DN_10_M3 @= { @ "IND_MD.DN.10:M3 : For the region of (INDDMY_MD SIZING 12um) with VIAx adopted, mim metal density over any 15*15um2 area for all lower mental layer >= 15%";
          VAR_104 = density_statistics_file( file = "IND_MD.DN.10.density_M3.rep" ); 
      _den_con = < IND_MD_DN_10; 
      _den_polygon_area_clip = true;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = MD_INT_DEN_CHKX, layer_hash = { "layer1" => M3X, "layer2" => MD_INT_DEN_CHK }, delta_window = { IND_MD_DN_10W, IND_MD_DN_10W }, delta_x = IND_MD_DN_10W / 2, delta_y = IND_MD_DN_10W / 2, boundary = BACKUP, statistics_files = { VAR_104 }, window_function = den_save_window_1 ); 
      } /* end of rule : IND_MD.DN.10:M3 */
      rIND_MD_DN_10_M4 @= { @ "IND_MD.DN.10:M4 : For the region of (INDDMY_MD SIZING 12um) with VIAx adopted, mim metal density over any 15*15um2 area for all lower mental layer >= 15%";
          VAR_105 = density_statistics_file( file = "IND_MD.DN.10.density_M4.rep" ); 
      _den_con = < IND_MD_DN_10; 
      _den_polygon_area_clip = true;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = MD_INT_DEN_CHKX, layer_hash = { "layer1" => M4X, "layer2" => MD_INT_DEN_CHK }, delta_window = { IND_MD_DN_10W, IND_MD_DN_10W }, delta_x = IND_MD_DN_10W / 2, delta_y = IND_MD_DN_10W / 2, boundary = BACKUP, statistics_files = { VAR_105 }, window_function = den_save_window_1 ); 
      } /* end of rule : IND_MD.DN.10:M4 */
      rIND_MD_DN_10_M5 @= { @ "IND_MD.DN.10:M5 : For the region of (INDDMY_MD SIZING 12um) with VIAx adopted, mim metal density over any 15*15um2 area for all lower mental layer >= 15%";
          VAR_106 = density_statistics_file( file = "IND_MD.DN.10.density_M5.rep" ); 
      _den_con = < IND_MD_DN_10; 
      _den_polygon_area_clip = true;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = MD_INT_DEN_CHKX, layer_hash = { "layer1" => M5X, "layer2" => MD_INT_DEN_CHK }, delta_window = { IND_MD_DN_10W, IND_MD_DN_10W }, delta_x = IND_MD_DN_10W / 2, delta_y = IND_MD_DN_10W / 2, boundary = BACKUP, statistics_files = { VAR_106 }, window_function = den_save_window_1 ); 
      } /* end of rule : IND_MD.DN.10:M5 */
      rIND_MD_DN_10_M6 @= { @ "IND_MD.DN.10:M6 : For the region of (INDDMY_MD SIZING 12um) with VIAx adopted, mim metal density over any 15*15um2 area for all lower mental layer >= 15%";
          VAR_107 = density_statistics_file( file = "IND_MD.DN.10.density_M6.rep" ); 
      _den_con = < IND_MD_DN_10; 
      _den_polygon_area_clip = true;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = MD_INT_DEN_CHKX, layer_hash = { "layer1" => M6X, "layer2" => MD_INT_DEN_CHK }, delta_window = { IND_MD_DN_10W, IND_MD_DN_10W }, delta_x = IND_MD_DN_10W / 2, delta_y = IND_MD_DN_10W / 2, boundary = BACKUP, statistics_files = { VAR_107 }, window_function = den_save_window_1 ); 
      } /* end of rule : IND_MD.DN.10:M6 */
      rIND_MD_R_17_VIA1 @= { @ "IND_MD.R.17:VIA1 : At least 100 VIA1 with space <= 0.2 um are required to connect M2(Mx) and M1(Mx or M1) in (INDDMY_MD SIZING 12 um)";
          sLAYER_997 = M2 and M1; 
          MD_M2OVPM1 = sLAYER_997 and IND_MD_REGION; 
          MD_CHECK_VIA1 = interacting( VIA1_EXD, MD_M2OVPM1 ); 
          MD_VIA1MERGE = size_inside_wrapper( MD_CHECK_VIA1, MD_M2OVPM1, distance = ( IND_MD_R_17 / 2 ), increment = M1_S_1 * 0.7 ); 
          MD_VIA1MERGE2 = enclosing( MD_VIA1MERGE, MD_CHECK_VIA1, >= dtoi(IND_MD_R_17_N) ); 
          MD_GOOD_VIA1 = MD_CHECK_VIA1 and MD_VIA1MERGE2; 
          MD_GM2OVPM1 = interacting( MD_M2OVPM1, MD_GOOD_VIA1 ); 
          MD_CHECK_VIA1 outside MD_GM2OVPM1; 
      } /* end of rule : IND_MD.R.17:VIA1 */
      rIND_MD_R_17_VIA2 @= { @ "IND_MD.R.17:VIA2 : At least 100 VIA2 with space <= 0.2 um are required to connect M3(Mx) and M2(Mx or M1) in (INDDMY_MD SIZING 12 um)";
          sLAYER_998 = M3 and M2; 
          MD_M3OVPM2 = sLAYER_998 and IND_MD_REGION; 
          MD_CHECK_VIA2 = interacting( VIA2_EXD, MD_M3OVPM2 ); 
          MD_VIA2MERGE = size_inside_wrapper( MD_CHECK_VIA2, MD_M3OVPM2, distance = ( IND_MD_R_17 / 2 ), increment = M2_S_1 * 0.7 ); 
          MD_VIA2MERGE2 = enclosing( MD_VIA2MERGE, MD_CHECK_VIA2, >= dtoi(IND_MD_R_17_N) ); 
          MD_GOOD_VIA2 = MD_CHECK_VIA2 and MD_VIA2MERGE2; 
          MD_GM3OVPM2 = interacting( MD_M3OVPM2, MD_GOOD_VIA2 ); 
          MD_CHECK_VIA2 outside MD_GM3OVPM2; 
      } /* end of rule : IND_MD.R.17:VIA2 */
      rIND_MD_R_17_VIA3 @= { @ "IND_MD.R.17:VIA3 : At least 100 VIA3 with space <= 0.2 um are required to connect M4(Mx) and M3(Mx or M1) in (INDDMY_MD SIZING 12 um)";
          sLAYER_999 = M4 and M3; 
          MD_M4OVPM3 = sLAYER_999 and IND_MD_REGION; 
          MD_CHECK_VIA3 = interacting( VIA3_EXD, MD_M4OVPM3 ); 
          MD_VIA3MERGE = size_inside_wrapper( MD_CHECK_VIA3, MD_M4OVPM3, distance = ( IND_MD_R_17 / 2 ), increment = M3_S_1 * 0.7 ); 
          MD_VIA3MERGE2 = enclosing( MD_VIA3MERGE, MD_CHECK_VIA3, >= dtoi(IND_MD_R_17_N) ); 
          MD_GOOD_VIA3 = MD_CHECK_VIA3 and MD_VIA3MERGE2; 
          MD_GM4OVPM3 = interacting( MD_M4OVPM3, MD_GOOD_VIA3 ); 
          MD_CHECK_VIA3 outside MD_GM4OVPM3; 
      } /* end of rule : IND_MD.R.17:VIA3 */
      rIND_MD_R_17_VIA4 @= { @ "IND_MD.R.17:VIA4 : At least 100 VIA4 with space <= 0.2 um are required to connect M5(Mx) and M4(Mx or M1) in (INDDMY_MD SIZING 12 um)";
          sLAYER_1000 = M5 and M4; 
          MD_M5OVPM4 = sLAYER_1000 and IND_MD_REGION; 
          MD_CHECK_VIA4 = interacting( VIA4_EXD, MD_M5OVPM4 ); 
          MD_VIA4MERGE = size_inside_wrapper( MD_CHECK_VIA4, MD_M5OVPM4, distance = ( IND_MD_R_17 / 2 ), increment = M4_S_1 * 0.7 ); 
          MD_VIA4MERGE2 = enclosing( MD_VIA4MERGE, MD_CHECK_VIA4, >= dtoi(IND_MD_R_17_N) ); 
          MD_GOOD_VIA4 = MD_CHECK_VIA4 and MD_VIA4MERGE2; 
          MD_GM5OVPM4 = interacting( MD_M5OVPM4, MD_GOOD_VIA4 ); 
          MD_CHECK_VIA4 outside MD_GM5OVPM4; 
      } /* end of rule : IND_MD.R.17:VIA4 */
      rIND_MD_R_17_VIA5 @= { @ "IND_MD.R.17:VIA5 : At least 100 VIA5 with space <= 0.2 um are required to connect M6(Mx) and M5(Mx or M1) in (INDDMY_MD SIZING 12 um)";
          sLAYER_1001 = M6 and M5; 
          MD_M6OVPM5 = sLAYER_1001 and IND_MD_REGION; 
          MD_CHECK_VIA5 = interacting( VIA5_EXD, MD_M6OVPM5 ); 
          MD_VIA5MERGE = size_inside_wrapper( MD_CHECK_VIA5, MD_M6OVPM5, distance = ( IND_MD_R_17 / 2 ), increment = M5_S_1 * 0.7 ); 
          MD_VIA5MERGE2 = enclosing( MD_VIA5MERGE, MD_CHECK_VIA5, >= dtoi(IND_MD_R_17_N) ); 
          MD_GOOD_VIA5 = MD_CHECK_VIA5 and MD_VIA5MERGE2; 
          MD_GM6OVPM5 = interacting( MD_M6OVPM5, MD_GOOD_VIA5 ); 
          MD_CHECK_VIA5 outside MD_GM6OVPM5; 
      } /* end of rule : IND_MD.R.17:VIA5 */
      rIND_MD_R_17_VIA6 @= { @ "IND_MD.R.17:VIA6 : At least 100 VIA6 with space <= 0.2 um are required to connect M7(Mx) and M6(Mx or M1) in (INDDMY_MD SIZING 12 um)";
          sLAYER_1002 = M7 and M6; 
          MD_M7OVPM6 = sLAYER_1002 and IND_MD_REGION; 
          MD_CHECK_VIA6 = interacting( VIA6_EXD, MD_M7OVPM6 ); 
          MD_VIA6MERGE = size_inside_wrapper( MD_CHECK_VIA6, MD_M7OVPM6, distance = ( IND_MD_R_17 / 2 ), increment = M6_S_1 * 0.7 ); 
          MD_VIA6MERGE2 = enclosing( MD_VIA6MERGE, MD_CHECK_VIA6, >= dtoi(IND_MD_R_17_N) ); 
          MD_GOOD_VIA6 = MD_CHECK_VIA6 and MD_VIA6MERGE2; 
          MD_GM7OVPM6 = interacting( MD_M7OVPM6, MD_GOOD_VIA6 ); 
          MD_CHECK_VIA6 outside MD_GM7OVPM6; 
      } /* end of rule : IND_MD.R.17:VIA6 */
      
      //IND_MD.R.18.RU can not be checked by DRC
      rIND_MD_W_1 @= { @ "IND_MD.W.1 : M1, DM1, DM1_O width in (INDDMY_COIL SIZING 16 um) >= 0.4";
          A = M1X not_outside IND_COIL_REGION; 
          sLAYER_1003 = internal1( A, < ( IND_MD_W_1 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          sLAYER_1003 not_outside IND_COIL_REGION; 
      } /* end of rule : IND_MD.W.1 */
      rIND_MD_W_2_M2 @= { @ "IND_MD.W.2:M2 : Mx , DMx , DMx_O width in (INDDMY_COIL SIZING 16 um) >= 0.6";
          A = M2X not_outside IND_COIL_REGION; 
          sLAYER_1004 = internal1( A, < ( IND_MD_W_2 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          sLAYER_1004 not_outside IND_COIL_REGION; 
      } /* end of rule : IND_MD.W.2:M2 */
      rIND_MD_W_2_M3 @= { @ "IND_MD.W.2:M3 : Mx , DMx , DMx_O width in (INDDMY_COIL SIZING 16 um) >= 0.6";
          A = M3X not_outside IND_COIL_REGION; 
          sLAYER_1005 = internal1( A, < ( IND_MD_W_2 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          sLAYER_1005 not_outside IND_COIL_REGION; 
      } /* end of rule : IND_MD.W.2:M3 */
      rIND_MD_W_2_M4 @= { @ "IND_MD.W.2:M4 : Mx , DMx , DMx_O width in (INDDMY_COIL SIZING 16 um) >= 0.6";
          A = M4X not_outside IND_COIL_REGION; 
          sLAYER_1006 = internal1( A, < ( IND_MD_W_2 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          sLAYER_1006 not_outside IND_COIL_REGION; 
      } /* end of rule : IND_MD.W.2:M4 */
      rIND_MD_W_2_M5 @= { @ "IND_MD.W.2:M5 : Mx , DMx , DMx_O width in (INDDMY_COIL SIZING 16 um) >= 0.6";
          A = M5X not_outside IND_COIL_REGION; 
          sLAYER_1007 = internal1( A, < ( IND_MD_W_2 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          sLAYER_1007 not_outside IND_COIL_REGION; 
      } /* end of rule : IND_MD.W.2:M5 */
      rIND_MD_W_2_M6 @= { @ "IND_MD.W.2:M6 : Mx , DMx , DMx_O width in (INDDMY_COIL SIZING 16 um) >= 0.6";
          A = M6X not_outside IND_COIL_REGION; 
          sLAYER_1008 = internal1( A, < ( IND_MD_W_2 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          sLAYER_1008 not_outside IND_COIL_REGION; 
      } /* end of rule : IND_MD.W.2:M6 */
      rIND_MD_W_2_M7 @= { @ "IND_MD.W.2:M7 : Mx , DMx , DMx_O width in (INDDMY_COIL SIZING 16 um) >= 0.6";
          A = M7X not_outside IND_COIL_REGION; 
          sLAYER_1009 = internal1( A, < ( IND_MD_W_2 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          sLAYER_1009 not_outside IND_COIL_REGION; 
      } /* end of rule : IND_MD.W.2:M7 */
      rIND_MD_W_3_M8 @= { @ "IND_MD.W.3:M8 : Mz , DMz width in (INDDMY_COIL SIZING 16 um)>= 0.8";
          A = M8X not_outside IND_COIL_REGION; 
          sLAYER_1010 = internal1( A, < ( IND_MD_W_3 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          sLAYER_1010 not_outside IND_COIL_REGION; 
      } /* end of rule : IND_MD.W.3:M8 */
      rIND_MD_W_3_M9 @= { @ "IND_MD.W.3:M9 : Mz , DMz width in (INDDMY_COIL SIZING 16 um)>= 0.8";
          A = M9X not_outside IND_COIL_REGION; 
          sLAYER_1011 = internal1( A, < ( IND_MD_W_3 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          sLAYER_1011 not_outside IND_COIL_REGION; 
      } /* end of rule : IND_MD.W.3:M9 */
      rIND_MD_W_4_M1 @= { @ "IND_MD.W.4:M1 : M1, DM1, DM1_O/Mx, DMx, DMx_O maximum width <= 12";
          A = M1X not_outside IND_COIL_REGION; 
          size( size( A, - ( ( IND_MD_W_4 + 0.01 ) / 2 ), clip_acute = BISECTOR ), ( IND_MD_W_4 + 0.01 ) / 2, clip_acute = BISECTOR ); 
      } /* end of rule : IND_MD.W.4:M1 */
      rIND_MD_W_4_M2 @= { @ "IND_MD.W.4:M2 : M1, DM1, DM1_O/Mx, DMx, DMx_O maximum width <= 12";
          A = M2X not_outside IND_COIL_REGION; 
          size( size( A, - ( ( IND_MD_W_4 + 0.01 ) / 2 ), clip_acute = BISECTOR ), ( IND_MD_W_4 + 0.01 ) / 2, clip_acute = BISECTOR ); 
      } /* end of rule : IND_MD.W.4:M2 */
      rIND_MD_W_4_M3 @= { @ "IND_MD.W.4:M3 : M1, DM1, DM1_O/Mx, DMx, DMx_O maximum width <= 12";
          A = M3X not_outside IND_COIL_REGION; 
          size( size( A, - ( ( IND_MD_W_4 + 0.01 ) / 2 ), clip_acute = BISECTOR ), ( IND_MD_W_4 + 0.01 ) / 2, clip_acute = BISECTOR ); 
      } /* end of rule : IND_MD.W.4:M3 */
      rIND_MD_W_4_M4 @= { @ "IND_MD.W.4:M4 : M1, DM1, DM1_O/Mx, DMx, DMx_O maximum width <= 12";
          A = M4X not_outside IND_COIL_REGION; 
          size( size( A, - ( ( IND_MD_W_4 + 0.01 ) / 2 ), clip_acute = BISECTOR ), ( IND_MD_W_4 + 0.01 ) / 2, clip_acute = BISECTOR ); 
      } /* end of rule : IND_MD.W.4:M4 */
      rIND_MD_W_4_M5 @= { @ "IND_MD.W.4:M5 : M1, DM1, DM1_O/Mx, DMx, DMx_O maximum width <= 12";
          A = M5X not_outside IND_COIL_REGION; 
          size( size( A, - ( ( IND_MD_W_4 + 0.01 ) / 2 ), clip_acute = BISECTOR ), ( IND_MD_W_4 + 0.01 ) / 2, clip_acute = BISECTOR ); 
      } /* end of rule : IND_MD.W.4:M5 */
      rIND_MD_W_4_M6 @= { @ "IND_MD.W.4:M6 : M1, DM1, DM1_O/Mx, DMx, DMx_O maximum width <= 12";
          A = M6X not_outside IND_COIL_REGION; 
          size( size( A, - ( ( IND_MD_W_4 + 0.01 ) / 2 ), clip_acute = BISECTOR ), ( IND_MD_W_4 + 0.01 ) / 2, clip_acute = BISECTOR ); 
      } /* end of rule : IND_MD.W.4:M6 */
      rIND_MD_W_4_M7 @= { @ "IND_MD.W.4:M7 : M1, DM1, DM1_O/Mx, DMx, DMx_O maximum width <= 12";
          A = M7X not_outside IND_COIL_REGION; 
          size( size( A, - ( ( IND_MD_W_4 + 0.01 ) / 2 ), clip_acute = BISECTOR ), ( IND_MD_W_4 + 0.01 ) / 2, clip_acute = BISECTOR ); 
      } /* end of rule : IND_MD.W.4:M7 */
      rIND_MD_W_7 @= { @ "IND_MD.W.7 : Max. dimension (either width or length) of an INDDMY_MD region <= 600 um";
          contains( INDDMY_MD, { 0.005, 600.005 + 0.01 } ); 
      } /* end of rule : IND_MD.W.7 */
      rIND_MD_S_1 @= { @ "IND_MD.S.1 : M1, DM1,DM1_O space in (INDDMY_COIL SIZING 16 um) >= 0.4";
          A = M1X not_outside IND_COIL_REGION; 
          sLAYER_1012 = external1( A, < ( IND_MD_S_1 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_1012 not_outside IND_COIL_REGION; 
      } /* end of rule : IND_MD.S.1 */
      rIND_MD_S_2_M2 @= { @ "IND_MD.S.2:M2 : Mx, DMx, DMx_O space in (INDDMY_COIL SIZING 16 um) >= 0.6";
          A = M2X not_outside IND_COIL_REGION; 
          sLAYER_1013 = external1( A, < ( IND_MD_S_2 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_1013 not_outside IND_COIL_REGION; 
      } /* end of rule : IND_MD.S.2:M2 */
      rIND_MD_S_2_M3 @= { @ "IND_MD.S.2:M3 : Mx, DMx, DMx_O space in (INDDMY_COIL SIZING 16 um) >= 0.6";
          A = M3X not_outside IND_COIL_REGION; 
          sLAYER_1014 = external1( A, < ( IND_MD_S_2 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_1014 not_outside IND_COIL_REGION; 
      } /* end of rule : IND_MD.S.2:M3 */
      rIND_MD_S_2_M4 @= { @ "IND_MD.S.2:M4 : Mx, DMx, DMx_O space in (INDDMY_COIL SIZING 16 um) >= 0.6";
          A = M4X not_outside IND_COIL_REGION; 
          sLAYER_1015 = external1( A, < ( IND_MD_S_2 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_1015 not_outside IND_COIL_REGION; 
      } /* end of rule : IND_MD.S.2:M4 */
      rIND_MD_S_2_M5 @= { @ "IND_MD.S.2:M5 : Mx, DMx, DMx_O space in (INDDMY_COIL SIZING 16 um) >= 0.6";
          A = M5X not_outside IND_COIL_REGION; 
          sLAYER_1016 = external1( A, < ( IND_MD_S_2 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_1016 not_outside IND_COIL_REGION; 
      } /* end of rule : IND_MD.S.2:M5 */
      rIND_MD_S_2_M6 @= { @ "IND_MD.S.2:M6 : Mx, DMx, DMx_O space in (INDDMY_COIL SIZING 16 um) >= 0.6";
          A = M6X not_outside IND_COIL_REGION; 
          sLAYER_1017 = external1( A, < ( IND_MD_S_2 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_1017 not_outside IND_COIL_REGION; 
      } /* end of rule : IND_MD.S.2:M6 */
      rIND_MD_S_2_M7 @= { @ "IND_MD.S.2:M7 : Mx, DMx, DMx_O space in (INDDMY_COIL SIZING 16 um) >= 0.6";
          A = M7X not_outside IND_COIL_REGION; 
          sLAYER_1018 = external1( A, < ( IND_MD_S_2 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_1018 not_outside IND_COIL_REGION; 
      } /* end of rule : IND_MD.S.2:M7 */
      rIND_MD_S_3_M8 @= { @ "IND_MD.S.3:M8 : Mz, DMz space in (INDDMY_COIL SIZING 16um) >= 0.8";
          A = M8X not_outside IND_COIL_REGION; 
          sLAYER_1019 = external1( A, < ( IND_MD_S_3 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_1019 not_outside IND_COIL_REGION; 
      } /* end of rule : IND_MD.S.3:M8 */
      rIND_MD_S_3_M9 @= { @ "IND_MD.S.3:M9 : Mz, DMz space in (INDDMY_COIL SIZING 16um) >= 0.8";
          A = M9X not_outside IND_COIL_REGION; 
          sLAYER_1020 = external1( A, < ( IND_MD_S_3 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          sLAYER_1020 not_outside IND_COIL_REGION; 
      } /* end of rule : IND_MD.S.3:M9 */
      rIND_MD_S_4_M1 @= { @ "IND_MD.S.4:M1 : M1, DM1, DM1_O/Mx, DMx, DMx_O/Mz, DMz space in (INDDMY_COIL SIZING 16 um) [at least one metal line width > 1.5 um (W1) and the parallel metal run length > 1.5 um (L1)] >= 1.0";
          X = external2( IND_MD_WIDEM11_p_5, M1X, < ( IND_MD_S_4 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M1X; 
          contains( Y, { GRID, 1.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND_MD.S.4:M1 */
      rIND_MD_S_5_M1 @= { @ "IND_MD.S.5:M1 : M1, DM1, DM1_O/Mx, DMx, DMx_O/Mz, DMz space in (INDDMY_COIL SIZING 16 um) [at least one metal line width > 4.5 um (W2) and the parallel metal run length > 4.5 um (L2)] >= 2.0";
          X = external2( IND_MD_WIDEM14_p_5, M1X, < ( IND_MD_S_5 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M1X; 
          contains( Y, { GRID, 4.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND_MD.S.5:M1 */
      rIND_MD_S_4_M2 @= { @ "IND_MD.S.4:M2 : M1, DM1, DM1_O/Mx, DMx, DMx_O/Mz, DMz space in (INDDMY_COIL SIZING 16 um) [at least one metal line width > 1.5 um (W1) and the parallel metal run length > 1.5 um (L1)] >= 1.0";
          X = external2( IND_MD_WIDEM21_p_5, M2X, < ( IND_MD_S_4 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M2X; 
          contains( Y, { GRID, 1.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND_MD.S.4:M2 */
      rIND_MD_S_5_M2 @= { @ "IND_MD.S.5:M2 : M1, DM1, DM1_O/Mx, DMx, DMx_O/Mz, DMz space in (INDDMY_COIL SIZING 16 um) [at least one metal line width > 4.5 um (W2) and the parallel metal run length > 4.5 um (L2)] >= 2.0";
          X = external2( IND_MD_WIDEM24_p_5, M2X, < ( IND_MD_S_5 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M2X; 
          contains( Y, { GRID, 4.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND_MD.S.5:M2 */
      rIND_MD_S_4_M3 @= { @ "IND_MD.S.4:M3 : M1, DM1, DM1_O/Mx, DMx, DMx_O/Mz, DMz space in (INDDMY_COIL SIZING 16 um) [at least one metal line width > 1.5 um (W1) and the parallel metal run length > 1.5 um (L1)] >= 1.0";
          X = external2( IND_MD_WIDEM31_p_5, M3X, < ( IND_MD_S_4 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M3X; 
          contains( Y, { GRID, 1.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND_MD.S.4:M3 */
      rIND_MD_S_5_M3 @= { @ "IND_MD.S.5:M3 : M1, DM1, DM1_O/Mx, DMx, DMx_O/Mz, DMz space in (INDDMY_COIL SIZING 16 um) [at least one metal line width > 4.5 um (W2) and the parallel metal run length > 4.5 um (L2)] >= 2.0";
          X = external2( IND_MD_WIDEM34_p_5, M3X, < ( IND_MD_S_5 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M3X; 
          contains( Y, { GRID, 4.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND_MD.S.5:M3 */
      rIND_MD_S_4_M4 @= { @ "IND_MD.S.4:M4 : M1, DM1, DM1_O/Mx, DMx, DMx_O/Mz, DMz space in (INDDMY_COIL SIZING 16 um) [at least one metal line width > 1.5 um (W1) and the parallel metal run length > 1.5 um (L1)] >= 1.0";
          X = external2( IND_MD_WIDEM41_p_5, M4X, < ( IND_MD_S_4 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M4X; 
          contains( Y, { GRID, 1.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND_MD.S.4:M4 */
      rIND_MD_S_5_M4 @= { @ "IND_MD.S.5:M4 : M1, DM1, DM1_O/Mx, DMx, DMx_O/Mz, DMz space in (INDDMY_COIL SIZING 16 um) [at least one metal line width > 4.5 um (W2) and the parallel metal run length > 4.5 um (L2)] >= 2.0";
          X = external2( IND_MD_WIDEM44_p_5, M4X, < ( IND_MD_S_5 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M4X; 
          contains( Y, { GRID, 4.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND_MD.S.5:M4 */
      rIND_MD_S_4_M5 @= { @ "IND_MD.S.4:M5 : M1, DM1, DM1_O/Mx, DMx, DMx_O/Mz, DMz space in (INDDMY_COIL SIZING 16 um) [at least one metal line width > 1.5 um (W1) and the parallel metal run length > 1.5 um (L1)] >= 1.0";
          X = external2( IND_MD_WIDEM51_p_5, M5X, < ( IND_MD_S_4 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M5X; 
          contains( Y, { GRID, 1.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND_MD.S.4:M5 */
      rIND_MD_S_5_M5 @= { @ "IND_MD.S.5:M5 : M1, DM1, DM1_O/Mx, DMx, DMx_O/Mz, DMz space in (INDDMY_COIL SIZING 16 um) [at least one metal line width > 4.5 um (W2) and the parallel metal run length > 4.5 um (L2)] >= 2.0";
          X = external2( IND_MD_WIDEM54_p_5, M5X, < ( IND_MD_S_5 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M5X; 
          contains( Y, { GRID, 4.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND_MD.S.5:M5 */
      rIND_MD_S_4_M6 @= { @ "IND_MD.S.4:M6 : M1, DM1, DM1_O/Mx, DMx, DMx_O/Mz, DMz space in (INDDMY_COIL SIZING 16 um) [at least one metal line width > 1.5 um (W1) and the parallel metal run length > 1.5 um (L1)] >= 1.0";
          X = external2( IND_MD_WIDEM61_p_5, M6X, < ( IND_MD_S_4 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M6X; 
          contains( Y, { GRID, 1.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND_MD.S.4:M6 */
      rIND_MD_S_5_M6 @= { @ "IND_MD.S.5:M6 : M1, DM1, DM1_O/Mx, DMx, DMx_O/Mz, DMz space in (INDDMY_COIL SIZING 16 um) [at least one metal line width > 4.5 um (W2) and the parallel metal run length > 4.5 um (L2)] >= 2.0";
          X = external2( IND_MD_WIDEM64_p_5, M6X, < ( IND_MD_S_5 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M6X; 
          contains( Y, { GRID, 4.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND_MD.S.5:M6 */
      rIND_MD_S_4_M7 @= { @ "IND_MD.S.4:M7 : M1, DM1, DM1_O/Mx, DMx, DMx_O/Mz, DMz space in (INDDMY_COIL SIZING 16 um) [at least one metal line width > 1.5 um (W1) and the parallel metal run length > 1.5 um (L1)] >= 1.0";
          X = external2( IND_MD_WIDEM71_p_5, M7X, < ( IND_MD_S_4 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M7X; 
          contains( Y, { GRID, 1.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND_MD.S.4:M7 */
      rIND_MD_S_5_M7 @= { @ "IND_MD.S.5:M7 : M1, DM1, DM1_O/Mx, DMx, DMx_O/Mz, DMz space in (INDDMY_COIL SIZING 16 um) [at least one metal line width > 4.5 um (W2) and the parallel metal run length > 4.5 um (L2)] >= 2.0";
          X = external2( IND_MD_WIDEM74_p_5, M7X, < ( IND_MD_S_5 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M7X; 
          contains( Y, { GRID, 4.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND_MD.S.5:M7 */
      rIND_MD_S_4_M8 @= { @ "IND_MD.S.4:M8 : M1, DM1, DM1_O/Mx, DMx, DMx_O/Mz, DMz space in (INDDMY_COIL SIZING 16 um) [at least one metal line width > 1.5 um (W1) and the parallel metal run length > 1.5 um (L1)] >= 1.0";
          X = external2( IND_MD_WIDEM81_p_5, M8X, < ( IND_MD_S_4 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M8X; 
          contains( Y, { GRID, 1.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND_MD.S.4:M8 */
      rIND_MD_S_5_M8 @= { @ "IND_MD.S.5:M8 : M1, DM1, DM1_O/Mx, DMx, DMx_O/Mz, DMz space in (INDDMY_COIL SIZING 16 um) [at least one metal line width > 4.5 um (W2) and the parallel metal run length > 4.5 um (L2)] >= 2.0";
          X = external2( IND_MD_WIDEM84_p_5, M8X, < ( IND_MD_S_5 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M8X; 
          contains( Y, { GRID, 4.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND_MD.S.5:M8 */
      rIND_MD_S_4_M9 @= { @ "IND_MD.S.4:M9 : M1, DM1, DM1_O/Mx, DMx, DMx_O/Mz, DMz space in (INDDMY_COIL SIZING 16 um) [at least one metal line width > 1.5 um (W1) and the parallel metal run length > 1.5 um (L1)] >= 1.0";
          X = external2( IND_MD_WIDEM91_p_5, M9X, < ( IND_MD_S_4 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M9X; 
          contains( Y, { GRID, 1.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND_MD.S.4:M9 */
      rIND_MD_S_5_M9 @= { @ "IND_MD.S.5:M9 : M1, DM1, DM1_O/Mx, DMx, DMx_O/Mz, DMz space in (INDDMY_COIL SIZING 16 um) [at least one metal line width > 4.5 um (W2) and the parallel metal run length > 4.5 um (L2)] >= 2.0";
          X = external2( IND_MD_WIDEM94_p_5, M9X, < ( IND_MD_S_5 - 0.01 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Y = X not M9X; 
          contains( Y, { GRID, 4.5 + GRID }, FORTY_FIVE ); 
      } /* end of rule : IND_MD.S.5:M9 */
      rIND_MD_R_2__IND_MD_R_3_VIA7 @= { @ "IND_MD.R.2__IND_MD.R.3:VIA7 : More than 4 VIA7 with space <= 1.7 um is required to connect M8(Mz or Mu) and M7(Mz or Mx) in (INDDMY_MD SIZING 12 um)";
          sLAYER_1021 = M8X and M7X; 
          M8OVPM7 = sLAYER_1021 and IND_MD_REGION; 
          CHECK_VIA7 = interacting( VIA7_EXD, M8OVPM7 ); 
          VIA7MERGE = size_inside_wrapper( CHECK_VIA7, M8OVPM7, distance = ( 1.7 / 2 ), increment = M7_S_1 * 0.7 ); 
          VIA7MERGE2 = enclosing( VIA7MERGE, CHECK_VIA7, >= 4 ); 
          GOOD_VIA7 = CHECK_VIA7 and VIA7MERGE2; 
          GM8OVPM7 = interacting( M8OVPM7, GOOD_VIA7 ); 
          CHECK_VIA7 outside GM8OVPM7; 
      } /* end of rule : IND_MD.R.2__IND_MD.R.3:VIA7 */
      rIND_MD_R_2__IND_MD_R_3_VIA8 @= { @ "IND_MD.R.2__IND_MD.R.3:VIA8 : More than 4 VIA8 with space <= 1.7 um is required to connect M9(Mz or Mu) and M8(Mz or Mx) in (INDDMY_MD SIZING 12 um)";
          sLAYER_1022 = M9X and M8X; 
          M9OVPM8 = sLAYER_1022 and IND_MD_REGION; 
          CHECK_VIA8 = interacting( VIA8_EXD, M9OVPM8 ); 
          VIA8MERGE = size_inside_wrapper( CHECK_VIA8, M9OVPM8, distance = ( 1.7 / 2 ), increment = M8_S_1 * 0.7 ); 
          VIA8MERGE2 = enclosing( VIA8MERGE, CHECK_VIA8, >= 4 ); 
          GOOD_VIA8 = CHECK_VIA8 and VIA8MERGE2; 
          GM9OVPM8 = interacting( M9OVPM8, GOOD_VIA8 ); 
          CHECK_VIA8 outside GM9OVPM8; 
      } /* end of rule : IND_MD.R.2__IND_MD.R.3:VIA8 */
      gLAYER_523 = INDDMY_COIL coincident_edge INDDMY_MD; 
      IND_MD_COIL_AREA1 = edge_size( gLAYER_523, inside = 0.005 ); 
      gLAYER_524 = INDDMY_COIL touching_edge IND_MD_COIL_AREA1; 
      IND_MD_COIL_AREA2 = edge_size( gLAYER_524, inside = 0.005 ); 
      gLAYER_525 = IND_MD_COIL_AREA1 or IND_MD_COIL_AREA2; 
      IND_MD_LEADING = polygon_extents( gLAYER_525 ); 
      INDDMY_COIL_M1 = M1 and INDDMY_COIL; 
      gLAYER_526 = M1 and IND_MD_REGION; 
      IND_MD_M1_A = external2( gLAYER_526, INDDMY_MD, < 0.01, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 135 ], look_thru = COINCIDENT, orientation = { } ); 
      IND_MD_M1_B = M1 outside_touching_edge IND_MD_M1_A; 
      IND_MD_LEADING_M1 = M1 and IND_MD_LEADING; 
      gLAYER_527 = INDDMY_COIL_M1 not IND_MD_LEADING_M1; 
      IND_MD_SPIRAL_M1 = gLAYER_527 and INDDMY_MD; 
      
      //need to check with SL if spiral only in TM
      rIND_MD_R_13_M1 @= { @ "IND_MD.R.13:M1 : INDDMY_MD enclosure of inductor metal spirals >= 4 um.";
          INDDMY_MD_45 = angle_edge( INDDMY_MD, == 45 ); 
          INDDMY_MD_90 = INDDMY_MD not_coincident_edge INDDMY_MD_45; 
          IND_MD_CORE_CHECK = IND_MD_SPIRAL_M1 not_inside_touching_edge IND_MD_M1_B; 
          enclose( IND_MD_CORE_CHECK, INDDMY_MD_45, < ( 4 - GRID ), extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
          enclose( IND_MD_CORE_CHECK, INDDMY_MD_90, < 4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
      } /* end of rule : IND_MD.R.13:M1 */
      INDDMY_COIL_M2 = M2 and INDDMY_COIL; 
      gLAYER_528 = M2 and IND_MD_REGION; 
      IND_MD_M2_A = external2( gLAYER_528, INDDMY_MD, < 0.01, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 135 ], look_thru = COINCIDENT, orientation = { } ); 
      IND_MD_M2_B = M2 outside_touching_edge IND_MD_M2_A; 
      IND_MD_LEADING_M2 = M2 and IND_MD_LEADING; 
      gLAYER_529 = INDDMY_COIL_M2 not IND_MD_LEADING_M2; 
      IND_MD_SPIRAL_M2 = gLAYER_529 and INDDMY_MD; 
      
      //need to check with SL if spiral only in TM
      rIND_MD_R_13_M2 @= { @ "IND_MD.R.13:M2 : INDDMY_MD enclosure of inductor metal spirals >= 4 um.";
          INDDMY_MD_45 = angle_edge( INDDMY_MD, == 45 ); 
          INDDMY_MD_90 = INDDMY_MD not_coincident_edge INDDMY_MD_45; 
          IND_MD_CORE_CHECK = IND_MD_SPIRAL_M2 not_inside_touching_edge IND_MD_M2_B; 
          enclose( IND_MD_CORE_CHECK, INDDMY_MD_45, < ( 4 - GRID ), extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
          enclose( IND_MD_CORE_CHECK, INDDMY_MD_90, < 4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
      } /* end of rule : IND_MD.R.13:M2 */
      INDDMY_COIL_M3 = M3 and INDDMY_COIL; 
      gLAYER_530 = M3 and IND_MD_REGION; 
      IND_MD_M3_A = external2( gLAYER_530, INDDMY_MD, < 0.01, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 135 ], look_thru = COINCIDENT, orientation = { } ); 
      IND_MD_M3_B = M3 outside_touching_edge IND_MD_M3_A; 
      IND_MD_LEADING_M3 = M3 and IND_MD_LEADING; 
      gLAYER_531 = INDDMY_COIL_M3 not IND_MD_LEADING_M3; 
      IND_MD_SPIRAL_M3 = gLAYER_531 and INDDMY_MD; 
      
      //need to check with SL if spiral only in TM
      rIND_MD_R_13_M3 @= { @ "IND_MD.R.13:M3 : INDDMY_MD enclosure of inductor metal spirals >= 4 um.";
          INDDMY_MD_45 = angle_edge( INDDMY_MD, == 45 ); 
          INDDMY_MD_90 = INDDMY_MD not_coincident_edge INDDMY_MD_45; 
          IND_MD_CORE_CHECK = IND_MD_SPIRAL_M3 not_inside_touching_edge IND_MD_M3_B; 
          enclose( IND_MD_CORE_CHECK, INDDMY_MD_45, < ( 4 - GRID ), extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
          enclose( IND_MD_CORE_CHECK, INDDMY_MD_90, < 4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
      } /* end of rule : IND_MD.R.13:M3 */
      INDDMY_COIL_M4 = M4 and INDDMY_COIL; 
      gLAYER_532 = M4 and IND_MD_REGION; 
      IND_MD_M4_A = external2( gLAYER_532, INDDMY_MD, < 0.01, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 135 ], look_thru = COINCIDENT, orientation = { } ); 
      IND_MD_M4_B = M4 outside_touching_edge IND_MD_M4_A; 
      IND_MD_LEADING_M4 = M4 and IND_MD_LEADING; 
      gLAYER_533 = INDDMY_COIL_M4 not IND_MD_LEADING_M4; 
      IND_MD_SPIRAL_M4 = gLAYER_533 and INDDMY_MD; 
      
      //need to check with SL if spiral only in TM
      rIND_MD_R_13_M4 @= { @ "IND_MD.R.13:M4 : INDDMY_MD enclosure of inductor metal spirals >= 4 um.";
          INDDMY_MD_45 = angle_edge( INDDMY_MD, == 45 ); 
          INDDMY_MD_90 = INDDMY_MD not_coincident_edge INDDMY_MD_45; 
          IND_MD_CORE_CHECK = IND_MD_SPIRAL_M4 not_inside_touching_edge IND_MD_M4_B; 
          enclose( IND_MD_CORE_CHECK, INDDMY_MD_45, < ( 4 - GRID ), extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
          enclose( IND_MD_CORE_CHECK, INDDMY_MD_90, < 4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
      } /* end of rule : IND_MD.R.13:M4 */
      INDDMY_COIL_M5 = M5 and INDDMY_COIL; 
      gLAYER_534 = M5 and IND_MD_REGION; 
      IND_MD_M5_A = external2( gLAYER_534, INDDMY_MD, < 0.01, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 135 ], look_thru = COINCIDENT, orientation = { } ); 
      IND_MD_M5_B = M5 outside_touching_edge IND_MD_M5_A; 
      IND_MD_LEADING_M5 = M5 and IND_MD_LEADING; 
      gLAYER_535 = INDDMY_COIL_M5 not IND_MD_LEADING_M5; 
      IND_MD_SPIRAL_M5 = gLAYER_535 and INDDMY_MD; 
      
      //need to check with SL if spiral only in TM
      rIND_MD_R_13_M5 @= { @ "IND_MD.R.13:M5 : INDDMY_MD enclosure of inductor metal spirals >= 4 um.";
          INDDMY_MD_45 = angle_edge( INDDMY_MD, == 45 ); 
          INDDMY_MD_90 = INDDMY_MD not_coincident_edge INDDMY_MD_45; 
          IND_MD_CORE_CHECK = IND_MD_SPIRAL_M5 not_inside_touching_edge IND_MD_M5_B; 
          enclose( IND_MD_CORE_CHECK, INDDMY_MD_45, < ( 4 - GRID ), extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
          enclose( IND_MD_CORE_CHECK, INDDMY_MD_90, < 4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
      } /* end of rule : IND_MD.R.13:M5 */
      INDDMY_COIL_M6 = M6 and INDDMY_COIL; 
      gLAYER_536 = M6 and IND_MD_REGION; 
      IND_MD_M6_A = external2( gLAYER_536, INDDMY_MD, < 0.01, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 135 ], look_thru = COINCIDENT, orientation = { } ); 
      IND_MD_M6_B = M6 outside_touching_edge IND_MD_M6_A; 
      IND_MD_LEADING_M6 = M6 and IND_MD_LEADING; 
      gLAYER_537 = INDDMY_COIL_M6 not IND_MD_LEADING_M6; 
      IND_MD_SPIRAL_M6 = gLAYER_537 and INDDMY_MD; 
      
      //need to check with SL if spiral only in TM
      rIND_MD_R_13_M6 @= { @ "IND_MD.R.13:M6 : INDDMY_MD enclosure of inductor metal spirals >= 4 um.";
          INDDMY_MD_45 = angle_edge( INDDMY_MD, == 45 ); 
          INDDMY_MD_90 = INDDMY_MD not_coincident_edge INDDMY_MD_45; 
          IND_MD_CORE_CHECK = IND_MD_SPIRAL_M6 not_inside_touching_edge IND_MD_M6_B; 
          enclose( IND_MD_CORE_CHECK, INDDMY_MD_45, < ( 4 - GRID ), extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
          enclose( IND_MD_CORE_CHECK, INDDMY_MD_90, < 4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
      } /* end of rule : IND_MD.R.13:M6 */
      INDDMY_COIL_M7 = M7 and INDDMY_COIL; 
      gLAYER_538 = M7 and IND_MD_REGION; 
      IND_MD_M7_A = external2( gLAYER_538, INDDMY_MD, < 0.01, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 135 ], look_thru = COINCIDENT, orientation = { } ); 
      IND_MD_M7_B = M7 outside_touching_edge IND_MD_M7_A; 
      IND_MD_LEADING_M7 = M7 and IND_MD_LEADING; 
      gLAYER_539 = INDDMY_COIL_M7 not IND_MD_LEADING_M7; 
      IND_MD_SPIRAL_M7 = gLAYER_539 and INDDMY_MD; 
      
      //need to check with SL if spiral only in TM
      rIND_MD_R_13_M7 @= { @ "IND_MD.R.13:M7 : INDDMY_MD enclosure of inductor metal spirals >= 4 um.";
          INDDMY_MD_45 = angle_edge( INDDMY_MD, == 45 ); 
          INDDMY_MD_90 = INDDMY_MD not_coincident_edge INDDMY_MD_45; 
          IND_MD_CORE_CHECK = IND_MD_SPIRAL_M7 not_inside_touching_edge IND_MD_M7_B; 
          enclose( IND_MD_CORE_CHECK, INDDMY_MD_45, < ( 4 - GRID ), extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
          enclose( IND_MD_CORE_CHECK, INDDMY_MD_90, < 4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
      } /* end of rule : IND_MD.R.13:M7 */
      INDDMY_COIL_M8 = M8 and INDDMY_COIL; 
      gLAYER_540 = M8 and IND_MD_REGION; 
      IND_MD_M8_A = external2( gLAYER_540, INDDMY_MD, < 0.01, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 135 ], look_thru = COINCIDENT, orientation = { } ); 
      IND_MD_M8_B = M8 outside_touching_edge IND_MD_M8_A; 
      IND_MD_LEADING_M8 = M8 and IND_MD_LEADING; 
      gLAYER_541 = INDDMY_COIL_M8 not IND_MD_LEADING_M8; 
      IND_MD_SPIRAL_M8 = gLAYER_541 and INDDMY_MD; 
      
      //need to check with SL if spiral only in TM
      rIND_MD_R_13_M8 @= { @ "IND_MD.R.13:M8 : INDDMY_MD enclosure of inductor metal spirals >= 4 um.";
          INDDMY_MD_45 = angle_edge( INDDMY_MD, == 45 ); 
          INDDMY_MD_90 = INDDMY_MD not_coincident_edge INDDMY_MD_45; 
          IND_MD_CORE_CHECK = IND_MD_SPIRAL_M8 not_inside_touching_edge IND_MD_M8_B; 
          enclose( IND_MD_CORE_CHECK, INDDMY_MD_45, < ( 4 - GRID ), extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
          enclose( IND_MD_CORE_CHECK, INDDMY_MD_90, < 4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
      } /* end of rule : IND_MD.R.13:M8 */
      INDDMY_COIL_M9 = M9 and INDDMY_COIL; 
      gLAYER_542 = M9 and IND_MD_REGION; 
      IND_MD_M9_A = external2( gLAYER_542, INDDMY_MD, < 0.01, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 135 ], look_thru = COINCIDENT, orientation = { } ); 
      IND_MD_M9_B = M9 outside_touching_edge IND_MD_M9_A; 
      IND_MD_LEADING_M9 = M9 and IND_MD_LEADING; 
      gLAYER_543 = INDDMY_COIL_M9 not IND_MD_LEADING_M9; 
      IND_MD_SPIRAL_M9 = gLAYER_543 and INDDMY_MD; 
      
      //need to check with SL if spiral only in TM
      rIND_MD_R_13_M9 @= { @ "IND_MD.R.13:M9 : INDDMY_MD enclosure of inductor metal spirals >= 4 um.";
          INDDMY_MD_45 = angle_edge( INDDMY_MD, == 45 ); 
          INDDMY_MD_90 = INDDMY_MD not_coincident_edge INDDMY_MD_45; 
          IND_MD_CORE_CHECK = IND_MD_SPIRAL_M9 not_inside_touching_edge IND_MD_M9_B; 
          enclose( IND_MD_CORE_CHECK, INDDMY_MD_45, < ( 4 - GRID ), extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
          enclose( IND_MD_CORE_CHECK, INDDMY_MD_90, < 4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
      } /* end of rule : IND_MD.R.13:M9 */
      
      //IND_MD.R.20U can't be checked by DRC
      #ifdef FULL_CHIP 
         rIND_MD_DN_6 @= { @ "IND_MD.DN.6 : Maximum density of INDDMY_MD in whole chip <= 5%";
             VAR_108 = density_statistics_file( file = "IND_MD.DN.6.density" ); 
         _den_con = > 0.05;
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => INDDMY_MD, "layer2" => gCHIP }, statistics_files = { VAR_108 }, window_function = den_save_window_1 ); 
         } /* end of rule : IND_MD.DN.6 */
         rIND_MD_DN_9 @= { @ "IND_MD.DN.9 : M1/Mx/Mz. metal density over the whole chip (include INDDMY_MD)>= 20%";
             CHIP_IND_MD = interacting( CHIPX, INDDMY_MD ); 
             VAR_109 = density_statistics_file( file = "IND_MD.DN.9.M1.density" ); 
         _den_con = < 0.2;
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIP_IND_MD, layer_hash = { "layer1" => M1X, "layer2" => gCHIP }, statistics_files = { VAR_109 }, window_function = den_save_window_1 ); 
             VAR_110 = density_statistics_file( file = "IND_MD.DN.9.M2.density" ); 
         _den_con = < 0.2;
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIP_IND_MD, layer_hash = { "layer1" => M2X, "layer2" => gCHIP }, statistics_files = { VAR_110 }, window_function = den_save_window_1 ); 
             VAR_111 = density_statistics_file( file = "IND_MD.DN.9.M3.density" ); 
         _den_con = < 0.2;
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIP_IND_MD, layer_hash = { "layer1" => M3X, "layer2" => gCHIP }, statistics_files = { VAR_111 }, window_function = den_save_window_1 ); 
             VAR_112 = density_statistics_file( file = "IND_MD.DN.9.M4.density" ); 
         _den_con = < 0.2;
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIP_IND_MD, layer_hash = { "layer1" => M4X, "layer2" => gCHIP }, statistics_files = { VAR_112 }, window_function = den_save_window_1 ); 
             VAR_113 = density_statistics_file( file = "IND_MD.DN.9.M5.density" ); 
         _den_con = < 0.2;
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIP_IND_MD, layer_hash = { "layer1" => M5X, "layer2" => gCHIP }, statistics_files = { VAR_113 }, window_function = den_save_window_1 ); 
             VAR_114 = density_statistics_file( file = "IND_MD.DN.9.M6.density" ); 
         _den_con = < 0.2;
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIP_IND_MD, layer_hash = { "layer1" => M6X, "layer2" => gCHIP }, statistics_files = { VAR_114 }, window_function = den_save_window_1 ); 
             VAR_115 = density_statistics_file( file = "IND_MD.DN.9.M7.density" ); 
         _den_con = < 0.2;
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIP_IND_MD, layer_hash = { "layer1" => M7X, "layer2" => gCHIP }, statistics_files = { VAR_115 }, window_function = den_save_window_1 ); 
             VAR_116 = density_statistics_file( file = "IND_MD.DN.9.M8.density" ); 
         _den_con = < 0.2;
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIP_IND_MD, layer_hash = { "layer1" => M8X, "layer2" => gCHIP }, statistics_files = { VAR_116 }, window_function = den_save_window_1 ); 
             VAR_117 = density_statistics_file( file = "IND_MD.DN.9.M9.density" ); 
         _den_con = < 0.2;
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIP_IND_MD, layer_hash = { "layer1" => M9X, "layer2" => gCHIP }, statistics_files = { VAR_117 }, window_function = den_save_window_1 ); 
         } /* end of rule : IND_MD.DN.9 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      
      //IND_MD.R.15 is checked by [IND_MD.W.1 ~ IND.W.5]
      //IND_MD.R.16 is checked by {RV.S.1.WB/RV.EN.1.WB/AP.W.1.WB/AP.W.2.WB/AP.S.1.WB}
      rIND_MD_DN_7_M1 @= { @ "IND_MD.DN.7:M1 : Maximum M1/Mx/Mz density within (INDDMY_MD SIZING 12 um) over any 50um x 50um area (stepping in 25um) <= 90%";
          VAR_118 = density_statistics_file( file = "IND_MD.DN.7.M1.density" ); 
      _den_con = > 0.9;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_REGION, layer_hash = { "layer1" => M1X }, delta_window = { 50, 50 }, delta_x = 25, delta_y = 25, boundary = BACKUP, statistics_files = { VAR_118 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND_MD.DN.7:M1 */
      rIND_MD_DN_7_M2 @= { @ "IND_MD.DN.7:M2 : Maximum M1/Mx/Mz density within (INDDMY_MD SIZING 12 um) over any 50um x 50um area (stepping in 25um) <= 90%";
          VAR_119 = density_statistics_file( file = "IND_MD.DN.7.M2.density" ); 
      _den_con = > 0.9;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_REGION, layer_hash = { "layer1" => M2X }, delta_window = { 50, 50 }, delta_x = 25, delta_y = 25, boundary = BACKUP, statistics_files = { VAR_119 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND_MD.DN.7:M2 */
      rIND_MD_DN_7_M3 @= { @ "IND_MD.DN.7:M3 : Maximum M1/Mx/Mz density within (INDDMY_MD SIZING 12 um) over any 50um x 50um area (stepping in 25um) <= 90%";
          VAR_120 = density_statistics_file( file = "IND_MD.DN.7.M3.density" ); 
      _den_con = > 0.9;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_REGION, layer_hash = { "layer1" => M3X }, delta_window = { 50, 50 }, delta_x = 25, delta_y = 25, boundary = BACKUP, statistics_files = { VAR_120 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND_MD.DN.7:M3 */
      rIND_MD_DN_7_M4 @= { @ "IND_MD.DN.7:M4 : Maximum M1/Mx/Mz density within (INDDMY_MD SIZING 12 um) over any 50um x 50um area (stepping in 25um) <= 90%";
          VAR_121 = density_statistics_file( file = "IND_MD.DN.7.M4.density" ); 
      _den_con = > 0.9;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_REGION, layer_hash = { "layer1" => M4X }, delta_window = { 50, 50 }, delta_x = 25, delta_y = 25, boundary = BACKUP, statistics_files = { VAR_121 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND_MD.DN.7:M4 */
      rIND_MD_DN_7_M5 @= { @ "IND_MD.DN.7:M5 : Maximum M1/Mx/Mz density within (INDDMY_MD SIZING 12 um) over any 50um x 50um area (stepping in 25um) <= 90%";
          VAR_122 = density_statistics_file( file = "IND_MD.DN.7.M5.density" ); 
      _den_con = > 0.9;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_REGION, layer_hash = { "layer1" => M5X }, delta_window = { 50, 50 }, delta_x = 25, delta_y = 25, boundary = BACKUP, statistics_files = { VAR_122 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND_MD.DN.7:M5 */
      rIND_MD_DN_7_M6 @= { @ "IND_MD.DN.7:M6 : Maximum M1/Mx/Mz density within (INDDMY_MD SIZING 12 um) over any 50um x 50um area (stepping in 25um) <= 90%";
          VAR_123 = density_statistics_file( file = "IND_MD.DN.7.M6.density" ); 
      _den_con = > 0.9;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_REGION, layer_hash = { "layer1" => M6X }, delta_window = { 50, 50 }, delta_x = 25, delta_y = 25, boundary = BACKUP, statistics_files = { VAR_123 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND_MD.DN.7:M6 */
      rIND_MD_DN_7_M7 @= { @ "IND_MD.DN.7:M7 : Maximum M1/Mx/Mz density within (INDDMY_MD SIZING 12 um) over any 50um x 50um area (stepping in 25um) <= 90%";
          VAR_124 = density_statistics_file( file = "IND_MD.DN.7.M7.density" ); 
      _den_con = > 0.9;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_REGION, layer_hash = { "layer1" => M7X }, delta_window = { 50, 50 }, delta_x = 25, delta_y = 25, boundary = BACKUP, statistics_files = { VAR_124 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND_MD.DN.7:M7 */
      rIND_MD_DN_7_M8 @= { @ "IND_MD.DN.7:M8 : Maximum M1/Mx/Mz density within (INDDMY_MD SIZING 12 um) over any 50um x 50um area (stepping in 25um) <= 90%";
          VAR_125 = density_statistics_file( file = "IND_MD.DN.7.M8.density" ); 
      _den_con = > 0.9;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_REGION, layer_hash = { "layer1" => M8X }, delta_window = { 50, 50 }, delta_x = 25, delta_y = 25, boundary = BACKUP, statistics_files = { VAR_125 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND_MD.DN.7:M8 */
      rIND_MD_DN_8_M1 @= { @ "IND_MD.DN.8:M1 : Maximum M1/Mx/Mz density within (INDDMY_MD SIZING 12 um) over any 100um x 100um area (stepping in 50um) <= 80%";
          VAR_126 = density_statistics_file( file = "IND_MD.DN.8.M1.density" ); 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_REGION, layer_hash = { "layer1" => M1X }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_126 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND_MD.DN.8:M1 */
      rIND_MD_DN_8_M2 @= { @ "IND_MD.DN.8:M2 : Maximum M1/Mx/Mz density within (INDDMY_MD SIZING 12 um) over any 100um x 100um area (stepping in 50um) <= 80%";
          VAR_127 = density_statistics_file( file = "IND_MD.DN.8.M2.density" ); 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_REGION, layer_hash = { "layer1" => M2X }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_127 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND_MD.DN.8:M2 */
      rIND_MD_DN_8_M3 @= { @ "IND_MD.DN.8:M3 : Maximum M1/Mx/Mz density within (INDDMY_MD SIZING 12 um) over any 100um x 100um area (stepping in 50um) <= 80%";
          VAR_128 = density_statistics_file( file = "IND_MD.DN.8.M3.density" ); 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_REGION, layer_hash = { "layer1" => M3X }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_128 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND_MD.DN.8:M3 */
      rIND_MD_DN_8_M4 @= { @ "IND_MD.DN.8:M4 : Maximum M1/Mx/Mz density within (INDDMY_MD SIZING 12 um) over any 100um x 100um area (stepping in 50um) <= 80%";
          VAR_129 = density_statistics_file( file = "IND_MD.DN.8.M4.density" ); 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_REGION, layer_hash = { "layer1" => M4X }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_129 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND_MD.DN.8:M4 */
      rIND_MD_DN_8_M5 @= { @ "IND_MD.DN.8:M5 : Maximum M1/Mx/Mz density within (INDDMY_MD SIZING 12 um) over any 100um x 100um area (stepping in 50um) <= 80%";
          VAR_130 = density_statistics_file( file = "IND_MD.DN.8.M5.density" ); 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_REGION, layer_hash = { "layer1" => M5X }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_130 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND_MD.DN.8:M5 */
      rIND_MD_DN_8_M6 @= { @ "IND_MD.DN.8:M6 : Maximum M1/Mx/Mz density within (INDDMY_MD SIZING 12 um) over any 100um x 100um area (stepping in 50um) <= 80%";
          VAR_131 = density_statistics_file( file = "IND_MD.DN.8.M6.density" ); 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_REGION, layer_hash = { "layer1" => M6X }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_131 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND_MD.DN.8:M6 */
      rIND_MD_DN_8_M7 @= { @ "IND_MD.DN.8:M7 : Maximum M1/Mx/Mz density within (INDDMY_MD SIZING 12 um) over any 100um x 100um area (stepping in 50um) <= 80%";
          VAR_132 = density_statistics_file( file = "IND_MD.DN.8.M7.density" ); 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_REGION, layer_hash = { "layer1" => M7X }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_132 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND_MD.DN.8:M7 */
      rIND_MD_DN_8_M8 @= { @ "IND_MD.DN.8:M8 : Maximum M1/Mx/Mz density within (INDDMY_MD SIZING 12 um) over any 100um x 100um area (stepping in 50um) <= 80%";
          VAR_133 = density_statistics_file( file = "IND_MD.DN.8.M8.density" ); 
      _den_con = > 0.8;
      _den_polygon_area_clip = false;
      #ifdef ICV_REPORT_DENSITY
      _den_print = true;
      #else
      _den_print = false;
      #endif
      _den_print_only = false;
          density( output_type = CLIPPED_DELTA_WINDOW, window_layer = IND_MD_REGION, layer_hash = { "layer1" => M8X }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_133 }, window_function = den_save_window_4 ); 
      } /* end of rule : IND_MD.DN.8:M8 */
      
      //CHIP CORNER RULE CHECKS
      //=======================
      #ifdef FULL_CHIP 
         
         // CSR.R.1 is checked by CSR.R.1:DNWi
         rCSR_R_1_DNWI @= { @ "CSR.R.1:DNWi : DNWi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and DNWI; 
         } /* end of rule : CSR.R.1:DNWi */
         
         // CSR.R.1 is checked by CSR.R.1:NWi
         rCSR_R_1_NWI @= { @ "CSR.R.1:NWi : NWi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and NWI; 
         } /* end of rule : CSR.R.1:NWi */
         
         // CSR.R.1 is checked by CSR.R.1:OD_18i
         rCSR_R_1_OD_18I @= { @ "CSR.R.1:OD_18i : OD_18i is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and OD_18I; 
         } /* end of rule : CSR.R.1:OD_18i */
         
         // CSR.R.1 is checked by CSR.R.1:OD_25i
         rCSR_R_1_OD_25I @= { @ "CSR.R.1:OD_25i : OD_25i is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and OD_25I; 
         } /* end of rule : CSR.R.1:OD_25i */
         
         // CSR.R.1 is checked by CSR.R.1:OD25_33
         rCSR_R_1_OD25_33 @= { @ "CSR.R.1:OD25_33 : OD25_33 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and OD25_33; 
         } /* end of rule : CSR.R.1:OD25_33 */
         
         // CSR.R.1 is checked by CSR.R.1:OD25_18
         rCSR_R_1_OD25_18 @= { @ "CSR.R.1:OD25_18 : OD25_18 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and OD25_18; 
         } /* end of rule : CSR.R.1:OD25_18 */
         
         // CSR.R.1 is checked by CSR.R.1:OD_33i
         rCSR_R_1_OD_33I @= { @ "CSR.R.1:OD_33i : OD_33i is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and OD_33I; 
         } /* end of rule : CSR.R.1:OD_33i */
         
         // CSR.R.1 is checked by CSR.R.1:OD_DECAP
         rCSR_R_1_OD_DECAP @= { @ "CSR.R.1:OD_DECAP : OD_DECAP is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and OD_DECAP; 
         } /* end of rule : CSR.R.1:OD_DECAP */
         
         // CSR.R.1 is checked by CSR.R.1:PPi
         rCSR_R_1_PPI @= { @ "CSR.R.1:PPi : PPi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and PPI; 
         } /* end of rule : CSR.R.1:PPi */
         
         // CSR.R.1 is checked by CSR.R.1:NPi
         rCSR_R_1_NPI @= { @ "CSR.R.1:NPi : NPi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and NPI; 
         } /* end of rule : CSR.R.1:NPi */
         
         // CSR.R.1 is checked by CSR.R.1:COi
         rCSR_R_1_COI @= { @ "CSR.R.1:COi : COi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and COI; 
         } /* end of rule : CSR.R.1:COi */
         
         // CSR.R.1 is checked by CSR.R.1:CO_PUSH
         rCSR_R_1_CO_PUSH @= { @ "CSR.R.1:CO_PUSH : CO_PUSH is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and CO_PUSH; 
         } /* end of rule : CSR.R.1:CO_PUSH */
         
         // CSR.R.1 is checked by CSR.R.1:CBi
         rCSR_R_1_CBI @= { @ "CSR.R.1:CBi : CBi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and CBI; 
         } /* end of rule : CSR.R.1:CBi */
         
         // CSR.R.1 is checked by CSR.R.1:CB2i
         rCSR_R_1_CB2I @= { @ "CSR.R.1:CB2i : CB2i is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and CB2I; 
         } /* end of rule : CSR.R.1:CB2i */
         
         // CSR.R.1 is checked by CSR.R.1:RPOi
         rCSR_R_1_RPOI @= { @ "CSR.R.1:RPOi : RPOi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and RPOI; 
         } /* end of rule : CSR.R.1:RPOi */
         
         // CSR.R.1 is checked by CSR.R.1:NT_Ni
         rCSR_R_1_NT_NI @= { @ "CSR.R.1:NT_Ni : NT_Ni is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and NT_NI; 
         } /* end of rule : CSR.R.1:NT_Ni */
         
         // CSR.R.1 is checked by CSR.R.1:NCap_NTNi
         rCSR_R_1_NCAP_NTNI @= { @ "CSR.R.1:NCap_NTNi : NCap_NTNi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and NCAP_NTNI; 
         } /* end of rule : CSR.R.1:NCap_NTNi */
         
         // CSR.R.1 is checked by CSR.R.1:FWALi
         rCSR_R_1_FWALI @= { @ "CSR.R.1:FWALi : FWALi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and FWALI; 
         } /* end of rule : CSR.R.1:FWALi */
         
         // CSR.R.1 is checked by CSR.R.1:FWCUi
         rCSR_R_1_FWCUI @= { @ "CSR.R.1:FWCUi : FWCUi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and FWCUI; 
         } /* end of rule : CSR.R.1:FWCUi */
         
         // CSR.R.1 is checked by CSR.R.1:POFUSE
         rCSR_R_1_POFUSE @= { @ "CSR.R.1:POFUSE : POFUSE is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and POFUSE; 
         } /* end of rule : CSR.R.1:POFUSE */
         
         // CSR.R.1 is checked by CSR.R.1:FUSELINK
         rCSR_R_1_FUSELINK @= { @ "CSR.R.1:FUSELINK : FUSELINK is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and FUSELINK; 
         } /* end of rule : CSR.R.1:FUSELINK */
         
         // CSR.R.1 is checked by CSR.R.1:PMi
         rCSR_R_1_PMI @= { @ "CSR.R.1:PMi : PMi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and PMI; 
         } /* end of rule : CSR.R.1:PMi */
         
         // CSR.R.1 is checked by CSR.R.1:PM1i
         rCSR_R_1_PM1I @= { @ "CSR.R.1:PM1i : PM1i is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and PM1I; 
         } /* end of rule : CSR.R.1:PM1i */
         
         // CSR.R.1 is checked by CSR.R.1:PM2i
         rCSR_R_1_PM2I @= { @ "CSR.R.1:PM2i : PM2i is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and PM2I; 
         } /* end of rule : CSR.R.1:PM2i */
         
         // CSR.R.1 is checked by CSR.R.1:SEALRINGi
         rCSR_R_1_SEALRINGI @= { @ "CSR.R.1:SEALRINGi : SEALRINGi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and SEALRINGI; 
         } /* end of rule : CSR.R.1:SEALRINGi */
         
         // CSR.R.1 is checked by CSR.R.1:VTH_Ni
         rCSR_R_1_VTH_NI @= { @ "CSR.R.1:VTH_Ni : VTH_Ni is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and VTH_NI; 
         } /* end of rule : CSR.R.1:VTH_Ni */
         
         // CSR.R.1 is checked by CSR.R.1:VTH_Pi
         rCSR_R_1_VTH_PI @= { @ "CSR.R.1:VTH_Pi : VTH_Pi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and VTH_PI; 
         } /* end of rule : CSR.R.1:VTH_Pi */
         
         // CSR.R.1 is checked by CSR.R.1:VTL_Ni
         rCSR_R_1_VTL_NI @= { @ "CSR.R.1:VTL_Ni : VTL_Ni is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and VTL_NI; 
         } /* end of rule : CSR.R.1:VTL_Ni */
         
         // CSR.R.1 is checked by CSR.R.1:VTL_Pi
         rCSR_R_1_VTL_PI @= { @ "CSR.R.1:VTL_Pi : VTL_Pi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and VTL_PI; 
         } /* end of rule : CSR.R.1:VTL_Pi */
         
         // CSR.R.1 is checked by CSR.R.1:UHVT_Ni
         rCSR_R_1_UHVT_NI @= { @ "CSR.R.1:UHVT_Ni : UHVT_Ni is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and UHVT_NI; 
         } /* end of rule : CSR.R.1:UHVT_Ni */
         
         // CSR.R.1 is checked by CSR.R.1:UHVT_Pi
         rCSR_R_1_UHVT_PI @= { @ "CSR.R.1:UHVT_Pi : UHVT_Pi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and UHVT_PI; 
         } /* end of rule : CSR.R.1:UHVT_Pi */
         
         // CSR.R.1 is checked by CSR.R.1:CBDi
         rCSR_R_1_CBDI @= { @ "CSR.R.1:CBDi : CBDi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and CBDI; 
         } /* end of rule : CSR.R.1:CBDi */
         
         // CSR.R.1 is checked by CSR.R.1:UBMi
         rCSR_R_1_UBMI @= { @ "CSR.R.1:UBMi : UBMi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and UBMI; 
         } /* end of rule : CSR.R.1:UBMi */
         
         // CSR.R.1 is checked by CSR.R.1:RH
         rCSR_R_1_RH @= { @ "CSR.R.1:RH : RH is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and RH; 
         } /* end of rule : CSR.R.1:RH */
         
         // CSR.R.1 is checked by CSR.R.1:ESD3
         rCSR_R_1_ESD3 @= { @ "CSR.R.1:ESD3 : ESD3 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and ESD3; 
         } /* end of rule : CSR.R.1:ESD3 */
         
         // CSR.R.1 is checked by CSR.R.1:VARi
         rCSR_R_1_VARI @= { @ "CSR.R.1:VARi : VARi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and VARI; 
         } /* end of rule : CSR.R.1:VARi */
         
         // CSR.R.1 is checked by CSR.R.1:APi
         rCSR_R_1_API @= { @ "CSR.R.1:APi : APi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and API; 
         } /* end of rule : CSR.R.1:APi */
         
         // CSR.R.1 is checked by CSR.R.1:Cu_PPIi
         rCSR_R_1_CU_PPII @= { @ "CSR.R.1:Cu_PPIi : Cu_PPIi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and CU_PPII; 
         } /* end of rule : CSR.R.1:Cu_PPIi */
         
         // CSR.R.1 is checked by CSR.R.1:CBMi
         rCSR_R_1_CBMI @= { @ "CSR.R.1:CBMi : CBMi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and CBMI; 
         } /* end of rule : CSR.R.1:CBMi */
         
         // CSR.R.1 is checked by CSR.R.1:CTMi
         rCSR_R_1_CTMI @= { @ "CSR.R.1:CTMi : CTMi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and CTMI; 
         } /* end of rule : CSR.R.1:CTMi */
         
         // CSR.R.1 is checked by CSR.R.1:RVi
         rCSR_R_1_RVI @= { @ "CSR.R.1:RVi : RVi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and RVI; 
         } /* end of rule : CSR.R.1:RVi */
         
         // CSR.R.1 is checked by CSR.R.1:DCOi
         rCSR_R_1_DCOI @= { @ "CSR.R.1:DCOi : DCOi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and DCOI; 
         } /* end of rule : CSR.R.1:DCOi */
         
         // CSR.R.1 is checked by CSR.R.1:HVD_P
         rCSR_R_1_HVD_P @= { @ "CSR.R.1:HVD_P : HVD_P is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and HVD_P; 
         } /* end of rule : CSR.R.1:HVD_P */
         
         // CSR.R.1 is checked by CSR.R.1:HVD_N_nw
         rCSR_R_1_HVD_N_NW @= { @ "CSR.R.1:HVD_N_nw : HVD_N_nw is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and HVD_N_NW; 
         } /* end of rule : CSR.R.1:HVD_N_nw */
         
         // CSR.R.1 is checked by CSR.R.1:SRM_ULL
         rCSR_R_1_SRM_ULL @= { @ "CSR.R.1:SRM_ULL : SRM_ULL is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and SRM_ULL; 
         } /* end of rule : CSR.R.1:SRM_ULL */
         
         // CSR.R.1 is checked by CSR.R.1:BJTDMY
         rCSR_R_1_BJTDMY @= { @ "CSR.R.1:BJTDMY : BJTDMY is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and BJTDMY; 
         } /* end of rule : CSR.R.1:BJTDMY */
         
         // CSR.R.1 is checked by CSR.R.1:NWDMY
         rCSR_R_1_NWDMY @= { @ "CSR.R.1:NWDMY : NWDMY is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and NWDMY; 
         } /* end of rule : CSR.R.1:NWDMY */
         
         // CSR.R.1 is checked by CSR.R.1:RPDMY
         rCSR_R_1_RPDMY @= { @ "CSR.R.1:RPDMY : RPDMY is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and RPDMY; 
         } /* end of rule : CSR.R.1:RPDMY */
         
         // CSR.R.1 is checked by CSR.R.1:PMDMY
         rCSR_R_1_PMDMY @= { @ "CSR.R.1:PMDMY : PMDMY is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and PMDMY; 
         } /* end of rule : CSR.R.1:PMDMY */
         
         // CSR.R.1 is checked by CSR.R.1:SDI
         rCSR_R_1_SDI @= { @ "CSR.R.1:SDI : SDI is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and SDI; 
         } /* end of rule : CSR.R.1:SDI */
         
         // CSR.R.1 is checked by CSR.R.1:ESD1DMY
         rCSR_R_1_ESD1DMY @= { @ "CSR.R.1:ESD1DMY : ESD1DMY is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and ESD1DMY; 
         } /* end of rule : CSR.R.1:ESD1DMY */
         
         // CSR.R.1 is checked by CSR.R.1:ESD2DMY
         rCSR_R_1_ESD2DMY @= { @ "CSR.R.1:ESD2DMY : ESD2DMY is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and ESD2DMY; 
         } /* end of rule : CSR.R.1:ESD2DMY */
         
         // CSR.R.1 is checked by CSR.R.1:RODMY
         rCSR_R_1_RODMY @= { @ "CSR.R.1:RODMY : RODMY is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and RODMY; 
         } /* end of rule : CSR.R.1:RODMY */
         
         // CSR.R.1 is checked by CSR.R.1:LMARK
         rCSR_R_1_LMARK @= { @ "CSR.R.1:LMARK : LMARK is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and LMARK; 
         } /* end of rule : CSR.R.1:LMARK */
         
         // CSR.R.1 is checked by CSR.R.1:SRM
         rCSR_R_1_SRM @= { @ "CSR.R.1:SRM : SRM is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and SRM; 
         } /* end of rule : CSR.R.1:SRM */
         
         // CSR.R.1 is checked by CSR.R.1:CSRDMY
         rCSR_R_1_CSRDMY @= { @ "CSR.R.1:CSRDMY : CSRDMY is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and CSRDMY; 
         } /* end of rule : CSR.R.1:CSRDMY */
         
         // CSR.R.1 is checked by CSR.R.1:CDUDMY
         rCSR_R_1_CDUDMY @= { @ "CSR.R.1:CDUDMY : CDUDMY is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and CDUDMY; 
         } /* end of rule : CSR.R.1:CDUDMY */
         
         // CSR.R.1 is checked by CSR.R.1:TCDDMY
         rCSR_R_1_TCDDMY @= { @ "CSR.R.1:TCDDMY : TCDDMY is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and TCDDMY; 
         } /* end of rule : CSR.R.1:TCDDMY */
         
         // CSR.R.1 is checked by CSR.R.1:LOGO
         rCSR_R_1_LOGO @= { @ "CSR.R.1:LOGO : LOGO is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and LOGO; 
         } /* end of rule : CSR.R.1:LOGO */
         
         // CSR.R.1 is checked by CSR.R.1:INDDMY
         rCSR_R_1_INDDMY @= { @ "CSR.R.1:INDDMY : INDDMY is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and INDDMY; 
         } /* end of rule : CSR.R.1:INDDMY */
         
         // CSR.R.1 is checked by CSR.R.1:CTMDMY
         rCSR_R_1_CTMDMY @= { @ "CSR.R.1:CTMDMY : CTMDMY is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and CTMDMY; 
         } /* end of rule : CSR.R.1:CTMDMY */
         
         // CSR.R.1 is checked by CSR.R.1:CTMDMY_10
         rCSR_R_1_CTMDMY_10 @= { @ "CSR.R.1:CTMDMY_10 : CTMDMY_10 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and CTMDMY_10; 
         } /* end of rule : CSR.R.1:CTMDMY_10 */
         
         // CSR.R.1 is checked by CSR.R.1:CTMDMY_15
         rCSR_R_1_CTMDMY_15 @= { @ "CSR.R.1:CTMDMY_15 : CTMDMY_15 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and CTMDMY_15; 
         } /* end of rule : CSR.R.1:CTMDMY_15 */
         
         // CSR.R.1 is checked by CSR.R.1:CTMDMY_20
         rCSR_R_1_CTMDMY_20 @= { @ "CSR.R.1:CTMDMY_20 : CTMDMY_20 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and CTMDMY_20; 
         } /* end of rule : CSR.R.1:CTMDMY_20 */
         
         // CSR.R.1 is checked by CSR.R.1:CTMDMY_21
         rCSR_R_1_CTMDMY_21 @= { @ "CSR.R.1:CTMDMY_21 : CTMDMY_21 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and CTMDMY_21; 
         } /* end of rule : CSR.R.1:CTMDMY_21 */
         
         // CSR.R.1 is checked by CSR.R.1:MOMDMY_1
         rCSR_R_1_MOMDMY_1 @= { @ "CSR.R.1:MOMDMY_1 : MOMDMY_1 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and MOMDMY_1; 
         } /* end of rule : CSR.R.1:MOMDMY_1 */
         
         // CSR.R.1 is checked by CSR.R.1:MOMDMY_2
         rCSR_R_1_MOMDMY_2 @= { @ "CSR.R.1:MOMDMY_2 : MOMDMY_2 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and MOMDMY_2; 
         } /* end of rule : CSR.R.1:MOMDMY_2 */
         
         // CSR.R.1 is checked by CSR.R.1:MOMDMY_3
         rCSR_R_1_MOMDMY_3 @= { @ "CSR.R.1:MOMDMY_3 : MOMDMY_3 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and MOMDMY_3; 
         } /* end of rule : CSR.R.1:MOMDMY_3 */
         
         // CSR.R.1 is checked by CSR.R.1:MOMDMY_4
         rCSR_R_1_MOMDMY_4 @= { @ "CSR.R.1:MOMDMY_4 : MOMDMY_4 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and MOMDMY_4; 
         } /* end of rule : CSR.R.1:MOMDMY_4 */
         
         // CSR.R.1 is checked by CSR.R.1:MOMDMY_5
         rCSR_R_1_MOMDMY_5 @= { @ "CSR.R.1:MOMDMY_5 : MOMDMY_5 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and MOMDMY_5; 
         } /* end of rule : CSR.R.1:MOMDMY_5 */
         
         // CSR.R.1 is checked by CSR.R.1:MOMDMY_6
         rCSR_R_1_MOMDMY_6 @= { @ "CSR.R.1:MOMDMY_6 : MOMDMY_6 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and MOMDMY_6; 
         } /* end of rule : CSR.R.1:MOMDMY_6 */
         
         // CSR.R.1 is checked by CSR.R.1:MOMDMY_7
         rCSR_R_1_MOMDMY_7 @= { @ "CSR.R.1:MOMDMY_7 : MOMDMY_7 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and MOMDMY_7; 
         } /* end of rule : CSR.R.1:MOMDMY_7 */
         
         // CSR.R.1 is checked by CSR.R.1:MOMDMY_8
         rCSR_R_1_MOMDMY_8 @= { @ "CSR.R.1:MOMDMY_8 : MOMDMY_8 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and MOMDMY_8; 
         } /* end of rule : CSR.R.1:MOMDMY_8 */
         
         // CSR.R.1 is checked by CSR.R.1:MOMDMY_9
         rCSR_R_1_MOMDMY_9 @= { @ "CSR.R.1:MOMDMY_9 : MOMDMY_9 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and MOMDMY_9; 
         } /* end of rule : CSR.R.1:MOMDMY_9 */
         
         // CSR.R.1 is checked by CSR.R.1:MOMDMY_AP
         rCSR_R_1_MOMDMY_AP @= { @ "CSR.R.1:MOMDMY_AP : MOMDMY_AP is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and MOMDMY_AP; 
         } /* end of rule : CSR.R.1:MOMDMY_AP */
         
         // CSR.R.1 is checked by CSR.R.1:RTMOMDMY
         rCSR_R_1_RTMOMDMY @= { @ "CSR.R.1:RTMOMDMY : RTMOMDMY is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and RTMOMDMY; 
         } /* end of rule : CSR.R.1:RTMOMDMY */
         
         // CSR.R.1 is checked by CSR.R.1:MOMDMY
         rCSR_R_1_MOMDMY @= { @ "CSR.R.1:MOMDMY : MOMDMY is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and MOMDMY; 
         } /* end of rule : CSR.R.1:MOMDMY */
         
         // CSR.R.1 is checked by CSR.R.1:MOMDMY_2T
         rCSR_R_1_MOMDMY_2T @= { @ "CSR.R.1:MOMDMY_2T : MOMDMY_2T is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and MOMDMY_2T; 
         } /* end of rule : CSR.R.1:MOMDMY_2T */
         
         // CSR.R.1 is checked by CSR.R.1:MOMDMY_100
         rCSR_R_1_MOMDMY_100 @= { @ "CSR.R.1:MOMDMY_100 : MOMDMY_100 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and MOMDMY_100; 
         } /* end of rule : CSR.R.1:MOMDMY_100 */
         
         // CSR.R.1 is checked by CSR.R.1:RFDMY
         rCSR_R_1_RFDMY @= { @ "CSR.R.1:RFDMY : RFDMY is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and RFDMY; 
         } /* end of rule : CSR.R.1:RFDMY */
         
         // CSR.R.1 is checked by CSR.R.1:WBDMY
         rCSR_R_1_WBDMY @= { @ "CSR.R.1:WBDMY : WBDMY is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and WBDMY; 
         } /* end of rule : CSR.R.1:WBDMY */
         
         // CSR.R.1 is checked by CSR.R.1:DIODMY
         rCSR_R_1_DIODMY @= { @ "CSR.R.1:DIODMY : DIODMY is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and DIODMY; 
         } /* end of rule : CSR.R.1:DIODMY */
         
         // CSR.R.1 is checked by CSR.R.1:SRAMDMY
         rCSR_R_1_SRAMDMY @= { @ "CSR.R.1:SRAMDMY : SRAMDMY is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and SRAMDMY; 
         } /* end of rule : CSR.R.1:SRAMDMY */
         
         // CSR.R.1 is checked by CSR.R.1:SRAMDMY_4
         rCSR_R_1_SRAMDMY_4 @= { @ "CSR.R.1:SRAMDMY_4 : SRAMDMY_4 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and SRAMDMY_4; 
         } /* end of rule : CSR.R.1:SRAMDMY_4 */
         
         // CSR.R.1 is checked by CSR.R.1:SRAMDMY_5
         rCSR_R_1_SRAMDMY_5 @= { @ "CSR.R.1:SRAMDMY_5 : SRAMDMY_5 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and SRAMDMY_5; 
         } /* end of rule : CSR.R.1:SRAMDMY_5 */
         
         // CSR.R.1 is checked by CSR.R.1:SRAMDMY_1
         rCSR_R_1_SRAMDMY_1 @= { @ "CSR.R.1:SRAMDMY_1 : SRAMDMY_1 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and SRAMDMY_1; 
         } /* end of rule : CSR.R.1:SRAMDMY_1 */
         
         // CSR.R.1 is checked by CSR.R.1:RAM1TDMY
         rCSR_R_1_RAM1TDMY @= { @ "CSR.R.1:RAM1TDMY : RAM1TDMY is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and RAM1TDMY; 
         } /* end of rule : CSR.R.1:RAM1TDMY */
         
         // CSR.R.1 is checked by CSR.R.1:OD1Ti
         rCSR_R_1_OD1TI @= { @ "CSR.R.1:OD1Ti : OD1Ti is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and OD1TI; 
         } /* end of rule : CSR.R.1:OD1Ti */
         
         // CSR.R.1 is checked by CSR.R.1:CLDDi
         rCSR_R_1_CLDDI @= { @ "CSR.R.1:CLDDi : CLDDi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and CLDDI; 
         } /* end of rule : CSR.R.1:CLDDi */
         
         // CSR.R.1 is checked by CSR.R.1:CROWNi
         rCSR_R_1_CROWNI @= { @ "CSR.R.1:CROWNi : CROWNi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and CROWNI; 
         } /* end of rule : CSR.R.1:CROWNi */
         
         // CSR.R.1 is checked by CSR.R.1:P3i
         rCSR_R_1_P3I @= { @ "CSR.R.1:P3i : P3i is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and P3I; 
         } /* end of rule : CSR.R.1:P3i */
         
         // CSR.R.1 is checked by CSR.R.1:SNCTi
         rCSR_R_1_SNCTI @= { @ "CSR.R.1:SNCTi : SNCTi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and SNCTI; 
         } /* end of rule : CSR.R.1:SNCTi */
         
         // CSR.R.1 is checked by CSR.R.1:LUPWDMY
         rCSR_R_1_LUPWDMY @= { @ "CSR.R.1:LUPWDMY : LUPWDMY is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and LUPWDMY; 
         } /* end of rule : CSR.R.1:LUPWDMY */
         
         // CSR.R.1 is checked by CSR.R.1:LUPWDMY_2
         rCSR_R_1_LUPWDMY_2 @= { @ "CSR.R.1:LUPWDMY_2 : LUPWDMY_2 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and LUPWDMY_2; 
         } /* end of rule : CSR.R.1:LUPWDMY_2 */
         
         // CSR.R.1 is checked by CSR.R.1:VDDDMY
         rCSR_R_1_VDDDMY @= { @ "CSR.R.1:VDDDMY : VDDDMY is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and VDDDMY; 
         } /* end of rule : CSR.R.1:VDDDMY */
         
         // CSR.R.1 is checked by CSR.R.1:VSSDMY
         rCSR_R_1_VSSDMY @= { @ "CSR.R.1:VSSDMY : VSSDMY is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and VSSDMY; 
         } /* end of rule : CSR.R.1:VSSDMY */
         
         // CSR.R.1 is checked by CSR.R.1:MATCHING
         rCSR_R_1_MATCHING @= { @ "CSR.R.1:MATCHING : MATCHING is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and MATCHING; 
         } /* end of rule : CSR.R.1:MATCHING */
         
         // CSR.R.1 is checked by CSR.R.1:M1i
         rCSR_R_1_M1I @= { @ "CSR.R.1:M1i : M1i is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and M1I; 
         } /* end of rule : CSR.R.1:M1i */
         
         // CSR.R.1 is checked by CSR.R.1:M1_real
         rCSR_R_1_M1_REAL @= { @ "CSR.R.1:M1_real : M1_real is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and M1_REAL; 
         } /* end of rule : CSR.R.1:M1_real */
         
         // CSR.R.1 is checked by CSR.R.1:DM1_O
         rCSR_R_1_DM1_O @= { @ "CSR.R.1:DM1_O : DM1_O is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and DM1_O; 
         } /* end of rule : CSR.R.1:DM1_O */
         
         // CSR.R.1 is checked by CSR.R.1:DUM1
         rCSR_R_1_DUM1 @= { @ "CSR.R.1:DUM1 : DUM1 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and DUM1; 
         } /* end of rule : CSR.R.1:DUM1 */
         
         // CSR.R.1 is checked by CSR.R.1:M2i
         rCSR_R_1_M2I @= { @ "CSR.R.1:M2i : M2i is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and M2I; 
         } /* end of rule : CSR.R.1:M2i */
         
         // CSR.R.1 is checked by CSR.R.1:M2_real
         rCSR_R_1_M2_REAL @= { @ "CSR.R.1:M2_real : M2_real is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and M2_REAL; 
         } /* end of rule : CSR.R.1:M2_real */
         
         // CSR.R.1 is checked by CSR.R.1:DM2_O
         rCSR_R_1_DM2_O @= { @ "CSR.R.1:DM2_O : DM2_O is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and DM2_O; 
         } /* end of rule : CSR.R.1:DM2_O */
         
         // CSR.R.1 is checked by CSR.R.1:DUM2
         rCSR_R_1_DUM2 @= { @ "CSR.R.1:DUM2 : DUM2 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and DUM2; 
         } /* end of rule : CSR.R.1:DUM2 */
         
         // CSR.R.1 is checked by CSR.R.1:M3i
         rCSR_R_1_M3I @= { @ "CSR.R.1:M3i : M3i is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and M3I; 
         } /* end of rule : CSR.R.1:M3i */
         
         // CSR.R.1 is checked by CSR.R.1:M3_real
         rCSR_R_1_M3_REAL @= { @ "CSR.R.1:M3_real : M3_real is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and M3_REAL; 
         } /* end of rule : CSR.R.1:M3_real */
         
         // CSR.R.1 is checked by CSR.R.1:DM3_O
         rCSR_R_1_DM3_O @= { @ "CSR.R.1:DM3_O : DM3_O is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and DM3_O; 
         } /* end of rule : CSR.R.1:DM3_O */
         
         // CSR.R.1 is checked by CSR.R.1:DUM3
         rCSR_R_1_DUM3 @= { @ "CSR.R.1:DUM3 : DUM3 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and DUM3; 
         } /* end of rule : CSR.R.1:DUM3 */
         
         // CSR.R.1 is checked by CSR.R.1:M4i
         rCSR_R_1_M4I @= { @ "CSR.R.1:M4i : M4i is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and M4I; 
         } /* end of rule : CSR.R.1:M4i */
         
         // CSR.R.1 is checked by CSR.R.1:M4_real
         rCSR_R_1_M4_REAL @= { @ "CSR.R.1:M4_real : M4_real is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and M4_REAL; 
         } /* end of rule : CSR.R.1:M4_real */
         
         // CSR.R.1 is checked by CSR.R.1:DM4_O
         rCSR_R_1_DM4_O @= { @ "CSR.R.1:DM4_O : DM4_O is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and DM4_O; 
         } /* end of rule : CSR.R.1:DM4_O */
         
         // CSR.R.1 is checked by CSR.R.1:DUM4
         rCSR_R_1_DUM4 @= { @ "CSR.R.1:DUM4 : DUM4 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and DUM4; 
         } /* end of rule : CSR.R.1:DUM4 */
         
         // CSR.R.1 is checked by CSR.R.1:M5i
         rCSR_R_1_M5I @= { @ "CSR.R.1:M5i : M5i is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and M5I; 
         } /* end of rule : CSR.R.1:M5i */
         
         // CSR.R.1 is checked by CSR.R.1:M5_real
         rCSR_R_1_M5_REAL @= { @ "CSR.R.1:M5_real : M5_real is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and M5_REAL; 
         } /* end of rule : CSR.R.1:M5_real */
         
         // CSR.R.1 is checked by CSR.R.1:DM5_O
         rCSR_R_1_DM5_O @= { @ "CSR.R.1:DM5_O : DM5_O is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and DM5_O; 
         } /* end of rule : CSR.R.1:DM5_O */
         
         // CSR.R.1 is checked by CSR.R.1:DUM5
         rCSR_R_1_DUM5 @= { @ "CSR.R.1:DUM5 : DUM5 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and DUM5; 
         } /* end of rule : CSR.R.1:DUM5 */
         
         // CSR.R.1 is checked by CSR.R.1:M6i
         rCSR_R_1_M6I @= { @ "CSR.R.1:M6i : M6i is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and M6I; 
         } /* end of rule : CSR.R.1:M6i */
         
         // CSR.R.1 is checked by CSR.R.1:M6_real
         rCSR_R_1_M6_REAL @= { @ "CSR.R.1:M6_real : M6_real is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and M6_REAL; 
         } /* end of rule : CSR.R.1:M6_real */
         
         // CSR.R.1 is checked by CSR.R.1:DM6_O
         rCSR_R_1_DM6_O @= { @ "CSR.R.1:DM6_O : DM6_O is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and DM6_O; 
         } /* end of rule : CSR.R.1:DM6_O */
         
         // CSR.R.1 is checked by CSR.R.1:DUM6
         rCSR_R_1_DUM6 @= { @ "CSR.R.1:DUM6 : DUM6 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and DUM6; 
         } /* end of rule : CSR.R.1:DUM6 */
         
         // CSR.R.1 is checked by CSR.R.1:M7i
         rCSR_R_1_M7I @= { @ "CSR.R.1:M7i : M7i is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and M7I; 
         } /* end of rule : CSR.R.1:M7i */
         
         // CSR.R.1 is checked by CSR.R.1:M7_real
         rCSR_R_1_M7_REAL @= { @ "CSR.R.1:M7_real : M7_real is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and M7_REAL; 
         } /* end of rule : CSR.R.1:M7_real */
         
         // CSR.R.1 is checked by CSR.R.1:DM7_O
         rCSR_R_1_DM7_O @= { @ "CSR.R.1:DM7_O : DM7_O is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and DM7_O; 
         } /* end of rule : CSR.R.1:DM7_O */
         
         // CSR.R.1 is checked by CSR.R.1:DUM7
         rCSR_R_1_DUM7 @= { @ "CSR.R.1:DUM7 : DUM7 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and DUM7; 
         } /* end of rule : CSR.R.1:DUM7 */
         
         // CSR.R.1 is checked by CSR.R.1:M8_OLD
         rCSR_R_1_M8_OLD @= { @ "CSR.R.1:M8_OLD : M8_OLD is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and M8_OLD; 
         } /* end of rule : CSR.R.1:M8_OLD */
         
         // CSR.R.1 is checked by CSR.R.1:M8_NEW
         rCSR_R_1_M8_NEW @= { @ "CSR.R.1:M8_NEW : M8_NEW is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and M8_NEW; 
         } /* end of rule : CSR.R.1:M8_NEW */
         
         // CSR.R.1 is checked by CSR.R.1:DUM8_OLD
         rCSR_R_1_DUM8_OLD @= { @ "CSR.R.1:DUM8_OLD : DUM8_OLD is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and DUM8_OLD; 
         } /* end of rule : CSR.R.1:DUM8_OLD */
         
         // CSR.R.1 is checked by CSR.R.1:DUM8_NEW
         rCSR_R_1_DUM8_NEW @= { @ "CSR.R.1:DUM8_NEW : DUM8_NEW is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and DUM8_NEW; 
         } /* end of rule : CSR.R.1:DUM8_NEW */
         
         // CSR.R.1 is checked by CSR.R.1:M9_OLD
         rCSR_R_1_M9_OLD @= { @ "CSR.R.1:M9_OLD : M9_OLD is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and M9_OLD; 
         } /* end of rule : CSR.R.1:M9_OLD */
         
         // CSR.R.1 is checked by CSR.R.1:M9_NEW
         rCSR_R_1_M9_NEW @= { @ "CSR.R.1:M9_NEW : M9_NEW is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and M9_NEW; 
         } /* end of rule : CSR.R.1:M9_NEW */
         
         // CSR.R.1 is checked by CSR.R.1:DUM9_OLD
         rCSR_R_1_DUM9_OLD @= { @ "CSR.R.1:DUM9_OLD : DUM9_OLD is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and DUM9_OLD; 
         } /* end of rule : CSR.R.1:DUM9_OLD */
         
         // CSR.R.1 is checked by CSR.R.1:DUM9_NEW
         rCSR_R_1_DUM9_NEW @= { @ "CSR.R.1:DUM9_NEW : DUM9_NEW is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and DUM9_NEW; 
         } /* end of rule : CSR.R.1:DUM9_NEW */
         
         // CSR.R.1 is checked by CSR.R.1:VIA1i
         rCSR_R_1_VIA1I @= { @ "CSR.R.1:VIA1i : VIA1i is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and VIA1I; 
         } /* end of rule : CSR.R.1:VIA1i */
         
         // CSR.R.1 is checked by CSR.R.1:VIA2i
         rCSR_R_1_VIA2I @= { @ "CSR.R.1:VIA2i : VIA2i is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and VIA2I; 
         } /* end of rule : CSR.R.1:VIA2i */
         
         // CSR.R.1 is checked by CSR.R.1:VIA3i
         rCSR_R_1_VIA3I @= { @ "CSR.R.1:VIA3i : VIA3i is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and VIA3I; 
         } /* end of rule : CSR.R.1:VIA3i */
         
         // CSR.R.1 is checked by CSR.R.1:VIA4i
         rCSR_R_1_VIA4I @= { @ "CSR.R.1:VIA4i : VIA4i is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and VIA4I; 
         } /* end of rule : CSR.R.1:VIA4i */
         
         // CSR.R.1 is checked by CSR.R.1:VIA5i
         rCSR_R_1_VIA5I @= { @ "CSR.R.1:VIA5i : VIA5i is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and VIA5I; 
         } /* end of rule : CSR.R.1:VIA5i */
         
         // CSR.R.1 is checked by CSR.R.1:VIA6i
         rCSR_R_1_VIA6I @= { @ "CSR.R.1:VIA6i : VIA6i is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and VIA6I; 
         } /* end of rule : CSR.R.1:VIA6i */
         
         // CSR.R.1 is checked by CSR.R.1:VIA7_OLD
         rCSR_R_1_VIA7_OLD @= { @ "CSR.R.1:VIA7_OLD : VIA7_OLD is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and VIA7_OLD; 
         } /* end of rule : CSR.R.1:VIA7_OLD */
         
         // CSR.R.1 is checked by CSR.R.1:VIA7_NEW
         rCSR_R_1_VIA7_NEW @= { @ "CSR.R.1:VIA7_NEW : VIA7_NEW is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and VIA7_NEW; 
         } /* end of rule : CSR.R.1:VIA7_NEW */
         
         // CSR.R.1 is checked by CSR.R.1:VIA8_OLD
         rCSR_R_1_VIA8_OLD @= { @ "CSR.R.1:VIA8_OLD : VIA8_OLD is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and VIA8_OLD; 
         } /* end of rule : CSR.R.1:VIA8_OLD */
         
         // CSR.R.1 is checked by CSR.R.1:VIA8_NEW
         rCSR_R_1_VIA8_NEW @= { @ "CSR.R.1:VIA8_NEW : VIA8_NEW is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and VIA8_NEW; 
         } /* end of rule : CSR.R.1:VIA8_NEW */
         
         // CSR.R.1 is checked by CSR.R.1:ODi
         rCSR_R_1_ODI @= { @ "CSR.R.1:ODi : ODi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and ODI; 
         } /* end of rule : CSR.R.1:ODi */
         
         // CSR.R.1 is checked by CSR.R.1:DOD
         rCSR_R_1_DOD @= { @ "CSR.R.1:DOD : DOD is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and DOD; 
         } /* end of rule : CSR.R.1:DOD */
         
         // CSR.R.1 is checked by CSR.R.1:POi
         rCSR_R_1_POI @= { @ "CSR.R.1:POi : POi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and POI; 
         } /* end of rule : CSR.R.1:POi */
         
         // CSR.R.1 is checked by CSR.R.1:DPO
         rCSR_R_1_DPO @= { @ "CSR.R.1:DPO : DPO is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and DPO; 
         } /* end of rule : CSR.R.1:DPO */
         
         // CSR.R.1 is checked by CSR.R.1:mVTLi
         rCSR_R_1_MVTLI @= { @ "CSR.R.1:mVTLi : mVTLi is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and MVTLI; 
         } /* end of rule : CSR.R.1:mVTLi */
         
         // CSR.R.1 is checked by CSR.R.1:RMDMY1
         rCSR_R_1_RMDMY1 @= { @ "CSR.R.1:RMDMY1 : RMDMY1 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and RMDMY1; 
         } /* end of rule : CSR.R.1:RMDMY1 */
         
         // CSR.R.1 is checked by CSR.R.1:RMDMY2
         rCSR_R_1_RMDMY2 @= { @ "CSR.R.1:RMDMY2 : RMDMY2 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and RMDMY2; 
         } /* end of rule : CSR.R.1:RMDMY2 */
         
         // CSR.R.1 is checked by CSR.R.1:RMDMY3
         rCSR_R_1_RMDMY3 @= { @ "CSR.R.1:RMDMY3 : RMDMY3 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and RMDMY3; 
         } /* end of rule : CSR.R.1:RMDMY3 */
         
         // CSR.R.1 is checked by CSR.R.1:RMDMY4
         rCSR_R_1_RMDMY4 @= { @ "CSR.R.1:RMDMY4 : RMDMY4 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and RMDMY4; 
         } /* end of rule : CSR.R.1:RMDMY4 */
         
         // CSR.R.1 is checked by CSR.R.1:RMDMY5
         rCSR_R_1_RMDMY5 @= { @ "CSR.R.1:RMDMY5 : RMDMY5 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and RMDMY5; 
         } /* end of rule : CSR.R.1:RMDMY5 */
         
         // CSR.R.1 is checked by CSR.R.1:RMDMY6
         rCSR_R_1_RMDMY6 @= { @ "CSR.R.1:RMDMY6 : RMDMY6 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and RMDMY6; 
         } /* end of rule : CSR.R.1:RMDMY6 */
         
         // CSR.R.1 is checked by CSR.R.1:RMDMY7
         rCSR_R_1_RMDMY7 @= { @ "CSR.R.1:RMDMY7 : RMDMY7 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and RMDMY7; 
         } /* end of rule : CSR.R.1:RMDMY7 */
         
         // CSR.R.1 is checked by CSR.R.1:RMDMY8
         rCSR_R_1_RMDMY8 @= { @ "CSR.R.1:RMDMY8 : RMDMY8 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and RMDMY8; 
         } /* end of rule : CSR.R.1:RMDMY8 */
         
         // CSR.R.1 is checked by CSR.R.1:RMDMY9
         rCSR_R_1_RMDMY9 @= { @ "CSR.R.1:RMDMY9 : RMDMY9 is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and RMDMY9; 
         } /* end of rule : CSR.R.1:RMDMY9 */
         
         // CSR.R.1 is checked by CSR.R.1:RMDMYAP
         rCSR_R_1_RMDMYAP @= { @ "CSR.R.1:RMDMYAP : RMDMYAP is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and RMDMYAP; 
         } /* end of rule : CSR.R.1:RMDMYAP */
         
         // CSR.R.1 is checked by CSR.R.1:INDDMY_COIL
         rCSR_R_1_INDDMY_COIL @= { @ "CSR.R.1:INDDMY_COIL : INDDMY_COIL is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and INDDMY_COIL; 
         } /* end of rule : CSR.R.1:INDDMY_COIL */
         
         // CSR.R.1 is checked by CSR.R.1:INDDMY_MD
         rCSR_R_1_INDDMY_MD @= { @ "CSR.R.1:INDDMY_MD : INDDMY_MD is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and INDDMY_MD; 
         } /* end of rule : CSR.R.1:INDDMY_MD */
         
         // CSR.R.1 is checked by CSR.R.1:INDDMY_HD
         rCSR_R_1_INDDMY_HD @= { @ "CSR.R.1:INDDMY_HD : INDDMY_HD is not allowed inside the empty area of chip corner.";
             EMPTY_AREA and INDDMY_HD; 
         } /* end of rule : CSR.R.1:INDDMY_HD */
      #endif /* end of #ifdef FULL_CHIP  */ 
      LMARK_METAL_CSR = LMARK_METAL and CSRDMY;    /* L-mark in CSR */ 
      LMARK_SLOT_CSR = LSLOT and CSRDMY;    /* L shaped oxide in L-mark metal */ 
      gLAYER_1134 = adjacent_edge( LMARK_SLOT_CSR, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      LMARK_MS_CSR = LMARK_METAL_CSR or LMARK_SLOT_CSR; 
      
      // Chip corner stress relief check
      #ifdef WLCSP_SEALRING 
         CSR_ED = adjacent_edge( CSRDMY, angle1 = == 135, angle2 = == 45, length = > 0 ); 
      #else /* the reverse of #ifdef WLCSP_SEALRING  */ 
         CSR_ED = adjacent_edge( CSRDMY, angle1 = == 90, angle2 = == 45, length = > 0 ); 
      #endif /* end of #ifdef WLCSP_SEALRING  */ 
      CSR_EXD = edge_size( CSR_ED, inside = 2 );    /* exclude the Seal Ring part    */ 
      gLAYER_545 = CO and CSRDMY; 
      gLAYER_544 = gLAYER_545 not VIA_EXD; 
      CC_CO = gLAYER_544 not CSR_EXD; 
      CC_M1 = M1 and CSRDMY; 
      gLAYER_547 = VIA1 and CSRDMY; 
      gLAYER_546 = gLAYER_547 not VIA_EXD; 
      CC_V1 = gLAYER_546 not CSR_EXD; 
      gLAYER_548 = size( size( CC_M1, - 0.6, clip_acute = NONE ), 0.6, clip_acute = NONE ); 
      CC_M1_HOLE = donut_holes( gLAYER_548, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      CC_M1_LSLOT = area( CC_M1_HOLE, > 300 ); 
      CC_M1_FENCE_HOLE = area( CC_M1_HOLE, <= 300 ); 
      gLAYER_551 = edge_size( CC_M1_FENCE_HOLE, outside = 2.5 ); 
      gLAYER_550 = CC_M1 not gLAYER_551; 
      gLAYER_549 = not_interacting( gLAYER_550, SEALRING ); 
      CC_M1_FENCE_CROSS = size( size( gLAYER_549, - 0.4, clip_acute = NONE ), 0.4, clip_acute = NONE ); 
      CC_M2 = M2 and CSRDMY; 
      gLAYER_553 = VIA2 and CSRDMY; 
      gLAYER_552 = gLAYER_553 not VIA_EXD; 
      CC_V2 = gLAYER_552 not CSR_EXD; 
      gLAYER_554 = size( size( CC_M2, - 0.6, clip_acute = NONE ), 0.6, clip_acute = NONE ); 
      CC_M2_HOLE = donut_holes( gLAYER_554, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      CC_M2_LSLOT = area( CC_M2_HOLE, > 300 ); 
      CC_M2_FENCE_HOLE = area( CC_M2_HOLE, <= 300 ); 
      gLAYER_557 = edge_size( CC_M2_FENCE_HOLE, outside = 2.5 ); 
      gLAYER_556 = CC_M2 not gLAYER_557; 
      gLAYER_555 = not_interacting( gLAYER_556, SEALRING ); 
      CC_M2_FENCE_CROSS = size( size( gLAYER_555, - 0.4, clip_acute = NONE ), 0.4, clip_acute = NONE ); 
      CC_M3 = M3 and CSRDMY; 
      gLAYER_559 = VIA3 and CSRDMY; 
      gLAYER_558 = gLAYER_559 not VIA_EXD; 
      CC_V3 = gLAYER_558 not CSR_EXD; 
      gLAYER_560 = size( size( CC_M3, - 0.6, clip_acute = NONE ), 0.6, clip_acute = NONE ); 
      CC_M3_HOLE = donut_holes( gLAYER_560, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      CC_M3_LSLOT = area( CC_M3_HOLE, > 300 ); 
      CC_M3_FENCE_HOLE = area( CC_M3_HOLE, <= 300 ); 
      gLAYER_563 = edge_size( CC_M3_FENCE_HOLE, outside = 2.5 ); 
      gLAYER_562 = CC_M3 not gLAYER_563; 
      gLAYER_561 = not_interacting( gLAYER_562, SEALRING ); 
      CC_M3_FENCE_CROSS = size( size( gLAYER_561, - 0.4, clip_acute = NONE ), 0.4, clip_acute = NONE ); 
      CC_M4 = M4 and CSRDMY; 
      gLAYER_565 = VIA4 and CSRDMY; 
      gLAYER_564 = gLAYER_565 not VIA_EXD; 
      CC_V4 = gLAYER_564 not CSR_EXD; 
      gLAYER_566 = size( size( CC_M4, - 0.6, clip_acute = NONE ), 0.6, clip_acute = NONE ); 
      CC_M4_HOLE = donut_holes( gLAYER_566, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      CC_M4_LSLOT = area( CC_M4_HOLE, > 300 ); 
      CC_M4_FENCE_HOLE = area( CC_M4_HOLE, <= 300 ); 
      gLAYER_569 = edge_size( CC_M4_FENCE_HOLE, outside = 2.5 ); 
      gLAYER_568 = CC_M4 not gLAYER_569; 
      gLAYER_567 = not_interacting( gLAYER_568, SEALRING ); 
      CC_M4_FENCE_CROSS = size( size( gLAYER_567, - 0.4, clip_acute = NONE ), 0.4, clip_acute = NONE ); 
      CC_M5 = M5 and CSRDMY; 
      gLAYER_571 = VIA5 and CSRDMY; 
      gLAYER_570 = gLAYER_571 not VIA_EXD; 
      CC_V5 = gLAYER_570 not CSR_EXD; 
      gLAYER_572 = size( size( CC_M5, - 0.6, clip_acute = NONE ), 0.6, clip_acute = NONE ); 
      CC_M5_HOLE = donut_holes( gLAYER_572, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      CC_M5_LSLOT = area( CC_M5_HOLE, > 300 ); 
      CC_M5_FENCE_HOLE = area( CC_M5_HOLE, <= 300 ); 
      gLAYER_575 = edge_size( CC_M5_FENCE_HOLE, outside = 2.5 ); 
      gLAYER_574 = CC_M5 not gLAYER_575; 
      gLAYER_573 = not_interacting( gLAYER_574, SEALRING ); 
      CC_M5_FENCE_CROSS = size( size( gLAYER_573, - 0.4, clip_acute = NONE ), 0.4, clip_acute = NONE ); 
      CC_M6 = M6 and CSRDMY; 
      gLAYER_577 = VIA6 and CSRDMY; 
      gLAYER_576 = gLAYER_577 not VIA_EXD; 
      CC_V6 = gLAYER_576 not CSR_EXD; 
      gLAYER_578 = size( size( CC_M6, - 0.6, clip_acute = NONE ), 0.6, clip_acute = NONE ); 
      CC_M6_HOLE = donut_holes( gLAYER_578, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      CC_M6_LSLOT = area( CC_M6_HOLE, > 300 ); 
      CC_M6_FENCE_HOLE = area( CC_M6_HOLE, <= 300 ); 
      gLAYER_581 = edge_size( CC_M6_FENCE_HOLE, outside = 2.5 ); 
      gLAYER_580 = CC_M6 not gLAYER_581; 
      gLAYER_579 = not_interacting( gLAYER_580, SEALRING ); 
      CC_M6_FENCE_CROSS = size( size( gLAYER_579, - 0.4, clip_acute = NONE ), 0.4, clip_acute = NONE ); 
      CC_M7 = M7 and CSRDMY; 
      gLAYER_583 = VIA7 and CSRDMY; 
      gLAYER_582 = gLAYER_583 not VIA_EXD; 
      CC_V7 = gLAYER_582 not CSR_EXD; 
      gLAYER_584 = size( size( CC_M7, - 0.6, clip_acute = NONE ), 0.6, clip_acute = NONE ); 
      CC_M7_HOLE = donut_holes( gLAYER_584, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      CC_M7_LSLOT = area( CC_M7_HOLE, > 300 ); 
      CC_M7_FENCE_HOLE = area( CC_M7_HOLE, <= 300 ); 
      gLAYER_587 = edge_size( CC_M7_FENCE_HOLE, outside = 2.5 ); 
      gLAYER_586 = CC_M7 not gLAYER_587; 
      gLAYER_585 = not_interacting( gLAYER_586, SEALRING ); 
      CC_M7_FENCE_CROSS = size( size( gLAYER_585, - 0.4, clip_acute = NONE ), 0.4, clip_acute = NONE ); 
      CC_M8 = M8 and CSRDMY; 
      gLAYER_589 = VIA8 and CSRDMY; 
      gLAYER_588 = gLAYER_589 not VIA_EXD; 
      CC_V8 = gLAYER_588 not CSR_EXD; 
      gLAYER_590 = size( size( CC_M8, - 0.6, clip_acute = NONE ), 0.6, clip_acute = NONE ); 
      CC_M8_HOLE = donut_holes( gLAYER_590, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      CC_M8_LSLOT = area( CC_M8_HOLE, > 300 ); 
      CC_M8_FENCE_HOLE = area( CC_M8_HOLE, <= 300 ); 
      gLAYER_593 = edge_size( CC_M8_FENCE_HOLE, outside = 2.5 ); 
      gLAYER_592 = CC_M8 not gLAYER_593; 
      gLAYER_591 = not_interacting( gLAYER_592, SEALRING ); 
      CC_M8_FENCE_CROSS = size( size( gLAYER_591, - 0.4, clip_acute = NONE ), 0.4, clip_acute = NONE ); 
      CC_M9 = M9I and CSRDMY; 
      #ifdef FULL_CHIP 
         
         // CSR.R.2 is checked by CSR.R.2:A
         rCSR_R_2_A @= { @ "CSR.R.2:A : CSR structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD";
             not_interacting( CSRDMY, ODI ); 
             not_interacting( CSRDMY, PPI ); 
             not_interacting( CSRDMY, M1X ); 
             not_interacting( CSRDMY, M2X ); 
             not_interacting( CSRDMY, M3X ); 
             not_interacting( CSRDMY, M4X ); 
             not_interacting( CSRDMY, M5X ); 
             not_interacting( CSRDMY, M6X ); 
             not_interacting( CSRDMY, M7X ); 
             not_interacting( CSRDMY, M8X ); 
             not_interacting( CSRDMY, M9X ); 
             not_enclosing( CSRDMY, COI ); 
             not_enclosing( CSRDMY, VIA1I ); 
             not_enclosing( CSRDMY, VIA2I ); 
             not_enclosing( CSRDMY, VIA3I ); 
             not_enclosing( CSRDMY, VIA4I ); 
             not_enclosing( CSRDMY, VIA5I ); 
             not_enclosing( CSRDMY, VIA6I ); 
             not_enclosing( CSRDMY, VIA7I ); 
             not_enclosing( CSRDMY, VIA8I ); 
         } /* end of rule : CSR.R.2:A */
         
         // CSR.R.2 is checked by CSR.R.2:B
         rCSR_R_2_B @= { @ "CSR.R.2:B : M1~M8 must be stacked and coincident the edge.";
             CC_M1 xor CC_M2; 
             CC_M2 xor CC_M3; 
             CC_M3 xor CC_M4; 
             CC_M4 xor CC_M5; 
             CC_M5 xor CC_M6; 
             CC_M6 xor CC_M7; 
             CC_M7 xor CC_M8; 
         } /* end of rule : CSR.R.2:B */
         
         // CSR.R.2 is checked by CSR.R.2:C
         rCSR_R_2_C @= { @ "CSR.R.2:C : CSR structure must be covered with CSRDMY";
             not_interacting( SR_EDGE, CSRDMY ); 
         } /* end of rule : CSR.R.2:C */
         
         // CSR.R.2 is checked by CSR.R.2:D
         rCSR_R_2_D @= { @ "CSR.R.2:D : M1~M8 fence metal width & space = " + CSR_R_2 + " um"; 
             not_rectangles( CC_M1_FENCE_HOLE, orientation = ORTHOGONAL, sides = { == CSR_R_2, == CSR_R_2 } ); 
             not_rectangles( CC_M1_FENCE_CROSS, orientation = ORTHOGONAL, sides = { == CSR_R_2, == CSR_R_2 } ); 
             not_rectangles( CC_M2_FENCE_HOLE, orientation = ORTHOGONAL, sides = { == CSR_R_2, == CSR_R_2 } ); 
             not_rectangles( CC_M2_FENCE_CROSS, orientation = ORTHOGONAL, sides = { == CSR_R_2, == CSR_R_2 } ); 
             not_rectangles( CC_M3_FENCE_HOLE, orientation = ORTHOGONAL, sides = { == CSR_R_2, == CSR_R_2 } ); 
             not_rectangles( CC_M3_FENCE_CROSS, orientation = ORTHOGONAL, sides = { == CSR_R_2, == CSR_R_2 } ); 
             not_rectangles( CC_M4_FENCE_HOLE, orientation = ORTHOGONAL, sides = { == CSR_R_2, == CSR_R_2 } ); 
             not_rectangles( CC_M4_FENCE_CROSS, orientation = ORTHOGONAL, sides = { == CSR_R_2, == CSR_R_2 } ); 
             not_rectangles( CC_M5_FENCE_HOLE, orientation = ORTHOGONAL, sides = { == CSR_R_2, == CSR_R_2 } ); 
             not_rectangles( CC_M5_FENCE_CROSS, orientation = ORTHOGONAL, sides = { == CSR_R_2, == CSR_R_2 } ); 
             not_rectangles( CC_M6_FENCE_HOLE, orientation = ORTHOGONAL, sides = { == CSR_R_2, == CSR_R_2 } ); 
             not_rectangles( CC_M6_FENCE_CROSS, orientation = ORTHOGONAL, sides = { == CSR_R_2, == CSR_R_2 } ); 
             not_rectangles( CC_M7_FENCE_HOLE, orientation = ORTHOGONAL, sides = { == CSR_R_2, == CSR_R_2 } ); 
             not_rectangles( CC_M7_FENCE_CROSS, orientation = ORTHOGONAL, sides = { == CSR_R_2, == CSR_R_2 } ); 
             not_rectangles( CC_M8_FENCE_HOLE, orientation = ORTHOGONAL, sides = { == CSR_R_2, == CSR_R_2 } ); 
             not_rectangles( CC_M8_FENCE_CROSS, orientation = ORTHOGONAL, sides = { == CSR_R_2, == CSR_R_2 } ); 
         } /* end of rule : CSR.R.2:D */
         
         // CSR.R.2 is checked by CSR.R.2:E
         rCSR_R_2_E @= { @ "CSR.R.2:E : The CSR pattern must be covered by solid L-mark Metal.";
             CC_M8_FENCE_HOLE not LMARK_METAL_CSR; 
         } /* end of rule : CSR.R.2:E */
         
         // CSR.R.2 is checked by CSR.R.2:F
         rCSR_R_2_F @= { @ "CSR.R.2:F : The L-slot can't overlap AP or PO";
             LMARK_SLOT_CSR and API; 
             LMARK_SLOT_CSR and POI; 
         } /* end of rule : CSR.R.2:F */
         rCSR_S_1 @= { @ "CSR.S.1 : CO space >= " + CSR_S_1 + " um"; 
             external1( CC_CO, < CSR_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
         } /* end of rule : CSR.S.1 */
         rCSR_EN_1 @= { @ "CSR.EN.1 : CO enclosure by M1[crossing area] >= " + CSR_EN_1 + " um"; 
             enclose( CC_CO, CC_M1_FENCE_CROSS, < CSR_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
         } /* end of rule : CSR.EN.1 */
         rCSR_S_2 @= { @ "CSR.S.2 : VIAx space at the same level >= " + CSR_S_2 + " um"; 
             external1( CC_V1, < CSR_S_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
             external1( CC_V2, < CSR_S_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
             external1( CC_V3, < CSR_S_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
             external1( CC_V4, < CSR_S_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
             external1( CC_V5, < CSR_S_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
             external1( CC_V6, < CSR_S_2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
         } /* end of rule : CSR.S.2 */
         rCSR_EN_2 @= { @ "CSR.EN.2 : VIAx enclosure by metal[crossing area] >= " + CSR_EN_2 + " um"; 
             enclose( CC_V1, CC_M1_FENCE_CROSS, < CSR_EN_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
             cutting( CC_V1, CC_M1_FENCE_CROSS ); 
             enclose( CC_V2, CC_M2_FENCE_CROSS, < CSR_EN_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
             cutting( CC_V2, CC_M2_FENCE_CROSS ); 
             enclose( CC_V3, CC_M3_FENCE_CROSS, < CSR_EN_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
             cutting( CC_V3, CC_M3_FENCE_CROSS ); 
             enclose( CC_V4, CC_M4_FENCE_CROSS, < CSR_EN_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
             cutting( CC_V4, CC_M4_FENCE_CROSS ); 
             enclose( CC_V5, CC_M5_FENCE_CROSS, < CSR_EN_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
             cutting( CC_V5, CC_M5_FENCE_CROSS ); 
             enclose( CC_V6, CC_M6_FENCE_CROSS, < CSR_EN_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
             cutting( CC_V6, CC_M6_FENCE_CROSS ); 
         } /* end of rule : CSR.EN.2 */
         
         // CSR.S.3 is not necessary to check; My is not offered in this deck
         // CSR.EN.3 is not necessary to check; My is not offered in this deck
         rCSR_S_4 @= { @ "CSR.S.4 : VIAz space >= " + CSR_S_4 + " um"; 
             external1( CC_V7, < CSR_S_4, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
             external1( CC_V8, < CSR_S_4, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
         } /* end of rule : CSR.S.4 */
         rCSR_EN_4 @= { @ "CSR.EN.4 : VIAz enclosure by metal[crossing area] >= " + CSR_EN_4 + " um"; 
             enclose( CC_V7, CC_M7_FENCE_CROSS, < CSR_EN_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
             cutting( CC_V7, CC_M7_FENCE_CROSS ); 
             enclose( CC_V8, CC_M8_FENCE_CROSS, < CSR_EN_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
             cutting( CC_V8, CC_M8_FENCE_CROSS ); 
         } /* end of rule : CSR.EN.4 */
         
         // CSR.S.5 is not necessary to check; Mr is not offered in this deck
         // CSR.EN.9 is not necessary to check; Mr is not offered in this deck
         
         // CSR.R.3 is checked by CSR.R.3:CO
         rCSR_R_3_CO @= { @ "CSR.R.3:CO : CO number at M1 crossing area = " + CSR_R_3_X + " um"; 
             interacting( CC_M1_FENCE_CROSS, CO, < dtoi(CSR_R_3_X) ); 
             interacting( CC_M1_FENCE_CROSS, CO, > dtoi(CSR_R_3_X) ); 
             not_interacting( CC_M1_FENCE_CROSS, CO ); 
         } /* end of rule : CSR.R.3:CO */
         
         // CSR.R.3 is checked by CSR.R.3:VIA1
         rCSR_R_3_VIA1 @= { @ "CSR.R.3:VIA1 : VIA1 number at M1 crossing area = " + CSR_R_3_X + " um"; 
             interacting( CC_M1_FENCE_CROSS, VIA1, < dtoi(CSR_R_3_X) ); 
             interacting( CC_M1_FENCE_CROSS, VIA1, > dtoi(CSR_R_3_X) ); 
             not_interacting( CC_M1_FENCE_CROSS, VIA1 ); 
         } /* end of rule : CSR.R.3:VIA1 */
         
         // CSR.R.3 is checked by CSR.R.3:VIA2
         rCSR_R_3_VIA2 @= { @ "CSR.R.3:VIA2 : VIA2 number at M2 crossing area = " + CSR_R_3_X + " um"; 
             interacting( CC_M2_FENCE_CROSS, VIA2, < dtoi(CSR_R_3_X) ); 
             interacting( CC_M2_FENCE_CROSS, VIA2, > dtoi(CSR_R_3_X) ); 
             not_interacting( CC_M2_FENCE_CROSS, VIA2 ); 
         } /* end of rule : CSR.R.3:VIA2 */
         
         // CSR.R.3 is checked by CSR.R.3:VIA3
         rCSR_R_3_VIA3 @= { @ "CSR.R.3:VIA3 : VIA3 number at M3 crossing area = " + CSR_R_3_X + " um"; 
             interacting( CC_M3_FENCE_CROSS, VIA3, < dtoi(CSR_R_3_X) ); 
             interacting( CC_M3_FENCE_CROSS, VIA3, > dtoi(CSR_R_3_X) ); 
             not_interacting( CC_M3_FENCE_CROSS, VIA3 ); 
         } /* end of rule : CSR.R.3:VIA3 */
         
         // CSR.R.3 is checked by CSR.R.3:VIA4
         rCSR_R_3_VIA4 @= { @ "CSR.R.3:VIA4 : VIA4 number at M4 crossing area = " + CSR_R_3_X + " um"; 
             interacting( CC_M4_FENCE_CROSS, VIA4, < dtoi(CSR_R_3_X) ); 
             interacting( CC_M4_FENCE_CROSS, VIA4, > dtoi(CSR_R_3_X) ); 
             not_interacting( CC_M4_FENCE_CROSS, VIA4 ); 
         } /* end of rule : CSR.R.3:VIA4 */
         
         // CSR.R.3 is checked by CSR.R.3:VIA5
         rCSR_R_3_VIA5 @= { @ "CSR.R.3:VIA5 : VIA5 number at M5 crossing area = " + CSR_R_3_X + " um"; 
             interacting( CC_M5_FENCE_CROSS, VIA5, < dtoi(CSR_R_3_X) ); 
             interacting( CC_M5_FENCE_CROSS, VIA5, > dtoi(CSR_R_3_X) ); 
             not_interacting( CC_M5_FENCE_CROSS, VIA5 ); 
         } /* end of rule : CSR.R.3:VIA5 */
         
         // CSR.R.3 is checked by CSR.R.3:VIA6
         rCSR_R_3_VIA6 @= { @ "CSR.R.3:VIA6 : VIA6 number at M6 crossing area = " + CSR_R_3_X + " um"; 
             interacting( CC_M6_FENCE_CROSS, VIA6, < dtoi(CSR_R_3_X) ); 
             interacting( CC_M6_FENCE_CROSS, VIA6, > dtoi(CSR_R_3_X) ); 
             not_interacting( CC_M6_FENCE_CROSS, VIA6 ); 
         } /* end of rule : CSR.R.3:VIA6 */
         
         // CSR.R.3 is checked by CSR.R.3:VIA7
         rCSR_R_3_VIA7 @= { @ "CSR.R.3:VIA7 : VIA7 number at M7 crossing area = " + CSR_R_3_Z + " um"; 
             interacting( CC_M7_FENCE_CROSS, VIA7, < dtoi(CSR_R_3_Z) ); 
             interacting( CC_M7_FENCE_CROSS, VIA7, > dtoi(CSR_R_3_Z) ); 
             not_interacting( CC_M7_FENCE_CROSS, VIA7 ); 
         } /* end of rule : CSR.R.3:VIA7 */
         
         // CSR.R.3 is checked by CSR.R.3:VIA8
         rCSR_R_3_VIA8 @= { @ "CSR.R.3:VIA8 : VIA8 number at M8 crossing area = " + CSR_R_3_Z + " um"; 
             interacting( CC_M8_FENCE_CROSS, VIA8, < dtoi(CSR_R_3_Z) ); 
             interacting( CC_M8_FENCE_CROSS, VIA8, > dtoi(CSR_R_3_Z) ); 
             not_interacting( CC_M8_FENCE_CROSS, VIA8 ); 
         } /* end of rule : CSR.R.3:VIA8 */
         rCSR_W_1 @= { @ "CSR.W.1 : Width of L-slot = " + CSR_W_1 + " um"; 
             size( size( LMARK_SLOT_CSR, - ( CSR_W_1 / 2 ), clip_acute = NONE ), CSR_W_1 / 2, clip_acute = NONE ); 
             internal1( LMARK_SLOT_CSR, < CSR_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orthogonal = BOTH ); 
         } /* end of rule : CSR.W.1 */
         rCSR_W_2 @= { @ "CSR.W.2 : Width of 45 degree corner of L-slot, >= " + CSR_W_2_1 + " um <= " + CSR_W_2_2 + " um"; 
             X = angle_edge( LMARK_SLOT_CSR, == 45 ); 
             Y = edge_size( X, inside = CSR_W_2_2 + GRID ); 
             Y outside LMARK_METAL_CSR; 
             internal1( LMARK_SLOT_CSR, < CSR_W_2_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, orthogonal = NEITHER ); 
         } /* end of rule : CSR.W.2 */
         
         // CSR.W.3 is checked by related rules (CO.W.2/VIAx.W.2/VIAy.W.2/VIAz.W.2/VIAr.W.2)
         rCSR_L_1 @= { @ "CSR.L.1 : Length of L-slot, >= " + CSR_L_1_1 + " um <= " + CSR_L_1_2 + " um"; 
             not_contains( LMARK_SLOT_CSR, { 10, CSR_L_1_1 }, FORTY_FIVE ); 
             contains( LMARK_SLOT_CSR, { 10, CSR_L_1_2 + GRID }, FORTY_FIVE ); 
         } /* end of rule : CSR.L.1 */
         #ifdef WLCSP_SEALRING 
            rCSR_EN_5_1 @= { @ "CSR.EN.5.1 : L-mark metal in CSR enclosure of L-slot [in the direction of L-slot length] >= " + CSR_EN_5_1 + " um <= " + CSR_EN_5_2 + " um"; 
                X = copy_edge( gLAYER_1134, ancestry = true ); 
                enclose( X, LMARK_MS_CSR, < CSR_EN_5_1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.004 ); 
                enclose( X, LMARK_MS_CSR, ( CSR_EN_5_2, 100 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.004 ); 
            } /* end of rule : CSR.EN.5.1 */
         #else /* the reverse of #ifdef WLCSP_SEALRING  */ 
            rCSR_EN_5 @= { @ "CSR.EN.5 : L-mark metal in CSR enclosure of L-slot [in the direction of L-slot length] >= " + CSR_EN_5_1 + " um <= " + CSR_EN_5_2 + " um"; 
                X = copy_edge( gLAYER_1134, ancestry = true ); 
                enclose( X, LMARK_MS_CSR, < CSR_EN_5_1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.004 ); 
                enclose( X, LMARK_MS_CSR, ( CSR_EN_5_2, 100 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.004 ); 
            } /* end of rule : CSR.EN.5 */
         #endif /* end of #ifdef WLCSP_SEALRING  */ 
         #ifdef WLCSP_SEALRING 
            gLAYER_594 = layer_extent( M9 ); 
            TM_SR_EXT = interacting( gLAYER_594, CSRDMY ); 
            TM_SR_CORNER_A = vertex( TM_SR_EXT, angles = { 90 }, shape = TRIANGLE, shape_size = CSR_EN_6_1_L1 ); 
            TM_SR_CORNER_B = vertex( TM_SR_EXT, angles = { 90 }, shape = TRIANGLE, shape_size = CSR_EN_6_1_L2 ); 
            gLAYER_595 = layer_extent( API ); 
            AP_SR_EXT = interacting( gLAYER_595, CSRDMY ); 
            TM_SR_CORNER_C = vertex( AP_SR_EXT, angles = { 90 }, shape = TRIANGLE, shape_size = CSR_EN_6_2_L1 ); 
            TM_SR_CORNER_D = vertex( AP_SR_EXT, angles = { 90 }, shape = TRIANGLE, shape_size = CSR_EN_6_2_L2 ); 
            
            //CSR.EN.10.1 is checked by CSR.EN.6.1:M1i
            //CSR.EN.6.1 is checked by CSR.EN.6.1:M1i
            rCSR_EN_6_1_M1I @= { @ "CSR.EN.6.1:M1i : An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.";
                TM_SR_CORNER_A and M1I; 
                not_interacting( TM_SR_CORNER_B, M1I ); 
            } /* end of rule : CSR.EN.6.1:M1i */
            
            //CSR.EN.10.1 is checked by CSR.EN.6.1:M2i
            //CSR.EN.6.1 is checked by CSR.EN.6.1:M2i
            rCSR_EN_6_1_M2I @= { @ "CSR.EN.6.1:M2i : An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.";
                TM_SR_CORNER_A and M2I; 
                not_interacting( TM_SR_CORNER_B, M2I ); 
            } /* end of rule : CSR.EN.6.1:M2i */
            
            //CSR.EN.10.1 is checked by CSR.EN.6.1:M3i
            //CSR.EN.6.1 is checked by CSR.EN.6.1:M3i
            rCSR_EN_6_1_M3I @= { @ "CSR.EN.6.1:M3i : An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.";
                TM_SR_CORNER_A and M3I; 
                not_interacting( TM_SR_CORNER_B, M3I ); 
            } /* end of rule : CSR.EN.6.1:M3i */
            
            //CSR.EN.10.1 is checked by CSR.EN.6.1:M4i
            //CSR.EN.6.1 is checked by CSR.EN.6.1:M4i
            rCSR_EN_6_1_M4I @= { @ "CSR.EN.6.1:M4i : An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.";
                TM_SR_CORNER_A and M4I; 
                not_interacting( TM_SR_CORNER_B, M4I ); 
            } /* end of rule : CSR.EN.6.1:M4i */
            
            //CSR.EN.10.1 is checked by CSR.EN.6.1:M5i
            //CSR.EN.6.1 is checked by CSR.EN.6.1:M5i
            rCSR_EN_6_1_M5I @= { @ "CSR.EN.6.1:M5i : An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.";
                TM_SR_CORNER_A and M5I; 
                not_interacting( TM_SR_CORNER_B, M5I ); 
            } /* end of rule : CSR.EN.6.1:M5i */
            
            //CSR.EN.10.1 is checked by CSR.EN.6.1:M6i
            //CSR.EN.6.1 is checked by CSR.EN.6.1:M6i
            rCSR_EN_6_1_M6I @= { @ "CSR.EN.6.1:M6i : An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.";
                TM_SR_CORNER_A and M6I; 
                not_interacting( TM_SR_CORNER_B, M6I ); 
            } /* end of rule : CSR.EN.6.1:M6i */
            
            //CSR.EN.10.1 is checked by CSR.EN.6.1:M7i
            //CSR.EN.6.1 is checked by CSR.EN.6.1:M7i
            rCSR_EN_6_1_M7I @= { @ "CSR.EN.6.1:M7i : An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.";
                TM_SR_CORNER_A and M7I; 
                not_interacting( TM_SR_CORNER_B, M7I ); 
            } /* end of rule : CSR.EN.6.1:M7i */
            
            //CSR.EN.10.1 is checked by CSR.EN.6.1:M8i
            //CSR.EN.6.1 is checked by CSR.EN.6.1:M8i
            rCSR_EN_6_1_M8I @= { @ "CSR.EN.6.1:M8i : An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.";
                TM_SR_CORNER_A and M8I; 
                not_interacting( TM_SR_CORNER_B, M8I ); 
            } /* end of rule : CSR.EN.6.1:M8i */
            
            //CSR.EN.10.1 is checked by CSR.EN.6.1:M9i
            //CSR.EN.6.1 is checked by CSR.EN.6.1:M9i
            rCSR_EN_6_1_M9I @= { @ "CSR.EN.6.1:M9i : An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.";
                TM_SR_CORNER_A and M9I; 
                not_interacting( TM_SR_CORNER_B, M9I ); 
            } /* end of rule : CSR.EN.6.1:M9i */
            
            //CSR.EN.10.2 is checked by CSR.EN.6.2:APi
            rCSR_EN_6_2_API @= { @ "CSR.EN.6.2:APi : An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.";
                TM_SR_CORNER_C and API; 
                not_interacting( TM_SR_CORNER_D, API ); 
            } /* end of rule : CSR.EN.6.2:APi */
         #else /* the reverse of #ifdef WLCSP_SEALRING  */ 
            
            //CSR.EN.10 is checked by CSR.EN.6
            rCSR_EN_6 @= { @ "CSR.EN.6 : L-mark metal in CSR enclosure of L-slot "
                                        "[perpendicular to the direction of the L-slot length] >= " + CSR_EN_6_A + " um <= " + CSR_EN_6_B + " um"; 
                X = adjacent_edge( LMARK_SLOT_CSR, angle1 = == 90, angle2 = == 225, length = > 0 ); 
                enclose( X, LMARK_MS_CSR, < CSR_EN_6_A, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.004 ); 
                enclose( X, LMARK_MS_CSR, ( CSR_EN_6_B, 100 ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.004 ); 
            } /* end of rule : CSR.EN.6 */
         #endif /* end of #ifdef WLCSP_SEALRING  */ 
         
         // CSR.EN.7 is checked by CSR.EN.7:VIA1
         rCSR_EN_7_VIA1 @= { @ "CSR.EN.7:VIA1 : Metal enclosure of VIA1 around L-slot >= " + CSR_EN_7_X + " um"; 
             external2( CC_M1_LSLOT, SR_VIA1, < CSR_EN_7_X, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
             CC_M1_LSLOT and SR_VIA1; 
         } /* end of rule : CSR.EN.7:VIA1 */
         
         // CSR.EN.7 is checked by CSR.EN.7:VIA2
         rCSR_EN_7_VIA2 @= { @ "CSR.EN.7:VIA2 : Metal enclosure of VIA2 around L-slot >= " + CSR_EN_7_X + " um"; 
             external2( CC_M2_LSLOT, SR_VIA2, < CSR_EN_7_X, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
             CC_M2_LSLOT and SR_VIA2; 
         } /* end of rule : CSR.EN.7:VIA2 */
         
         // CSR.EN.7 is checked by CSR.EN.7:VIA3
         rCSR_EN_7_VIA3 @= { @ "CSR.EN.7:VIA3 : Metal enclosure of VIA3 around L-slot >= " + CSR_EN_7_X + " um"; 
             external2( CC_M3_LSLOT, SR_VIA3, < CSR_EN_7_X, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
             CC_M3_LSLOT and SR_VIA3; 
         } /* end of rule : CSR.EN.7:VIA3 */
         
         // CSR.EN.7 is checked by CSR.EN.7:VIA4
         rCSR_EN_7_VIA4 @= { @ "CSR.EN.7:VIA4 : Metal enclosure of VIA4 around L-slot >= " + CSR_EN_7_X + " um"; 
             external2( CC_M4_LSLOT, SR_VIA4, < CSR_EN_7_X, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
             CC_M4_LSLOT and SR_VIA4; 
         } /* end of rule : CSR.EN.7:VIA4 */
         
         // CSR.EN.7 is checked by CSR.EN.7:VIA5
         rCSR_EN_7_VIA5 @= { @ "CSR.EN.7:VIA5 : Metal enclosure of VIA5 around L-slot >= " + CSR_EN_7_X + " um"; 
             external2( CC_M5_LSLOT, SR_VIA5, < CSR_EN_7_X, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
             CC_M5_LSLOT and SR_VIA5; 
         } /* end of rule : CSR.EN.7:VIA5 */
         
         // CSR.EN.7 is checked by CSR.EN.7:VIA6
         rCSR_EN_7_VIA6 @= { @ "CSR.EN.7:VIA6 : Metal enclosure of VIA6 around L-slot >= " + CSR_EN_7_X + " um"; 
             external2( CC_M6_LSLOT, SR_VIA6, < CSR_EN_7_X, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
             CC_M6_LSLOT and SR_VIA6; 
         } /* end of rule : CSR.EN.7:VIA6 */
         
         // CSR.EN.7 is checked by CSR.EN.7:VIA7
         rCSR_EN_7_VIA7 @= { @ "CSR.EN.7:VIA7 : Metal enclosure of VIA7 around L-slot >= " + CSR_EN_7_Z + " um"; 
             external2( CC_M7_LSLOT, SR_VIA7, < CSR_EN_7_Z, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
             CC_M7_LSLOT and SR_VIA7; 
         } /* end of rule : CSR.EN.7:VIA7 */
         
         // CSR.EN.7 is checked by CSR.EN.7:VIA8
         rCSR_EN_7_VIA8 @= { @ "CSR.EN.7:VIA8 : Metal enclosure of VIA8 around L-slot >= " + CSR_EN_7_Z + " um"; 
             external2( CC_M8_LSLOT, SR_VIA8, < CSR_EN_7_Z, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
             CC_M8_LSLOT and SR_VIA8; 
         } /* end of rule : CSR.EN.7:VIA8 */
         rCSR_EN_8 @= { @ "CSR.EN.8 : Metal enclosure by L-mark metal in CSR around L-slot >= " + CSR_EN_8 + " um"; 
             external2( LMARK_SLOT_CSR, M1I, < CSR_EN_8, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
             LMARK_SLOT_CSR and M1I; 
             external2( LMARK_SLOT_CSR, M2I, < CSR_EN_8, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
             LMARK_SLOT_CSR and M2I; 
             external2( LMARK_SLOT_CSR, M3I, < CSR_EN_8, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
             LMARK_SLOT_CSR and M3I; 
             external2( LMARK_SLOT_CSR, M4I, < CSR_EN_8, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
             LMARK_SLOT_CSR and M4I; 
             external2( LMARK_SLOT_CSR, M5I, < CSR_EN_8, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
             LMARK_SLOT_CSR and M5I; 
             external2( LMARK_SLOT_CSR, M6I, < CSR_EN_8, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
             LMARK_SLOT_CSR and M6I; 
             external2( LMARK_SLOT_CSR, M7I, < CSR_EN_8, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
             LMARK_SLOT_CSR and M7I; 
             external2( LMARK_SLOT_CSR, M8I, < CSR_EN_8, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
             LMARK_SLOT_CSR and M8I; 
         } /* end of rule : CSR.EN.8 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      
      // Seal-Ring Rule Check
      //=====================
      gLAYER_597 = M1I and SR_RING; 
      gLAYER_596 = interacting( gLAYER_597, SEALRING ); 
      ASSH = donut_holes( gLAYER_596, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      ASS = size( size( ASSH, - SR_S_1, clip_acute = NONE ), SR_S_1, clip_acute = NONE );    /* remove un-wanted hole in corner */ 
      CORR = size( ASS, clip_acute = NONE, distance = - SR_S_1 );    /* core region  */ 
      ISOR = ASS not CORR;               /* assembly isolation region */ 
      #ifdef FULL_CHIP 
         #ifdef WLCSP_SEALRING 
            rSR_S_1 @= { @ "SR.S.1 : Width of Assembly isolation >= " + SR_S_1 + " um, Only M1~Mtop, AP, CB, CBD, RV and CDU allowed in assembly isolation region " 
                                    "1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring "
                                    "2. Connect circuit to sealring through AP, it is only allowed connecting to the most inner sealring (AP overlap with CB2 is not allowed)";
                ISOR and DNWI; 
                ISOR and NWI; 
                sLAYER_1023 = ISOR and POI; 
                sLAYER_1023 not_inside CDUDMY; 
                ISOR and DPO; 
                sLAYER_1024 = ISOR and ODI; 
                sLAYER_1024 not_inside CDUDMY; 
                ISOR and DOD; 
                ISOR and CBMI; 
                ISOR and CTMI; 
                sLAYER_1025 = ISOR and COI; 
                sLAYER_1025 not_inside CDUDMY; 
                ISOR and VIA1I; 
                ISOR and VIA2I; 
                ISOR and VIA3I; 
                ISOR and VIA4I; 
                ISOR and VIA5I; 
                ISOR and VIA6I; 
                ISOR and VIA7I; 
                ISOR and VIA8I; 
                ISOR and UBMI; 
            } /* end of rule : SR.S.1 */
            rSR_S_1_CB @= { @ "SR.S.1:CB : Width of Assembly isolation >= " + SR_S_1 + " um, Only M1~Mtop, AP, CB, CBD, RV and CDU allowed in assembly isolation region " 
                                          "1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring";
                sLAYER_1027 = not_interacting( CBI, SEALRING ); 
                sLAYER_1026 = sLAYER_1027 not_inside CDUDMY; 
                sLAYER_1026 and ISOR; 
            } /* end of rule : SR.S.1:CB */
            rSR_S_1_CBD @= { @ "SR.S.1:CBD : Width of Assembly isolation >= " + SR_S_1 + " um, Only M1~Mtop, AP, CB, CBD, RV  and CDU allowed in assembly isolation region " 
                                            "1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring";
                sLAYER_1029 = not_interacting( CBDI, SEALRING ); 
                sLAYER_1028 = sLAYER_1029 not_inside CDUDMY; 
                sLAYER_1028 and ISOR; 
            } /* end of rule : SR.S.1:CBD */
            rSR_S_1_RV @= { @ "SR.S.1:RV : Width of Assembly isolation >= " + SR_S_1 + " um, Only M1~Mtop, AP, CB, CBD, RV  and CDU allowed in assembly isolation region " 
                                          "1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring";
                sLAYER_1031 = not_interacting( RVI, SEALRING ); 
                sLAYER_1030 = sLAYER_1031 not_inside CDUDMY; 
                sLAYER_1030 and ISOR; 
            } /* end of rule : SR.S.1:RV */
         #else /* the reverse of #ifdef WLCSP_SEALRING  */ 
            rSR_S_1 @= { @ "SR.S.1 : Width of Assembly isolation >= " + SR_S_1 + " um, Only M1~Mtop and CDU allowed in assembly isolation region " 
                                    "1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring "
                                    "2. Connect circuit to sealring through AP, it is only allowed connecting to the most inner sealring (AP overlap with CB2 is not allowed)";
                ISOR and DNWI; 
                ISOR and NWI; 
                sLAYER_1032 = ISOR and POI; 
                sLAYER_1032 not_inside CDUDMY; 
                ISOR and DPO; 
                sLAYER_1033 = ISOR and ODI; 
                sLAYER_1033 not_inside CDUDMY; 
                ISOR and DOD; 
                ISOR and CBMI; 
                ISOR and CTMI; 
                sLAYER_1034 = ISOR and COI; 
                sLAYER_1034 not_inside CDUDMY; 
                ISOR and VIA1I; 
                ISOR and VIA2I; 
                ISOR and VIA3I; 
                ISOR and VIA4I; 
                ISOR and VIA5I; 
                ISOR and VIA6I; 
                ISOR and VIA7I; 
                ISOR and VIA8I; 
                ISOR and UBMI; 
                ISOR and CBDI; 
                ISOR and CBI; 
                ISOR and CB2I; 
            } /* end of rule : SR.S.1 */
         #endif /* end of #ifdef WLCSP_SEALRING  */ 
         rSR_S_1_M1 @= { @ "SR.S.1:M1 : Width of Assembly isolation >= " + SR_S_1 + " um, Only M1~Mtop, AP, CB, CBD, RV and CDU allowed in assembly isolation region " 
                                       "1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring";
             sLAYER_1036 = not_interacting( M1I, SEALRING ); 
             sLAYER_1035 = sLAYER_1036 not_inside CDUDMY; 
             sLAYER_1035 and ISOR; 
             DUM1 and ISOR; 
         } /* end of rule : SR.S.1:M1 */
         rSR_S_1_M2 @= { @ "SR.S.1:M2 : Width of Assembly isolation >= " + SR_S_1 + " um, Only M1~Mtop, AP, CB, CBD, RV and CDU allowed in assembly isolation region " 
                                       "1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring";
             sLAYER_1038 = not_interacting( M2I, SEALRING ); 
             sLAYER_1037 = sLAYER_1038 not_inside CDUDMY; 
             sLAYER_1037 and ISOR; 
             DUM2 and ISOR; 
         } /* end of rule : SR.S.1:M2 */
         rSR_S_1_M3 @= { @ "SR.S.1:M3 : Width of Assembly isolation >= " + SR_S_1 + " um, Only M1~Mtop, AP, CB, CBD, RV and CDU allowed in assembly isolation region " 
                                       "1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring";
             sLAYER_1040 = not_interacting( M3I, SEALRING ); 
             sLAYER_1039 = sLAYER_1040 not_inside CDUDMY; 
             sLAYER_1039 and ISOR; 
             DUM3 and ISOR; 
         } /* end of rule : SR.S.1:M3 */
         rSR_S_1_M4 @= { @ "SR.S.1:M4 : Width of Assembly isolation >= " + SR_S_1 + " um, Only M1~Mtop, AP, CB, CBD, RV and CDU allowed in assembly isolation region " 
                                       "1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring";
             sLAYER_1042 = not_interacting( M4I, SEALRING ); 
             sLAYER_1041 = sLAYER_1042 not_inside CDUDMY; 
             sLAYER_1041 and ISOR; 
             DUM4 and ISOR; 
         } /* end of rule : SR.S.1:M4 */
         rSR_S_1_M5 @= { @ "SR.S.1:M5 : Width of Assembly isolation >= " + SR_S_1 + " um, Only M1~Mtop, AP, CB, CBD, RV and CDU allowed in assembly isolation region " 
                                       "1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring";
             sLAYER_1044 = not_interacting( M5I, SEALRING ); 
             sLAYER_1043 = sLAYER_1044 not_inside CDUDMY; 
             sLAYER_1043 and ISOR; 
             DUM5 and ISOR; 
         } /* end of rule : SR.S.1:M5 */
         rSR_S_1_M6 @= { @ "SR.S.1:M6 : Width of Assembly isolation >= " + SR_S_1 + " um, Only M1~Mtop, AP, CB, CBD, RV and CDU allowed in assembly isolation region " 
                                       "1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring";
             sLAYER_1046 = not_interacting( M6I, SEALRING ); 
             sLAYER_1045 = sLAYER_1046 not_inside CDUDMY; 
             sLAYER_1045 and ISOR; 
             DUM6 and ISOR; 
         } /* end of rule : SR.S.1:M6 */
         rSR_S_1_M7 @= { @ "SR.S.1:M7 : Width of Assembly isolation >= " + SR_S_1 + " um, Only M1~Mtop, AP, CB, CBD, RV and CDU allowed in assembly isolation region " 
                                       "1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring";
             sLAYER_1048 = not_interacting( M7I, SEALRING ); 
             sLAYER_1047 = sLAYER_1048 not_inside CDUDMY; 
             sLAYER_1047 and ISOR; 
             DUM7 and ISOR; 
         } /* end of rule : SR.S.1:M7 */
         rSR_S_1_M8 @= { @ "SR.S.1:M8 : Width of Assembly isolation >= " + SR_S_1 + " um, Only M1~Mtop, AP, CB, CBD, RV and CDU allowed in assembly isolation region " 
                                       "1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring";
             sLAYER_1050 = not_interacting( M8I, SEALRING ); 
             sLAYER_1049 = sLAYER_1050 not_inside CDUDMY; 
             sLAYER_1049 and ISOR; 
             DUM8 and ISOR; 
         } /* end of rule : SR.S.1:M8 */
         rSR_S_1_M9 @= { @ "SR.S.1:M9 : Width of Assembly isolation >= " + SR_S_1 + " um, Only M1~Mtop, AP, CB, CBD, RV and CDU allowed in assembly isolation region " 
                                       "1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring";
             sLAYER_1052 = not_interacting( M9I, SEALRING ); 
             sLAYER_1051 = sLAYER_1052 not_inside CDUDMY; 
             sLAYER_1051 and ISOR; 
             DUM9 and ISOR; 
         } /* end of rule : SR.S.1:M9 */
         #ifdef WLCSP_SEALRING 
            rSR_S_1_AP @= { @ "SR.S.1:AP : Width of Assembly isolation >= " + SR_S_1 + " um, Only M1~Mtop and CDU allowed in assembly isolation region " 
                                          "2. Connect circuit to sealring through AP, it is only allowed connecting to the most inner sealring (AP overlap with CB2 is not allowed)";
                sLAYER_1053 = not_interacting( API, SEALRING ); 
                sLAYER_1053 and ISOR; 
                sLAYER_1054 = API and SRCSR; 
                sLAYER_1054 and CB2I; 
            } /* end of rule : SR.S.1:AP */
            rSR_AP_WARNING @= { @ "SR.AP:WARNING : AP is must in seal-ring if flip chip or AlCu RDL or AlCu fuse is used "
                                                  "AP enclosure of CB/CBD in seal-ring >= 1";
                sLAYER_1055 = interacting( gCHIP, API ); 
                SRCSRX = interacting( SR_EDGE, sLAYER_1055 );    /* flip chip or AlCu RDL or AlCu fuse is used */ 
                SRX_CB = CBI inside SRCSRX; 
                SRX_CBD = CBDI inside SRCSRX; 
                SRX_RV = RVI inside SRCSRX; 
                SRX_CB not API; 
                SRX_CBD not API; 
                SRX_RV not API; 
                A1 = angle_edge( SRX_CB, != 45 ); 
                A2 = angle_edge( SRX_CB, == 45 ); 
                B1 = angle_edge( SRX_CBD, != 45 ); 
                B2 = angle_edge( SRX_CBD, == 45 ); 
                C1 = angle_edge( SRX_RV, != 45 ); 
                C2 = angle_edge( SRX_RV, == 45 ); 
                enclose( A1, API, < 1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.004 ); 
                enclose( B1, API, < 1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.004 ); 
                enclose( C1, API, < 1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.004 ); 
                enclose( A2, API, < ( 1 - GRID ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.004 ); 
                enclose( B2, API, < ( 1 - GRID ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.004 ); 
                enclose( C2, API, < ( 1 - GRID ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.004 ); 
            } /* end of rule : SR.AP:WARNING */
         #else /* the reverse of #ifdef WLCSP_SEALRING  */ 
            rSR_S_1_AP @= { @ "SR.S.1:AP : Width of Assembly isolation >= " + SR_S_1 + " um, Only M1~Mtop and CDU allowed in assembly isolation region " 
                                          "2. Connect circuit to sealring through AP is not allowed";
                API and ISOR; 
            } /* end of rule : SR.S.1:AP */
            rSR_AP_WARNING @= { @ "SR.AP:WARNING : AP is must in seal-ring if flip chip or AlCu RDL or AlCu fuse is used "
                                                  "AP enclosure of CB/CBD/CB2 in seal-ring >= 1";
                sLAYER_1056 = interacting( gCHIP, AP ); 
                SR_EDGEX = interacting( SR_EDGE, sLAYER_1056 );    /* flip chip or AlCu RDL or AlCu fuse is used */ 
                SRX_CB = CBI inside SR_EDGEX; 
                SRX_CBD = CBDI inside SR_EDGEX; 
                SRX_CB2 = CB2I inside SR_EDGEX; 
                SRX_RV = RVI inside SR_EDGEX; 
                SRX_CB not AP; 
                SRX_CBD not AP; 
                SRX_CB2 not AP; 
                SRX_RV not AP; 
                enclose( SRX_CB, AP, < 1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
                enclose( SRX_CBD, AP, < 1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
                enclose( SRX_CB2, AP, < 1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
                enclose( SRX_RV, AP, < 1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
            } /* end of rule : SR.AP:WARNING */
         #endif /* end of #ifdef WLCSP_SEALRING  */ 
         rSR_CB_WARNING @= { @ "SR.CB:WARNING : CB is must in seal-ring if wire bond is used";
             sLAYER_1057 = interacting( gCHIP, CBI ); 
             CHIP_INT_CB = not_interacting( sLAYER_1057, UBMI ); 
             SR_EDGEX = interacting( SR_EDGE, CHIP_INT_CB ); 
             not_interacting( SR_EDGEX, CBI ); 
         } /* end of rule : SR.CB:WARNING */
         rSR_CBD_RV_WARNING @= { @ "SR.CBD_RV:WARNING : CBD is must in seal-ring if flip chip (without AlCu fuse or AlCu RDL) is used "
                                                       "Either CBD or RV is must in seal-ring if flip chip(with AlCu fuse or AlCu RDL) is used";
             CHIP_UBM = interacting( gCHIP, UBMI ); 
             sLAYER_1058 = RVI or FWALI; 
             CHIP_UBM_1 = interacting( CHIP_UBM, sLAYER_1058 ); 
             sLAYER_1059 = RVI or FWALI; 
             CHIP_UBM_2 = not_interacting( CHIP_UBM, sLAYER_1059 ); 
             SR_EDGEX1 = interacting( SR_EDGE, CHIP_UBM_1 ); 
             sLAYER_1060 = CBDI or RVI; 
             not_interacting( SR_EDGEX1, sLAYER_1060 ); 
             SR_EDGEX2 = interacting( SR_EDGE, CHIP_UBM_2 ); 
             not_interacting( SR_EDGEX2, CBDI ); 
         } /* end of rule : SR.CBD_RV:WARNING */
         rSR_UBM_WARNING @= { @ "SR.UBM:WARNING : Do not draw UBM on Chip corner stress relief pattern/Seal ring/Assembly isolation";
             SRCSR and UBMI; 
         } /* end of rule : SR.UBM:WARNING */
         rSR_CO_VIA_WARNING @= { @ "SR.CO_VIA:WARNING : line-co and line-viax must be continuous";
             LINE_CO = not_rectangles( SR_CO, sides = { == CO_W_1, == CO_W_1 } ); 
             adjacent_edge( LINE_CO, angle1 = <= 90, angle2 = < 180, length = < ( 20 * CO_W_2 ) ); 
             LINE_VIA1 = not_rectangles( SR_VIA1, sides = { == VIA1_W_1, == VIA1_W_1 } ); 
             adjacent_edge( LINE_VIA1, angle1 = <= 90, angle2 = < 180, length = < ( 20 * VIA1_W_2 ) ); 
             LINE_VIA2 = not_rectangles( SR_VIA2, sides = { == VIA2_W_1, == VIA2_W_1 } ); 
             adjacent_edge( LINE_VIA2, angle1 = <= 90, angle2 = < 180, length = < ( 20 * VIA2_W_2 ) ); 
             LINE_VIA3 = not_rectangles( SR_VIA3, sides = { == VIA3_W_1, == VIA3_W_1 } ); 
             adjacent_edge( LINE_VIA3, angle1 = <= 90, angle2 = < 180, length = < ( 20 * VIA3_W_2 ) ); 
             LINE_VIA4 = not_rectangles( SR_VIA4, sides = { == VIA4_W_1, == VIA4_W_1 } ); 
             adjacent_edge( LINE_VIA4, angle1 = <= 90, angle2 = < 180, length = < ( 20 * VIA4_W_2 ) ); 
             LINE_VIA5 = not_rectangles( SR_VIA5, sides = { == VIA5_W_1, == VIA5_W_1 } ); 
             adjacent_edge( LINE_VIA5, angle1 = <= 90, angle2 = < 180, length = < ( 20 * VIA5_W_2 ) ); 
             LINE_VIA6 = not_rectangles( SR_VIA6, sides = { == VIA6_W_1, == VIA6_W_1 } ); 
             adjacent_edge( LINE_VIA6, angle1 = <= 90, angle2 = < 180, length = < ( 20 * VIA6_W_2 ) ); 
             LINE_VIA7 = not_rectangles( SR_VIA7, sides = { == VIA7_W_1, == VIA7_W_1 } ); 
             adjacent_edge( LINE_VIA7, angle1 = <= 90, angle2 = < 180, length = < ( 20 * VIA7_W_2 ) ); 
             LINE_VIA8 = not_rectangles( SR_VIA8, sides = { == VIA8_W_1, == VIA8_W_1 } ); 
             adjacent_edge( LINE_VIA8, angle1 = <= 90, angle2 = < 180, length = < ( 20 * VIA8_W_2 ) ); 
         } /* end of rule : SR.CO_VIA:WARNING */
         rSR_R_1 @= { @ "SR.R.1 : SEALRING layers is a must if either you add sealring by themselves, or metal fuse is used";
             not_interacting( CHIP_WISR, SEALRINGI ); 
             sLAYER_1061 = interacting( CHIP_NOSR, PMDMY ); 
             not_interacting( sLAYER_1061, SEALRINGI ); 
         } /* end of rule : SR.R.1 */
         rSR_R_3_CO @= { @ "SR.R.3:CO : CO bar, VIA (x,y,z,r,u) bar, CB/CBD/RV bar must be continuous as a ring.";
             LINE_SR_CO = not_rectangles( SR_CO, sides = { == CO_W_1, == CO_W_1 } ); 
             adjacent_edge( LINE_SR_CO, angle1 = <= 90, angle2 = < 180, length = < ( 20 * CO_W_2 ) ); 
         } /* end of rule : SR.R.3:CO */
         rSR_R_3_VIA1 @= { @ "SR.R.3:VIA1 : CO bar, VIA (x,y,z,r,u) bar, CB/CBD/RV bar must be continuous as a ring.";
             LINE_SR_VIA1 = not_rectangles( SR_VIA1, sides = { == VIA1_W_1, == VIA1_W_1 } ); 
             adjacent_edge( LINE_SR_VIA1, angle1 = <= 90, angle2 = < 180, length = < ( 20 * VIA1_W_2 ) ); 
         } /* end of rule : SR.R.3:VIA1 */
         rSR_R_3_VIA2 @= { @ "SR.R.3:VIA2 : CO bar, VIA (x,y,z,r,u) bar, CB/CBD/RV bar must be continuous as a ring.";
             LINE_SR_VIA2 = not_rectangles( SR_VIA2, sides = { == VIA2_W_1, == VIA2_W_1 } ); 
             adjacent_edge( LINE_SR_VIA2, angle1 = <= 90, angle2 = < 180, length = < ( 20 * VIA2_W_2 ) ); 
         } /* end of rule : SR.R.3:VIA2 */
         rSR_R_3_VIA3 @= { @ "SR.R.3:VIA3 : CO bar, VIA (x,y,z,r,u) bar, CB/CBD/RV bar must be continuous as a ring.";
             LINE_SR_VIA3 = not_rectangles( SR_VIA3, sides = { == VIA3_W_1, == VIA3_W_1 } ); 
             adjacent_edge( LINE_SR_VIA3, angle1 = <= 90, angle2 = < 180, length = < ( 20 * VIA3_W_2 ) ); 
         } /* end of rule : SR.R.3:VIA3 */
         rSR_R_3_VIA4 @= { @ "SR.R.3:VIA4 : CO bar, VIA (x,y,z,r,u) bar, CB/CBD/RV bar must be continuous as a ring.";
             LINE_SR_VIA4 = not_rectangles( SR_VIA4, sides = { == VIA4_W_1, == VIA4_W_1 } ); 
             adjacent_edge( LINE_SR_VIA4, angle1 = <= 90, angle2 = < 180, length = < ( 20 * VIA4_W_2 ) ); 
         } /* end of rule : SR.R.3:VIA4 */
         rSR_R_3_VIA5 @= { @ "SR.R.3:VIA5 : CO bar, VIA (x,y,z,r,u) bar, CB/CBD/RV bar must be continuous as a ring.";
             LINE_SR_VIA5 = not_rectangles( SR_VIA5, sides = { == VIA5_W_1, == VIA5_W_1 } ); 
             adjacent_edge( LINE_SR_VIA5, angle1 = <= 90, angle2 = < 180, length = < ( 20 * VIA5_W_2 ) ); 
         } /* end of rule : SR.R.3:VIA5 */
         rSR_R_3_VIA6 @= { @ "SR.R.3:VIA6 : CO bar, VIA (x,y,z,r,u) bar, CB/CBD/RV bar must be continuous as a ring.";
             LINE_SR_VIA6 = not_rectangles( SR_VIA6, sides = { == VIA6_W_1, == VIA6_W_1 } ); 
             adjacent_edge( LINE_SR_VIA6, angle1 = <= 90, angle2 = < 180, length = < ( 20 * VIA6_W_2 ) ); 
         } /* end of rule : SR.R.3:VIA6 */
         rSR_R_3_VIA7 @= { @ "SR.R.3:VIA7 : CO bar, VIA (x,y,z,r,u) bar, CB/CBD/RV bar must be continuous as a ring.";
             LINE_SR_VIA7 = not_rectangles( SR_VIA7, sides = { == VIA7_W_1, == VIA7_W_1 } ); 
             adjacent_edge( LINE_SR_VIA7, angle1 = <= 90, angle2 = < 180, length = < ( 20 * VIA7_W_2 ) ); 
         } /* end of rule : SR.R.3:VIA7 */
         rSR_R_3_VIA8 @= { @ "SR.R.3:VIA8 : CO bar, VIA (x,y,z,r,u) bar, CB/CBD/RV bar must be continuous as a ring.";
             LINE_SR_VIA8 = not_rectangles( SR_VIA8, sides = { == VIA8_W_1, == VIA8_W_1 } ); 
             adjacent_edge( LINE_SR_VIA8, angle1 = <= 90, angle2 = < 180, length = < ( 20 * VIA8_W_2 ) ); 
         } /* end of rule : SR.R.3:VIA8 */
         rSR_R_3_CB @= { @ "SR.R.3:CB : CO bar, VIA (x,y,z,r,u) bar, CB/CBD/RV bar must be continuous as a ring.";
             sLAYER_1063 = interacting( CB, SEALRING ); 
             sLAYER_1062 = not_rectangles( sLAYER_1063 );
             not_donuts( sLAYER_1062 );
             sLAYER_1064 = interacting( CB, SEALRING ); 
             adjacent_edge( sLAYER_1064, angle1 = <= 90, angle2 = < 180, length = < ( 20 * CB_W_7 ) ); 
         } /* end of rule : SR.R.3:CB */
         rSR_R_3_CBD @= { @ "SR.R.3:CBD : CO bar, VIA (x,y,z,r,u) bar, CB/CBD/RV bar must be continuous as a ring.";
             sLAYER_1066 = interacting( CBD, SEALRING ); 
             sLAYER_1065 = not_rectangles( sLAYER_1066 );
             not_donuts( sLAYER_1065 );
             sLAYER_1067 = interacting( CBD, SEALRING ); 
             adjacent_edge( sLAYER_1067, angle1 = <= 90, angle2 = < 180, length = < ( 20 * CB_W_7 ) ); 
         } /* end of rule : SR.R.3:CBD */
         rSR_R_3_RV @= { @ "SR.R.3:RV : CO bar, VIA (x,y,z,r,u) bar, CB/CBD/RV bar must be continuous as a ring.";
             sLAYER_1069 = interacting( RV, SEALRING ); 
             sLAYER_1068 = not_rectangles( sLAYER_1069 );
             not_donuts( sLAYER_1068 );
             sLAYER_1070 = interacting( RV, SEALRING ); 
             adjacent_edge( sLAYER_1070, angle1 = <= 90, angle2 = < 180, length = < ( 20 * CB_W_7 ) ); 
         } /* end of rule : SR.R.3:RV */
         SR_CHECK = size( size( SEALRING, CSR_W_1 / 2, clip_acute = NONE ), - ( CSR_W_1 / 2 ), clip_acute = NONE ); 
         rSR_R_4_OD @= { @ "SR.R.4:OD : Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD";
             SEALRING not OD; 
         } /* end of rule : SR.R.4:OD */
         rSR_R_4_PP @= { @ "SR.R.4:PP : Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD";
             SEALRING not PP; 
         } /* end of rule : SR.R.4:PP */
         rSR_R_4_M1 @= { @ "SR.R.4:M1 : Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD";
             not_interacting( SR_CHECK, M1X ); 
         } /* end of rule : SR.R.4:M1 */
         rSR_R_4_M2 @= { @ "SR.R.4:M2 : Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD";
             not_interacting( SR_CHECK, M2X ); 
         } /* end of rule : SR.R.4:M2 */
         rSR_R_4_M3 @= { @ "SR.R.4:M3 : Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD";
             not_interacting( SR_CHECK, M3X ); 
         } /* end of rule : SR.R.4:M3 */
         rSR_R_4_M4 @= { @ "SR.R.4:M4 : Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD";
             not_interacting( SR_CHECK, M4X ); 
         } /* end of rule : SR.R.4:M4 */
         rSR_R_4_M5 @= { @ "SR.R.4:M5 : Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD";
             not_interacting( SR_CHECK, M5X ); 
         } /* end of rule : SR.R.4:M5 */
         rSR_R_4_M6 @= { @ "SR.R.4:M6 : Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD";
             not_interacting( SR_CHECK, M6X ); 
         } /* end of rule : SR.R.4:M6 */
         rSR_R_4_M7 @= { @ "SR.R.4:M7 : Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD";
             not_interacting( SR_CHECK, M7X ); 
         } /* end of rule : SR.R.4:M7 */
         rSR_R_4_M8 @= { @ "SR.R.4:M8 : Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD";
             not_interacting( SR_CHECK, M8X ); 
         } /* end of rule : SR.R.4:M8 */
         rSR_R_4_M9 @= { @ "SR.R.4:M9 : Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD";
             not_interacting( SR_CHECK, M9X ); 
         } /* end of rule : SR.R.4:M9 */
         rSR_R_4_CO @= { @ "SR.R.4:CO : Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD";
             not_enclosing( SR_M1, COI ); 
         } /* end of rule : SR.R.4:CO */
         rSR_R_4_VIA1 @= { @ "SR.R.4:VIA1 : Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD";
             not_enclosing( SR_M1, VIA1I ); 
         } /* end of rule : SR.R.4:VIA1 */
         rSR_R_4_VIA2 @= { @ "SR.R.4:VIA2 : Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD";
             not_enclosing( SR_M2, VIA2I ); 
         } /* end of rule : SR.R.4:VIA2 */
         rSR_R_4_VIA3 @= { @ "SR.R.4:VIA3 : Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD";
             not_enclosing( SR_M3, VIA3I ); 
         } /* end of rule : SR.R.4:VIA3 */
         rSR_R_4_VIA4 @= { @ "SR.R.4:VIA4 : Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD";
             not_enclosing( SR_M4, VIA4I ); 
         } /* end of rule : SR.R.4:VIA4 */
         rSR_R_4_VIA5 @= { @ "SR.R.4:VIA5 : Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD";
             not_enclosing( SR_M5, VIA5I ); 
         } /* end of rule : SR.R.4:VIA5 */
         rSR_R_4_VIA6 @= { @ "SR.R.4:VIA6 : Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD";
             not_enclosing( SR_M6, VIA6I ); 
         } /* end of rule : SR.R.4:VIA6 */
         rSR_R_4_VIA7 @= { @ "SR.R.4:VIA7 : Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD";
             not_enclosing( SR_M7, VIA7I ); 
         } /* end of rule : SR.R.4:VIA7 */
         rSR_R_4_VIA8 @= { @ "SR.R.4:VIA8 : Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD";
             not_enclosing( SR_M8, VIA8I ); 
         } /* end of rule : SR.R.4:VIA8 */
         
         //SR.EN.2 is checked by SR.EN.1
         rSR_EN_1 @= { @ "SR.EN.1 : {OD INTERACT SEALRING} enclosure of metal with the outer edge of sealring >= " + SR_EN_1 + " um"; 
             SR_OD = interacting( OD, SEALRING ); 
             SR_OD_HOLES = donut_holes( SR_OD, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
             SR_OD_FULL = SR_OD or SR_OD_HOLES; 
             enclose( SR_M1, SR_OD_FULL, < SR_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = NOT_CONTAINED ); 
             enclose( SR_M2, SR_OD_FULL, < SR_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = NOT_CONTAINED ); 
             enclose( SR_M3, SR_OD_FULL, < SR_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = NOT_CONTAINED ); 
             enclose( SR_M4, SR_OD_FULL, < SR_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = NOT_CONTAINED ); 
             enclose( SR_M5, SR_OD_FULL, < SR_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = NOT_CONTAINED ); 
             enclose( SR_M6, SR_OD_FULL, < SR_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = NOT_CONTAINED ); 
             enclose( SR_M7, SR_OD_FULL, < SR_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = NOT_CONTAINED ); 
             enclose( SR_M8, SR_OD_FULL, < SR_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = NOT_CONTAINED ); 
             enclose( SR_M9, SR_OD_FULL, < SR_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = NOT_CONTAINED ); 
             sLAYER_1071 = layer_extent( SR_OD_FULL ); 
             SR_OD_FULL xor sLAYER_1071; 
         } /* end of rule : SR.EN.1 */
         #ifdef WLCSP_SEALRING 
            ASSH_WLCSP = contains( SRODH, { 50, 50 }, FORTY_FIVE ); 
            CHIP_EDGE_REAL_WLCSP = size( ASSH_WLCSP, clip_acute = NONE, distance = - 10 ); 
            gLAYER_598 = interacting( CHIPX, ASSH_WLCSP ); 
            SR_WLCSP = gLAYER_598 not ASSH_WLCSP; 
            ASS_WLCSP = ASSH_WLCSP not CHIP_EDGE_REAL_WLCSP; 
            rAP_W_4 @= { @ "AP.W.4 : Width of (AP AND (seal-ring or Assembly isolation) NOT OUTSIDE Assembly isolation)(DRC tolerance at 45-degree turning: " + WLCSP_TOL + " um) >= " + AP_W_4 + " um"; 
                sLAYER_1073 = SR_WLCSP or ASS_WLCSP; 
                sLAYER_1072 = API and sLAYER_1073; 
                A0 = sLAYER_1072 not_outside ASS_WLCSP; 
                A_NON45 = angle_edge( A0, != 45 ); 
                internal1( A_NON45, < AP_W_4, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                A_45 = angle_edge( A0, == 45 ); 
                internal1( A_45, < ( AP_W_4 - WLCSP_TOL ), extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                not_interacting( ASS_WLCSP, API ); 
            } /* end of rule : AP.W.4 */
            rAP_W_5 @= { @ "AP.W.5 : Width of (AP NOT PM1) NOT OUTSIDE Assembly isolation (DRC tolerance at 45-degree turning: " + WLCSP_TOL + " um) >= " + AP_W_5 + " um"; 
                sLAYER_1074 = API not PM1I; 
                A0 = sLAYER_1074 not_outside ASS_WLCSP; 
                A_NON45 = angle_edge( A0, != 45 ); 
                internal1( A_NON45, < AP_W_5, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                A_45 = angle_edge( A0, == 45 ); 
                internal1( A_45, < ( AP_W_5 - WLCSP_TOL ), extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                not_interacting( ASS_WLCSP, A0 ); 
            } /* end of rule : AP.W.5 */
            
            //AP.S.5.S is checked by AP.S.5
            rAP_S_5 @= { @ "AP.S.5 : Space of {{AP NOT CSRDMY} AND seal-ring} (DRC tolerance at 45-degree turning 0.02 um) = " + AP_S_5; 
                sLAYER_1075 = API not CSRDMY; 
                AP_CHECK_PRE = sLAYER_1075 and SR_WLCSP; 
                sLAYER_1076 = not_interacting( AP_CHECK_PRE, CSRDMY ); 
                sLAYER_1077 = donut_holes( AP_CHECK_PRE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
                AP_CHECK1 = sLAYER_1076 or sLAYER_1077; 
                AP_CHECK2 = donut_holes( AP_CHECK_PRE, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
                sAP_CHECK = AP_CHECK2 not AP_CHECK1; 
                sLAYER_1078 = interacting( CHIPX, SR_WLCSP ); 
                not_interacting( sLAYER_1078, sAP_CHECK );
                DIA_EDGE = angle_edge( sAP_CHECK, == 45 ); 
                ORTHO_EDGE = angle_edge( sAP_CHECK, != 45 ); 
                AP_CHECK_WAIVE = internal1( ORTHO_EDGE, == AP_S_5, extension = NONE, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                sLAYER_1079 = internal1( ORTHO_EDGE, ( AP_S_5, (AP_S_5 + WLCSP_TOL) ], extension = NONE, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                sLAYER_1079 not AP_CHECK_WAIVE; 
                wide( sAP_CHECK, > ( AP_S_5 + WLCSP_TOL ), forty_five = INTERNAL ); 
                internal1( ORTHO_EDGE, < AP_S_5, extension = NONE, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                internal1( DIA_EDGE, < ( AP_S_5 - WLCSP_TOL ), extension = NONE, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
            } /* end of rule : AP.S.5 */
            rAP_W_6 @= { @ "AP.W.6 : Width of (AP interact Assembly isolation AND PM2) (DRC tolerance at 45-degree turning: " + WLCSP_TOL + " um) == " + AP_W_6 + " um"; 
                sLAYER_1080 = interacting( API, ASS_WLCSP ); 
                A = sLAYER_1080 and PM2I; 
                DIA_EDGE = angle_edge( A, == 45 ); 
                ORTHO_EDGE = angle_edge( A, != 45 ); 
                A_WAIVE = internal1( ORTHO_EDGE, == AP_W_6, extension = NONE, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                sLAYER_1081 = internal1( ORTHO_EDGE, ( AP_W_6, (AP_W_6 + WLCSP_TOL) ], extension = NONE, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                sLAYER_1081 not A_WAIVE; 
                wide( A, > ( AP_W_6 + WLCSP_TOL ), forty_five = INTERNAL ); 
                internal1( ORTHO_EDGE, < AP_W_6, extension = NONE, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                internal1( DIA_EDGE, < ( AP_W_6 - WLCSP_TOL ), extension = NONE, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
            } /* end of rule : AP.W.6 */
            
            //PM.W.5.S is checked by PM.W.5
            rPM_W_5 @= { @ "PM.W.5 : Width of (((seal-ring OR Assembly isolation) INTERACT PM1) NOT PM1) (DRC tolerance at 45-degree turning: " + WLCSP_TOL + " um) == " + PM_W_5 + " um"; 
                sLAYER_1083 = ASS_WLCSP or SR_WLCSP; 
                sLAYER_1082 = interacting( sLAYER_1083, PM1I ); 
                A = sLAYER_1082 not PM1I; 
                DIA_EDGE = angle_edge( A, == 45 ); 
                ORTHO_EDGE = angle_edge( A, != 45 ); 
                A_WAIVE = internal1( ORTHO_EDGE, == PM_W_5, extension = NONE, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                sLAYER_1084 = internal1( ORTHO_EDGE, ( PM_W_5, (PM_W_5 + WLCSP_TOL) ], extension = NONE, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                sLAYER_1084 not A_WAIVE; 
                wide( A, > ( PM_W_5 + WLCSP_TOL ), forty_five = INTERNAL ); 
                internal1( ORTHO_EDGE, < PM_W_5, extension = NONE, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                internal1( DIA_EDGE, < ( PM_W_5 - WLCSP_TOL ), extension = NONE, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
            } /* end of rule : PM.W.5 */
            rPM_W_6 @= { @ "PM.W.6 : Width of (((seal-ring OR Assembly isolation) INTERACT PM2) NOT PM2) (DRC tolerance at 45-degree turning: " + WLCSP_TOL + " um) == " + PM_W_6 + " um"; 
                sLAYER_1086 = SR_WLCSP or ASS_WLCSP; 
                sLAYER_1085 = interacting( sLAYER_1086, PM2I ); 
                A = sLAYER_1085 not PM2I; 
                DIA_EDGE = angle_edge( A, == 45 ); 
                ORTHO_EDGE = angle_edge( A, != 45 ); 
                A_WAIVE = internal1( ORTHO_EDGE, == PM_W_6, extension = NONE, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                sLAYER_1087 = internal1( ORTHO_EDGE, ( PM_W_6, (PM_W_6 + WLCSP_TOL) ], extension = NONE, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                sLAYER_1087 not A_WAIVE; 
                wide( A, > ( PM_W_6 + WLCSP_TOL ), forty_five = INTERNAL ); 
                internal1( ORTHO_EDGE, < PM_W_6, extension = NONE, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                internal1( DIA_EDGE, < ( PM_W_6 - WLCSP_TOL ), extension = NONE, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
            } /* end of rule : PM.W.6 */
            rCB_W_7_CB @= { @ "CB.W.7:CB : Width of CB opening interact seal-ring (DRC tolerance at 45-degree turning: " + WLCSP_TOL + " um) == " + CB_W_7 + " um"; 
                A = interacting( CBI, SR_WLCSP ); 
                X1 = angle_edge( A, != 45 ); 
                X2 = angle_edge( A, == 45 ); 
                internal1( X1, ( CB_W_7, (CB_W_7 * 2) ), extension = NONE, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                internal1( X2, ( (CB_W_7 + 0.02), (CB_W_7 * 2) ), extension = NONE, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                sLAYER_1088 = wide( A, >= ( CB_W_7 * 2 ), forty_five = INTERNAL ); 
                contains( sLAYER_1088, { 10, GRID }, FORTY_FIVE ); 
                internal1( X1, < CB_W_7, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
                internal1( X2, < ( CB_W_7 - 0.02 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
            } /* end of rule : CB.W.7:CB */
            rCB_W_7_CBD @= { @ "CB.W.7:CBD : Width of CBD opening interact seal-ring (DRC tolerance at 45-degree turning: " + WLCSP_TOL + " um) == " + CB_W_7 + " um"; 
                A = interacting( CBDI, SR_WLCSP ); 
                X1 = angle_edge( A, != 45 ); 
                X2 = angle_edge( A, == 45 ); 
                internal1( X1, ( CB_W_7, (CB_W_7 * 2) ), extension = NONE, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                internal1( X2, ( (CB_W_7 + 0.02), (CB_W_7 * 2) ), extension = NONE, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                sLAYER_1089 = wide( A, >= ( CB_W_7 * 2 ), forty_five = INTERNAL ); 
                contains( sLAYER_1089, { 10, GRID }, FORTY_FIVE ); 
                internal1( X1, < CB_W_7, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
                internal1( X2, < ( CB_W_7 - 0.02 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
            } /* end of rule : CB.W.7:CBD */
            rCB_W_7_RV @= { @ "CB.W.7:RV : Width of RV opening interact seal-ring (DRC tolerance at 45-degree turning: " + WLCSP_TOL + " um) == " + CB_W_7 + " um"; 
                A = interacting( RVI, SR_WLCSP ); 
                X1 = angle_edge( A, != 45 ); 
                X2 = angle_edge( A, == 45 ); 
                internal1( X1, ( CB_W_7, (CB_W_7 * 2) ), extension = NONE, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                internal1( X2, ( (CB_W_7 + 0.02), (CB_W_7 * 2) ), extension = NONE, intersecting = {  }, intersection_angle = < 90, orientation = { PARALLEL }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                sLAYER_1090 = wide( A, >= ( CB_W_7 * 2 ), forty_five = INTERNAL ); 
                contains( sLAYER_1090, { 10, GRID }, FORTY_FIVE ); 
                internal1( X1, < CB_W_7, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
                internal1( X2, < ( CB_W_7 - 0.02 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
            } /* end of rule : CB.W.7:RV */
            rPM_R_1 @= { @ "PM.R.1 : More than one PM1 INTERACT {seal-ring OR Assembly isolation} is not allowed V";
                sLAYER_1091 = SR_WLCSP or ASS_WLCSP; 
                A = interacting( PM1I, sLAYER_1091 ); 
                interacting( CHIPX, A, > 1 ); 
            } /* end of rule : PM.R.1 */
            rPM_R_2 @= { @ "PM.R.2 : PM1/PM2 [INTERACT {seal-ring OR Assembly isolation}] must fully abut die edge for WLCSP process.";
                sLAYER_1092 = SR_WLCSP or ASS_WLCSP; 
                PM1_CHECK = interacting( PM1I, sLAYER_1092 ); 
                A = donut_holes( PM1_CHECK, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
                OUT_PM1_EDGE = PM1_CHECK or A; 
                C = interacting( CHIPX, PM1_CHECK ); 
                OUT_PM1_EDGE xor C; 
                sLAYER_1093 = SR_WLCSP or ASS_WLCSP; 
                PM2_CHECK = interacting( PM2I, sLAYER_1093 ); 
                B = donut_holes( PM2_CHECK, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
                OUT_PM2_EDGE = PM2_CHECK or B; 
                D = interacting( CHIPX, PM2_CHECK ); 
                OUT_PM2_EDGE xor D; 
            } /* end of rule : PM.R.2 */
            rPM_R_3 @= { @ "PM.R.3 : More than one PM2 INTERACT {seal-ring OR Assembly isolation} is not allowed V";
                sLAYER_1094 = SR_WLCSP or ASS_WLCSP; 
                A = interacting( PM2I, sLAYER_1094 ); 
                interacting( CHIPX, A, > 1 ); 
            } /* end of rule : PM.R.3 */
            rPM_R_8 @= { @ "PM.R.8 : seal-ring NOT INTERACT PM1/PM2 is not allowed for WLCSP process.The rule is applied while PM1/PM2 exists in a chip.";
                A = interacting( CHIPX, PM1I ); 
                B = interacting( CHIPX, PM2I ); 
                sLAYER_1095 = interacting( SR_WLCSP, A ); 
                not_interacting( sLAYER_1095, PM1I ); 
                sLAYER_1096 = interacting( SR_WLCSP, B ); 
                not_interacting( sLAYER_1096, PM2I ); 
            } /* end of rule : PM.R.8 */
            rAP_R_1 @= { @ "AP.R.1 : Die edge must fully abut AP [INSIDE seal-ring] ((except {{LMARK SIZING 2 um} AND Full_Chip})) .";
                A = API inside SR_WLCSP; 
                AH = donut_holes( A, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
                AA = A or AH; 
                sLAYER_1097 = CHIPX xor AA; 
                sLAYER_1099 = size( LMARK, clip_acute = NONE, distance = 2 ); 
                sLAYER_1098 = sLAYER_1099 and CHIPX; 
                sLAYER_1097 not sLAYER_1098;
            } /* end of rule : AP.R.1 */
            rAP_EN_3_CB @= { @ "AP.EN.3:CB : AP enclosure of CB/CBD/RV  in seal-ring (DRC tolerance at 45-degree turning: " + WLCSP_TOL + " um) == " + AP_EN_3 + " um"; 
                A0 = API and SR_WLCSP; 
                B0 = CBI and SR_WLCSP; 
                sLAYER_1335 = external1( B0, < AP_EN_3_W, extension = RADIAL, intersecting = { } ); 
                sLAYER_1336 = vertex( B0, angles = { 315 }, shape = TRIANGLE, shape_size = AP_EN_3_W ); 
                sLAYER_1100 = sLAYER_1335 or sLAYER_1336;
                sLAYER_1102 = donut_holes( CBI, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
                sLAYER_1101 = interacting( sLAYER_1102, CSRDMY ); 
                INTERNAL_CORNER_WAIVE_PRE = sLAYER_1100 inside sLAYER_1101; 
                INTERNAL_CORNER_WAIVE = size( INTERNAL_CORNER_WAIVE_PRE, clip_acute = NONE, distance = GRID );    /* waive 45 corner */ 
                AP_CORNER_WAIVE_PRE = external1( B0, < ( 0.5 * AP_EN_3 ), extension = RADIAL, intersecting = {  }, intersection_angle = ( 134.9, 135.1 ), look_thru = NOT_ADJACENT, membership = SAME_POLYGON ); 
                AP_CORNER_WAIVE = size( AP_CORNER_WAIVE_PRE, clip_acute = NONE, distance = GRID );    /* waive 145 notch area */ 
                WAIVE_MERGE = INTERNAL_CORNER_WAIVE or AP_CORNER_WAIVE;    /* waive 45 corner area and 145 notch area    */ 
                PAD_IN_SR_CHK = B0 not_touching_edge A0; 
                sLAYER_1104 = not_enclose_edge( PAD_IN_SR_CHK, API, == AP_EN_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = NOT_CONTAINED, output_layer = LAYER1 ); 
                sLAYER_1103 = angle_edge( sLAYER_1104, != 45 );
                or_edge( not_edge( sLAYER_1103, WAIVE_MERGE ), coincident_inside_edge( sLAYER_1103, WAIVE_MERGE ) )  not_coincident_edge (sLAYER_1102 inside A0);    /* otho direction fixed value check */ 
                enclose_edge( PAD_IN_SR_CHK, API, < ( AP_EN_3 - WLCSP_TOL ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, orientation = { PARALLEL }, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* 45 degree direction  -WLCSP_TOL */ 
                sLAYER_1105 = enclose_edge( PAD_IN_SR_CHK, API, ( (AP_EN_3 + WLCSP_TOL), (AP_EN_3 + 42) ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, orientation = { PARALLEL }, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                or_edge( not_edge( sLAYER_1105, WAIVE_MERGE ), coincident_inside_edge( sLAYER_1105, WAIVE_MERGE ) )  not_coincident_edge (sLAYER_1102 inside A0);    /* 45 degree direction  +WLCSP_TOL */ 
            } /* end of rule : AP.EN.3:CB */
            rAP_EN_3_CBD @= { @ "AP.EN.3:CBD : AP enclosure of CB/CBD/RV  in seal-ring (DRC tolerance at 45-degree turning: " + WLCSP_TOL + " um) == " + AP_EN_3 + " um"; 
                A0 = API and SR_WLCSP; 
                B0 = CBDI and SR_WLCSP; 
                sLAYER_1337 = external1( B0, < AP_EN_3_W, extension = RADIAL, intersecting = { } ); 
                sLAYER_1338 = vertex( B0, angles = { 315 }, shape = TRIANGLE, shape_size = AP_EN_3_W ); 
                sLAYER_1106 = sLAYER_1337 or sLAYER_1338;
                sLAYER_1108 = donut_holes( CBDI, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
                sLAYER_1107 = interacting( sLAYER_1108, CSRDMY ); 
                INTERNAL_CORNER_WAIVE_PRE = sLAYER_1106 inside sLAYER_1107; 
                INTERNAL_CORNER_WAIVE = size( INTERNAL_CORNER_WAIVE_PRE, clip_acute = NONE, distance = GRID );    /* waive 45 corner */ 
                AP_CORNER_WAIVE_PRE = external1( B0, < ( 0.5 * AP_EN_3 ), extension = RADIAL, intersecting = {  }, intersection_angle = ( 134.9, 135.1 ), look_thru = NOT_ADJACENT, membership = SAME_POLYGON ); 
                AP_CORNER_WAIVE = size( AP_CORNER_WAIVE_PRE, clip_acute = NONE, distance = GRID );    /* waive 145 notch area */ 
                WAIVE_MERGE = INTERNAL_CORNER_WAIVE or AP_CORNER_WAIVE;    /* waive 45 corner area and 145 notch area    */ 
                PAD_IN_SR_CHK = B0 not_touching_edge A0; 
                sLAYER_1110 = not_enclose_edge( PAD_IN_SR_CHK, API, == AP_EN_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = NOT_CONTAINED, output_layer = LAYER1 ); 
                sLAYER_1109 = angle_edge( sLAYER_1110, != 45 );
                or_edge( not_edge( sLAYER_1109, WAIVE_MERGE ), coincident_inside_edge( sLAYER_1109, WAIVE_MERGE ) )  not_coincident_edge (sLAYER_1108 inside A0);    /* otho direction fixed value check */ 
                enclose_edge( PAD_IN_SR_CHK, API, < ( AP_EN_3 - WLCSP_TOL ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, orientation = { PARALLEL }, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* 45 degree direction  -WLCSP_TOL */ 
                sLAYER_1111 = enclose_edge( PAD_IN_SR_CHK, API, ( (AP_EN_3 + WLCSP_TOL), (AP_EN_3 + 42) ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, orientation = { PARALLEL }, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                or_edge( not_edge( sLAYER_1111, WAIVE_MERGE ), coincident_inside_edge( sLAYER_1111, WAIVE_MERGE ) )  not_coincident_edge (sLAYER_1108 inside A0);    /* 45 degree direction  +WLCSP_TOL */ 
            } /* end of rule : AP.EN.3:CBD */
            rAP_EN_3_RV @= { @ "AP.EN.3:RV : AP enclosure of CB/CBD/RV  in seal-ring (DRC tolerance at 45-degree turning: " + WLCSP_TOL + " um) == " + AP_EN_3 + " um"; 
                A0 = API and SR_WLCSP; 
                B0 = RVI and SR_WLCSP; 
                sLAYER_1339 = external1( B0, < AP_EN_3_W, extension = RADIAL, intersecting = { } ); 
                sLAYER_1340 = vertex( B0, angles = { 315 }, shape = TRIANGLE, shape_size = AP_EN_3_W ); 
                sLAYER_1112 = sLAYER_1339 or sLAYER_1340;
                sLAYER_1114 = donut_holes( RVI, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
                sLAYER_1113 = interacting( sLAYER_1114, CSRDMY ); 
                INTERNAL_CORNER_WAIVE_PRE = sLAYER_1112 inside sLAYER_1113; 
                INTERNAL_CORNER_WAIVE = size( INTERNAL_CORNER_WAIVE_PRE, clip_acute = NONE, distance = GRID );    /* waive 45 corner */ 
                AP_CORNER_WAIVE_PRE = external1( B0, < ( 0.5 * AP_EN_3 ), extension = RADIAL, intersecting = {  }, intersection_angle = ( 134.9, 135.1 ), look_thru = NOT_ADJACENT, membership = SAME_POLYGON ); 
                AP_CORNER_WAIVE = size( AP_CORNER_WAIVE_PRE, clip_acute = NONE, distance = GRID );    /* waive 145 notch area */ 
                WAIVE_MERGE = INTERNAL_CORNER_WAIVE or AP_CORNER_WAIVE;    /* waive 45 corner area and 145 notch area    */ 
                PAD_IN_SR_CHK = B0 not_touching_edge A0; 
                sLAYER_1116 = not_enclose_edge( PAD_IN_SR_CHK, API, == AP_EN_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = NOT_CONTAINED, output_layer = LAYER1 ); 
                sLAYER_1115 = angle_edge( sLAYER_1116, != 45 );
                or_edge( not_edge( sLAYER_1115, WAIVE_MERGE ), coincident_inside_edge( sLAYER_1115, WAIVE_MERGE ) )  not_coincident_edge (sLAYER_1114 inside A0);    /* otho direction fixed value check */ 
                enclose_edge( PAD_IN_SR_CHK, API, < ( AP_EN_3 - WLCSP_TOL ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, orientation = { PARALLEL }, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* 45 degree direction  -WLCSP_TOL */ 
                sLAYER_1117 = enclose_edge( PAD_IN_SR_CHK, API, ( (AP_EN_3 + WLCSP_TOL), (AP_EN_3 + 42) ), extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, orientation = { PARALLEL }, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
                or_edge( not_edge( sLAYER_1117, WAIVE_MERGE ), coincident_inside_edge( sLAYER_1117, WAIVE_MERGE ) )  not_coincident_edge (sLAYER_1114 inside A0);    /* 45 degree direction  +WLCSP_TOL */ 
            } /* end of rule : AP.EN.3:RV */
         #endif /* end of #ifdef WLCSP_SEALRING  */ 
      #endif /* end of #ifdef FULL_CHIP  */ 
      
      //CDU CHECKS
      //==========
      #ifdef FULL_CHIP 
         rCDU_R_1 @= { @ "CDU.R.1 : CDUDMY must be inside the assembly isolation beside seal ring.";
             CDUDMY not_inside ISOR; 
             not_interacting( ISOR, CDUDMY ); 
         } /* end of rule : CDU.R.1 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      rCDU_R_2 @= { @ "CDU.R.2 : OD/POLY/CO/M1/NP must be inside layer CDUDMY.";
          not_enclosing( CDUDMY, ODI ); 
          not_enclosing( CDUDMY, POI ); 
          not_enclosing( CDUDMY, COI ); 
          not_enclosing( CDUDMY, M1I ); 
          not_enclosing( CDUDMY, NPI ); 
      } /* end of rule : CDU.R.2 */
      rCDU_WARNING1 @= { @ "CDU:WARNING1 : CDU width == 5.6 um";
          internal1( CDUDMY, < 5.6, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          size( size( CDUDMY, - 2.8, clip_acute = NONE ), 2.8, clip_acute = NONE ); 
      } /* end of rule : CDU:WARNING1 */
      rCDU_WARNING2 @= { @ "CDU:WARNING2 : The space from the CDU long edge to the sealring inner edge is 2.2 um";
          enclose( CDUDMY, ISOR, < 2.2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : CDU:WARNING2 */
      
      //DUMMY M1 CHECKS
      //==================
      rDM1_W_1 @= { @ "DM1.W.1 : Width >= " + DM1_W_1 + " um"; 
          internal1( DUM1, < DM1_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : DM1.W.1 */
      rDM1_W_2 @= { @ "DM1.W.2 : Width (maximum) (checked by sizing down 1.5 um) <= " + DM1_W_2 + " um"; 
          size( size( DUM1, - ( DM1_W_2 / 2 ), clip_acute = NONE ), DM1_W_2 / 2, clip_acute = NONE ); 
      } /* end of rule : DM1.W.2 */
      rDM1_S_1 @= { @ "DM1.S.1 : Space >= " + DM1_S_1 + " um"; 
          external1( DUM1, < DM1_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : DM1.S.1 */
      rDM1_S_2 @= { @ "DM1.S.2 : Space to M1 >= " + DM1_S_2 + " um"; 
          external2( M1I, DUM1, < DM1_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          M1I and DUM1; 
      } /* end of rule : DM1.S.2 */
      
      //DM1.S.3.S is checked by DM1.S.3
      rDM1_S_3 @= { @ "DM1.S.3 : Space to Mx (Overlap is not allowed) [Mx width > " + DM1_S_3_W + " um and the parallel metal run length > " + DM1_S_3_L + " um] >=  " + DM1_S_3; 
          X = external2( M1WIDE_4_p_5, DUM1, < DM1_S_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          contains( X, { DM1_S_2, DM1_S_3_L + 0.005 }, FORTY_FIVE ); 
      } /* end of rule : DM1.S.3 */
      
      //DM1.S.3.1.S is checked by DM1.S.3.1
      rDM1_S_3_1 @= { @ "DM1.S.3.1 : Space to Mx (Overlap is not allowed) [Mx width > " + DM1_S_3_1_W + " um and the parallel metal run length > " + DM1_S_3_1_L + " um] >= " + DM1_S_3_1; 
          X = external2( M1WIDE_1_p_5, DUM1, < DM1_S_3_1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          contains( X, { DM1_S_2, DM1_S_3_1_L + 0.005 }, FORTY_FIVE ); 
      } /* end of rule : DM1.S.3.1 */
      rDM1_S_4 @= { @ "DM1.S.4 : Space to FW (Overlap is not allowed) >= " + DM1_S_4 + " um"; 
          external2( FWI, DUM1, < DM1_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          FWI and DUM1; 
      } /* end of rule : DM1.S.4 */
      
      // DM1.S.5.0 is checked by DM1.S.5 and DM1.S.5.1
      // for solid L-mark (old)
      rDM1_S_5 @= { @ "DM1.S.5 : Space to LMARK (Overlap is not allowed) >= " + DM1_S_5 + " um"; 
          external2( LMARK_SOLID, DUM1, < DM1_S_5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          DUM1 and LMARK_SOLID; 
      } /* end of rule : DM1.S.5 */
      
      // for hollow L-mark (new)
      rDM1_S_5_1 @= { @ "DM1.S.5.1 : Space to L-slot (Overlap is not allowed) >= " + DM1_S_5_1 + " um"; 
          external2( LSLOT, DUM1, < DM1_S_5_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          DUM1 and LSLOT; 
      } /* end of rule : DM1.S.5.1 */
      rDM1_S_7 @= { @ "DM1.S.7 : Space to LOGO (Overlap is not allowed) >= 0.0 um";
          LOGO and DUM1; 
      } /* end of rule : DM1.S.7 */
      rDM1_S_8 @= { @ "DM1.S.8 : Space to INDDMY (Overlap is not allowed) >= " + DM1_S_8 + " um"; 
          external2( INDDMY, DUM1, < DM1_S_8, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          INDDMY and DUM1; 
      } /* end of rule : DM1.S.8 */
      
      // DM1.S.9 is not necessary to check
      rDM1_S_10 @= { @ "DM1.S.10 : Space to 45-degree bent Mx >= " + DM1_S_10 + " um2"; 
          X = edge_size( M1_EDGE_45, outside = DM1_S_10 ); 
          X and DUM1; 
      } /* end of rule : DM1.S.10 */
      #ifdef FULL_CHIP 
         rDM1_EN_1 @= { @ "DM1.EN.1 : Enclosure by chip edge >= " + DM1_EN_1 + " um"; 
             sLAYER_1118 = size( CHIP_CHAMFERED, clip_acute = NONE, distance = - DM1_EN_1 ); 
             DUM1 not sLAYER_1118; 
         } /* end of rule : DM1.EN.1 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      rDM1_A_1 @= { @ "DM1.A.1 : Min. area >= " + DM1_A_1 + " um2"; 
          area( DUM1, < DM1_A_1 ); 
      } /* end of rule : DM1.A.1 */
      rDM1_A_2 @= { @ "DM1.A.2 : Max. area <= " + DM1_A_2 + " um2"; 
          area( DUM1, > DM1_A_2 ); 
      } /* end of rule : DM1.A.2 */
      #ifdef FULL_CHIP 
         rDM1_R_1 @= { @ "DM1.R.1 : DM1 is a must. The DM1 CAD layer (TSMC default, 31;1 for DM1) must be different from the M1 CAD layer.";
             not_interacting( CHIPX, DUM1 ); 
         } /* end of rule : DM1.R.1 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      
      // DM1.R.2 is checked by related rules (CSR.R.1.LAYERS_NO_EXC)
      rDM1_R_3 @= { @ "DM1.R.3 : 0 or 45 degree solid shapes are allowed (Only rectangle and solid dummy is allowed)";
          not_rectangles( DUM1 ); 
          rectangles( DUM1 ) touching ( angle_edge(DUM1, angles = { (0,45), (45,90) }) );
          donut_holes( DUM1, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      } /* end of rule : DM1.R.3 */
      
      // DMx_O.R.1 is checked by DM1_O.R.1
      rDM1_O_R_1 @= { @ "DM1_O.R.1 : DM1_O interact M1 is not allowed";
          interacting( DM1_O, M1_REAL ); 
      } /* end of rule : DM1_O.R.1 */
      
      //DUMMY M2 CHECKS
      //==================
      rDM2_W_1 @= { @ "DM2.W.1 : Width >= " + DM2_W_1 + " um"; 
          internal1( DUM2, < DM2_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : DM2.W.1 */
      rDM2_W_2 @= { @ "DM2.W.2 : Width (maximum) (checked by sizing down 1.5 um) <= " + DM2_W_2 + " um"; 
          size( size( DUM2, - ( DM2_W_2 / 2 ), clip_acute = NONE ), DM2_W_2 / 2, clip_acute = NONE ); 
      } /* end of rule : DM2.W.2 */
      rDM2_S_1 @= { @ "DM2.S.1 : Space >= " + DM2_S_1 + " um"; 
          external1( DUM2, < DM2_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : DM2.S.1 */
      rDM2_S_2 @= { @ "DM2.S.2 : Space to M2 >= " + DM2_S_2 + " um"; 
          external2( M2I, DUM2, < DM2_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          M2I and DUM2; 
      } /* end of rule : DM2.S.2 */
      
      //DM2.S.3.S is checked by DM2.S.3
      rDM2_S_3 @= { @ "DM2.S.3 : Space to Mx (Overlap is not allowed) [Mx width > " + DM2_S_3_W + " um and the parallel metal run length > " + DM2_S_3_L + " um] >=  " + DM2_S_3; 
          X = external2( M2WIDE_4_p_5, DUM2, < DM2_S_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          contains( X, { DM2_S_2, DM2_S_3_L + 0.005 }, FORTY_FIVE ); 
      } /* end of rule : DM2.S.3 */
      
      //DM2.S.3.1.S is checked by DM2.S.3.1
      rDM2_S_3_1 @= { @ "DM2.S.3.1 : Space to Mx (Overlap is not allowed) [Mx width > " + DM2_S_3_1_W + " um and the parallel metal run length > " + DM2_S_3_1_L + " um] >= " + DM2_S_3_1; 
          X = external2( M2WIDE_1_p_5, DUM2, < DM2_S_3_1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          contains( X, { DM2_S_2, DM2_S_3_1_L + 0.005 }, FORTY_FIVE ); 
      } /* end of rule : DM2.S.3.1 */
      rDM2_S_4 @= { @ "DM2.S.4 : Space to FW (Overlap is not allowed) >= " + DM2_S_4 + " um"; 
          external2( FWI, DUM2, < DM2_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          FWI and DUM2; 
      } /* end of rule : DM2.S.4 */
      
      // DM2.S.5.0 is checked by DM2.S.5 and DM2.S.5.1
      // for solid L-mark (old)
      rDM2_S_5 @= { @ "DM2.S.5 : Space to LMARK (Overlap is not allowed) >= " + DM2_S_5 + " um"; 
          external2( LMARK_SOLID, DUM2, < DM2_S_5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          DUM2 and LMARK_SOLID; 
      } /* end of rule : DM2.S.5 */
      
      // for hollow L-mark (new)
      rDM2_S_5_1 @= { @ "DM2.S.5.1 : Space to L-slot (Overlap is not allowed) >= " + DM2_S_5_1 + " um"; 
          external2( LSLOT, DUM2, < DM2_S_5_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          DUM2 and LSLOT; 
      } /* end of rule : DM2.S.5.1 */
      rDM2_S_7 @= { @ "DM2.S.7 : Space to LOGO (Overlap is not allowed) >= 0.0 um";
          LOGO and DUM2; 
      } /* end of rule : DM2.S.7 */
      rDM2_S_8 @= { @ "DM2.S.8 : Space to INDDMY (Overlap is not allowed) >= " + DM2_S_8 + " um"; 
          external2( INDDMY, DUM2, < DM2_S_8, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          INDDMY and DUM2; 
      } /* end of rule : DM2.S.8 */
      
      // DM2.S.9 is not necessary to check
      rDM2_S_10 @= { @ "DM2.S.10 : Space to 45-degree bent Mx >= " + DM2_S_10 + " um2"; 
          X = edge_size( M2_EDGE_45, outside = DM2_S_10 ); 
          X and DUM2; 
      } /* end of rule : DM2.S.10 */
      #ifdef FULL_CHIP 
         rDM2_EN_1 @= { @ "DM2.EN.1 : Enclosure by chip edge >= " + DM2_EN_1 + " um"; 
             sLAYER_1119 = size( CHIP_CHAMFERED, clip_acute = NONE, distance = - DM2_EN_1 ); 
             DUM2 not sLAYER_1119; 
         } /* end of rule : DM2.EN.1 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      rDM2_A_1 @= { @ "DM2.A.1 : Min. area >= " + DM2_A_1 + " um2"; 
          area( DUM2, < DM2_A_1 ); 
      } /* end of rule : DM2.A.1 */
      rDM2_A_2 @= { @ "DM2.A.2 : Max. area <= " + DM2_A_2 + " um2"; 
          area( DUM2, > DM2_A_2 ); 
      } /* end of rule : DM2.A.2 */
      #ifdef FULL_CHIP 
         rDM2_R_1 @= { @ "DM2.R.1 : DM2 is a must. The DM2 CAD layer (TSMC default, 32;1 for DM2) must be different from the M2 CAD layer.";
             not_interacting( CHIPX, DUM2 ); 
         } /* end of rule : DM2.R.1 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      
      // DM2.R.2 is checked by related rules (CSR.R.1.LAYERS_NO_EXC)
      rDM2_R_3 @= { @ "DM2.R.3 : 0 or 45 degree solid shapes are allowed (Only rectangle and solid dummy is allowed)";
          not_rectangles( DUM2 ); 
          rectangles( DUM2 ) touching ( angle_edge(DUM2, angles = { (0,45), (45,90) }) );
          donut_holes( DUM2, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      } /* end of rule : DM2.R.3 */
      
      // DMx_O.R.1 is checked by DM2_O.R.1
      rDM2_O_R_1 @= { @ "DM2_O.R.1 : DM2_O interact M2 is not allowed";
          interacting( DM2_O, M2_REAL ); 
      } /* end of rule : DM2_O.R.1 */
      
      //DUMMY M3 CHECKS
      //==================
      rDM3_W_1 @= { @ "DM3.W.1 : Width >= " + DM3_W_1 + " um"; 
          internal1( DUM3, < DM3_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : DM3.W.1 */
      rDM3_W_2 @= { @ "DM3.W.2 : Width (maximum) (checked by sizing down 1.5 um) <= " + DM3_W_2 + " um"; 
          size( size( DUM3, - ( DM3_W_2 / 2 ), clip_acute = NONE ), DM3_W_2 / 2, clip_acute = NONE ); 
      } /* end of rule : DM3.W.2 */
      rDM3_S_1 @= { @ "DM3.S.1 : Space >= " + DM3_S_1 + " um"; 
          external1( DUM3, < DM3_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : DM3.S.1 */
      rDM3_S_2 @= { @ "DM3.S.2 : Space to M3 >= " + DM3_S_2 + " um"; 
          external2( M3I, DUM3, < DM3_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          M3I and DUM3; 
      } /* end of rule : DM3.S.2 */
      
      //DM3.S.3.S is checked by DM3.S.3
      rDM3_S_3 @= { @ "DM3.S.3 : Space to Mx (Overlap is not allowed) [Mx width > " + DM3_S_3_W + " um and the parallel metal run length > " + DM3_S_3_L + " um] >=  " + DM3_S_3; 
          X = external2( M3WIDE_4_p_5, DUM3, < DM3_S_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          contains( X, { DM3_S_2, DM3_S_3_L + 0.005 }, FORTY_FIVE ); 
      } /* end of rule : DM3.S.3 */
      
      //DM3.S.3.1.S is checked by DM3.S.3.1
      rDM3_S_3_1 @= { @ "DM3.S.3.1 : Space to Mx (Overlap is not allowed) [Mx width > " + DM3_S_3_1_W + " um and the parallel metal run length > " + DM3_S_3_1_L + " um] >= " + DM3_S_3_1; 
          X = external2( M3WIDE_1_p_5, DUM3, < DM3_S_3_1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          contains( X, { DM3_S_2, DM3_S_3_1_L + 0.005 }, FORTY_FIVE ); 
      } /* end of rule : DM3.S.3.1 */
      rDM3_S_4 @= { @ "DM3.S.4 : Space to FW (Overlap is not allowed) >= " + DM3_S_4 + " um"; 
          external2( FWI, DUM3, < DM3_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          FWI and DUM3; 
      } /* end of rule : DM3.S.4 */
      
      // DM3.S.5.0 is checked by DM3.S.5 and DM3.S.5.1
      // for solid L-mark (old)
      rDM3_S_5 @= { @ "DM3.S.5 : Space to LMARK (Overlap is not allowed) >= " + DM3_S_5 + " um"; 
          external2( LMARK_SOLID, DUM3, < DM3_S_5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          DUM3 and LMARK_SOLID; 
      } /* end of rule : DM3.S.5 */
      
      // for hollow L-mark (new)
      rDM3_S_5_1 @= { @ "DM3.S.5.1 : Space to L-slot (Overlap is not allowed) >= " + DM3_S_5_1 + " um"; 
          external2( LSLOT, DUM3, < DM3_S_5_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          DUM3 and LSLOT; 
      } /* end of rule : DM3.S.5.1 */
      rDM3_S_7 @= { @ "DM3.S.7 : Space to LOGO (Overlap is not allowed) >= 0.0 um";
          LOGO and DUM3; 
      } /* end of rule : DM3.S.7 */
      rDM3_S_8 @= { @ "DM3.S.8 : Space to INDDMY (Overlap is not allowed) >= " + DM3_S_8 + " um"; 
          external2( INDDMY, DUM3, < DM3_S_8, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          INDDMY and DUM3; 
      } /* end of rule : DM3.S.8 */
      
      // DM3.S.9 is not necessary to check
      rDM3_S_10 @= { @ "DM3.S.10 : Space to 45-degree bent Mx >= " + DM3_S_10 + " um2"; 
          X = edge_size( M3_EDGE_45, outside = DM3_S_10 ); 
          X and DUM3; 
      } /* end of rule : DM3.S.10 */
      #ifdef FULL_CHIP 
         rDM3_EN_1 @= { @ "DM3.EN.1 : Enclosure by chip edge >= " + DM3_EN_1 + " um"; 
             sLAYER_1120 = size( CHIP_CHAMFERED, clip_acute = NONE, distance = - DM3_EN_1 ); 
             DUM3 not sLAYER_1120; 
         } /* end of rule : DM3.EN.1 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      rDM3_A_1 @= { @ "DM3.A.1 : Min. area >= " + DM3_A_1 + " um2"; 
          area( DUM3, < DM3_A_1 ); 
      } /* end of rule : DM3.A.1 */
      rDM3_A_2 @= { @ "DM3.A.2 : Max. area <= " + DM3_A_2 + " um2"; 
          area( DUM3, > DM3_A_2 ); 
      } /* end of rule : DM3.A.2 */
      #ifdef FULL_CHIP 
         rDM3_R_1 @= { @ "DM3.R.1 : DM3 is a must. The DM3 CAD layer (TSMC default, 33;1 for DM3) must be different from the M3 CAD layer.";
             not_interacting( CHIPX, DUM3 ); 
         } /* end of rule : DM3.R.1 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      
      // DM3.R.2 is checked by related rules (CSR.R.1.LAYERS_NO_EXC)
      rDM3_R_3 @= { @ "DM3.R.3 : 0 or 45 degree solid shapes are allowed (Only rectangle and solid dummy is allowed)";
          not_rectangles( DUM3 ); 
          rectangles( DUM3 ) touching ( angle_edge(DUM3, angles = { (0,45), (45,90) }) );
          donut_holes( DUM3, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      } /* end of rule : DM3.R.3 */
      
      // DMx_O.R.1 is checked by DM3_O.R.1
      rDM3_O_R_1 @= { @ "DM3_O.R.1 : DM3_O interact M3 is not allowed";
          interacting( DM3_O, M3_REAL ); 
      } /* end of rule : DM3_O.R.1 */
      
      //DUMMY M4 CHECKS
      //==================
      rDM4_W_1 @= { @ "DM4.W.1 : Width >= " + DM4_W_1 + " um"; 
          internal1( DUM4, < DM4_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : DM4.W.1 */
      rDM4_W_2 @= { @ "DM4.W.2 : Width (maximum) (checked by sizing down 1.5 um) <= " + DM4_W_2 + " um"; 
          size( size( DUM4, - ( DM4_W_2 / 2 ), clip_acute = NONE ), DM4_W_2 / 2, clip_acute = NONE ); 
      } /* end of rule : DM4.W.2 */
      rDM4_S_1 @= { @ "DM4.S.1 : Space >= " + DM4_S_1 + " um"; 
          external1( DUM4, < DM4_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : DM4.S.1 */
      rDM4_S_2 @= { @ "DM4.S.2 : Space to M4 >= " + DM4_S_2 + " um"; 
          external2( M4I, DUM4, < DM4_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          M4I and DUM4; 
      } /* end of rule : DM4.S.2 */
      
      //DM4.S.3.S is checked by DM4.S.3
      rDM4_S_3 @= { @ "DM4.S.3 : Space to Mx (Overlap is not allowed) [Mx width > " + DM4_S_3_W + " um and the parallel metal run length > " + DM4_S_3_L + " um] >=  " + DM4_S_3; 
          X = external2( M4WIDE_4_p_5, DUM4, < DM4_S_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          contains( X, { DM4_S_2, DM4_S_3_L + 0.005 }, FORTY_FIVE ); 
      } /* end of rule : DM4.S.3 */
      
      //DM4.S.3.1.S is checked by DM4.S.3.1
      rDM4_S_3_1 @= { @ "DM4.S.3.1 : Space to Mx (Overlap is not allowed) [Mx width > " + DM4_S_3_1_W + " um and the parallel metal run length > " + DM4_S_3_1_L + " um] >= " + DM4_S_3_1; 
          X = external2( M4WIDE_1_p_5, DUM4, < DM4_S_3_1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          contains( X, { DM4_S_2, DM4_S_3_1_L + 0.005 }, FORTY_FIVE ); 
      } /* end of rule : DM4.S.3.1 */
      rDM4_S_4 @= { @ "DM4.S.4 : Space to FW (Overlap is not allowed) >= " + DM4_S_4 + " um"; 
          external2( FWI, DUM4, < DM4_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          FWI and DUM4; 
      } /* end of rule : DM4.S.4 */
      
      // DM4.S.5.0 is checked by DM4.S.5 and DM4.S.5.1
      // for solid L-mark (old)
      rDM4_S_5 @= { @ "DM4.S.5 : Space to LMARK (Overlap is not allowed) >= " + DM4_S_5 + " um"; 
          external2( LMARK_SOLID, DUM4, < DM4_S_5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          DUM4 and LMARK_SOLID; 
      } /* end of rule : DM4.S.5 */
      
      // for hollow L-mark (new)
      rDM4_S_5_1 @= { @ "DM4.S.5.1 : Space to L-slot (Overlap is not allowed) >= " + DM4_S_5_1 + " um"; 
          external2( LSLOT, DUM4, < DM4_S_5_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          DUM4 and LSLOT; 
      } /* end of rule : DM4.S.5.1 */
      rDM4_S_7 @= { @ "DM4.S.7 : Space to LOGO (Overlap is not allowed) >= 0.0 um";
          LOGO and DUM4; 
      } /* end of rule : DM4.S.7 */
      rDM4_S_8 @= { @ "DM4.S.8 : Space to INDDMY (Overlap is not allowed) >= " + DM4_S_8 + " um"; 
          external2( INDDMY, DUM4, < DM4_S_8, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          INDDMY and DUM4; 
      } /* end of rule : DM4.S.8 */
      
      // DM4.S.9 is not necessary to check
      rDM4_S_10 @= { @ "DM4.S.10 : Space to 45-degree bent Mx >= " + DM4_S_10 + " um2"; 
          X = edge_size( M4_EDGE_45, outside = DM4_S_10 ); 
          X and DUM4; 
      } /* end of rule : DM4.S.10 */
      #ifdef FULL_CHIP 
         rDM4_EN_1 @= { @ "DM4.EN.1 : Enclosure by chip edge >= " + DM4_EN_1 + " um"; 
             sLAYER_1121 = size( CHIP_CHAMFERED, clip_acute = NONE, distance = - DM4_EN_1 ); 
             DUM4 not sLAYER_1121; 
         } /* end of rule : DM4.EN.1 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      rDM4_A_1 @= { @ "DM4.A.1 : Min. area >= " + DM4_A_1 + " um2"; 
          area( DUM4, < DM4_A_1 ); 
      } /* end of rule : DM4.A.1 */
      rDM4_A_2 @= { @ "DM4.A.2 : Max. area <= " + DM4_A_2 + " um2"; 
          area( DUM4, > DM4_A_2 ); 
      } /* end of rule : DM4.A.2 */
      #ifdef FULL_CHIP 
         rDM4_R_1 @= { @ "DM4.R.1 : DM4 is a must. The DM4 CAD layer (TSMC default, 34;1 for DM4) must be different from the M4 CAD layer.";
             not_interacting( CHIPX, DUM4 ); 
         } /* end of rule : DM4.R.1 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      
      // DM4.R.2 is checked by related rules (CSR.R.1.LAYERS_NO_EXC)
      rDM4_R_3 @= { @ "DM4.R.3 : 0 or 45 degree solid shapes are allowed (Only rectangle and solid dummy is allowed)";
          not_rectangles( DUM4 ); 
          rectangles( DUM4 ) touching ( angle_edge(DUM4, angles = { (0,45), (45,90) }) );
          donut_holes( DUM4, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      } /* end of rule : DM4.R.3 */
      
      // DMx_O.R.1 is checked by DM4_O.R.1
      rDM4_O_R_1 @= { @ "DM4_O.R.1 : DM4_O interact M4 is not allowed";
          interacting( DM4_O, M4_REAL ); 
      } /* end of rule : DM4_O.R.1 */
      
      //DUMMY M5 CHECKS
      //==================
      rDM5_W_1 @= { @ "DM5.W.1 : Width >= " + DM5_W_1 + " um"; 
          internal1( DUM5, < DM5_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : DM5.W.1 */
      rDM5_W_2 @= { @ "DM5.W.2 : Width (maximum) (checked by sizing down 1.5 um) <= " + DM5_W_2 + " um"; 
          size( size( DUM5, - ( DM5_W_2 / 2 ), clip_acute = NONE ), DM5_W_2 / 2, clip_acute = NONE ); 
      } /* end of rule : DM5.W.2 */
      rDM5_S_1 @= { @ "DM5.S.1 : Space >= " + DM5_S_1 + " um"; 
          external1( DUM5, < DM5_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : DM5.S.1 */
      rDM5_S_2 @= { @ "DM5.S.2 : Space to M5 >= " + DM5_S_2 + " um"; 
          external2( M5I, DUM5, < DM5_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          M5I and DUM5; 
      } /* end of rule : DM5.S.2 */
      
      //DM5.S.3.S is checked by DM5.S.3
      rDM5_S_3 @= { @ "DM5.S.3 : Space to Mx (Overlap is not allowed) [Mx width > " + DM5_S_3_W + " um and the parallel metal run length > " + DM5_S_3_L + " um] >=  " + DM5_S_3; 
          X = external2( M5WIDE_4_p_5, DUM5, < DM5_S_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          contains( X, { DM5_S_2, DM5_S_3_L + 0.005 }, FORTY_FIVE ); 
      } /* end of rule : DM5.S.3 */
      
      //DM5.S.3.1.S is checked by DM5.S.3.1
      rDM5_S_3_1 @= { @ "DM5.S.3.1 : Space to Mx (Overlap is not allowed) [Mx width > " + DM5_S_3_1_W + " um and the parallel metal run length > " + DM5_S_3_1_L + " um] >= " + DM5_S_3_1; 
          X = external2( M5WIDE_1_p_5, DUM5, < DM5_S_3_1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          contains( X, { DM5_S_2, DM5_S_3_1_L + 0.005 }, FORTY_FIVE ); 
      } /* end of rule : DM5.S.3.1 */
      rDM5_S_4 @= { @ "DM5.S.4 : Space to FW (Overlap is not allowed) >= " + DM5_S_4 + " um"; 
          external2( FWI, DUM5, < DM5_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          FWI and DUM5; 
      } /* end of rule : DM5.S.4 */
      
      // DM5.S.5.0 is checked by DM5.S.5 and DM5.S.5.1
      // for solid L-mark (old)
      rDM5_S_5 @= { @ "DM5.S.5 : Space to LMARK (Overlap is not allowed) >= " + DM5_S_5 + " um"; 
          external2( LMARK_SOLID, DUM5, < DM5_S_5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          DUM5 and LMARK_SOLID; 
      } /* end of rule : DM5.S.5 */
      
      // for hollow L-mark (new)
      rDM5_S_5_1 @= { @ "DM5.S.5.1 : Space to L-slot (Overlap is not allowed) >= " + DM5_S_5_1 + " um"; 
          external2( LSLOT, DUM5, < DM5_S_5_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          DUM5 and LSLOT; 
      } /* end of rule : DM5.S.5.1 */
      rDM5_S_7 @= { @ "DM5.S.7 : Space to LOGO (Overlap is not allowed) >= 0.0 um";
          LOGO and DUM5; 
      } /* end of rule : DM5.S.7 */
      rDM5_S_8 @= { @ "DM5.S.8 : Space to INDDMY (Overlap is not allowed) >= " + DM5_S_8 + " um"; 
          external2( INDDMY, DUM5, < DM5_S_8, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          INDDMY and DUM5; 
      } /* end of rule : DM5.S.8 */
      
      // DM5.S.9 is not necessary to check
      rDM5_S_10 @= { @ "DM5.S.10 : Space to 45-degree bent Mx >= " + DM5_S_10 + " um2"; 
          X = edge_size( M5_EDGE_45, outside = DM5_S_10 ); 
          X and DUM5; 
      } /* end of rule : DM5.S.10 */
      #ifdef FULL_CHIP 
         rDM5_EN_1 @= { @ "DM5.EN.1 : Enclosure by chip edge >= " + DM5_EN_1 + " um"; 
             sLAYER_1122 = size( CHIP_CHAMFERED, clip_acute = NONE, distance = - DM5_EN_1 ); 
             DUM5 not sLAYER_1122; 
         } /* end of rule : DM5.EN.1 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      rDM5_A_1 @= { @ "DM5.A.1 : Min. area >= " + DM5_A_1 + " um2"; 
          area( DUM5, < DM5_A_1 ); 
      } /* end of rule : DM5.A.1 */
      rDM5_A_2 @= { @ "DM5.A.2 : Max. area <= " + DM5_A_2 + " um2"; 
          area( DUM5, > DM5_A_2 ); 
      } /* end of rule : DM5.A.2 */
      #ifdef FULL_CHIP 
         rDM5_R_1 @= { @ "DM5.R.1 : DM5 is a must. The DM5 CAD layer (TSMC default, 35;1 for DM5) must be different from the M5 CAD layer.";
             not_interacting( CHIPX, DUM5 ); 
         } /* end of rule : DM5.R.1 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      
      // DM5.R.2 is checked by related rules (CSR.R.1.LAYERS_NO_EXC)
      rDM5_R_3 @= { @ "DM5.R.3 : 0 or 45 degree solid shapes are allowed (Only rectangle and solid dummy is allowed)";
          not_rectangles( DUM5 ); 
          rectangles( DUM5 ) touching ( angle_edge(DUM5, angles = { (0,45), (45,90) }) );
          donut_holes( DUM5, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      } /* end of rule : DM5.R.3 */
      
      // DMx_O.R.1 is checked by DM5_O.R.1
      rDM5_O_R_1 @= { @ "DM5_O.R.1 : DM5_O interact M5 is not allowed";
          interacting( DM5_O, M5_REAL ); 
      } /* end of rule : DM5_O.R.1 */
      
      //DUMMY M6 CHECKS
      //==================
      rDM6_W_1 @= { @ "DM6.W.1 : Width >= " + DM6_W_1 + " um"; 
          internal1( DUM6, < DM6_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : DM6.W.1 */
      rDM6_W_2 @= { @ "DM6.W.2 : Width (maximum) (checked by sizing down 1.5 um) <= " + DM6_W_2 + " um"; 
          size( size( DUM6, - ( DM6_W_2 / 2 ), clip_acute = NONE ), DM6_W_2 / 2, clip_acute = NONE ); 
      } /* end of rule : DM6.W.2 */
      rDM6_S_1 @= { @ "DM6.S.1 : Space >= " + DM6_S_1 + " um"; 
          external1( DUM6, < DM6_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : DM6.S.1 */
      rDM6_S_2 @= { @ "DM6.S.2 : Space to M6 >= " + DM6_S_2 + " um"; 
          external2( M6I, DUM6, < DM6_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          M6I and DUM6; 
      } /* end of rule : DM6.S.2 */
      
      //DM6.S.3.S is checked by DM6.S.3
      rDM6_S_3 @= { @ "DM6.S.3 : Space to Mx (Overlap is not allowed) [Mx width > " + DM6_S_3_W + " um and the parallel metal run length > " + DM6_S_3_L + " um] >=  " + DM6_S_3; 
          X = external2( M6WIDE_4_p_5, DUM6, < DM6_S_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          contains( X, { DM6_S_2, DM6_S_3_L + 0.005 }, FORTY_FIVE ); 
      } /* end of rule : DM6.S.3 */
      
      //DM6.S.3.1.S is checked by DM6.S.3.1
      rDM6_S_3_1 @= { @ "DM6.S.3.1 : Space to Mx (Overlap is not allowed) [Mx width > " + DM6_S_3_1_W + " um and the parallel metal run length > " + DM6_S_3_1_L + " um] >= " + DM6_S_3_1; 
          X = external2( M6WIDE_1_p_5, DUM6, < DM6_S_3_1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          contains( X, { DM6_S_2, DM6_S_3_1_L + 0.005 }, FORTY_FIVE ); 
      } /* end of rule : DM6.S.3.1 */
      rDM6_S_4 @= { @ "DM6.S.4 : Space to FW (Overlap is not allowed) >= " + DM6_S_4 + " um"; 
          external2( FWI, DUM6, < DM6_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          FWI and DUM6; 
      } /* end of rule : DM6.S.4 */
      
      // DM6.S.5.0 is checked by DM6.S.5 and DM6.S.5.1
      // for solid L-mark (old)
      rDM6_S_5 @= { @ "DM6.S.5 : Space to LMARK (Overlap is not allowed) >= " + DM6_S_5 + " um"; 
          external2( LMARK_SOLID, DUM6, < DM6_S_5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          DUM6 and LMARK_SOLID; 
      } /* end of rule : DM6.S.5 */
      
      // for hollow L-mark (new)
      rDM6_S_5_1 @= { @ "DM6.S.5.1 : Space to L-slot (Overlap is not allowed) >= " + DM6_S_5_1 + " um"; 
          external2( LSLOT, DUM6, < DM6_S_5_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          DUM6 and LSLOT; 
      } /* end of rule : DM6.S.5.1 */
      rDM6_S_7 @= { @ "DM6.S.7 : Space to LOGO (Overlap is not allowed) >= 0.0 um";
          LOGO and DUM6; 
      } /* end of rule : DM6.S.7 */
      rDM6_S_8 @= { @ "DM6.S.8 : Space to INDDMY (Overlap is not allowed) >= " + DM6_S_8 + " um"; 
          external2( INDDMY, DUM6, < DM6_S_8, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          INDDMY and DUM6; 
      } /* end of rule : DM6.S.8 */
      
      // DM6.S.9 is not necessary to check
      rDM6_S_10 @= { @ "DM6.S.10 : Space to 45-degree bent Mx >= " + DM6_S_10 + " um2"; 
          X = edge_size( M6_EDGE_45, outside = DM6_S_10 ); 
          X and DUM6; 
      } /* end of rule : DM6.S.10 */
      #ifdef FULL_CHIP 
         rDM6_EN_1 @= { @ "DM6.EN.1 : Enclosure by chip edge >= " + DM6_EN_1 + " um"; 
             sLAYER_1123 = size( CHIP_CHAMFERED, clip_acute = NONE, distance = - DM6_EN_1 ); 
             DUM6 not sLAYER_1123; 
         } /* end of rule : DM6.EN.1 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      rDM6_A_1 @= { @ "DM6.A.1 : Min. area >= " + DM6_A_1 + " um2"; 
          area( DUM6, < DM6_A_1 ); 
      } /* end of rule : DM6.A.1 */
      rDM6_A_2 @= { @ "DM6.A.2 : Max. area <= " + DM6_A_2 + " um2"; 
          area( DUM6, > DM6_A_2 ); 
      } /* end of rule : DM6.A.2 */
      #ifdef FULL_CHIP 
         rDM6_R_1 @= { @ "DM6.R.1 : DM6 is a must. The DM6 CAD layer (TSMC default, 36;1 for DM6) must be different from the M6 CAD layer.";
             not_interacting( CHIPX, DUM6 ); 
         } /* end of rule : DM6.R.1 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      
      // DM6.R.2 is checked by related rules (CSR.R.1.LAYERS_NO_EXC)
      rDM6_R_3 @= { @ "DM6.R.3 : 0 or 45 degree solid shapes are allowed (Only rectangle and solid dummy is allowed)";
          not_rectangles( DUM6 ); 
          rectangles( DUM6 ) touching ( angle_edge(DUM6, angles = { (0,45), (45,90) }) );
          donut_holes( DUM6, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      } /* end of rule : DM6.R.3 */
      
      // DMx_O.R.1 is checked by DM6_O.R.1
      rDM6_O_R_1 @= { @ "DM6_O.R.1 : DM6_O interact M6 is not allowed";
          interacting( DM6_O, M6_REAL ); 
      } /* end of rule : DM6_O.R.1 */
      
      //DUMMY M7 CHECKS
      //==================
      rDM7_W_1 @= { @ "DM7.W.1 : Width >= " + DM7_W_1 + " um"; 
          internal1( DUM7, < DM7_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : DM7.W.1 */
      rDM7_W_2 @= { @ "DM7.W.2 : Width (maximum) (checked by sizing down 1.5 um) <= " + DM7_W_2 + " um"; 
          size( size( DUM7, - ( DM7_W_2 / 2 ), clip_acute = NONE ), DM7_W_2 / 2, clip_acute = NONE ); 
      } /* end of rule : DM7.W.2 */
      rDM7_S_1 @= { @ "DM7.S.1 : Space >= " + DM7_S_1 + " um"; 
          external1( DUM7, < DM7_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : DM7.S.1 */
      rDM7_S_2 @= { @ "DM7.S.2 : Space to M7 >= " + DM7_S_2 + " um"; 
          external2( M7I, DUM7, < DM7_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          M7I and DUM7; 
      } /* end of rule : DM7.S.2 */
      
      //DM7.S.3.S is checked by DM7.S.3
      rDM7_S_3 @= { @ "DM7.S.3 : Space to Mx (Overlap is not allowed) [Mx width > " + DM7_S_3_W + " um and the parallel metal run length > " + DM7_S_3_L + " um] >=  " + DM7_S_3; 
          X = external2( M7WIDE_4_p_5, DUM7, < DM7_S_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          contains( X, { DM7_S_2, DM7_S_3_L + 0.005 }, FORTY_FIVE ); 
      } /* end of rule : DM7.S.3 */
      
      //DM7.S.3.1.S is checked by DM7.S.3.1
      rDM7_S_3_1 @= { @ "DM7.S.3.1 : Space to Mx (Overlap is not allowed) [Mx width > " + DM7_S_3_1_W + " um and the parallel metal run length > " + DM7_S_3_1_L + " um] >= " + DM7_S_3_1; 
          X = external2( M7WIDE_1_p_5, DUM7, < DM7_S_3_1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          contains( X, { DM7_S_2, DM7_S_3_1_L + 0.005 }, FORTY_FIVE ); 
      } /* end of rule : DM7.S.3.1 */
      rDM7_S_4 @= { @ "DM7.S.4 : Space to FW (Overlap is not allowed) >= " + DM7_S_4 + " um"; 
          external2( FWI, DUM7, < DM7_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          FWI and DUM7; 
      } /* end of rule : DM7.S.4 */
      
      // DM7.S.5.0 is checked by DM7.S.5 and DM7.S.5.1
      // for solid L-mark (old)
      rDM7_S_5 @= { @ "DM7.S.5 : Space to LMARK (Overlap is not allowed) >= " + DM7_S_5 + " um"; 
          external2( LMARK_SOLID, DUM7, < DM7_S_5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          DUM7 and LMARK_SOLID; 
      } /* end of rule : DM7.S.5 */
      
      // for hollow L-mark (new)
      rDM7_S_5_1 @= { @ "DM7.S.5.1 : Space to L-slot (Overlap is not allowed) >= " + DM7_S_5_1 + " um"; 
          external2( LSLOT, DUM7, < DM7_S_5_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          DUM7 and LSLOT; 
      } /* end of rule : DM7.S.5.1 */
      rDM7_S_7 @= { @ "DM7.S.7 : Space to LOGO (Overlap is not allowed) >= 0.0 um";
          LOGO and DUM7; 
      } /* end of rule : DM7.S.7 */
      rDM7_S_8 @= { @ "DM7.S.8 : Space to INDDMY (Overlap is not allowed) >= " + DM7_S_8 + " um"; 
          external2( INDDMY, DUM7, < DM7_S_8, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          INDDMY and DUM7; 
      } /* end of rule : DM7.S.8 */
      rDM7_S_9 @= { @ "DM7.S.9 : Space to CBM [CBM between Mx and Mx+1] (Overlap is not allowed) >= " + DM7_S_9 + " um"; 
          external2( CBM, DUM7, < DM7_S_9, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          CBM and DUM7; 
      } /* end of rule : DM7.S.9 */
      rDM7_S_10 @= { @ "DM7.S.10 : Space to 45-degree bent Mx >= " + DM7_S_10 + " um2"; 
          X = edge_size( M7_EDGE_45, outside = DM7_S_10 ); 
          X and DUM7; 
      } /* end of rule : DM7.S.10 */
      #ifdef FULL_CHIP 
         rDM7_EN_1 @= { @ "DM7.EN.1 : Enclosure by chip edge >= " + DM7_EN_1 + " um"; 
             sLAYER_1124 = size( CHIP_CHAMFERED, clip_acute = NONE, distance = - DM7_EN_1 ); 
             DUM7 not sLAYER_1124; 
         } /* end of rule : DM7.EN.1 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      rDM7_A_1 @= { @ "DM7.A.1 : Min. area >= " + DM7_A_1 + " um2"; 
          area( DUM7, < DM7_A_1 ); 
      } /* end of rule : DM7.A.1 */
      rDM7_A_2 @= { @ "DM7.A.2 : Max. area <= " + DM7_A_2 + " um2"; 
          area( DUM7, > DM7_A_2 ); 
      } /* end of rule : DM7.A.2 */
      #ifdef FULL_CHIP 
         rDM7_R_1 @= { @ "DM7.R.1 : DM7 is a must. The DM7 CAD layer (TSMC default, 37;1 for DM7) must be different from the M7 CAD layer.";
             not_interacting( CHIPX, DUM7 ); 
         } /* end of rule : DM7.R.1 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      
      // DM7.R.2 is checked by related rules (CSR.R.1.LAYERS_NO_EXC)
      rDM7_R_3 @= { @ "DM7.R.3 : 0 or 45 degree solid shapes are allowed (Only rectangle and solid dummy is allowed)";
          not_rectangles( DUM7 ); 
          rectangles( DUM7 ) touching ( angle_edge(DUM7, angles = { (0,45), (45,90) }) );
          donut_holes( DUM7, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      } /* end of rule : DM7.R.3 */
      
      // DMx_O.R.1 is checked by DM7_O.R.1
      rDM7_O_R_1 @= { @ "DM7_O.R.1 : DM7_O interact M7 is not allowed";
          interacting( DM7_O, M7_REAL ); 
      } /* end of rule : DM7_O.R.1 */
      
      //DUMMY M8 CHECKS
      //==================
      rDM8_W_1 @= { @ "DM8.W.1 : Width >= " + DM8_W_1 + " um"; 
          internal1( DUM8, < DM8_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : DM8.W.1 */
      rDM8_W_2 @= { @ "DM8.W.2 : Width (maximum) (checked by sizing down 1.5 um) <= " + DM8_W_2 + " um"; 
          size( size( DUM8, - ( DM8_W_2 / 2 ), clip_acute = NONE ), DM8_W_2 / 2, clip_acute = NONE ); 
      } /* end of rule : DM8.W.2 */
      rDM8_S_1 @= { @ "DM8.S.1 : Space >= " + DM8_S_1 + " um"; 
          external1( DUM8, < DM8_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : DM8.S.1 */
      rDM8_S_2 @= { @ "DM8.S.2 : Space to M8 >= " + DM8_S_2 + " um"; 
          external2( M8I, DUM8, < DM8_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          M8I and DUM8; 
      } /* end of rule : DM8.S.2 */
      
      //DM8.S.3.S is checked by DM8.S.3
      rDM8_S_3 @= { @ "DM8.S.3 : Space to Mx (Overlap is not allowed) [Mx width > " + DM8_S_3_W + " um and the parallel metal run length > " + DM8_S_3_L + " um] >=  " + DM8_S_3; 
          X = external2( M8WIDE_4_p_5, DUM8, < DM8_S_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          contains( X, { DM8_S_2, DM8_S_3_L + 0.005 }, FORTY_FIVE ); 
      } /* end of rule : DM8.S.3 */
      
      //DM8.S.3.1 is not necessary to check ; DM8 is not Mx
      //DM8.S.3.1.S is not necessary to check ; DM8 is not Mx
      rDM8_S_4 @= { @ "DM8.S.4 : Space to FW (Overlap is not allowed) >= " + DM8_S_4 + " um"; 
          external2( FWI, DUM8, < DM8_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          FWI and DUM8; 
      } /* end of rule : DM8.S.4 */
      
      // DM8.S.5.0 is checked by DM8.S.5 and DM8.S.5.1
      // for solid L-mark (old)
      rDM8_S_5 @= { @ "DM8.S.5 : Space to LMARK (Overlap is not allowed) >= " + DM8_S_5 + " um"; 
          external2( LMARK_SOLID, DUM8, < DM8_S_5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          DUM8 and LMARK_SOLID; 
      } /* end of rule : DM8.S.5 */
      
      // for hollow L-mark (new)
      rDM8_S_5_1 @= { @ "DM8.S.5.1 : Space to L-slot (Overlap is not allowed) >= " + DM8_S_5_1 + " um"; 
          external2( LSLOT, DUM8, < DM8_S_5_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          DUM8 and LSLOT; 
      } /* end of rule : DM8.S.5.1 */
      rDM8_S_7 @= { @ "DM8.S.7 : Space to LOGO (Overlap is not allowed) >= 0.0 um";
          LOGO and DUM8; 
      } /* end of rule : DM8.S.7 */
      rDM8_S_8 @= { @ "DM8.S.8 : Space to INDDMY (Overlap is not allowed) >= " + DM8_S_8 + " um"; 
          external2( INDDMY, DUM8, < DM8_S_8, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          INDDMY and DUM8; 
      } /* end of rule : DM8.S.8 */
      
      // DM8.S.9 is not necessary to check
      
      // DM8.S.10 is not necessary to check
      #ifdef FULL_CHIP 
         rDM8_EN_1 @= { @ "DM8.EN.1 : Enclosure by chip edge >= " + DM8_EN_1 + " um"; 
             sLAYER_1125 = size( CHIP_CHAMFERED, clip_acute = NONE, distance = - DM8_EN_1 ); 
             DUM8 not sLAYER_1125; 
         } /* end of rule : DM8.EN.1 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      rDM8_A_1 @= { @ "DM8.A.1 : Min. area >= " + DM8_A_1 + " um2"; 
          area( DUM8, < DM8_A_1 ); 
      } /* end of rule : DM8.A.1 */
      rDM8_A_2 @= { @ "DM8.A.2 : Max. area <= " + DM8_A_2 + " um2"; 
          area( DUM8, > DM8_A_2 ); 
      } /* end of rule : DM8.A.2 */
      #ifdef FULL_CHIP 
         rDM8_R_1 @= { @ "DM8.R.1 : DM8 is a must. The DM8 CAD layer (TSMC default, 38;41 for DM8) must be different from the M8 CAD layer.";
             not_interacting( CHIPX, DUM8 ); 
         } /* end of rule : DM8.R.1 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      
      // DM8.R.2 is checked by related rules (CSR.R.1.LAYERS_NO_EXC)
      rDM8_R_3 @= { @ "DM8.R.3 : 0 or 45 degree solid shapes are allowed (Only rectangle and solid dummy is allowed)";
          not_rectangles( DUM8 ); 
          rectangles( DUM8 ) touching ( angle_edge(DUM8, angles = { (0,45), (45,90) }) );
          donut_holes( DUM8, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      } /* end of rule : DM8.R.3 */
      
      //DUMMY M9 CHECKS
      //==================
      rDM9_W_1 @= { @ "DM9.W.1 : Width >= " + DM9_W_1 + " um"; 
          internal1( DUM9, < DM9_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : DM9.W.1 */
      rDM9_W_2 @= { @ "DM9.W.2 : Width (maximum) (checked by sizing down 1.5 um) <= " + DM9_W_2 + " um"; 
          size( size( DUM9, - ( DM9_W_2 / 2 ), clip_acute = NONE ), DM9_W_2 / 2, clip_acute = NONE ); 
      } /* end of rule : DM9.W.2 */
      rDM9_S_1 @= { @ "DM9.S.1 : Space >= " + DM9_S_1 + " um"; 
          external1( DUM9, < DM9_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : DM9.S.1 */
      rDM9_S_2 @= { @ "DM9.S.2 : Space to M9 >= " + DM9_S_2 + " um"; 
          external2( M9I, DUM9, < DM9_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          M9I and DUM9; 
      } /* end of rule : DM9.S.2 */
      
      //DM9.S.3.S is checked by DM9.S.3
      rDM9_S_3 @= { @ "DM9.S.3 : Space to Mx (Overlap is not allowed) [Mx width > " + DM9_S_3_W + " um and the parallel metal run length > " + DM9_S_3_L + " um] >=  " + DM9_S_3; 
          X = external2( M9WIDE_4_p_5, DUM9, < DM9_S_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = ALL, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          contains( X, { DM9_S_2, DM9_S_3_L + 0.005 }, FORTY_FIVE ); 
      } /* end of rule : DM9.S.3 */
      
      //DM9.S.3.1 is not necessary to check ; DM9 is not Mx
      //DM9.S.3.1.S is not necessary to check ; DM9 is not Mx
      rDM9_S_4 @= { @ "DM9.S.4 : Space to FW (Overlap is not allowed) >= " + DM9_S_4 + " um"; 
          external2( FWI, DUM9, < DM9_S_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          FWI and DUM9; 
      } /* end of rule : DM9.S.4 */
      
      // DM9.S.5.0 is checked by DM9.S.5 and DM9.S.5.1
      // for solid L-mark (old)
      rDM9_S_5 @= { @ "DM9.S.5 : Space to LMARK (Overlap is not allowed) >= " + DM9_S_5 + " um"; 
          external2( LMARK_SOLID, DUM9, < DM9_S_5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          DUM9 and LMARK_SOLID; 
      } /* end of rule : DM9.S.5 */
      
      // for hollow L-mark (new)
      rDM9_S_5_1 @= { @ "DM9.S.5.1 : Space to L-slot (Overlap is not allowed) >= " + DM9_S_5_1 + " um"; 
          external2( LSLOT, DUM9, < DM9_S_5_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          DUM9 and LSLOT; 
      } /* end of rule : DM9.S.5.1 */
      rDM9_S_7 @= { @ "DM9.S.7 : Space to LOGO (Overlap is not allowed) >= 0.0 um";
          LOGO and DUM9; 
      } /* end of rule : DM9.S.7 */
      rDM9_S_8 @= { @ "DM9.S.8 : Space to INDDMY (Overlap is not allowed) >= " + DM9_S_8 + " um"; 
          external2( INDDMY, DUM9, < DM9_S_8, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          INDDMY and DUM9; 
      } /* end of rule : DM9.S.8 */
      
      // DM9.S.9 is not necessary to check
      
      // DM9.S.10 is not necessary to check
      #ifdef FULL_CHIP 
         rDM9_EN_1 @= { @ "DM9.EN.1 : Enclosure by chip edge >= " + DM9_EN_1 + " um"; 
             sLAYER_1126 = size( CHIP_CHAMFERED, clip_acute = NONE, distance = - DM9_EN_1 ); 
             DUM9 not sLAYER_1126; 
         } /* end of rule : DM9.EN.1 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      rDM9_A_1 @= { @ "DM9.A.1 : Min. area >= " + DM9_A_1 + " um2"; 
          area( DUM9, < DM9_A_1 ); 
      } /* end of rule : DM9.A.1 */
      rDM9_A_2 @= { @ "DM9.A.2 : Max. area <= " + DM9_A_2 + " um2"; 
          area( DUM9, > DM9_A_2 ); 
      } /* end of rule : DM9.A.2 */
      #ifdef FULL_CHIP 
         rDM9_R_1 @= { @ "DM9.R.1 : DM9 is a must. The DM9 CAD layer (TSMC default, 39;41 for DM9) must be different from the M9 CAD layer.";
             not_interacting( CHIPX, DUM9 ); 
         } /* end of rule : DM9.R.1 */
      #endif /* end of #ifdef FULL_CHIP  */ 
      
      // DM9.R.2 is checked by related rules (CSR.R.1.LAYERS_NO_EXC)
      rDM9_R_3 @= { @ "DM9.R.3 : 0 or 45 degree solid shapes are allowed (Only rectangle and solid dummy is allowed)";
          not_rectangles( DUM9 ); 
          rectangles( DUM9 ) touching ( angle_edge(DUM9, angles = { (0,45), (45,90) }) );
          donut_holes( DUM9, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      } /* end of rule : DM9.R.3 */
      
      // RV Layout Rules  
      //==============================================
      RV_CHECK = RV not_inside SR_EDGE; 
      gLAYER_599 = IND_EXD or IND_MD_EXD; 
      RV_CHECK_INSIDE = RV_CHECK not_outside gLAYER_599; 
      RV_CHECK_OUTSIDE = RV_CHECK not RV_CHECK_INSIDE; 
      
      //RV.W.1.FC is checked by RV.W.1.WB
      rRV_W_1_WB @= { @ "RV.W.1.WB : Width (maximum = minimum) (Not inside seal ring) = " + RV_W_1 + " um"; 
          not_rectangles( RV_CHECK, orientation = ORTHOGONAL, sides = { == RV_W_1, == RV_W_1 } ); 
      } /* end of rule : RV.W.1.WB */
      
      //RV.S.1.FC is checked by RV.S.1.WB 
      rRV_S_1_WB @= { @ "RV.S.1.WB : Space >= " + RV_S_1 + " um"; 
          external1( RV_CHECK_OUTSIDE, < RV_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          external1( RV_CHECK_INSIDE, < ( RV_S_1 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : RV.S.1.WB */
      
      //RV.S.2.FC is checked by related rules (in flip chip DRC)
      rRV_S_3_WB @= { @ "RV.S.3.WB : Space to CB/CB2/FW {Overlap is not allowed} >= " + RV_S_3 + " um"; 
          external2( RV_CHECK, CB, < RV_S_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          RV_CHECK and CB; 
          external2( RV_CHECK, CB2, < RV_S_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          RV_CHECK and CB2; 
          external2( RV_CHECK, FW, < RV_S_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          RV_CHECK and FW; 
      } /* end of rule : RV.S.3.WB */
      
      //RV.EN.1.FC is checked by RV.EN.1.WB
      rRV_EN_1_WB @= { @ "RV.EN.1.WB : Enclosure by Mtop (Not inside seal ring) >= " + RV_EN_1 + " um"; 
          enclose( RV_CHECK_OUTSIDE, M9, < RV_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          enclose( RV_CHECK_INSIDE, M9, < ( RV_EN_1 - 0.01 ), extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          RV_CHECK not M9; 
      } /* end of rule : RV.EN.1.WB */
      
      //RV.R.1.FC is checked by RV.R.1.WB
      #ifdef WLCSP_SEALRING 
         rRV_R_1_WB @= { @ "RV.R.1.WB : A 45-degree rotated RV is prohibited.";
             angle_edge( RV_CHECK, ( 0, 90 ) ); 
         } /* end of rule : RV.R.1.WB */
      #else /* the reverse of #ifdef WLCSP_SEALRING  */ 
         rRV_R_1_WB @= { @ "RV.R.1.WB : A 45-degree rotated RV is prohibited.";
             angle_edge( RV, ( 0, 90 ) ); 
         } /* end of rule : RV.R.1.WB */
      #endif /* end of #ifdef WLCSP_SEALRING  */ 
      
      //RV.R.2.WB is checked by related rules (in wire-bond DRC)
      
      //RV.R.3.FC is checked by related rules (in flip-chip DRC)
      
      // AP Layout Rules
      //=================
      AP_CHECK = AP not_inside SR_EDGE; 
      gLAYER_600 = FW_AP or RV; 
      CHIP_INT_AP = interacting( CHIP_EDGE, gLAYER_600 ); 
      CB_CHECK = CB not_inside SR_EDGE; 
      CB2_CHECK = CB2 not_inside SR_EDGE; 
      CBD_CHECK = CBD not_inside SR_EDGE; 
      CB_CHECK2 = interacting( CB_CHECK, CHIP_INT_AP ); 
      CB2_CHECK2 = interacting( CB2_CHECK, CHIP_INT_AP ); 
      gLAYER_601 = IND_EXD or IND_MD_EXD; 
      AP_CHECK_INSIDE = AP_CHECK not_outside gLAYER_601; 
      AP_CHECK_OUTSIDE = AP_CHECK not AP_CHECK_INSIDE; 
      
      //AP.W.1.FC is checked by AP.W.1.WB    
      rAP_W_1_WB @= { @ "AP.W.1.WB : Width [interconnect only] [ not inside FW_AP or sealring] >= " + AP_W_1 + " um"; 
          A = AP_CHECK_OUTSIDE not FW_AP; 
          B = AP_CHECK_INSIDE not FW_AP; 
          internal1( A, < AP_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          internal1( B, < ( AP_W_1 - 0.01 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
      } /* end of rule : AP.W.1.WB */
      
      //AP.W.2.FC is checked by AP.W.2.WB
      rAP_W_2_WB @= { @ "AP.W.2.WB : Maximum width [interconnect only] [ not inside UBM, CB or CB2] <= " + AP_W_2 + " um"; 
          sLAYER_1130 = IND_EXD or IND_MD_EXD; 
          sLAYER_1129 = AP outside sLAYER_1130; 
          sLAYER_1128 = sLAYER_1129 not UBM; 
          sLAYER_1127 = sLAYER_1128 not CB; 
          A = sLAYER_1127 not CB2; 
          sLAYER_1134 = IND_EXD or IND_MD_EXD; 
          sLAYER_1133 = AP and sLAYER_1134; 
          sLAYER_1132 = sLAYER_1133 not UBM; 
          sLAYER_1131 = sLAYER_1132 not CB; 
          B = sLAYER_1131 not CB2; 
          wide( A, > AP_W_2, forty_five = INTERNAL ); 
          wide( B, > ( AP_W_2 + 0.01 ), forty_five = INTERNAL ); 
      } /* end of rule : AP.W.2.WB */
      #ifdef _28K_AP 
         AP_HOLE = donut_holes( AP, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
         AP_HOLE_SHOURT_EDGE = length_edge( AP_HOLE, < 3 ); 
         gLAYER_1150 = internal1( AP_HOLE, <= 0.01, extension = RADIAL, intersecting = { } ); 
         gLAYER_1151 = vertex( AP_HOLE, angles = { 90 }, shape = TRIANGLE, shape_size = 0.01 ); 
         GRID_VERTEX = gLAYER_1150 or gLAYER_1151; 
         AP_HOLE_SHOURT_EDGE_REGION = edge_size( AP_HOLE_SHOURT_EDGE, inside = 0.005 ); 
         GRID_VERTEX_CHECK = interacting( GRID_VERTEX, AP_HOLE_SHOURT_EDGE_REGION ); 
         GRID_EXTENT = polygon_centers( GRID_VERTEX_CHECK, 0.01 ); 
         
         //AP.W.3.FC is checked by AP.W.3.WB
         rAP_W_3_WB @= { @ "AP.W.3.WB : AP hole width for 28KA AP should >= " + AP_W_3 + ", except < 100 inner 90-degrees vertex of AP holes [width < " + AP_W_3 + " um] within window 100 um x 100 um, stepping 50 um"; 
             VAR_134 = density_statistics_file( file = "AP.W.3.density" ); 
         _den_con = >= 100;
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIP_EDGE, layer_hash = { "layer1" => GRID_EXTENT }, delta_window = { 100, 100 }, delta_x = 50, delta_y = 50, boundary = BACKUP, statistics_files = { VAR_134 }, window_function = den_save_window_14 ); 
         } /* end of rule : AP.W.3.WB */
      #endif /* end of #ifdef _28K_AP  */ 
      rAP_S_1_FC @= { @ "AP.S.1.FC : Space (Except space in the same polygon within {UBM SIZING 5um} region) >= " + AP_S_1 + " um"; 
          A = size( UBM, clip_acute = NONE, distance = 5 ); 
          external1( AP, < AP_S_1, extension = RADIAL, intersecting = {  }, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, relational = { POINT_TOUCH } ); 
          sLAYER_1135 = external1( AP, < AP_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, relational = { POINT_TOUCH } ); 
          sLAYER_1135 not A; 
      } /* end of rule : AP.S.1.FC */
      rAP_S_1_WB @= { @ "AP.S.1.WB : Space (Except space in the same polygon within {CB2 SIZING 5um} region) >= " + AP_S_1 + " um"; 
          A = size( CB2, clip_acute = NONE, distance = 5 ); 
          external1( AP, < AP_S_1, extension = RADIAL, intersecting = {  }, look_thru = NOT_ADJACENT, membership = DIFFERENT_POLYGON, relational = { POINT_TOUCH } ); 
          sLAYER_1136 = external1( AP, < AP_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, membership = SAME_POLYGON, relational = { POINT_TOUCH } ); 
          sLAYER_1136 not A; 
      } /* end of rule : AP.S.1.WB */
      
      //AP.S.1.1.WB is checked by related rules (in wire-bond DRC)
      //AP.S.2.FC is checked by AP.S.2.WB 
      rAP_S_2_WB @= { @ "AP.S.2.WB : Space to FW_CU/FW_AP [(overlap FW_CU)/(Cut FW_AP) is prohibited] >= " + AP_S_2 + " um"; 
          external2( AP, FW, < AP_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          AP and FW_CU; 
          cutting( AP, FW_AP ); 
      } /* end of rule : AP.S.2.WB */
      
      //AP.S.3.FC is checked by AP.S.3.WB
      rAP_S_3_WB @= { @ "AP.S.3.WB : Space to LMARK [overlap is prohibited, except seal-ring] >= " + AP_S_3 + " um"; 
          external2( AP_CHECK, LMARK, < AP_S_3, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          AP_CHECK and LMARK; 
      } /* end of rule : AP.S.3.WB */
      
      //AP.S.4.WB is checked by related rules (in wire-bond DRC)
      //AP.S.4.FC is checked by related rules (in flip-chip DRC)
      //AP.EN.1.FC is checked by AP.EN.1.WB
      rAP_EN_1_WB @= { @ "AP.EN.1.WB : Enclosured of RV (Not inside seal ring) >= " + AP_EN_1 + " um"; 
          enclose( RV_CHECK_OUTSIDE, AP_CHECK_OUTSIDE, < AP_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          enclose( RV_CHECK_INSIDE, AP_CHECK_INSIDE, < ( AP_EN_1 - 0.01 ), extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          RV_CHECK not AP_CHECK; 
      } /* end of rule : AP.EN.1.WB */
      rAP_EN_2_WB @= { @ "AP.EN.2.WB : Enclosure of CB/CB2 (DRC tolerance: 0.01 um) >= 1";
          enclose( CB_CHECK, AP, < ( AP_EN_2 - TOL ), extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          CB_CHECK2 not AP; 
          enclose( CB2_CHECK, AP, < ( AP_EN_2 - TOL ), extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          CB2_CHECK2 not AP; 
      } /* end of rule : AP.EN.2.WB */
      #ifdef FULL_CHIP 
         
         // AP.DN.1.WB is checked by AP.DN.1:L and AP.DN.1:H
         // AP.DN.1.FC is checked by AP.DN.1:L and AP.DN.1:H
         rAP_DN_1_L @= { @ "AP.DN.1:L : AP density across full chip >= " + AP_DN_1_L; 
             sLAYER_1341 = chip_extent();
             VAR_135 = density_statistics_file( file = "AP.DN.1L.density" ); 
         _den_con = < AP_DN_1_L; 
         _den_polygon_area_clip = true;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( window_layer = sLAYER_1341, layer_hash = { "layer1" => AP, "layer2" => CHIP_INT_AP }, statistics_files = { VAR_135 }, window_function = den_save_window_1 ); 
         } /* end of rule : AP.DN.1:L */
         rAP_DN_1_H @= { @ "AP.DN.1:H : AP density across full chip <= " + AP_DN_1_H; 
             sLAYER_1342 = chip_extent();
             VAR_136 = density_statistics_file( file = "AP.DN.1H.density" ); 
         _den_con = > AP_DN_1_H; 
         _den_polygon_area_clip = true;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             density( window_layer = sLAYER_1342, layer_hash = { "layer1" => AP, "layer2" => CHIP_INT_AP }, statistics_files = { VAR_136 }, window_function = den_save_window_1 ); 
         } /* end of rule : AP.DN.1:H */
      #endif /* end of #ifdef FULL_CHIP  */ 
      R_M0 = RNGX and POLY; 
      R_V0 = RNGX and CO; 
      R_M1 = RNGX and M1; 
      R_V1 = RNGX and VIA1; 
      R_M2 = RNGX and M2; 
      R_V2 = RNGX and VIA2; 
      R_M3 = RNGX and M3; 
      R_V3 = RNGX and VIA3; 
      R_M4 = RNGX and M4; 
      R_V4 = RNGX and VIA4; 
      R_M5 = RNGX and M5; 
      R_V5 = RNGX and VIA5; 
      R_M6 = RNGX and M6; 
      R_V6 = RNGX and VIA6; 
      R_M7 = RNGX and M7; 
      R_V7 = RNGX and VIA7; 
      R_M8 = RNGX and M8; 
      R_V8 = RNGX and VIA8; 
      R_M9 = RNGX and M9; 
      H_RM1 = donut_holes( R_M1, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      H_RV1 = donut_holes( R_V1, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      H_RM2 = donut_holes( R_M2, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      H_RV2 = donut_holes( R_V2, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      H_RM3 = donut_holes( R_M3, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      H_RV3 = donut_holes( R_V3, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      H_RM4 = donut_holes( R_M4, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      H_RV4 = donut_holes( R_V4, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      H_RM5 = donut_holes( R_M5, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      H_RV5 = donut_holes( R_V5, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      H_RM6 = donut_holes( R_M6, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      H_RV6 = donut_holes( R_V6, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      H_RM7 = donut_holes( R_M7, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      H_RV7 = donut_holes( R_V7, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      H_RM8 = donut_holes( R_M8, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      H_RV8 = donut_holes( R_V8, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      H_RM9 = donut_holes( R_M9, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      MTFS_W = adjacent_edge( MTFS, angle1 = == 270, angle2 = == 270, length = > 0 ); 
      MTFS_B = adjacent_edge( MTFS, angle1 = == 270, angle2 = == 90, length = > 0 ); 
      MTFS_D = adjacent_edge( MTFS, angle1 = == 90, angle2 = == 90, length = > 0 ); 
      MTFS_E = internal2( MTFS_D, MTFS_B, < 15, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = RELATED_COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
      MTFS_EA = MTFS_E and MTFS; 
      MTFS_R = MTFS not MTFS_EA; 
      MTFS_CR = internal1( MTFS_W, < 3, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC );    /* metal fuse between dog bone */ 
      
      // Warining checks 
      //=================
      rFUSE_WARN_1 @= { @ "FUSE_WARN.1 : AP fuse must be covered by PMDMY.";
          FW_AP outside PMDMY; 
      } /* end of rule : FUSE_WARN.1 */
      rFUSE_WARN_2 @= { @ "FUSE_WARN.2 : PWELL/PMDMY/FW should be used in fuse structure.";
          MTFS and NWI; 
          MTFS outside PMDMY; 
          PMDMY outside MTFS; 
          PMDMY outside FW_AP; 
      } /* end of rule : FUSE_WARN.2 */
      rFUSE_WARN_3 @= { @ "FUSE_WARN.3 : Metal fuse should be a dog bone shape.";
          vertices( MTFS, != 12 ); 
      } /* end of rule : FUSE_WARN.3 */
      
      // AP fuse Rules checks
      //===================
      rFU_L_1_1 @= { @ "FU.L.1.1 : Length of AP fuse between dog bone >= " + FU_L_1_1 + " um"; 
          not_contains( MTFS_CR, { GRID, FU_L_1_1 } ); 
      } /* end of rule : FU.L.1.1 */
      rFU_S_1 @= { @ "FU.S.1 : Spece of AP fuse >= " + FU_S_1 + " um"; 
          external1( MTFS_CR, < FU_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : FU.S.1 */
      
      // Alignment Mark (L-mark) Rules checks
      //=====================================
      LMARK_NOT_CSR = LMARK outside CSRDMY; 
      MTLM = M9I and LMARK_NOT_CSR; 
      gLAYER_1152 = donut_holes( MTLM ); 
      MTLMH = outside( gLAYER_1152, MTLM );    /* L-mark region */ 
      MTLMH_L = adjacent_edge( MTLMH, angle1 = == 90, angle2 = == 90, length = <= LW_W_1_MAX ); 
      MTLMH_P = adjacent_edge( MTLMH, angle1 = == 90, angle2 = == 90, length = >= LW_L_1_MIN ); 
      rLW_W_1 @= { @ "LW.W.1 : Minimum width of L-slot  >= " + LW_W_1_MIN + " um " 
                              "Maximum width of L-slot   <= " + LW_W_1_MAX + " um"; 
          internal1( MTLMH, < LW_W_1_MIN, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          size( size( MTLMH, - ( LW_W_1_MAX / 2 ), clip_acute = NONE ), LW_W_1_MAX / 2, clip_acute = NONE ); 
      } /* end of rule : LW.W.1 */
      rLW_L_1 @= { @ "LW.L.1 : Minimum length of L-slot  >= " + LW_L_1_MIN + " um " 
                              "Maximum length of L-slot  <= " + LW_L_1_MAX + " um"; 
          not_contains( MTLMH, { LW_W_1_MIN, LW_L_1_MIN }, FORTY_FIVE ); 
          contains( MTLMH, { LW_W_1_MIN, LW_L_1_MAX + GRID }, FORTY_FIVE ); 
          not_touching( MTLMH, MTLMH_P, == 2 ); 
      } /* end of rule : LW.L.1 */
      rLW_EN_1 @= { @ "LW.EN.1 : LMARK enclosure of L-slot [in the direction of the L-slot length] >= " + LW_EN_1 + " um"; 
          enclose( MTLMH_L, LMARK, < LW_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
      } /* end of rule : LW.EN.1 */
      rLW_EN_2 @= { @ "LW.EN.2 : LMARK enclosure of L-slot [perpendicular to the direction of the L-slot length] >= " + LW_EN_2 + " um"; 
          enclose( MTLMH_P, LMARK, < LW_EN_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
      } /* end of rule : LW.EN.2 */
   #endif /* end of #ifdef BACK_END  */ 
   
   //LOGO CHECKS
   //============
   rLOGO_S_1 @= { @ "LOGO.S.1 : Min. chearance from LOGO to real OD/PO/Metal " + LOGO_S_1 + " um"; 
       sLAYER_1137 = size( LOGO, clip_acute = NONE, distance = LOGO_S_1 ); 
       LOGO_EXT = sLAYER_1137 not LOGO; 
       sLAYER_1138 = ODI not TCDDMY; 
       LOGO_EXT and sLAYER_1138; 
       sLAYER_1139 = POI not TCDDMY; 
       LOGO_EXT and sLAYER_1139; 
       M1I_R = M1I not DM1_O; 
       LOGO_EXT and M1I_R; 
       M2I_R = M2I not DM2_O; 
       LOGO_EXT and M2I_R; 
       M3I_R = M3I not DM3_O; 
       LOGO_EXT and M3I_R; 
       M4I_R = M4I not DM4_O; 
       LOGO_EXT and M4I_R; 
       M5I_R = M5I not DM5_O; 
       LOGO_EXT and M5I_R; 
       M6I_R = M6I not DM6_O; 
       LOGO_EXT and M6I_R; 
       M7I_R = M7I not DM7_O; 
       LOGO_EXT and M7I_R; 
       LOGO_EXT and M8I; 
       LOGO_EXT and M9I; 
   } /* end of rule : LOGO.S.1 */
   rLOGO_O_1 @= { @ "LOGO.O.1 : Overlap of CTP, CB, DOD, DPO, or DMx is not allowed.";
       LOGO and CBI; 
       LOGO and CBDI; 
       LOGO and DOD; 
       LOGO and DPO; 
       LOGO and FWI; 
       LOGO and PMI; 
       LOGO and UBMI; 
       LOGO and DM1_O; 
       LOGO and DM2_O; 
       LOGO and DM3_O; 
       LOGO and DM4_O; 
       LOGO and DM5_O; 
       LOGO and DM6_O; 
       LOGO and DM7_O; 
   } /* end of rule : LOGO.O.1 */
   
   // LOGO.R.1U is not necessary to check
   
   // LOGO.R.2 is checked by PO.EX.1, PO.EX.2, RR:AR:SP:PO.EX.2, PO.EX.3, PO.R.1, and PO.R.4.
   rLOGO_R_4 @= { @ "LOGO.R.4 : NW, OD, PO and Metals cut LOGO is not allowed";
       cutting( NWI, LOGO ); 
       cutting( ODI, LOGO ); 
       cutting( POI, LOGO ); 
       cutting( M1X, LOGO ); 
       cutting( M2X, LOGO ); 
       cutting( M3X, LOGO ); 
       cutting( M4X, LOGO ); 
       cutting( M5X, LOGO ); 
       cutting( M6X, LOGO ); 
       cutting( M7X, LOGO ); 
       cutting( M8X, LOGO ); 
       cutting( M9X, LOGO ); 
   } /* end of rule : LOGO.R.4 */
   #ifdef FRONT_END 
      #ifdef DISCONNECT_AFTER_RESISTOR 
         NWRIU = NWRIT not EMPTYI; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NWRIU }, NWRIT }} ); 
         NSTPIU = NSTPI not EMPTYI; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSTPIU }, NSTPI }} ); 
         gLAYER_602 = PSTPI not EMPTYI; 
         PSTPIU = gLAYER_602 not VAR; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSTPIU }, PSTPI }} ); 
         NSDIU = NSDC not EMPTYI; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSDIU }, NSDC }} ); 
         PSDIU = PSDC not EMPTYI; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSDIU }, PSDC }} ); 
         CBIU = CBI not EMPTYI; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CBIU }, CBI }} ); 
         CB2IU = CB2I not EMPTYI; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CB2IU }, CB2I }} ); 
         UBMNIU = UBMN not EMPTYI; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMNIU }, UBMN }} ); 
         UBMDIU = UBMD not EMPTYI; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMDIU }, UBMD }} ); 
         gLAYER_1153 = text_origin( text_131, cells = { get_top_cell() }, shape_size = 0.001, text = VDD_TEXT );
         PWR_M1IU_BY_TEXT = M1I interacting gLAYER_1153; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M1IU_BY_TEXT }, M1I }} ); 
         gLAYER_1154 = text_origin( text_131, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
         GND_M1IU_BY_TEXT = M1I interacting gLAYER_1154; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M1IU_BY_TEXT }, M1I }} ); 
         gLAYER_1155 = text_origin( text_131, cells = { get_top_cell() }, shape_size = 0.001, text = PAD_TEXT );
         PAD_M1IU_BY_TEXT = M1I interacting gLAYER_1155; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M1IU_BY_TEXT }, M1I }} ); 
         gLAYER_1156 = text_origin( text_132, cells = { get_top_cell() }, shape_size = 0.001, text = VDD_TEXT );
         PWR_M2IU_BY_TEXT = M2I interacting gLAYER_1156; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M2IU_BY_TEXT }, M2I }} ); 
         gLAYER_1157 = text_origin( text_132, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
         GND_M2IU_BY_TEXT = M2I interacting gLAYER_1157; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M2IU_BY_TEXT }, M2I }} ); 
         gLAYER_1158 = text_origin( text_132, cells = { get_top_cell() }, shape_size = 0.001, text = PAD_TEXT );
         PAD_M2IU_BY_TEXT = M2I interacting gLAYER_1158; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M2IU_BY_TEXT }, M2I }} ); 
         gLAYER_1159 = text_origin( text_133, cells = { get_top_cell() }, shape_size = 0.001, text = VDD_TEXT );
         PWR_M3IU_BY_TEXT = M3I interacting gLAYER_1159; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M3IU_BY_TEXT }, M3I }} ); 
         gLAYER_1160 = text_origin( text_133, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
         GND_M3IU_BY_TEXT = M3I interacting gLAYER_1160; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M3IU_BY_TEXT }, M3I }} ); 
         gLAYER_1161 = text_origin( text_133, cells = { get_top_cell() }, shape_size = 0.001, text = PAD_TEXT );
         PAD_M3IU_BY_TEXT = M3I interacting gLAYER_1161; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M3IU_BY_TEXT }, M3I }} ); 
         gLAYER_1162 = text_origin( text_134, cells = { get_top_cell() }, shape_size = 0.001, text = VDD_TEXT );
         PWR_M4IU_BY_TEXT = M4I interacting gLAYER_1162; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M4IU_BY_TEXT }, M4I }} ); 
         gLAYER_1163 = text_origin( text_134, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
         GND_M4IU_BY_TEXT = M4I interacting gLAYER_1163; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M4IU_BY_TEXT }, M4I }} ); 
         gLAYER_1164 = text_origin( text_134, cells = { get_top_cell() }, shape_size = 0.001, text = PAD_TEXT );
         PAD_M4IU_BY_TEXT = M4I interacting gLAYER_1164; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M4IU_BY_TEXT }, M4I }} ); 
         gLAYER_1165 = text_origin( text_135, cells = { get_top_cell() }, shape_size = 0.001, text = VDD_TEXT );
         PWR_M5IU_BY_TEXT = M5I interacting gLAYER_1165; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M5IU_BY_TEXT }, M5I }} ); 
         gLAYER_1166 = text_origin( text_135, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
         GND_M5IU_BY_TEXT = M5I interacting gLAYER_1166; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M5IU_BY_TEXT }, M5I }} ); 
         gLAYER_1167 = text_origin( text_135, cells = { get_top_cell() }, shape_size = 0.001, text = PAD_TEXT );
         PAD_M5IU_BY_TEXT = M5I interacting gLAYER_1167; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M5IU_BY_TEXT }, M5I }} ); 
         gLAYER_1168 = text_origin( text_136, cells = { get_top_cell() }, shape_size = 0.001, text = VDD_TEXT );
         PWR_M6IU_BY_TEXT = M6I interacting gLAYER_1168; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M6IU_BY_TEXT }, M6I }} ); 
         gLAYER_1169 = text_origin( text_136, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
         GND_M6IU_BY_TEXT = M6I interacting gLAYER_1169; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M6IU_BY_TEXT }, M6I }} ); 
         gLAYER_1170 = text_origin( text_136, cells = { get_top_cell() }, shape_size = 0.001, text = PAD_TEXT );
         PAD_M6IU_BY_TEXT = M6I interacting gLAYER_1170; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M6IU_BY_TEXT }, M6I }} ); 
         gLAYER_1171 = text_origin( text_137, cells = { get_top_cell() }, shape_size = 0.001, text = VDD_TEXT );
         PWR_M7IU_BY_TEXT = M7I interacting gLAYER_1171; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M7IU_BY_TEXT }, M7I }} ); 
         gLAYER_1172 = text_origin( text_137, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
         GND_M7IU_BY_TEXT = M7I interacting gLAYER_1172; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M7IU_BY_TEXT }, M7I }} ); 
         gLAYER_1173 = text_origin( text_137, cells = { get_top_cell() }, shape_size = 0.001, text = PAD_TEXT );
         PAD_M7IU_BY_TEXT = M7I interacting gLAYER_1173; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M7IU_BY_TEXT }, M7I }} ); 
         gLAYER_1174 = text_origin( text_138, cells = { get_top_cell() }, shape_size = 0.001, text = VDD_TEXT );
         PWR_M8IU_BY_TEXT = M8I interacting gLAYER_1174; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M8IU_BY_TEXT }, M8I }} ); 
         gLAYER_1175 = text_origin( text_138, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
         GND_M8IU_BY_TEXT = M8I interacting gLAYER_1175; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M8IU_BY_TEXT }, M8I }} ); 
         gLAYER_1176 = text_origin( text_138, cells = { get_top_cell() }, shape_size = 0.001, text = PAD_TEXT );
         PAD_M8IU_BY_TEXT = M8I interacting gLAYER_1176; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M8IU_BY_TEXT }, M8I }} ); 
         gLAYER_1177 = text_origin( text_139, cells = { get_top_cell() }, shape_size = 0.001, text = VDD_TEXT );
         PWR_M9IU_BY_TEXT = M9I interacting gLAYER_1177; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M9IU_BY_TEXT }, M9I }} ); 
         gLAYER_1178 = text_origin( text_139, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
         GND_M9IU_BY_TEXT = M9I interacting gLAYER_1178; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M9IU_BY_TEXT }, M9I }} ); 
         gLAYER_1179 = text_origin( text_139, cells = { get_top_cell() }, shape_size = 0.001, text = PAD_TEXT );
         PAD_M9IU_BY_TEXT = M9I interacting gLAYER_1179; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M9IU_BY_TEXT }, M9I }} ); 
         gLAYER_1180 = text_origin( text_126, cells = { get_top_cell() }, shape_size = 0.001, text = VDD_TEXT );
         PWR_APIU_BY_TEXT = API interacting gLAYER_1180; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_APIU_BY_TEXT }, API }} ); 
         gLAYER_1181 = text_origin( text_126, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
         GND_APIU_BY_TEXT = API interacting gLAYER_1181; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_APIU_BY_TEXT }, API }} ); 
         gLAYER_1182 = text_origin( text_126, cells = { get_top_cell() }, shape_size = 0.001, text = PAD_TEXT );
         PAD_APIU_BY_TEXT = API interacting gLAYER_1182; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_APIU_BY_TEXT }, API }} ); 
      #else /* the reverse of #ifdef DISCONNECT_AFTER_RESISTOR  */ 
         NWRIU = NWRUT not EMPTYI; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NWRIU }, NWRUT }} ); 
         NSTPIU = NSTPU not EMPTYI; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSTPIU }, NSTPU }} ); 
         gLAYER_603 = PSTPU not EMPTYI; 
         PSTPIU = gLAYER_603 not VAR; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSTPIU }, PSTPU }} ); 
         NSDIU = NSDU not EMPTYI; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSDIU }, NSDU }} ); 
         PSDIU = PSDU not EMPTYI; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSDIU }, PSDU }} ); 
         CBIU = CBU not EMPTYI; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CBIU }, CBU }} ); 
         CB2IU = CB2U not EMPTYI; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ CB2IU }, CB2U }} ); 
         UBMNIU = UBMNU not EMPTYI; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMNIU }, UBMNU }} ); 
         UBMDIU = UBMDU not EMPTYI; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ UBMDIU }, UBMDU }} ); 
         gLAYER_1183 = text_origin( text_131, cells = { get_top_cell() }, shape_size = 0.001, text = VDD_TEXT );
         PWR_M1IU_BY_TEXT = M1U interacting gLAYER_1183; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M1IU_BY_TEXT }, M1U }} ); 
         gLAYER_1184 = text_origin( text_131, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
         GND_M1IU_BY_TEXT = M1U interacting gLAYER_1184; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M1IU_BY_TEXT }, M1U }} ); 
         gLAYER_1185 = text_origin( text_131, cells = { get_top_cell() }, shape_size = 0.001, text = PAD_TEXT );
         PAD_M1IU_BY_TEXT = M1U interacting gLAYER_1185; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M1IU_BY_TEXT }, M1U }} ); 
         gLAYER_1186 = text_origin( text_132, cells = { get_top_cell() }, shape_size = 0.001, text = VDD_TEXT );
         PWR_M2IU_BY_TEXT = M2U interacting gLAYER_1186; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M2IU_BY_TEXT }, M2U }} ); 
         gLAYER_1187 = text_origin( text_132, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
         GND_M2IU_BY_TEXT = M2U interacting gLAYER_1187; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M2IU_BY_TEXT }, M2U }} ); 
         gLAYER_1188 = text_origin( text_132, cells = { get_top_cell() }, shape_size = 0.001, text = PAD_TEXT );
         PAD_M2IU_BY_TEXT = M2U interacting gLAYER_1188; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M2IU_BY_TEXT }, M2U }} ); 
         gLAYER_1189 = text_origin( text_133, cells = { get_top_cell() }, shape_size = 0.001, text = VDD_TEXT );
         PWR_M3IU_BY_TEXT = M3U interacting gLAYER_1189; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M3IU_BY_TEXT }, M3U }} ); 
         gLAYER_1190 = text_origin( text_133, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
         GND_M3IU_BY_TEXT = M3U interacting gLAYER_1190; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M3IU_BY_TEXT }, M3U }} ); 
         gLAYER_1191 = text_origin( text_133, cells = { get_top_cell() }, shape_size = 0.001, text = PAD_TEXT );
         PAD_M3IU_BY_TEXT = M3U interacting gLAYER_1191; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M3IU_BY_TEXT }, M3U }} ); 
         gLAYER_1192 = text_origin( text_134, cells = { get_top_cell() }, shape_size = 0.001, text = VDD_TEXT );
         PWR_M4IU_BY_TEXT = M4U interacting gLAYER_1192; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M4IU_BY_TEXT }, M4U }} ); 
         gLAYER_1193 = text_origin( text_134, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
         GND_M4IU_BY_TEXT = M4U interacting gLAYER_1193; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M4IU_BY_TEXT }, M4U }} ); 
         gLAYER_1194 = text_origin( text_134, cells = { get_top_cell() }, shape_size = 0.001, text = PAD_TEXT );
         PAD_M4IU_BY_TEXT = M4U interacting gLAYER_1194; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M4IU_BY_TEXT }, M4U }} ); 
         gLAYER_1195 = text_origin( text_135, cells = { get_top_cell() }, shape_size = 0.001, text = VDD_TEXT );
         PWR_M5IU_BY_TEXT = M5U interacting gLAYER_1195; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M5IU_BY_TEXT }, M5U }} ); 
         gLAYER_1196 = text_origin( text_135, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
         GND_M5IU_BY_TEXT = M5U interacting gLAYER_1196; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M5IU_BY_TEXT }, M5U }} ); 
         gLAYER_1197 = text_origin( text_135, cells = { get_top_cell() }, shape_size = 0.001, text = PAD_TEXT );
         PAD_M5IU_BY_TEXT = M5U interacting gLAYER_1197; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M5IU_BY_TEXT }, M5U }} ); 
         gLAYER_1198 = text_origin( text_136, cells = { get_top_cell() }, shape_size = 0.001, text = VDD_TEXT );
         PWR_M6IU_BY_TEXT = M6U interacting gLAYER_1198; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M6IU_BY_TEXT }, M6U }} ); 
         gLAYER_1199 = text_origin( text_136, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
         GND_M6IU_BY_TEXT = M6U interacting gLAYER_1199; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M6IU_BY_TEXT }, M6U }} ); 
         gLAYER_1200 = text_origin( text_136, cells = { get_top_cell() }, shape_size = 0.001, text = PAD_TEXT );
         PAD_M6IU_BY_TEXT = M6U interacting gLAYER_1200; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M6IU_BY_TEXT }, M6U }} ); 
         gLAYER_1201 = text_origin( text_137, cells = { get_top_cell() }, shape_size = 0.001, text = VDD_TEXT );
         PWR_M7IU_BY_TEXT = M7U interacting gLAYER_1201; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M7IU_BY_TEXT }, M7U }} ); 
         gLAYER_1202 = text_origin( text_137, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
         GND_M7IU_BY_TEXT = M7U interacting gLAYER_1202; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M7IU_BY_TEXT }, M7U }} ); 
         gLAYER_1203 = text_origin( text_137, cells = { get_top_cell() }, shape_size = 0.001, text = PAD_TEXT );
         PAD_M7IU_BY_TEXT = M7U interacting gLAYER_1203; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M7IU_BY_TEXT }, M7U }} ); 
         gLAYER_1204 = text_origin( text_138, cells = { get_top_cell() }, shape_size = 0.001, text = VDD_TEXT );
         PWR_M8IU_BY_TEXT = M8U interacting gLAYER_1204; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M8IU_BY_TEXT }, M8U }} ); 
         gLAYER_1205 = text_origin( text_138, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
         GND_M8IU_BY_TEXT = M8U interacting gLAYER_1205; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M8IU_BY_TEXT }, M8U }} ); 
         gLAYER_1206 = text_origin( text_138, cells = { get_top_cell() }, shape_size = 0.001, text = PAD_TEXT );
         PAD_M8IU_BY_TEXT = M8U interacting gLAYER_1206; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M8IU_BY_TEXT }, M8U }} ); 
         gLAYER_1207 = text_origin( text_139, cells = { get_top_cell() }, shape_size = 0.001, text = VDD_TEXT );
         PWR_M9IU_BY_TEXT = M9U interacting gLAYER_1207; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_M9IU_BY_TEXT }, M9U }} ); 
         gLAYER_1208 = text_origin( text_139, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
         GND_M9IU_BY_TEXT = M9U interacting gLAYER_1208; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_M9IU_BY_TEXT }, M9U }} ); 
         gLAYER_1209 = text_origin( text_139, cells = { get_top_cell() }, shape_size = 0.001, text = PAD_TEXT );
         PAD_M9IU_BY_TEXT = M9U interacting gLAYER_1209; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_M9IU_BY_TEXT }, M9U }} ); 
         gLAYER_1210 = text_origin( text_126, cells = { get_top_cell() }, shape_size = 0.001, text = VDD_TEXT );
         PWR_APIU_BY_TEXT = APU interacting gLAYER_1210; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PWR_APIU_BY_TEXT }, APU }} ); 
         gLAYER_1211 = text_origin( text_126, cells = { get_top_cell() }, shape_size = 0.001, text = VSS_TEXT );
         GND_APIU_BY_TEXT = APU interacting gLAYER_1211; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ GND_APIU_BY_TEXT }, APU }} ); 
         gLAYER_1212 = text_origin( text_126, cells = { get_top_cell() }, shape_size = 0.001, text = PAD_TEXT );
         PAD_APIU_BY_TEXT = APU interacting gLAYER_1212; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PAD_APIU_BY_TEXT }, APU }} ); 
      #endif /* end of #ifdef DISCONNECT_AFTER_RESISTOR  */ 
      
      // Power PAD
      gLAYER_604 = not_interacting( NSTPIU, RNWEL ); 
      NSTPUX = gLAYER_604 not VAR; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSTPUX }, NSTPIU }} ); 
      VDD_CB = net_select( CONNECT_DB, connected_to_any = { NSTPUX }, output_from_layers = { CBIU } ); 
      VSS_CB = net_select( CONNECT_DB, connected_to_any = { PSTPIU }, output_from_layers = { CBIU } ); 
      VDD_CB2 = net_select( CONNECT_DB, connected_to_any = { NSTPUX }, output_from_layers = { CB2IU } ); 
      VSS_CB2 = net_select( CONNECT_DB, connected_to_any = { PSTPIU }, output_from_layers = { CB2IU } ); 
      VDD_UBMN = net_select( CONNECT_DB, connected_to_any = { NSTPUX }, output_from_layers = { UBMNIU } ); 
      VDD_UBMD = net_select( CONNECT_DB, connected_to_any = { NSTPUX }, output_from_layers = { UBMDIU } ); 
      VDD_UBM = VDD_UBMN or VDD_UBMD; 
      VSS_UBMN = net_select( CONNECT_DB, connected_to_any = { PSTPIU }, output_from_layers = { UBMNIU } ); 
      VSS_UBMD = net_select( CONNECT_DB, connected_to_any = { PSTPIU }, output_from_layers = { UBMDIU } ); 
      VSS_UBM = VSS_UBMN or VSS_UBMD; 
      VDD_CB_BY_DUMMY = interacting( CBIU, VDDDMY ); 
      VSS_CB_BY_DUMMY = interacting( CBIU, VSSDMY ); 
      VDD_CB2_BY_DUMMY = interacting( CB2IU, VDDDMY ); 
      VSS_CB2_BY_DUMMY = interacting( CB2IU, VSSDMY ); 
      VDD_UBMN_BY_DUMMY = interacting( UBMNIU, VDDDMY ); 
      VDD_UBMD_BY_DUMMY = interacting( UBMDIU, VDDDMY ); 
      VSS_UBMN_BY_DUMMY = interacting( UBMNIU, VSSDMY ); 
      VSS_UBMD_BY_DUMMY = interacting( UBMDIU, VSSDMY ); 
      
      // Signal PAD
      gLAYER_607 = CBIU not VDD_CB; 
      gLAYER_606 = gLAYER_607 not VSS_CB; 
      gLAYER_605 = gLAYER_606 not VDD_CB_BY_DUMMY; 
      IO_CB = gLAYER_605 not VSS_CB_BY_DUMMY; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ IO_CB }, CBIU }} ); 
      gLAYER_610 = CB2IU not VDD_CB2; 
      gLAYER_609 = gLAYER_610 not VSS_CB2; 
      gLAYER_608 = gLAYER_609 not VDD_CB2_BY_DUMMY; 
      IO_CB2 = gLAYER_608 not VSS_CB2_BY_DUMMY; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ IO_CB2 }, CB2IU }} ); 
      gLAYER_613 = UBMNIU not VDD_UBM; 
      gLAYER_612 = gLAYER_613 not VSS_UBM; 
      gLAYER_611 = gLAYER_612 not VDD_UBMN_BY_DUMMY; 
      IO_UBMN = gLAYER_611 not VSS_UBMN_BY_DUMMY; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ IO_UBMN }, UBMNIU }} ); 
      gLAYER_616 = UBMDIU not VDD_UBM; 
      gLAYER_615 = gLAYER_616 not VSS_UBM; 
      gLAYER_614 = gLAYER_615 not VDD_UBMD_BY_DUMMY; 
      IO_UBMD = gLAYER_614 not VSS_UBMD_BY_DUMMY; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ IO_UBMD }, UBMDIU }} ); 
      PSD_PAD = net_area_ratio( CONNECT_DB, > 0, { "layer1" => PSDIU, "layer2" => CBIU, "layer3" => CB2IU, "layer4" => UBMNIU, "layer5" => UBMDIU }, 5, 5, {  }, NAR_SAVE_NET_15, false ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSD_PAD }, PSDIU }} ); 
      NSD_PAD = net_area_ratio( CONNECT_DB, > 0, { "layer1" => NSDIU, "layer2" => CBIU, "layer3" => CB2IU, "layer4" => UBMNIU, "layer5" => UBMDIU }, 5, 5, {  }, NAR_SAVE_NET_15, false ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSD_PAD }, NSDIU }} ); 
      PSD_IOPAD_STP = net_area_ratio( CONNECT_DB, > 0, { "layer1" => PSDIU, "layer2" => IO_CB, "layer3" => IO_CB2, "layer4" => IO_UBMN, "layer5" => IO_UBMD }, 5, 5, {  }, NAR_SAVE_NET_15, false ); 
      NSD_IOPAD_STP = net_area_ratio( CONNECT_DB, > 0, { "layer1" => NSDIU, "layer2" => IO_CB, "layer3" => IO_CB2, "layer4" => IO_UBMN, "layer5" => IO_UBMD }, 5, 5, {  }, NAR_SAVE_NET_15, false ); 
      NWR_IOPAD_STP = net_area_ratio( CONNECT_DB, > 0, { "layer1" => NWRIU, "layer2" => IO_CB, "layer3" => IO_CB2, "layer4" => IO_UBMN, "layer5" => IO_UBMD }, 5, 5, {  }, NAR_SAVE_NET_15, false ); 
      MOS = interacting( DACT, GATE ); 
      #ifdef DEFINE_PAD_BY_TEXT 
         PSD_PAD_TEXT = net_select( CONNECT_DB, connected_to_any = { PAD_M9IU_BY_TEXT, PAD_M8IU_BY_TEXT, PAD_M7IU_BY_TEXT, PAD_M6IU_BY_TEXT, PAD_M5IU_BY_TEXT, PAD_M4IU_BY_TEXT, PAD_M3IU_BY_TEXT, PAD_M2IU_BY_TEXT, PAD_M1IU_BY_TEXT, PAD_APIU_BY_TEXT }, output_from_layers = { PSDIU } ); 
         NSD_PAD_TEXT = net_select( CONNECT_DB, connected_to_any = { PAD_M9IU_BY_TEXT, PAD_M8IU_BY_TEXT, PAD_M7IU_BY_TEXT, PAD_M6IU_BY_TEXT, PAD_M5IU_BY_TEXT, PAD_M4IU_BY_TEXT, PAD_M3IU_BY_TEXT, PAD_M2IU_BY_TEXT, PAD_M1IU_BY_TEXT, PAD_APIU_BY_TEXT }, output_from_layers = { NSDIU } ); 
         NWR_PAD_TEXT = net_select( CONNECT_DB, connected_to_any = { PAD_M9IU_BY_TEXT, PAD_M8IU_BY_TEXT, PAD_M7IU_BY_TEXT, PAD_M6IU_BY_TEXT, PAD_M5IU_BY_TEXT, PAD_M4IU_BY_TEXT, PAD_M3IU_BY_TEXT, PAD_M2IU_BY_TEXT, PAD_M1IU_BY_TEXT, PAD_APIU_BY_TEXT }, output_from_layers = { NWRIU } ); 
         PSD_VDD_VSS_PAD_TEXT = net_select( CONNECT_DB, connected_to_any = { PWR_M9IU_BY_TEXT, PWR_M8IU_BY_TEXT, PWR_M7IU_BY_TEXT, PWR_M6IU_BY_TEXT, PWR_M5IU_BY_TEXT, PWR_M4IU_BY_TEXT, PWR_M3IU_BY_TEXT, PWR_M2IU_BY_TEXT, PWR_M1IU_BY_TEXT, PWR_APIU_BY_TEXT, GND_M9IU_BY_TEXT, GND_M8IU_BY_TEXT, GND_M7IU_BY_TEXT, GND_M6IU_BY_TEXT, GND_M5IU_BY_TEXT, GND_M4IU_BY_TEXT, GND_M3IU_BY_TEXT, GND_M2IU_BY_TEXT, GND_M1IU_BY_TEXT, GND_APIU_BY_TEXT }, output_from_layers = { PSDIU } ); 
         NSD_VDD_VSS_PAD_TEXT = net_select( CONNECT_DB, connected_to_any = { PWR_M9IU_BY_TEXT, PWR_M8IU_BY_TEXT, PWR_M7IU_BY_TEXT, PWR_M6IU_BY_TEXT, PWR_M5IU_BY_TEXT, PWR_M4IU_BY_TEXT, PWR_M3IU_BY_TEXT, PWR_M2IU_BY_TEXT, PWR_M1IU_BY_TEXT, PWR_APIU_BY_TEXT, GND_M9IU_BY_TEXT, GND_M8IU_BY_TEXT, GND_M7IU_BY_TEXT, GND_M6IU_BY_TEXT, GND_M5IU_BY_TEXT, GND_M4IU_BY_TEXT, GND_M3IU_BY_TEXT, GND_M2IU_BY_TEXT, GND_M1IU_BY_TEXT, GND_APIU_BY_TEXT }, output_from_layers = { NSDIU } ); 
         NWR_VDD_VSS_PAD_TEXT = net_select( CONNECT_DB, connected_to_any = { PWR_M9IU_BY_TEXT, PWR_M8IU_BY_TEXT, PWR_M7IU_BY_TEXT, PWR_M6IU_BY_TEXT, PWR_M5IU_BY_TEXT, PWR_M4IU_BY_TEXT, PWR_M3IU_BY_TEXT, PWR_M2IU_BY_TEXT, PWR_M1IU_BY_TEXT, PWR_APIU_BY_TEXT, GND_M9IU_BY_TEXT, GND_M8IU_BY_TEXT, GND_M7IU_BY_TEXT, GND_M6IU_BY_TEXT, GND_M5IU_BY_TEXT, GND_M4IU_BY_TEXT, GND_M3IU_BY_TEXT, GND_M2IU_BY_TEXT, GND_M1IU_BY_TEXT, GND_APIU_BY_TEXT }, output_from_layers = { NWRIU } ); 
         gLAYER_618 = PSD_IOPAD_STP or PSD_PAD_TEXT; 
         gLAYER_617 = gLAYER_618 not PSD_VDD_VSS_PAD_TEXT; 
         PSD_IOPAD = interacting( PSDIU, gLAYER_617 ); 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSD_IOPAD }, PSDIU }} ); 
         gLAYER_620 = NSD_IOPAD_STP or NSD_PAD_TEXT; 
         gLAYER_619 = gLAYER_620 not NSD_VDD_VSS_PAD_TEXT; 
         NSD_IOPAD = interacting( NSDIU, gLAYER_619 ); 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSD_IOPAD }, NSDIU }} ); 
         gLAYER_622 = NWR_IOPAD_STP or NWR_PAD_TEXT; 
         gLAYER_621 = gLAYER_622 not NWR_VDD_VSS_PAD_TEXT; 
         NWR_IOPAD = interacting( NWRIU, gLAYER_621 ); 
         PMOS_FILTER = copy( EMPTYI ); 
         NMOS_FILTER = copy( EMPTYI ); 
      #else /* the reverse of #ifdef DEFINE_PAD_BY_TEXT  */ 
         PSD_IOPAD = interacting( PSDIU, PSD_IOPAD_STP ); 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSD_IOPAD }, PSDIU }} ); 
         NSD_IOPAD = interacting( NSDIU, NSD_IOPAD_STP ); 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSD_IOPAD }, NSDIU }} ); 
         NWR_IOPAD = interacting( NWRIU, NWR_IOPAD_STP ); 
         gLAYER_623 = VDDDMY or VSSDMY; 
         MOS_FILTER_DMY = interacting( gCHIP, gLAYER_623 ); 
         gLAYER_624 = interacting( MOS, PSD_PAD, == 1, connect_sequence = CONNECT_DB, count_by = NET ); 
         PMOS_FILTER = gLAYER_624 not MOS_FILTER_DMY; 
         gLAYER_625 = interacting( MOS, NSD_PAD, == 1, connect_sequence = CONNECT_DB, count_by = NET ); 
         NMOS_FILTER = gLAYER_625 not MOS_FILTER_DMY; 
      #endif /* end of #ifdef DEFINE_PAD_BY_TEXT  */ 
      SD_IOPAD = PSD_IOPAD or NSD_IOPAD; 
      gLAYER_626 = not_interacting( MOS, CO ); 
      gLAYER_627 = interacting( POLY, CO ); 
      DUMMY_MOS = not_interacting( gLAYER_626, gLAYER_627 ); 
      gLAYER_628 = not_interacting( DACT, POLY ); 
      DUMMY_DIODE = not_interacting( gLAYER_628, CO ); 
      gLAYER_630 = interacting( GATE, PP ); 
      gLAYER_629 = interacting( gLAYER_630, gNP );
      G_DIODE = interacting( MOS, gLAYER_629 ); 
      gLAYER_631 = DACT not DUMMY_MOS; 
      DACT_REAL = gLAYER_631 not DUMMY_DIODE; 
      PACT_REAL = PACT and DACT_REAL; 
      NACT_REAL = NACT and DACT_REAL; 
      gLAYER_635 = DACT_REAL not PMOS_FILTER; 
      gLAYER_634 = gLAYER_635 not NMOS_FILTER; 
      gLAYER_633 = interacting( gLAYER_634, SD_IOPAD ); 
      gLAYER_636 = interacting( OD, NWR_IOPAD ); 
      gLAYER_632 = gLAYER_633 or gLAYER_636;
      POST_DRIVER_ACT = gLAYER_632 not_inside LUPWDMY; 
      gLAYER_637 = interacting( POST_DRIVER_ACT, PSDIU ); 
      POST_DRIVER_PACT = gLAYER_637 not_inside LUPWDMY; 
      gLAYER_639 = interacting( POST_DRIVER_ACT, NSDIU ); 
      gLAYER_640 = interacting( OD, NWR_IOPAD ); 
      gLAYER_638 = gLAYER_639 or gLAYER_640;
      POST_DRIVER_NACT = gLAYER_638 not_inside LUPWDMY; 
      gLAYER_641 = interacting( POST_DRIVER_PACT, GATE ); 
      POST_DRIVER_PMOS = gLAYER_641 not G_DIODE; 
      POST_DRIVER_PMOS_NW = stamp( POST_DRIVER_PMOS, NWEL, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
      POST_DRIVER_PMOS_NW_HV = interacting( POST_DRIVER_PMOS_NW, HV_GATE ); 
      gLAYER_642 = interacting( POST_DRIVER_PMOS_NW_HV, OD_25 ); 
      POST_DRIVER_PMOS_NW_5V = interacting( gLAYER_642, HVD_P ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NW_5V }, POST_DRIVER_PMOS_NW }} ); 
      POST_DRIVER_PMOS_NW_33V = interacting( POST_DRIVER_PMOS_NW_HV, OD_33 ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NW_33V }, POST_DRIVER_PMOS_NW }} ); 
      gLAYER_643 = interacting( POST_DRIVER_PMOS_NW_HV, OD_25 ); 
      POST_DRIVER_PMOS_NW_25V = not_interacting( gLAYER_643, HVD_P ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NW_25V }, POST_DRIVER_PMOS_NW }} ); 
      POST_DRIVER_PMOS_NW_18V = interacting( POST_DRIVER_PMOS_NW_HV, OD_18 ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NW_18V }, POST_DRIVER_PMOS_NW }} ); 
      POST_DRIVER_PMOS_NW_LV = POST_DRIVER_PMOS_NW not POST_DRIVER_PMOS_NW_HV; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NW_LV }, POST_DRIVER_PMOS_NW }} ); 
      POST_DRIVER_PMOS_NWI = stamp( POST_DRIVER_PMOS, NWI, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
      POST_DRIVER_PMOS_NWI_HV = interacting( POST_DRIVER_PMOS_NWI, HV_GATE ); 
      gLAYER_644 = interacting( POST_DRIVER_PMOS_NWI_HV, OD_25 ); 
      POST_DRIVER_PMOS_NWI_5V = interacting( gLAYER_644, HVD_P ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NWI_5V }, POST_DRIVER_PMOS_NWI }} ); 
      POST_DRIVER_PMOS_NWI_33V = interacting( POST_DRIVER_PMOS_NWI_HV, OD_33 ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NWI_33V }, POST_DRIVER_PMOS_NWI }} ); 
      gLAYER_645 = interacting( POST_DRIVER_PMOS_NWI_HV, OD_25 ); 
      POST_DRIVER_PMOS_NWI_25V = not_interacting( gLAYER_645, HVD_P ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NWI_25V }, POST_DRIVER_PMOS_NWI }} ); 
      POST_DRIVER_PMOS_NWI_18V = interacting( POST_DRIVER_PMOS_NWI_HV, OD_18 ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NWI_18V }, POST_DRIVER_PMOS_NWI }} ); 
      POST_DRIVER_PMOS_NWI_LV = POST_DRIVER_PMOS_NWI not POST_DRIVER_PMOS_NWI_HV; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NWI_LV }, POST_DRIVER_PMOS_NWI }} ); 
      gLAYER_646 = interacting( POST_DRIVER_NACT, GATE ); 
      POST_DRIVER_NMOS = gLAYER_646 not G_DIODE; 
      gLAYER_647 = POST_DRIVER_NMOS inside DNW; 
      POST_DRIVER_NMOS_RW = stamp( gLAYER_647, DNW, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
      POST_DRIVER_NMOS_PW = POST_DRIVER_NMOS not POST_DRIVER_NMOS_RW; 
      POST_DRIVER_NMOS_RW_HV = interacting( POST_DRIVER_NMOS_RW, HV_GATE ); 
      gLAYER_648 = interacting( POST_DRIVER_NMOS_RW_HV, OD_25 ); 
      POST_DRIVER_NMOS_RW_5V = interacting( gLAYER_648, HVD_N_NW ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NMOS_RW_5V }, POST_DRIVER_NMOS_RW }} ); 
      POST_DRIVER_NMOS_RW_33V = interacting( POST_DRIVER_NMOS_RW_HV, OD_33 ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NMOS_RW_33V }, POST_DRIVER_NMOS_RW }} ); 
      gLAYER_649 = interacting( POST_DRIVER_NMOS_RW_HV, OD_25 ); 
      POST_DRIVER_NMOS_RW_25V = not_interacting( gLAYER_649, HVD_N_NW ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NMOS_RW_25V }, POST_DRIVER_NMOS_RW }} ); 
      POST_DRIVER_NMOS_RW_18V = interacting( POST_DRIVER_NMOS_RW_HV, OD_18 ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NMOS_RW_18V }, POST_DRIVER_NMOS_RW }} ); 
      POST_DRIVER_NMOS_RW_LV = POST_DRIVER_NMOS_RW not POST_DRIVER_NMOS_RW_HV; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NMOS_RW_LV }, POST_DRIVER_NMOS_RW }} ); 
      POST_DRIVER_NMOS_PW_HV = interacting( POST_DRIVER_NMOS_PW, HV_GATE ); 
      gLAYER_650 = interacting( POST_DRIVER_NMOS_PW_HV, OD_25 ); 
      POST_DRIVER_NMOS_PW_5V = interacting( gLAYER_650, HVD_N_NW ); 
      POST_DRIVER_NMOS_PW_33V = interacting( POST_DRIVER_NMOS_PW_HV, OD_33 ); 
      gLAYER_651 = interacting( POST_DRIVER_NMOS_PW_HV, OD_25 ); 
      POST_DRIVER_NMOS_PW_25V = not_interacting( gLAYER_651, HVD_N_NW ); 
      POST_DRIVER_NMOS_PW_18V = interacting( POST_DRIVER_NMOS_PW_HV, OD_18 ); 
      POST_DRIVER_NMOS_PW_LV = POST_DRIVER_NMOS_PW not POST_DRIVER_NMOS_PW_HV; 
      POST_DRIVER_PINJ = copy( POST_DRIVER_PACT ); 
      POST_DRIVER_PINJ_NW = stamp( POST_DRIVER_PINJ, NWEL, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
      POST_DRIVER_PINJ_NW_HV = interacting( POST_DRIVER_PINJ_NW, OD2 ); 
      POST_DRIVER_PINJ_NW_5V = interacting( POST_DRIVER_PINJ_NW_HV, HVD_P ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PINJ_NW_5V }, POST_DRIVER_PINJ_NW }} ); 
      POST_DRIVER_PINJ_NW_33V = interacting( POST_DRIVER_PINJ_NW_HV, OD_33 ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PINJ_NW_33V }, POST_DRIVER_PINJ_NW }} ); 
      POST_DRIVER_PINJ_NW_25V = interacting( POST_DRIVER_PINJ_NW_HV, OD_25 ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PINJ_NW_25V }, POST_DRIVER_PINJ_NW }} ); 
      POST_DRIVER_PINJ_NW_18V = interacting( POST_DRIVER_PINJ_NW_HV, OD_18 ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PINJ_NW_18V }, POST_DRIVER_PINJ_NW }} ); 
      POST_DRIVER_PINJ_NW_LV = POST_DRIVER_PINJ_NW not POST_DRIVER_PINJ_NW_HV; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PINJ_NW_LV }, POST_DRIVER_PINJ_NW }} ); 
      POST_DRIVER_NINJ = copy( POST_DRIVER_NACT ); 
      gLAYER_652 = POST_DRIVER_NINJ inside DNW; 
      POST_DRIVER_NINJ_RW = stamp( gLAYER_652, DNW, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
      POST_DRIVER_NINJ_RW_HV = interacting( POST_DRIVER_NINJ_RW, OD2 ); 
      POST_DRIVER_NINJ_RW_5V = interacting( POST_DRIVER_NINJ_RW_HV, HVD_N_NW ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NINJ_RW_5V }, POST_DRIVER_NINJ_RW }} ); 
      POST_DRIVER_NINJ_RW_33V = interacting( POST_DRIVER_NINJ_RW_HV, OD_33 ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NINJ_RW_33V }, POST_DRIVER_NINJ_RW }} ); 
      POST_DRIVER_NINJ_RW_25V = interacting( POST_DRIVER_NINJ_RW_HV, OD_25 ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NINJ_RW_25V }, POST_DRIVER_NINJ_RW }} ); 
      POST_DRIVER_NINJ_RW_18V = interacting( POST_DRIVER_NINJ_RW_HV, OD_18 ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NINJ_RW_18V }, POST_DRIVER_NINJ_RW }} ); 
      POST_DRIVER_NINJ_RW_LV = POST_DRIVER_NINJ_RW not POST_DRIVER_NINJ_RW_HV; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NINJ_RW_LV }, POST_DRIVER_NINJ_RW }} ); 
      POST_DRIVER_NINJ_PW = POST_DRIVER_NINJ not POST_DRIVER_NINJ_RW; 
      POST_DRIVER_NINJ_PW_HV = interacting( POST_DRIVER_NINJ_PW, OD2 ); 
      POST_DRIVER_NINJ_PW_5V = interacting( POST_DRIVER_NINJ_PW_HV, HVD_N_NW ); 
      POST_DRIVER_NINJ_PW_33V = interacting( POST_DRIVER_NINJ_PW_HV, OD_33 ); 
      POST_DRIVER_NINJ_PW_25V = interacting( POST_DRIVER_NINJ_PW_HV, OD_25 ); 
      POST_DRIVER_NINJ_PW_18V = interacting( POST_DRIVER_NINJ_PW_HV, OD_18 ); 
      POST_DRIVER_NINJ_PW_LV = POST_DRIVER_NINJ_PW not POST_DRIVER_NINJ_PW_HV; 
      DNWC = stamp( DNW, NWI, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
      gLAYER_653 = POST_DRIVER_NMOS inside DNWC; 
      POST_DRIVER_NMOS_RWI = stamp( gLAYER_653, DNWC, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
      POST_DRIVER_NMOS_RWI_HV = interacting( POST_DRIVER_NMOS_RWI, HV_GATE ); 
      gLAYER_654 = interacting( POST_DRIVER_NMOS_RWI_HV, OD_25 ); 
      POST_DRIVER_NMOS_RWI_5V = interacting( gLAYER_654, HVD_N_NW ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NMOS_RWI_5V }, POST_DRIVER_NMOS_RWI }} ); 
      POST_DRIVER_NMOS_RWI_33V = interacting( POST_DRIVER_NMOS_RWI_HV, OD_33 ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NMOS_RWI_33V }, POST_DRIVER_NMOS_RWI }} ); 
      gLAYER_655 = interacting( POST_DRIVER_NMOS_RWI_HV, OD_25 ); 
      POST_DRIVER_NMOS_RWI_25V = not_interacting( gLAYER_655, HVD_N_NW ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NMOS_RWI_25V }, POST_DRIVER_NMOS_RWI }} ); 
      POST_DRIVER_NMOS_RWI_18V = interacting( POST_DRIVER_NMOS_RWI_HV, OD_18 ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NMOS_RWI_18V }, POST_DRIVER_NMOS_RWI }} ); 
      POST_DRIVER_NMOS_RWI_LV = POST_DRIVER_NMOS_RWI not POST_DRIVER_NMOS_RWI_HV; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NMOS_RWI_LV }, POST_DRIVER_NMOS_RWI }} ); 
      POST_DRIVER_MOS = POST_DRIVER_NMOS or POST_DRIVER_PMOS; 
      BESIDE_POST_DRIVER = size( POST_DRIVER_ACT, clip_acute = NONE, corner_extension = RADIAL_INSIDE, distance = LUP_2, radial_sectors = 4 ); 
      gLAYER_659 = interacting( NACT_REAL, GATE ); 
      gLAYER_658 = interacting( gLAYER_659, BESIDE_POST_DRIVER ); 
      gLAYER_657 = gLAYER_658 not POST_DRIVER_NACT; 
      gLAYER_656 = gLAYER_657 not DUMMY_MOS; 
      BESIDE_POST_DRIVER_NMOS = gLAYER_656 not G_DIODE; 
      gLAYER_663 = interacting( PACT_REAL, GATE ); 
      gLAYER_662 = interacting( gLAYER_663, BESIDE_POST_DRIVER ); 
      gLAYER_661 = gLAYER_662 not POST_DRIVER_PACT; 
      gLAYER_660 = gLAYER_661 not DUMMY_MOS; 
      BESIDE_POST_DRIVER_PMOS = gLAYER_660 not G_DIODE; 
      BESIDE_POST_DRIVER_PMOS_NW = stamp( BESIDE_POST_DRIVER_PMOS, NWEL, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
      BESIDE_POST_DRIVER_PMOS_NW_HV = interacting( BESIDE_POST_DRIVER_PMOS_NW, HV_GATE ); 
      gLAYER_665 = interacting( BESIDE_POST_DRIVER_PMOS_NW_HV, OD_25 ); 
      gLAYER_664 = interacting( gLAYER_665, HVD_P ); 
      BESIDE_POST_DRIVER_PMOS_NW_5V = not_interacting( gLAYER_664, DNW ); 
      BESIDE_POST_DRIVER_PMOS_NW_33V = interacting( BESIDE_POST_DRIVER_PMOS_NW_HV, OD_33 ); 
      gLAYER_666 = interacting( BESIDE_POST_DRIVER_PMOS_NW_HV, OD_25 ); 
      BESIDE_POST_DRIVER_PMOS_NW_25V = not_interacting( gLAYER_666, HVD_P ); 
      BESIDE_POST_DRIVER_PMOS_NW_18V = interacting( BESIDE_POST_DRIVER_PMOS_NW_HV, OD_18 ); 
      BESIDE_POST_DRIVER_PMOS_NW_LV = BESIDE_POST_DRIVER_PMOS_NW not BESIDE_POST_DRIVER_PMOS_NW_HV; 
      BESIDE_POST_DRIVER_PMOS_NWI = stamp( BESIDE_POST_DRIVER_PMOS, NWI, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
      BESIDE_POST_DRIVER_PMOS_NWI_HV = interacting( BESIDE_POST_DRIVER_PMOS_NWI, HV_GATE ); 
      gLAYER_668 = interacting( BESIDE_POST_DRIVER_PMOS_NWI_HV, OD_25 ); 
      gLAYER_667 = interacting( gLAYER_668, HVD_P ); 
      BESIDE_POST_DRIVER_PMOS_NWI_5V = not_interacting( gLAYER_667, DNW ); 
      BESIDE_POST_DRIVER_PMOS_NWI_33V = interacting( BESIDE_POST_DRIVER_PMOS_NWI_HV, OD_33 ); 
      gLAYER_669 = interacting( BESIDE_POST_DRIVER_PMOS_NWI_HV, OD_25 ); 
      BESIDE_POST_DRIVER_PMOS_NWI_25V = not_interacting( gLAYER_669, HVD_P ); 
      BESIDE_POST_DRIVER_PMOS_NWI_18V = interacting( BESIDE_POST_DRIVER_PMOS_NWI_HV, OD_18 ); 
      BESIDE_POST_DRIVER_PMOS_NWI_LV = BESIDE_POST_DRIVER_PMOS_NWI not BESIDE_POST_DRIVER_PMOS_NWI_HV; 
      gLAYER_670 = BESIDE_POST_DRIVER_NMOS inside DNW; 
      BESIDE_POST_DRIVER_NMOS_RW = stamp( gLAYER_670, DNW, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
      BESIDE_POST_DRIVER_NMOS_PW = BESIDE_POST_DRIVER_NMOS not BESIDE_POST_DRIVER_NMOS_RW; 
      BESIDE_POST_DRIVER_NMOS_RW_HV = interacting( BESIDE_POST_DRIVER_NMOS_RW, HV_GATE ); 
      gLAYER_671 = interacting( BESIDE_POST_DRIVER_NMOS_RW_HV, OD_25 ); 
      BESIDE_POST_DRIVER_NMOS_RW_5V = interacting( gLAYER_671, HVD_N_NW ); 
      BESIDE_POST_DRIVER_NMOS_RW_33V = interacting( BESIDE_POST_DRIVER_NMOS_RW_HV, OD_33 ); 
      gLAYER_672 = interacting( BESIDE_POST_DRIVER_NMOS_RW_HV, OD_25 ); 
      BESIDE_POST_DRIVER_NMOS_RW_25V = not_interacting( gLAYER_672, HVD_N_NW ); 
      BESIDE_POST_DRIVER_NMOS_RW_18V = interacting( BESIDE_POST_DRIVER_NMOS_RW_HV, OD_18 ); 
      BESIDE_POST_DRIVER_NMOS_RW_LV = BESIDE_POST_DRIVER_NMOS_RW not BESIDE_POST_DRIVER_NMOS_RW_HV; 
      BESIDE_POST_DRIVER_NMOS_PW_HV = interacting( BESIDE_POST_DRIVER_NMOS_PW, HV_GATE ); 
      gLAYER_674 = interacting( BESIDE_POST_DRIVER_NMOS_PW_HV, OD_25 ); 
      gLAYER_673 = interacting( gLAYER_674, HVD_N_NW ); 
      BESIDE_POST_DRIVER_NMOS_PW_5V = not_interacting( gLAYER_673, DNW ); 
      BESIDE_POST_DRIVER_NMOS_PW_33V = interacting( BESIDE_POST_DRIVER_NMOS_PW_HV, OD_33 ); 
      gLAYER_675 = interacting( BESIDE_POST_DRIVER_NMOS_PW_HV, OD_25 ); 
      BESIDE_POST_DRIVER_NMOS_PW_25V = not_interacting( gLAYER_675, HVD_N_NW ); 
      BESIDE_POST_DRIVER_NMOS_PW_18V = interacting( BESIDE_POST_DRIVER_NMOS_PW_HV, OD_18 ); 
      BESIDE_POST_DRIVER_NMOS_PW_LV = BESIDE_POST_DRIVER_NMOS_PW not BESIDE_POST_DRIVER_NMOS_PW_HV; 
      gLAYER_676 = BESIDE_POST_DRIVER_NMOS inside DNWC; 
      BESIDE_POST_DRIVER_NMOS_RWI = stamp( gLAYER_676, DNWC, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
      BESIDE_POST_DRIVER_NMOS_RWI_HV = interacting( BESIDE_POST_DRIVER_NMOS_RWI, HV_GATE ); 
      gLAYER_677 = interacting( BESIDE_POST_DRIVER_NMOS_RWI_HV, OD_25 ); 
      BESIDE_POST_DRIVER_NMOS_RWI_5V = interacting( gLAYER_677, HVD_N_NW ); 
      BESIDE_POST_DRIVER_NMOS_RWI_33V = interacting( BESIDE_POST_DRIVER_NMOS_RWI_HV, OD_33 ); 
      gLAYER_678 = interacting( BESIDE_POST_DRIVER_NMOS_RWI_HV, OD_25 ); 
      BESIDE_POST_DRIVER_NMOS_RWI_25V = not_interacting( gLAYER_678, HVD_N_NW ); 
      BESIDE_POST_DRIVER_NMOS_RWI_18V = interacting( BESIDE_POST_DRIVER_NMOS_RWI_HV, OD_18 ); 
      BESIDE_POST_DRIVER_NMOS_RWI_LV = BESIDE_POST_DRIVER_NMOS_RWI not BESIDE_POST_DRIVER_NMOS_RWI_HV; 
      gLAYER_679 = POST_DRIVER_NACT or BESIDE_POST_DRIVER_NMOS; 
      PTAP_GUARD_RING_HOLEX = enclosing( PTAP_GUARD_RING_HOLE, gLAYER_679 ); 
      gLAYER_680 = POST_DRIVER_PACT or BESIDE_POST_DRIVER_PMOS; 
      NTAP_GUARD_RING_HOLEX = enclosing( NTAP_GUARD_RING_HOLE, gLAYER_680 ); 
      gLAYER_681 = outside_touching( PSTPI, PTAP_GUARD_RING_HOLEX ); 
      PTAP_GUARD_RING_WIDE = wide( gLAYER_681, >= LUP_3_W, forty_five = INTERNAL ); 
      gLAYER_682 = outside_touching( NSTPI, NTAP_GUARD_RING_HOLEX ); 
      NTAP_GUARD_RING_WIDE = wide( gLAYER_682, >= LUP_3_W, forty_five = INTERNAL ); 
      PW_INSIDE_GUARD_RING_WIDE_PRE1 = PW_INSIDE_GUARD_RING not_coincident_outside_edge PTAP_GUARD_RING_WIDE; 
      PW_INSIDE_GUARD_RING_WIDE = PW_INSIDE_GUARD_RING not_touching PW_INSIDE_GUARD_RING_WIDE_PRE1; 
      NW_INSIDE_GUARD_RING_WIDE_PRE1 = NW_INSIDE_GUARD_RING not_coincident_outside_edge NTAP_GUARD_RING_WIDE; 
      NW_INSIDE_GUARD_RING_WIDE = NW_INSIDE_GUARD_RING not_touching NW_INSIDE_GUARD_RING_WIDE_PRE1; 
      gLAYER_683 = donut_holes( PTAP_GUARD_RING_WIDE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      PTAP_GUARD_RING_WIDE_HOLE = gLAYER_683 or PW_INSIDE_GUARD_RING_WIDE; 
      gLAYER_684 = donut_holes( NTAP_GUARD_RING_WIDE, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
      NTAP_GUARD_RING_WIDE_HOLE = gLAYER_684 or NW_INSIDE_GUARD_RING_WIDE; 
      POST_DRIVER_PMOS_NW_NG = POST_DRIVER_PMOS_NW not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NW_NG }, POST_DRIVER_PMOS_NW }} ); 
      POST_DRIVER_PMOS_NW_HV_NG = POST_DRIVER_PMOS_NW_HV not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      POST_DRIVER_PMOS_NW_5V_NG = POST_DRIVER_PMOS_NW_5V not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NW_5V_NG }, POST_DRIVER_PMOS_NW_5V }} ); 
      POST_DRIVER_PMOS_NW_33V_NG = POST_DRIVER_PMOS_NW_33V not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NW_33V_NG }, POST_DRIVER_PMOS_NW_33V }} ); 
      POST_DRIVER_PMOS_NW_25V_NG = POST_DRIVER_PMOS_NW_25V not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NW_25V_NG }, POST_DRIVER_PMOS_NW_25V }} ); 
      POST_DRIVER_PMOS_NW_18V_NG = POST_DRIVER_PMOS_NW_18V not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NW_18V_NG }, POST_DRIVER_PMOS_NW_18V }} ); 
      POST_DRIVER_PMOS_NW_LV_NG = POST_DRIVER_PMOS_NW_LV not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NW_LV_NG }, POST_DRIVER_PMOS_NW_LV }} ); 
      POST_DRIVER_PMOS_NWI_NG = POST_DRIVER_PMOS_NWI not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NWI_NG }, POST_DRIVER_PMOS_NWI }} ); 
      POST_DRIVER_PMOS_NWI_HV_NG = POST_DRIVER_PMOS_NWI_HV not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      POST_DRIVER_PMOS_NWI_5V_NG = POST_DRIVER_PMOS_NWI_5V not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NWI_5V_NG }, POST_DRIVER_PMOS_NWI_5V }} ); 
      POST_DRIVER_PMOS_NWI_33V_NG = POST_DRIVER_PMOS_NWI_33V not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NWI_33V_NG }, POST_DRIVER_PMOS_NWI_33V }} ); 
      POST_DRIVER_PMOS_NWI_25V_NG = POST_DRIVER_PMOS_NWI_25V not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NWI_25V_NG }, POST_DRIVER_PMOS_NWI_25V }} ); 
      POST_DRIVER_PMOS_NWI_18V_NG = POST_DRIVER_PMOS_NWI_18V not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NWI_18V_NG }, POST_DRIVER_PMOS_NWI_18V }} ); 
      POST_DRIVER_PMOS_NWI_LV_NG = POST_DRIVER_PMOS_NWI_LV not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PMOS_NWI_LV_NG }, POST_DRIVER_PMOS_NWI_LV }} ); 
      POST_DRIVER_NMOS_RW_NG = POST_DRIVER_NMOS_RW not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NMOS_RW_NG }, POST_DRIVER_NMOS_RW }} ); 
      POST_DRIVER_NMOS_RW_HV_NG = POST_DRIVER_NMOS_RW_HV not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      POST_DRIVER_NMOS_RW_5V_NG = POST_DRIVER_NMOS_RW_5V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NMOS_RW_5V_NG }, POST_DRIVER_NMOS_RW_5V }} ); 
      POST_DRIVER_NMOS_RW_33V_NG = POST_DRIVER_NMOS_RW_33V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NMOS_RW_33V_NG }, POST_DRIVER_NMOS_RW_33V }} ); 
      POST_DRIVER_NMOS_RW_25V_NG = POST_DRIVER_NMOS_RW_25V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NMOS_RW_25V_NG }, POST_DRIVER_NMOS_RW_25V }} ); 
      POST_DRIVER_NMOS_RW_18V_NG = POST_DRIVER_NMOS_RW_18V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NMOS_RW_18V_NG }, POST_DRIVER_NMOS_RW_18V }} ); 
      POST_DRIVER_NMOS_RW_LV_NG = POST_DRIVER_NMOS_RW_LV not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NMOS_RW_LV_NG }, POST_DRIVER_NMOS_RW_LV }} ); 
      POST_DRIVER_NMOS_PW_NG = POST_DRIVER_NMOS_PW not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      POST_DRIVER_NMOS_PW_HV_NG = POST_DRIVER_NMOS_PW_HV not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      POST_DRIVER_NMOS_PW_5V_NG = POST_DRIVER_NMOS_PW_5V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      POST_DRIVER_NMOS_PW_33V_NG = POST_DRIVER_NMOS_PW_33V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      POST_DRIVER_NMOS_PW_25V_NG = POST_DRIVER_NMOS_PW_25V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      POST_DRIVER_NMOS_PW_18V_NG = POST_DRIVER_NMOS_PW_18V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      POST_DRIVER_NMOS_PW_LV_NG = POST_DRIVER_NMOS_PW_LV not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      POST_DRIVER_NMOS_RWI_NG = POST_DRIVER_NMOS_RWI not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NMOS_RWI_NG }, POST_DRIVER_NMOS_RWI }} ); 
      POST_DRIVER_NMOS_RWI_HV_NG = POST_DRIVER_NMOS_RWI_HV not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      POST_DRIVER_NMOS_RWI_5V_NG = POST_DRIVER_NMOS_RWI_5V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NMOS_RWI_5V_NG }, POST_DRIVER_NMOS_RWI_5V }} ); 
      POST_DRIVER_NMOS_RWI_33V_NG = POST_DRIVER_NMOS_RWI_33V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NMOS_RWI_33V_NG }, POST_DRIVER_NMOS_RWI_33V }} ); 
      POST_DRIVER_NMOS_RWI_25V_NG = POST_DRIVER_NMOS_RWI_25V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NMOS_RWI_25V_NG }, POST_DRIVER_NMOS_RWI_25V }} ); 
      POST_DRIVER_NMOS_RWI_18V_NG = POST_DRIVER_NMOS_RWI_18V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NMOS_RWI_18V_NG }, POST_DRIVER_NMOS_RWI_18V }} ); 
      POST_DRIVER_NMOS_RWI_LV_NG = POST_DRIVER_NMOS_RWI_LV not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NMOS_RWI_LV_NG }, POST_DRIVER_NMOS_RWI_LV }} ); 
      BESIDE_POST_DRIVER_PMOS_NW_NG = BESIDE_POST_DRIVER_PMOS_NW not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ BESIDE_POST_DRIVER_PMOS_NW_NG }, BESIDE_POST_DRIVER_PMOS_NW }} ); 
      BESIDE_POST_DRIVER_PMOS_NW_5V_NG = BESIDE_POST_DRIVER_PMOS_NW_5V not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      BESIDE_POST_DRIVER_PMOS_NW_33V_NG = BESIDE_POST_DRIVER_PMOS_NW_33V not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      BESIDE_POST_DRIVER_PMOS_NW_25V_NG = BESIDE_POST_DRIVER_PMOS_NW_25V not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      BESIDE_POST_DRIVER_PMOS_NW_18V_NG = BESIDE_POST_DRIVER_PMOS_NW_18V not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      BESIDE_POST_DRIVER_PMOS_NW_LV_NG = BESIDE_POST_DRIVER_PMOS_NW_LV not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      BESIDE_POST_DRIVER_PMOS_NWI_NG = BESIDE_POST_DRIVER_PMOS_NWI not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ BESIDE_POST_DRIVER_PMOS_NWI_NG }, BESIDE_POST_DRIVER_PMOS_NWI }} ); 
      BESIDE_POST_DRIVER_PMOS_NWI_5V_NG = BESIDE_POST_DRIVER_PMOS_NWI_5V not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      BESIDE_POST_DRIVER_PMOS_NWI_33V_NG = BESIDE_POST_DRIVER_PMOS_NWI_33V not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      BESIDE_POST_DRIVER_PMOS_NWI_25V_NG = BESIDE_POST_DRIVER_PMOS_NWI_25V not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      BESIDE_POST_DRIVER_PMOS_NWI_18V_NG = BESIDE_POST_DRIVER_PMOS_NWI_18V not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      BESIDE_POST_DRIVER_PMOS_NWI_LV_NG = BESIDE_POST_DRIVER_PMOS_NWI_LV not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      BESIDE_POST_DRIVER_NMOS_RW_NG = BESIDE_POST_DRIVER_NMOS_RW not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ BESIDE_POST_DRIVER_NMOS_RW_NG }, BESIDE_POST_DRIVER_NMOS_RW }} ); 
      BESIDE_POST_DRIVER_NMOS_PW_NG = BESIDE_POST_DRIVER_NMOS_PW not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      BESIDE_POST_DRIVER_NMOS_RW_5V_NG = BESIDE_POST_DRIVER_NMOS_RW_5V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      BESIDE_POST_DRIVER_NMOS_RW_33V_NG = BESIDE_POST_DRIVER_NMOS_RW_33V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      BESIDE_POST_DRIVER_NMOS_RW_25V_NG = BESIDE_POST_DRIVER_NMOS_RW_25V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      BESIDE_POST_DRIVER_NMOS_RW_18V_NG = BESIDE_POST_DRIVER_NMOS_RW_18V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      BESIDE_POST_DRIVER_NMOS_RW_LV_NG = BESIDE_POST_DRIVER_NMOS_RW_LV not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      BESIDE_POST_DRIVER_NMOS_PW_5V_NG = BESIDE_POST_DRIVER_NMOS_PW_5V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      BESIDE_POST_DRIVER_NMOS_PW_33V_NG = BESIDE_POST_DRIVER_NMOS_PW_33V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      BESIDE_POST_DRIVER_NMOS_PW_25V_NG = BESIDE_POST_DRIVER_NMOS_PW_25V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      BESIDE_POST_DRIVER_NMOS_PW_18V_NG = BESIDE_POST_DRIVER_NMOS_PW_18V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      BESIDE_POST_DRIVER_NMOS_PW_LV_NG = BESIDE_POST_DRIVER_NMOS_PW_LV not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      BESIDE_POST_DRIVER_NMOS_RWI_NG = BESIDE_POST_DRIVER_NMOS_RWI not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ BESIDE_POST_DRIVER_NMOS_RWI_NG }, BESIDE_POST_DRIVER_NMOS_RWI }} ); 
      BESIDE_POST_DRIVER_NMOS_RWI_5V_NG = BESIDE_POST_DRIVER_NMOS_RWI_5V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      BESIDE_POST_DRIVER_NMOS_RWI_33V_NG = BESIDE_POST_DRIVER_NMOS_RWI_33V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      BESIDE_POST_DRIVER_NMOS_RWI_25V_NG = BESIDE_POST_DRIVER_NMOS_RWI_25V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      BESIDE_POST_DRIVER_NMOS_RWI_18V_NG = BESIDE_POST_DRIVER_NMOS_RWI_18V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      BESIDE_POST_DRIVER_NMOS_RWI_LV_NG = BESIDE_POST_DRIVER_NMOS_RWI_LV not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      POST_DRIVER_PINJ_NW_5V_NG = POST_DRIVER_PINJ_NW_5V not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PINJ_NW_5V_NG }, POST_DRIVER_PINJ_NW_5V }} ); 
      POST_DRIVER_PINJ_NW_33V_NG = POST_DRIVER_PINJ_NW_33V not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PINJ_NW_33V_NG }, POST_DRIVER_PINJ_NW_33V }} ); 
      POST_DRIVER_PINJ_NW_25V_NG = POST_DRIVER_PINJ_NW_25V not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PINJ_NW_25V_NG }, POST_DRIVER_PINJ_NW_25V }} ); 
      POST_DRIVER_PINJ_NW_18V_NG = POST_DRIVER_PINJ_NW_18V not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PINJ_NW_18V_NG }, POST_DRIVER_PINJ_NW_18V }} ); 
      POST_DRIVER_PINJ_NW_LV_NG = POST_DRIVER_PINJ_NW_LV not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PINJ_NW_LV_NG }, POST_DRIVER_PINJ_NW_LV }} ); 
      POST_DRIVER_NINJ_RW_5V_NG = POST_DRIVER_NINJ_RW_5V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NINJ_RW_5V_NG }, POST_DRIVER_NINJ_RW_5V }} ); 
      POST_DRIVER_NINJ_RW_33V_NG = POST_DRIVER_NINJ_RW_33V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NINJ_RW_33V_NG }, POST_DRIVER_NINJ_RW_33V }} ); 
      POST_DRIVER_NINJ_RW_25V_NG = POST_DRIVER_NINJ_RW_25V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NINJ_RW_25V_NG }, POST_DRIVER_NINJ_RW_25V }} ); 
      POST_DRIVER_NINJ_RW_18V_NG = POST_DRIVER_NINJ_RW_18V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NINJ_RW_18V_NG }, POST_DRIVER_NINJ_RW_18V }} ); 
      POST_DRIVER_NINJ_RW_LV_NG = POST_DRIVER_NINJ_RW_LV not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NINJ_RW_LV_NG }, POST_DRIVER_NINJ_RW_LV }} ); 
      POST_DRIVER_NINJ_PW_5V_NG = POST_DRIVER_NINJ_PW_5V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      POST_DRIVER_NINJ_PW_33V_NG = POST_DRIVER_NINJ_PW_33V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      POST_DRIVER_NINJ_PW_25V_NG = POST_DRIVER_NINJ_PW_25V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      POST_DRIVER_NINJ_PW_18V_NG = POST_DRIVER_NINJ_PW_18V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      POST_DRIVER_NINJ_PW_LV_NG = POST_DRIVER_NINJ_PW_LV not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      POST_DRIVER_PINJ_NWI = stamp( POST_DRIVER_PINJ, NWI, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
      POST_DRIVER_PINJ_NWI_HV = interacting( POST_DRIVER_PINJ_NWI, OD2 ); 
      POST_DRIVER_PINJ_NWI_5V = interacting( POST_DRIVER_PINJ_NWI_HV, HVD_P ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PINJ_NWI_5V }, POST_DRIVER_PINJ_NWI }} ); 
      POST_DRIVER_PINJ_NWI_33V = interacting( POST_DRIVER_PINJ_NWI_HV, OD_33 ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PINJ_NWI_33V }, POST_DRIVER_PINJ_NWI }} ); 
      POST_DRIVER_PINJ_NWI_25V = interacting( POST_DRIVER_PINJ_NWI_HV, OD_25 ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PINJ_NWI_25V }, POST_DRIVER_PINJ_NWI }} ); 
      POST_DRIVER_PINJ_NWI_18V = interacting( POST_DRIVER_PINJ_NWI_HV, OD_18 ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PINJ_NWI_18V }, POST_DRIVER_PINJ_NWI }} ); 
      POST_DRIVER_PINJ_NWI_LV = POST_DRIVER_PINJ_NWI not POST_DRIVER_PINJ_NWI_HV; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PINJ_NWI_LV }, POST_DRIVER_PINJ_NWI }} ); 
      gLAYER_685 = POST_DRIVER_NINJ inside DNW; 
      POST_DRIVER_NINJ_RWI = stamp( gLAYER_685, DNWC, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
      POST_DRIVER_NINJ_RWI_HV = interacting( POST_DRIVER_NINJ_RWI, OD2 ); 
      POST_DRIVER_NINJ_RWI_5V = interacting( POST_DRIVER_NINJ_RWI_HV, HVD_N_NW ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NINJ_RWI_5V }, POST_DRIVER_NINJ_RWI }} ); 
      POST_DRIVER_NINJ_RWI_33V = interacting( POST_DRIVER_NINJ_RWI_HV, OD_33 ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NINJ_RWI_33V }, POST_DRIVER_NINJ_RWI }} ); 
      POST_DRIVER_NINJ_RWI_25V = interacting( POST_DRIVER_NINJ_RWI_HV, OD_25 ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NINJ_RWI_25V }, POST_DRIVER_NINJ_RWI }} ); 
      POST_DRIVER_NINJ_RWI_18V = interacting( POST_DRIVER_NINJ_RWI_HV, OD_18 ); 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NINJ_RWI_18V }, POST_DRIVER_NINJ_RWI }} ); 
      POST_DRIVER_NINJ_RWI_LV = POST_DRIVER_NINJ_RWI not POST_DRIVER_NINJ_RWI_HV; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NINJ_RWI_LV }, POST_DRIVER_NINJ_RWI }} ); 
      POST_DRIVER_PINJ_NWI_5V_NG = POST_DRIVER_PINJ_NWI_5V not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PINJ_NWI_5V_NG }, POST_DRIVER_PINJ_NWI_5V }} ); 
      POST_DRIVER_PINJ_NWI_33V_NG = POST_DRIVER_PINJ_NWI_33V not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PINJ_NWI_33V_NG }, POST_DRIVER_PINJ_NWI_33V }} ); 
      POST_DRIVER_PINJ_NWI_25V_NG = POST_DRIVER_PINJ_NWI_25V not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PINJ_NWI_25V_NG }, POST_DRIVER_PINJ_NWI_25V }} ); 
      POST_DRIVER_PINJ_NWI_18V_NG = POST_DRIVER_PINJ_NWI_18V not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PINJ_NWI_18V_NG }, POST_DRIVER_PINJ_NWI_18V }} ); 
      POST_DRIVER_PINJ_NWI_LV_NG = POST_DRIVER_PINJ_NWI_LV not_inside NTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_PINJ_NWI_LV_NG }, POST_DRIVER_PINJ_NWI_LV }} ); 
      POST_DRIVER_NINJ_RWI_5V_NG = POST_DRIVER_NINJ_RWI_5V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NINJ_RWI_5V_NG }, POST_DRIVER_NINJ_RWI_5V }} ); 
      POST_DRIVER_NINJ_RWI_33V_NG = POST_DRIVER_NINJ_RWI_33V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NINJ_RWI_33V_NG }, POST_DRIVER_NINJ_RWI_33V }} ); 
      POST_DRIVER_NINJ_RWI_25V_NG = POST_DRIVER_NINJ_RWI_25V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NINJ_RWI_25V_NG }, POST_DRIVER_NINJ_RWI_25V }} ); 
      POST_DRIVER_NINJ_RWI_18V_NG = POST_DRIVER_NINJ_RWI_18V not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NINJ_RWI_18V_NG }, POST_DRIVER_NINJ_RWI_18V }} ); 
      POST_DRIVER_NINJ_RWI_LV_NG = POST_DRIVER_NINJ_RWI_LV not_inside PTAP_GUARD_RING_WIDE_HOLE; 
      CONNECT_DB = incremental_connect( CONNECT_DB, {{{ POST_DRIVER_NINJ_RWI_LV_NG }, POST_DRIVER_NINJ_RWI_LV }} ); 
      #ifdef GUIDELINE_LUP 
         rLUP_1G @= { @ "LUP.1g : Any N+ OD injector or an N+ OD injector cluster connected to an I/O pad must be surrounded by a P+ guard-ring. "
                                 "Any P+ OD injector or a P+ OD injector cluster connected to an I/O pad must be surrounded by a N+ guard-ring.";
             POST_DRIVER_NACT not_inside PTAP_GUARD_RING_HOLE; 
             POST_DRIVER_PACT not_inside NTAP_GUARD_RING_HOLE; 
         } /* end of rule : LUP.1g */
         rLUP_2G @= { @ "LUP.2g : Within " + LUP_2 + " um space from the OD injector, a P+ guard-ring is required to surround an NMOS or an NMOS cluster. And an N+ guard-ring is required to surround a PMOS or a PMOS cluster."; 
             sLAYER_1143 = interacting( DNW, BESIDE_POST_DRIVER_NMOS_RW ); 
             sLAYER_1142 = interacting( NWEL, sLAYER_1143 ); 
             sLAYER_1141 = interacting( sLAYER_1142, POST_DRIVER_PMOS_NW ); 
             sLAYER_1140 = interacting( DNW, sLAYER_1141 ); 
             X = interacting( BESIDE_POST_DRIVER_NMOS_RW, sLAYER_1140 ); 
             Y = external2_edge( POST_DRIVER_PMOS_NWI, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
             sLAYER_1144 = not_interacting( BESIDE_POST_DRIVER_NMOS_RWI, X ); 
             BESIDE_POST_DRIVER_NMOS_WAIVE = sLAYER_1144 not_touching Y; 
             sLAYER_1145 = BESIDE_POST_DRIVER_NMOS not BESIDE_POST_DRIVER_NMOS_WAIVE; 
             sLAYER_1145 not_inside PTAP_GUARD_RING_HOLE; 
             BESIDE_POST_DRIVER_PMOS not_inside NTAP_GUARD_RING_HOLE; 
         } /* end of rule : LUP.2g */
         
         //LUP.3.0 is checked by related rules (LUP.3.1.1g, LUP.3.1.2g, LUP.3.2.1g, LUP.3.2.2g, LUP.3.3.1g, LUP.3.3.2g, LUP.3.4.1g, LUP.3.4.2g, LUP.3.5.1g, LUP.3.5.2g, LUP.5.1.1g, LUP.5.1.2g, LUP.5.2.1g, LUP.5.2.2g, LUP.5.3.1g, LUP.5.3.2g, LUP.5.4.1g, LUP.5.4.2g)
         //LUP.3.1.0 is checked by LUP.3.1.1g and LUP.3.1.2g
         rLUP_3_1_1G @= { @ "LUP.3.1.1g : For the 1.2V or 1.0V N/PMOS which connects to an I/O pad, space between the NMOS and the PMOS >= " + LUP_3_1_1 + " um"; 
             external2_edge( POST_DRIVER_NMOS_PW_LV, POST_DRIVER_PMOS_NW_LV, < LUP_3_1_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_LV, POST_DRIVER_PMOS_NW_LV, < LUP_3_1_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RW_LV, POST_DRIVER_PMOS_NW_LV, < LUP_3_1_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_LV, POST_DRIVER_PMOS_NW_LV, < LUP_3_1_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RWI_LV, POST_DRIVER_PMOS_NWI_LV, < LUP_3_1_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_LV, POST_DRIVER_PMOS_NWI_LV, < LUP_3_1_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
         } /* end of rule : LUP.3.1.1g */
         rLUP_3_1_2G @= { @ "LUP.3.1.2g : For the 1.2V or 1.0V N/PMOS which connects to an I/O pad, space between the NMOS and the PMOS >= " + LUP_3_1_2 + " um " 
                                         "if one of guard-ring < " + LUP_3_W + " um"; 
             external2_edge( POST_DRIVER_NMOS_PW_LV_NG, POST_DRIVER_PMOS_NW_LV, < LUP_3_1_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_LV_NG, POST_DRIVER_PMOS_NW_LV, < LUP_3_1_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RW_LV_NG, POST_DRIVER_PMOS_NW_LV, < LUP_3_1_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_LV_NG, POST_DRIVER_PMOS_NW_LV, < LUP_3_1_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2( POST_DRIVER_NMOS_RWI_LV_NG, POST_DRIVER_PMOS_NWI_LV, < LUP_3_1_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
             external2_edge( POST_DRIVER_NMOS_PW_LV, POST_DRIVER_PMOS_NW_LV_NG, < LUP_3_1_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_LV, POST_DRIVER_PMOS_NW_LV_NG, < LUP_3_1_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RW_LV, POST_DRIVER_PMOS_NW_LV_NG, < LUP_3_1_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_LV, POST_DRIVER_PMOS_NW_LV_NG, < LUP_3_1_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RWI_LV, POST_DRIVER_PMOS_NWI_LV_NG, < LUP_3_1_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_LV, POST_DRIVER_PMOS_NWI_LV_NG, < LUP_3_1_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
         } /* end of rule : LUP.3.1.2g */
         
         //LUP.3.2.0 is checked by LUP.3.2.1g and LUP.3.2.2g 
         rLUP_3_2_1G @= { @ "LUP.3.2.1g : For the 1.8V N/PMOS which connects to an I/O pad directly, space between the 1.8V NMOS and the 1.8V/1.2V/1.0V PMOS, space between the 1.8V PMOS and the 1.8V/1.2V/1.0V NMOS >= " + LUP_3_2_1 + " um"; 
             external2_edge( POST_DRIVER_NMOS_PW_18V, POST_DRIVER_PMOS_NW_18V, < LUP_3_2_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_18V, POST_DRIVER_PMOS_NW_18V, < LUP_3_2_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_PW_18V, POST_DRIVER_PMOS_NW_LV, < LUP_3_2_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_18V, POST_DRIVER_PMOS_NW_LV, < LUP_3_2_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_PW_LV, POST_DRIVER_PMOS_NW_18V, < LUP_3_2_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_LV, POST_DRIVER_PMOS_NW_18V, < LUP_3_2_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RW_18V, POST_DRIVER_PMOS_NW_18V, < LUP_3_2_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_18V, POST_DRIVER_PMOS_NW_18V, < LUP_3_2_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RW_18V, POST_DRIVER_PMOS_NW_LV, < LUP_3_2_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_18V, POST_DRIVER_PMOS_NW_LV, < LUP_3_2_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RW_LV, POST_DRIVER_PMOS_NW_18V, < LUP_3_2_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_LV, POST_DRIVER_PMOS_NW_18V, < LUP_3_2_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RWI_18V, POST_DRIVER_PMOS_NWI_18V, < LUP_3_2_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_18V, POST_DRIVER_PMOS_NWI_18V, < LUP_3_2_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RWI_18V, POST_DRIVER_PMOS_NWI_LV, < LUP_3_2_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_18V, POST_DRIVER_PMOS_NWI_LV, < LUP_3_2_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RWI_LV, POST_DRIVER_PMOS_NWI_18V, < LUP_3_2_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_LV, POST_DRIVER_PMOS_NWI_18V, < LUP_3_2_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
         } /* end of rule : LUP.3.2.1g */
         rLUP_3_2_2G @= { @ "LUP.3.2.2g : For the 1.8V N/PMOS which connects to an I/O pad directly, space between the 1.8V NMOS and the 1.8V/1.2V/1.0V PMOS, space between the 1.8V PMOS and the 1.8V/1.2V/1.0V NMOS >= " + LUP_3_2_2 + " um  if one of guard-ring < " + LUP_3_W + " um"; 
             external2_edge( POST_DRIVER_NMOS_PW_18V_NG, POST_DRIVER_PMOS_NW_18V, < LUP_3_2_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_18V_NG, POST_DRIVER_PMOS_NW_18V, < LUP_3_2_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_PW_18V_NG, POST_DRIVER_PMOS_NW_LV, < LUP_3_2_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_18V_NG, POST_DRIVER_PMOS_NW_LV, < LUP_3_2_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_PW_LV_NG, POST_DRIVER_PMOS_NW_18V, < LUP_3_2_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_LV_NG, POST_DRIVER_PMOS_NW_18V, < LUP_3_2_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RW_18V_NG, POST_DRIVER_PMOS_NW_18V, < LUP_3_2_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_18V_NG, POST_DRIVER_PMOS_NW_18V, < LUP_3_2_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RW_18V_NG, POST_DRIVER_PMOS_NW_LV, < LUP_3_2_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_18V_NG, POST_DRIVER_PMOS_NW_LV, < LUP_3_2_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION  */ 
             external2_edge( POST_DRIVER_NMOS_RW_LV_NG, POST_DRIVER_PMOS_NW_18V, < LUP_3_2_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_LV_NG, POST_DRIVER_PMOS_NW_18V, < LUP_3_2_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RWI_18V_NG, POST_DRIVER_PMOS_NWI_18V, < LUP_3_2_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_18V_NG, POST_DRIVER_PMOS_NWI_18V, < LUP_3_2_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RWI_18V_NG, POST_DRIVER_PMOS_NWI_LV, < LUP_3_2_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_18V_NG, POST_DRIVER_PMOS_NWI_LV, < LUP_3_2_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RWI_LV_NG, POST_DRIVER_PMOS_NWI_18V, < LUP_3_2_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_LV_NG, POST_DRIVER_PMOS_NWI_18V, < LUP_3_2_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_PW_18V, POST_DRIVER_PMOS_NW_18V_NG, < LUP_3_2_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_18V, POST_DRIVER_PMOS_NW_18V_NG, < LUP_3_2_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_PW_18V, POST_DRIVER_PMOS_NW_LV_NG, < LUP_3_2_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_18V, POST_DRIVER_PMOS_NW_LV_NG, < LUP_3_2_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_PW_LV, POST_DRIVER_PMOS_NW_18V_NG, < LUP_3_2_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_LV, POST_DRIVER_PMOS_NW_18V_NG, < LUP_3_2_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RW_18V, POST_DRIVER_PMOS_NW_18V_NG, < LUP_3_2_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_18V, POST_DRIVER_PMOS_NW_18V_NG, < LUP_3_2_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RW_18V, POST_DRIVER_PMOS_NW_LV_NG, < LUP_3_2_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_18V, POST_DRIVER_PMOS_NW_LV_NG, < LUP_3_2_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RW_LV, POST_DRIVER_PMOS_NW_18V_NG, < LUP_3_2_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_LV, POST_DRIVER_PMOS_NW_18V_NG, < LUP_3_2_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RWI_18V, POST_DRIVER_PMOS_NWI_18V_NG, < LUP_3_2_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_18V, POST_DRIVER_PMOS_NWI_18V_NG, < LUP_3_2_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RWI_18V, POST_DRIVER_PMOS_NWI_LV_NG, < LUP_3_2_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_18V, POST_DRIVER_PMOS_NWI_LV_NG, < LUP_3_2_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RWI_LV, POST_DRIVER_PMOS_NWI_18V_NG, < LUP_3_2_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_LV, POST_DRIVER_PMOS_NWI_18V_NG, < LUP_3_2_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
         } /* end of rule : LUP.3.2.2g */
         
         //LUP.3.3.0 is checked by LUP.3.3.1g and LUP.3.3.2g
         rLUP_3_3_1G @= { @ "LUP.3.3.1g : For the 2.5V N/PMOS which connects to an I/O pad directly, space between the 2.5V NMOS and the 2.5V/1.2V/1.0V PMOS, space between the 2.5V PMOS and the 2.5V/1.2V/1.0V NMOS >= " + LUP_3_3_1 + " um"; 
             external2_edge( POST_DRIVER_NMOS_PW_25V, POST_DRIVER_PMOS_NW_25V, < LUP_3_3_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_25V, POST_DRIVER_PMOS_NW_25V, < LUP_3_3_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_PW_25V, POST_DRIVER_PMOS_NW_LV, < LUP_3_3_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_25V, POST_DRIVER_PMOS_NW_LV, < LUP_3_3_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_PW_LV, POST_DRIVER_PMOS_NW_25V, < LUP_3_3_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_LV, POST_DRIVER_PMOS_NW_25V, < LUP_3_3_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RW_25V, POST_DRIVER_PMOS_NW_25V, < LUP_3_3_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_25V, POST_DRIVER_PMOS_NW_25V, < LUP_3_3_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RW_25V, POST_DRIVER_PMOS_NW_LV, < LUP_3_3_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_25V, POST_DRIVER_PMOS_NW_LV, < LUP_3_3_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RW_LV, POST_DRIVER_PMOS_NW_25V, < LUP_3_3_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_LV, POST_DRIVER_PMOS_NW_25V, < LUP_3_3_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RWI_25V, POST_DRIVER_PMOS_NWI_25V, < LUP_3_3_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_25V, POST_DRIVER_PMOS_NWI_25V, < LUP_3_3_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION  */ 
             external2_edge( POST_DRIVER_NMOS_RWI_25V, POST_DRIVER_PMOS_NWI_LV, < LUP_3_3_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_25V, POST_DRIVER_PMOS_NWI_LV, < LUP_3_3_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RWI_LV, POST_DRIVER_PMOS_NWI_25V, < LUP_3_3_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_LV, POST_DRIVER_PMOS_NWI_25V, < LUP_3_3_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
         } /* end of rule : LUP.3.3.1g */
         rLUP_3_3_2G @= { @ "LUP.3.3.2g : For the 2.5V N/PMOS which connects to an I/O pad directly, space between the 2.5V NMOS and the 2.5V/1.2V/1.0V PMOS, space between the 2.5V PMOS and the 2.5V/1.2V/1.0V NMOS >= " + LUP_3_3_2 + " um if one of guard-ring < " + LUP_3_W + " um"; 
             external2_edge( POST_DRIVER_NMOS_PW_25V_NG, POST_DRIVER_PMOS_NW_25V, < LUP_3_3_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_25V_NG, POST_DRIVER_PMOS_NW_25V, < LUP_3_3_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_PW_25V_NG, POST_DRIVER_PMOS_NW_LV, < LUP_3_3_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_25V_NG, POST_DRIVER_PMOS_NW_LV, < LUP_3_3_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_PW_LV_NG, POST_DRIVER_PMOS_NW_25V, < LUP_3_3_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_LV_NG, POST_DRIVER_PMOS_NW_25V, < LUP_3_3_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RW_25V_NG, POST_DRIVER_PMOS_NW_25V, < LUP_3_3_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_25V_NG, POST_DRIVER_PMOS_NW_25V, < LUP_3_3_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION  */ 
             external2_edge( POST_DRIVER_NMOS_RW_25V_NG, POST_DRIVER_PMOS_NW_LV, < LUP_3_3_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_25V_NG, POST_DRIVER_PMOS_NW_LV, < LUP_3_3_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION  */ 
             external2_edge( POST_DRIVER_NMOS_RW_LV_NG, POST_DRIVER_PMOS_NW_25V, < LUP_3_3_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_LV_NG, POST_DRIVER_PMOS_NW_25V, < LUP_3_3_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION  */ 
             external2_edge( POST_DRIVER_NMOS_RWI_25V_NG, POST_DRIVER_PMOS_NWI_25V, < LUP_3_3_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_25V_NG, POST_DRIVER_PMOS_NWI_25V, < LUP_3_3_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RWI_25V_NG, POST_DRIVER_PMOS_NWI_LV, < LUP_3_3_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_25V_NG, POST_DRIVER_PMOS_NWI_LV, < LUP_3_3_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RWI_LV_NG, POST_DRIVER_PMOS_NWI_25V, < LUP_3_3_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_LV_NG, POST_DRIVER_PMOS_NWI_25V, < LUP_3_3_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_PW_25V, POST_DRIVER_PMOS_NW_25V_NG, < LUP_3_3_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_25V, POST_DRIVER_PMOS_NW_25V_NG, < LUP_3_3_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_PW_25V, POST_DRIVER_PMOS_NW_LV_NG, < LUP_3_3_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_25V, POST_DRIVER_PMOS_NW_LV_NG, < LUP_3_3_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_PW_LV, POST_DRIVER_PMOS_NW_25V_NG, < LUP_3_3_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_LV, POST_DRIVER_PMOS_NW_25V_NG, < LUP_3_3_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RW_25V, POST_DRIVER_PMOS_NW_25V_NG, < LUP_3_3_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_25V, POST_DRIVER_PMOS_NW_25V_NG, < LUP_3_3_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION   */ 
             external2_edge( POST_DRIVER_NMOS_RW_25V, POST_DRIVER_PMOS_NW_LV_NG, < LUP_3_3_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_25V, POST_DRIVER_PMOS_NW_LV_NG, < LUP_3_3_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION  */ 
             external2_edge( POST_DRIVER_NMOS_RW_LV, POST_DRIVER_PMOS_NW_25V_NG, < LUP_3_3_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_LV, POST_DRIVER_PMOS_NW_25V_NG, < LUP_3_3_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION  */ 
             external2_edge( POST_DRIVER_NMOS_RWI_25V, POST_DRIVER_PMOS_NWI_25V_NG, < LUP_3_3_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_25V, POST_DRIVER_PMOS_NWI_25V_NG, < LUP_3_3_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RWI_25V, POST_DRIVER_PMOS_NWI_LV_NG, < LUP_3_3_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_25V, POST_DRIVER_PMOS_NWI_LV_NG, < LUP_3_3_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RWI_LV, POST_DRIVER_PMOS_NWI_25V_NG, < LUP_3_3_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_LV, POST_DRIVER_PMOS_NWI_25V_NG, < LUP_3_3_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
         } /* end of rule : LUP.3.3.2g */
         
         //LUP.3.4.0 is checked by LUP.3.4.1g and LUP.3.4.2g
         rLUP_3_4_1G @= { @ "LUP.3.4.1g : For the 3.3V N/PMOS which connects to an I/O pad directly, space between the 3.3V NMOS and the 3.3V/1.2V/1.0V PMOS, space between the 3.3V PMOS and the 3.3V/1.2V/1.0V NMOS >= " + LUP_3_4_1 + " um"; 
             external2_edge( POST_DRIVER_NMOS_PW_33V, POST_DRIVER_PMOS_NW_33V, < LUP_3_4_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_33V, POST_DRIVER_PMOS_NW_33V, < LUP_3_4_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_PW_33V, POST_DRIVER_PMOS_NW_LV, < LUP_3_4_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_33V, POST_DRIVER_PMOS_NW_LV, < LUP_3_4_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_PW_LV, POST_DRIVER_PMOS_NW_33V, < LUP_3_4_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_LV, POST_DRIVER_PMOS_NW_33V, < LUP_3_4_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RW_33V, POST_DRIVER_PMOS_NW_33V, < LUP_3_4_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_33V, POST_DRIVER_PMOS_NW_33V, < LUP_3_4_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RW_33V, POST_DRIVER_PMOS_NW_LV, < LUP_3_4_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_33V, POST_DRIVER_PMOS_NW_LV, < LUP_3_4_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RW_LV, POST_DRIVER_PMOS_NW_33V, < LUP_3_4_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_LV, POST_DRIVER_PMOS_NW_33V, < LUP_3_4_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RWI_33V, POST_DRIVER_PMOS_NWI_33V, < LUP_3_4_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_33V, POST_DRIVER_PMOS_NWI_33V, < LUP_3_4_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RWI_33V, POST_DRIVER_PMOS_NWI_LV, < LUP_3_4_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_33V, POST_DRIVER_PMOS_NWI_LV, < LUP_3_4_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RWI_LV, POST_DRIVER_PMOS_NWI_33V, < LUP_3_4_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_LV, POST_DRIVER_PMOS_NWI_33V, < LUP_3_4_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
         } /* end of rule : LUP.3.4.1g */
         rLUP_3_4_2G @= { @ "LUP.3.4.2g : For the 3.3V N/PMOS which connects to an I/O pad directly, space between the 3.3V NMOS and the 3.3V/1.2V/1.0V PMOS, space between the 3.3V PMOS and the 3.3V/1.2V/1.0V NMOS >= " + LUP_3_4_2 + " um if one of guard-ring < " + LUP_3_W + " um"; 
             external2_edge( POST_DRIVER_NMOS_PW_33V_NG, POST_DRIVER_PMOS_NW_33V, < LUP_3_4_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_33V_NG, POST_DRIVER_PMOS_NW_33V, < LUP_3_4_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_PW_33V_NG, POST_DRIVER_PMOS_NW_LV, < LUP_3_4_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_33V_NG, POST_DRIVER_PMOS_NW_LV, < LUP_3_4_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_PW_LV_NG, POST_DRIVER_PMOS_NW_33V, < LUP_3_4_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_LV_NG, POST_DRIVER_PMOS_NW_33V, < LUP_3_4_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RW_33V_NG, POST_DRIVER_PMOS_NW_33V, < LUP_3_4_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_33V_NG, POST_DRIVER_PMOS_NW_33V, < LUP_3_4_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RW_33V_NG, POST_DRIVER_PMOS_NW_LV, < LUP_3_4_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_33V_NG, POST_DRIVER_PMOS_NW_LV, < LUP_3_4_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RW_LV_NG, POST_DRIVER_PMOS_NW_33V, < LUP_3_4_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_LV_NG, POST_DRIVER_PMOS_NW_33V, < LUP_3_4_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RWI_33V_NG, POST_DRIVER_PMOS_NWI_33V, < LUP_3_4_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_33V_NG, POST_DRIVER_PMOS_NWI_33V, < LUP_3_4_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RWI_33V_NG, POST_DRIVER_PMOS_NWI_LV, < LUP_3_4_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_33V_NG, POST_DRIVER_PMOS_NWI_LV, < LUP_3_4_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RWI_LV_NG, POST_DRIVER_PMOS_NWI_33V, < LUP_3_4_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_LV_NG, POST_DRIVER_PMOS_NWI_33V, < LUP_3_4_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_PW_33V, POST_DRIVER_PMOS_NW_33V_NG, < LUP_3_4_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_33V, POST_DRIVER_PMOS_NW_33V_NG, < LUP_3_4_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_PW_33V, POST_DRIVER_PMOS_NW_LV_NG, < LUP_3_4_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_33V, POST_DRIVER_PMOS_NW_LV_NG, < LUP_3_4_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_PW_LV, POST_DRIVER_PMOS_NW_33V_NG, < LUP_3_4_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_PW_LV, POST_DRIVER_PMOS_NW_33V_NG, < LUP_3_4_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RW_33V, POST_DRIVER_PMOS_NW_33V_NG, < LUP_3_4_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_33V, POST_DRIVER_PMOS_NW_33V_NG, < LUP_3_4_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RW_33V, POST_DRIVER_PMOS_NW_LV_NG, < LUP_3_4_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_33V, POST_DRIVER_PMOS_NW_LV_NG, < LUP_3_4_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RW_LV, POST_DRIVER_PMOS_NW_33V_NG, < LUP_3_4_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RW_LV, POST_DRIVER_PMOS_NW_33V_NG, < LUP_3_4_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RWI_33V, POST_DRIVER_PMOS_NWI_33V_NG, < LUP_3_4_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_33V, POST_DRIVER_PMOS_NWI_33V_NG, < LUP_3_4_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NMOS_RWI_33V, POST_DRIVER_PMOS_NWI_LV_NG, < LUP_3_4_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_33V, POST_DRIVER_PMOS_NWI_LV_NG, < LUP_3_4_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION  */ 
             external2_edge( POST_DRIVER_NMOS_RWI_LV, POST_DRIVER_PMOS_NWI_33V_NG, < LUP_3_4_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NMOS_RWI_LV, POST_DRIVER_PMOS_NWI_33V_NG, < LUP_3_4_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
         } /* end of rule : LUP.3.4.2g */
         #ifdef LP 
            
            //LUP.3.5.0 is checked by LUP.3.5.1g and LUP.3.5.2g
            rLUP_3_5_1G @= { @ "LUP.3.5.1g : For the 5V N/PMOS which connects to an I/O pad directly, space between the 5V NMOS and the 5V/2.5V/1.2V PMOS, space between the 5V PMOS and the 5V/2.5V/1.2V NMOS >= " + LUP_3_5_1 + " um"; 
                external2_edge( POST_DRIVER_NMOS_PW_5V, POST_DRIVER_PMOS_NW, < LUP_3_5_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_PW_5V, POST_DRIVER_PMOS_NW, < LUP_3_5_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_PW, POST_DRIVER_PMOS_NW_5V, < LUP_3_5_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_PW, POST_DRIVER_PMOS_NW_5V, < LUP_3_5_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_RW_5V, POST_DRIVER_PMOS_NW, < LUP_3_5_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_RW_5V, POST_DRIVER_PMOS_NW, < LUP_3_5_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_RW, POST_DRIVER_PMOS_NW_5V, < LUP_3_5_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_RW, POST_DRIVER_PMOS_NW_5V, < LUP_3_5_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_RWI_5V, POST_DRIVER_PMOS_NWI, < LUP_3_5_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_RWI_5V, POST_DRIVER_PMOS_NWI, < LUP_3_5_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_RWI, POST_DRIVER_PMOS_NWI_5V, < LUP_3_5_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_RWI, POST_DRIVER_PMOS_NWI_5V, < LUP_3_5_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
            } /* end of rule : LUP.3.5.1g */
            rLUP_3_5_2G @= { @ "LUP.3.5.2g : For the 5V N/PMOS which connects to an I/O pad directly, space between the 5V NMOS and the 5V/2.5V/1.2V PMOS, space between the 5V PMOS and the 5V/2.5V/1.2V NMOS >= " + LUP_3_5_2 + " um if one of guard-ring < " + LUP_3_W + " um"; 
                external2_edge( POST_DRIVER_NMOS_PW_5V_NG, POST_DRIVER_PMOS_NW, < LUP_3_5_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_PW_5V_NG, POST_DRIVER_PMOS_NW, < LUP_3_5_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_PW_NG, POST_DRIVER_PMOS_NW_5V, < LUP_3_5_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_PW_NG, POST_DRIVER_PMOS_NW_5V, < LUP_3_5_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_RW_5V_NG, POST_DRIVER_PMOS_NW, < LUP_3_5_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_RW_5V_NG, POST_DRIVER_PMOS_NW, < LUP_3_5_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_RW_NG, POST_DRIVER_PMOS_NW_5V, < LUP_3_5_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_RW_NG, POST_DRIVER_PMOS_NW_5V, < LUP_3_5_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_RWI_5V_NG, POST_DRIVER_PMOS_NWI, < LUP_3_5_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_RWI_5V_NG, POST_DRIVER_PMOS_NWI, < LUP_3_5_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_RWI_NG, POST_DRIVER_PMOS_NWI_5V, < LUP_3_5_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_RWI_NG, POST_DRIVER_PMOS_NWI_5V, < LUP_3_5_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_PW_5V, POST_DRIVER_PMOS_NW_NG, < LUP_3_5_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_PW_5V, POST_DRIVER_PMOS_NW_NG, < LUP_3_5_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_PW, POST_DRIVER_PMOS_NW_5V_NG, < LUP_3_5_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_PW, POST_DRIVER_PMOS_NW_5V_NG, < LUP_3_5_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_RW_5V, POST_DRIVER_PMOS_NW_NG, < LUP_3_5_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_RW_5V, POST_DRIVER_PMOS_NW_NG, < LUP_3_5_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_RW, POST_DRIVER_PMOS_NW_5V_NG, < LUP_3_5_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_RW, POST_DRIVER_PMOS_NW_5V_NG, < LUP_3_5_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_RWI_5V, POST_DRIVER_PMOS_NWI_NG, < LUP_3_5_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_RWI_5V, POST_DRIVER_PMOS_NWI_NG, < LUP_3_5_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_RWI, POST_DRIVER_PMOS_NWI_5V_NG, < LUP_3_5_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NMOS_RWI, POST_DRIVER_PMOS_NWI_5V_NG, < LUP_3_5_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
            } /* end of rule : LUP.3.5.2g */
         #endif /* end of #ifdef LP  */ 
         rLUP_4G @= { @ "LUP.4g : Width of the N+ guard-ring, P+ guard-ring, N+ STRAP and P+ STRAP for the OD injector, and also MOS within " + LUP_2 + " um space from OD injector. >= " + LUP_4 + " um"; 
             sLAYER_1146 = outside_touching( PSTPI, PTAP_GUARD_RING_HOLEX ); 
             PTAP_GUARD_RING_WIDE2 = wide( sLAYER_1146, >= LUP_4, forty_five = INTERNAL ); 
             sLAYER_1147 = outside_touching( NSTPI, NTAP_GUARD_RING_HOLEX ); 
             NTAP_GUARD_RING_WIDE2 = wide( sLAYER_1147, >= LUP_4, forty_five = INTERNAL ); 
             PW_INSIDE_GUARD_RING_WIDE2_PRE1 = PW_INSIDE_GUARD_RING not_coincident_outside_edge PTAP_GUARD_RING_WIDE2; 
             PW_INSIDE_GUARD_RING_WIDE2 = PW_INSIDE_GUARD_RING not_touching PW_INSIDE_GUARD_RING_WIDE2_PRE1; 
             NW_INSIDE_GUARD_RING_WIDE2_PRE1 = NW_INSIDE_GUARD_RING not_coincident_outside_edge NTAP_GUARD_RING_WIDE2; 
             NW_INSIDE_GUARD_RING_WIDE2 = NW_INSIDE_GUARD_RING not_touching NW_INSIDE_GUARD_RING_WIDE2_PRE1; 
             sLAYER_1148 = donut_holes( PTAP_GUARD_RING_WIDE2, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
             PTAP_GUARD_RING_WIDE2_HOLE = sLAYER_1148 or PW_INSIDE_GUARD_RING_WIDE2; 
             sLAYER_1149 = donut_holes( NTAP_GUARD_RING_WIDE2, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
             NTAP_GUARD_RING_WIDE2_HOLE = sLAYER_1149 or NW_INSIDE_GUARD_RING_WIDE2; 
             PTAP_GUARD_RING_HOLE_CHECK = PTAP_GUARD_RING_HOLEX not_inside PTAP_GUARD_RING_WIDE2_HOLE; 
             NTAP_GUARD_RING_HOLE_CHECK = NTAP_GUARD_RING_HOLEX not_inside NTAP_GUARD_RING_WIDE2_HOLE; 
             PTAP_GUARD_RING_CHECK = PSTPI coincident_outside_edge PTAP_GUARD_RING_HOLE_CHECK; 
             NTAP_GUARD_RING_CHECK = NSTPI coincident_outside_edge NTAP_GUARD_RING_HOLE_CHECK; 
             internal2( PTAP_GUARD_RING_CHECK, PSTPI, < LUP_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = RELATED_COINCIDENT, width = 0.002 ); 
             internal2( NTAP_GUARD_RING_CHECK, NSTPI, < LUP_4, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = RELATED_COINCIDENT, width = 0.002 ); 
         } /* end of rule : LUP.4g */
         
         //LUP.5.1.0 is checked by LUP.5.1.1g and LUP.5.1.2g
         rLUP_5_1_1G @= { @ "LUP.5.1.1g : Minimum space >= " + LUP_5_1_1 + " um " 
                                         "1. between 1.2V-1.0V N+ OD injector which connects to the IO pad and the the PMOS in the internal circuit "
                                         "2. between 1.2V-1.0V P+ OD injector which connects to the IO pad and the the NMOS in the internal circuit";
             external2_edge( POST_DRIVER_PINJ_NW_LV, BESIDE_POST_DRIVER_NMOS_PW, < LUP_5_1_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NW_LV, BESIDE_POST_DRIVER_NMOS_PW, < LUP_5_1_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_PINJ_NW_LV, BESIDE_POST_DRIVER_NMOS_RW, < LUP_5_1_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NW_LV, BESIDE_POST_DRIVER_NMOS_RW, < LUP_5_1_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_PINJ_NWI_LV, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_5_1_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NWI_LV, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_5_1_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_PW_LV, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_1_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_PW_LV, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_1_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_RW_LV, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_1_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_RW_LV, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_1_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_RWI_LV, BESIDE_POST_DRIVER_PMOS_NWI, < LUP_5_1_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_RWI_LV, BESIDE_POST_DRIVER_PMOS_NWI, < LUP_5_1_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
         } /* end of rule : LUP.5.1.1g */
         rLUP_5_1_2G @= { @ "LUP.5.1.2g : Minimum space >= " + LUP_5_1_2 + " um if one of guard-ring < " + LUP_3_W + " um " 
                                         "1. between 1.2V-1.0V N+ OD injector which connects to the IO pad and the the PMOS in the internal circuit "
                                         "2. between 1.2V-1.0V P+ OD injector which connects to the IO pad and the the NMOS in the internal circuit";
             external2_edge( POST_DRIVER_PINJ_NW_LV_NG, BESIDE_POST_DRIVER_NMOS_PW, < LUP_5_1_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NW_LV_NG, BESIDE_POST_DRIVER_NMOS_PW, < LUP_5_1_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_PINJ_NW_LV_NG, BESIDE_POST_DRIVER_NMOS_RW, < LUP_5_1_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NW_LV_NG, BESIDE_POST_DRIVER_NMOS_RW, < LUP_5_1_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_PINJ_NWI_LV_NG, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_5_1_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NWI_LV_NG, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_5_1_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_PW_LV_NG, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_1_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_PW_LV_NG, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_1_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_RW_LV_NG, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_1_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_RW_LV_NG, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_1_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_RWI_LV_NG, BESIDE_POST_DRIVER_PMOS_NWI, < LUP_5_1_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_RWI_LV_NG, BESIDE_POST_DRIVER_PMOS_NWI, < LUP_5_1_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_PINJ_NW_LV, BESIDE_POST_DRIVER_NMOS_PW_NG, < LUP_5_1_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NW_LV, BESIDE_POST_DRIVER_NMOS_PW_NG, < LUP_5_1_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_PINJ_NW_LV, BESIDE_POST_DRIVER_NMOS_RW_NG, < LUP_5_1_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NW_LV, BESIDE_POST_DRIVER_NMOS_RW_NG, < LUP_5_1_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_PINJ_NWI_LV, BESIDE_POST_DRIVER_NMOS_RWI_NG, < LUP_5_1_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NWI_LV, BESIDE_POST_DRIVER_NMOS_RWI_NG, < LUP_5_1_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_PW_LV, BESIDE_POST_DRIVER_PMOS_NW_NG, < LUP_5_1_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_PW_LV, BESIDE_POST_DRIVER_PMOS_NW_NG, < LUP_5_1_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_RW_LV, BESIDE_POST_DRIVER_PMOS_NW_NG, < LUP_5_1_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_RW_LV, BESIDE_POST_DRIVER_PMOS_NW_NG, < LUP_5_1_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_RWI_LV, BESIDE_POST_DRIVER_PMOS_NWI_NG, < LUP_5_1_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_RWI_LV, BESIDE_POST_DRIVER_PMOS_NWI_NG, < LUP_5_1_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
         } /* end of rule : LUP.5.1.2g */
         
         //LUP.5.2.0 is checked by LUP.5.2.1g and LUP.5.2.2g
         rLUP_5_2_1G @= { @ "LUP.5.2.1g : Minimum space >= " + LUP_5_2_1 + " um " 
                                         "1. between 1.8V N+ OD injector which connects to the IO pad and the the PMOS in the internal circuit "
                                         "2. between 1.8V P+ OD injector which connects to the IO pad and the the NMOS in the internal circuit";
             external2_edge( POST_DRIVER_PINJ_NW_18V, BESIDE_POST_DRIVER_NMOS_PW, < LUP_5_2_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NW_18V, BESIDE_POST_DRIVER_NMOS_PW, < LUP_5_2_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_PINJ_NW_18V, BESIDE_POST_DRIVER_NMOS_RW, < LUP_5_2_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NW_18V, BESIDE_POST_DRIVER_NMOS_RW, < LUP_5_2_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION  */ 
             external2_edge( POST_DRIVER_PINJ_NWI_18V, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_5_2_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NWI_18V, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_5_2_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_PW_18V, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_2_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_PW_18V, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_2_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_RW_18V, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_2_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_RW_18V, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_2_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_RWI_18V, BESIDE_POST_DRIVER_PMOS_NWI, < LUP_5_2_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_RWI_18V, BESIDE_POST_DRIVER_PMOS_NWI, < LUP_5_2_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
         } /* end of rule : LUP.5.2.1g */
         rLUP_5_2_2G @= { @ "LUP.5.2.2g : Minimum space >= " + LUP_5_2_2 + " um if one of guard-ring < " + LUP_3_W + " um " 
                                         "1. between 1.8V N+ OD injector which connects to the IO pad and the the PMOS in the internal circuit "
                                         "2. between 1.8V P+ OD injector which connects to the IO pad and the the NMOS in the internal circuit";
             external2_edge( POST_DRIVER_PINJ_NW_18V_NG, BESIDE_POST_DRIVER_NMOS_PW, < LUP_5_2_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NW_18V_NG, BESIDE_POST_DRIVER_NMOS_PW, < LUP_5_2_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_PINJ_NW_18V_NG, BESIDE_POST_DRIVER_NMOS_RW, < LUP_5_2_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NW_18V_NG, BESIDE_POST_DRIVER_NMOS_RW, < LUP_5_2_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NWI_18V_NG, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_5_2_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NWI_18V_NG, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_5_2_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_PW_18V_NG, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_2_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_PW_18V_NG, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_2_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_RW_18V_NG, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_2_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_RW_18V_NG, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_2_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_RWI_18V_NG, BESIDE_POST_DRIVER_PMOS_NWI, < LUP_5_2_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_RWI_18V_NG, BESIDE_POST_DRIVER_PMOS_NWI, < LUP_5_2_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NW_18V, BESIDE_POST_DRIVER_NMOS_PW_NG, < LUP_5_2_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NW_18V, BESIDE_POST_DRIVER_NMOS_PW_NG, < LUP_5_2_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_PINJ_NW_18V, BESIDE_POST_DRIVER_NMOS_RW_NG, < LUP_5_2_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NW_18V, BESIDE_POST_DRIVER_NMOS_RW_NG, < LUP_5_2_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_PINJ_NWI_18V, BESIDE_POST_DRIVER_NMOS_RWI_NG, < LUP_5_2_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NWI_18V, BESIDE_POST_DRIVER_NMOS_RWI_NG, < LUP_5_2_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_PW_18V, BESIDE_POST_DRIVER_PMOS_NW_NG, < LUP_5_2_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_PW_18V, BESIDE_POST_DRIVER_PMOS_NW_NG, < LUP_5_2_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_RW_18V, BESIDE_POST_DRIVER_PMOS_NW_NG, < LUP_5_2_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_RW_18V, BESIDE_POST_DRIVER_PMOS_NW_NG, < LUP_5_2_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_RWI_18V, BESIDE_POST_DRIVER_PMOS_NWI_NG, < LUP_5_2_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_RWI_18V, BESIDE_POST_DRIVER_PMOS_NWI_NG, < LUP_5_2_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
         } /* end of rule : LUP.5.2.2g */
         
         //LUP.5.3.0 is checked by LUP.5.3.1g and LUP.5.3.2g
         rLUP_5_3_1G @= { @ "LUP.5.3.1g : Minimum space >= " + LUP_5_3_1 + " um " 
                                         "1. between 2.5V N+ OD injector which connects to the IO pad and the the PMOS in the internal circuit "
                                         "2. between 2.5V P+ OD injector which connects to the IO pad and the the NMOS in the internal circuit";
             external2_edge( POST_DRIVER_PINJ_NW_25V, BESIDE_POST_DRIVER_NMOS_PW, < LUP_5_3_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NW_25V, BESIDE_POST_DRIVER_NMOS_PW, < LUP_5_3_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_PINJ_NW_25V, BESIDE_POST_DRIVER_NMOS_RW, < LUP_5_3_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NW_25V, BESIDE_POST_DRIVER_NMOS_RW, < LUP_5_3_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_PINJ_NWI_25V, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_5_3_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NWI_25V, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_5_3_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_PW_25V, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_3_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_PW_25V, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_3_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_RW_25V, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_3_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_RW_25V, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_3_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_RWI_25V, BESIDE_POST_DRIVER_PMOS_NWI, < LUP_5_3_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_RWI_25V, BESIDE_POST_DRIVER_PMOS_NWI, < LUP_5_3_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
         } /* end of rule : LUP.5.3.1g */
         rLUP_5_3_2G @= { @ "LUP.5.3.2g : Minimum space >= " + LUP_5_3_2 + " um if one of guard-ring < " + LUP_3_W + " um " 
                                         "1. between 2.5V N+ OD injector which connects to the IO pad and the the PMOS in the internal circuit "
                                         "2. between 2.5V P+ OD injector which connects to the IO pad and the the NMOS in the internal circuit";
             external2_edge( POST_DRIVER_PINJ_NW_25V_NG, BESIDE_POST_DRIVER_NMOS_PW, < LUP_5_3_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NW_25V_NG, BESIDE_POST_DRIVER_NMOS_PW, < LUP_5_3_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_PINJ_NW_25V_NG, BESIDE_POST_DRIVER_NMOS_RW, < LUP_5_3_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NW_25V_NG, BESIDE_POST_DRIVER_NMOS_RW, < LUP_5_3_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_PINJ_NWI_25V_NG, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_5_3_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NWI_25V_NG, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_5_3_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_PW_25V_NG, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_3_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_PW_25V_NG, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_3_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_RW_25V_NG, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_3_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_RW_25V_NG, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_3_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_RWI_25V_NG, BESIDE_POST_DRIVER_PMOS_NWI, < LUP_5_3_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_RWI_25V_NG, BESIDE_POST_DRIVER_PMOS_NWI, < LUP_5_3_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_PINJ_NW_25V, BESIDE_POST_DRIVER_NMOS_PW_NG, < LUP_5_3_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NW_25V, BESIDE_POST_DRIVER_NMOS_PW_NG, < LUP_5_3_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_PINJ_NW_25V, BESIDE_POST_DRIVER_NMOS_RW_NG, < LUP_5_3_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NW_25V, BESIDE_POST_DRIVER_NMOS_RW_NG, < LUP_5_3_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_PINJ_NWI_25V, BESIDE_POST_DRIVER_NMOS_RWI_NG, < LUP_5_3_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NWI_25V, BESIDE_POST_DRIVER_NMOS_RWI_NG, < LUP_5_3_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_PW_25V, BESIDE_POST_DRIVER_PMOS_NW_NG, < LUP_5_3_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_PW_25V, BESIDE_POST_DRIVER_PMOS_NW_NG, < LUP_5_3_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_RW_25V, BESIDE_POST_DRIVER_PMOS_NW_NG, < LUP_5_3_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_RW_25V, BESIDE_POST_DRIVER_PMOS_NW_NG, < LUP_5_3_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_RWI_25V, BESIDE_POST_DRIVER_PMOS_NWI_NG, < LUP_5_3_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_RWI_25V, BESIDE_POST_DRIVER_PMOS_NWI_NG, < LUP_5_3_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
         } /* end of rule : LUP.5.3.2g */
         
         //LUP.5.4.0 is checked by LUP.5.4.1g and LUP.5.4.2g
         rLUP_5_4_1G @= { @ "LUP.5.4.1g : Minimum space >= " + LUP_5_4_1 + " um " 
                                         "1. between 3.3V N+ OD injector which connects to the IO pad and the the PMOS in the internal circuit "
                                         "2. between 3.3V P+ OD injector which connects to the IO pad and the the NMOS in the internal circuit";
             external2_edge( POST_DRIVER_PINJ_NW_33V, BESIDE_POST_DRIVER_NMOS_PW, < LUP_5_4_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NW_33V, BESIDE_POST_DRIVER_NMOS_PW, < LUP_5_4_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_PINJ_NW_33V, BESIDE_POST_DRIVER_NMOS_RW, < LUP_5_4_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NW_33V, BESIDE_POST_DRIVER_NMOS_RW, < LUP_5_4_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_PINJ_NWI_33V, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_5_4_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NWI_33V, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_5_4_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_PW_33V, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_4_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_PW_33V, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_4_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_RW_33V, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_4_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_RW_33V, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_4_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_RWI_33V, BESIDE_POST_DRIVER_PMOS_NWI, < LUP_5_4_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_RWI_33V, BESIDE_POST_DRIVER_PMOS_NWI, < LUP_5_4_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
         } /* end of rule : LUP.5.4.1g */
         rLUP_5_4_2G @= { @ "LUP.5.4.2g : Minimum space >= " + LUP_5_4_2 + " um if one of guard-ring < " + LUP_3_W + " um " 
                                         "1. between 3.3V N+ OD injector which connects to the IO pad and the the PMOS in the internal circuit "
                                         "2. between 3.3V P+ OD injector which connects to the IO pad and the the NMOS in the internal circuit";
             external2_edge( POST_DRIVER_PINJ_NW_33V_NG, BESIDE_POST_DRIVER_NMOS_PW, < LUP_5_4_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NW_33V_NG, BESIDE_POST_DRIVER_NMOS_PW, < LUP_5_4_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_PINJ_NW_33V_NG, BESIDE_POST_DRIVER_NMOS_RW, < LUP_5_4_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NW_33V_NG, BESIDE_POST_DRIVER_NMOS_RW, < LUP_5_4_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_PINJ_NWI_33V_NG, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_5_4_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NWI_33V_NG, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_5_4_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_PW_33V_NG, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_4_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_PW_33V_NG, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_4_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_RW_33V_NG, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_4_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_RW_33V_NG, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_4_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_RWI_33V_NG, BESIDE_POST_DRIVER_PMOS_NWI, < LUP_5_4_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_RWI_33V_NG, BESIDE_POST_DRIVER_PMOS_NWI, < LUP_5_4_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_PINJ_NW_33V, BESIDE_POST_DRIVER_NMOS_PW_NG, < LUP_5_4_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NW_33V, BESIDE_POST_DRIVER_NMOS_PW_NG, < LUP_5_4_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_PINJ_NW_33V, BESIDE_POST_DRIVER_NMOS_RW_NG, < LUP_5_4_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NW_33V, BESIDE_POST_DRIVER_NMOS_RW_NG, < LUP_5_4_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_PINJ_NWI_33V, BESIDE_POST_DRIVER_NMOS_RWI_NG, < LUP_5_4_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_PINJ_NWI_33V, BESIDE_POST_DRIVER_NMOS_RWI_NG, < LUP_5_4_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_PW_33V, BESIDE_POST_DRIVER_PMOS_NW_NG, < LUP_5_4_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_PW_33V, BESIDE_POST_DRIVER_PMOS_NW_NG, < LUP_5_4_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_RW_33V, BESIDE_POST_DRIVER_PMOS_NW_NG, < LUP_5_4_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_RW_33V, BESIDE_POST_DRIVER_PMOS_NW_NG, < LUP_5_4_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
             external2_edge( POST_DRIVER_NINJ_RWI_33V, BESIDE_POST_DRIVER_PMOS_NWI_NG, < LUP_5_4_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
             external2_edge( POST_DRIVER_NINJ_RWI_33V, BESIDE_POST_DRIVER_PMOS_NWI_NG, < LUP_5_4_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
         } /* end of rule : LUP.5.4.2g */
         #ifdef LP 
            
            //LUP.5.5.0 is checked by LUP.5.5.1g and LUP.5.5.2g
            rLUP_5_5_1G @= { @ "LUP.5.5.1g : Minimum space >= " + LUP_5_5_1 + " um " 
                                            "1. between 5V N+ OD injector which connects to the IO pad and the the PMOS in the internal circuit "
                                            "2. between 5V P+ OD injector which connects to the IO pad and the the NMOS in the internal circuit";
                external2_edge( POST_DRIVER_PINJ_NW_5V, BESIDE_POST_DRIVER_NMOS_PW, < LUP_5_5_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_PINJ_NW_5V, BESIDE_POST_DRIVER_NMOS_PW, < LUP_5_5_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
                external2_edge( POST_DRIVER_PINJ_NW_5V, BESIDE_POST_DRIVER_NMOS_RW, < LUP_5_5_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_PINJ_NW_5V, BESIDE_POST_DRIVER_NMOS_RW, < LUP_5_5_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
                external2_edge( POST_DRIVER_PINJ_NWI_5V, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_5_5_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_PINJ_NWI_5V, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_5_5_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
                external2_edge( POST_DRIVER_NINJ_PW_5V, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_5_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NINJ_PW_5V, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_5_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
                external2_edge( POST_DRIVER_NINJ_RW_5V, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_5_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NINJ_RW_5V, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_5_1, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
                external2_edge( POST_DRIVER_NINJ_RWI_5V, BESIDE_POST_DRIVER_PMOS_NWI, < LUP_5_5_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NINJ_RWI_5V, BESIDE_POST_DRIVER_PMOS_NWI, < LUP_5_5_1, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
            } /* end of rule : LUP.5.5.1g */
            rLUP_5_5_2G @= { @ "LUP.5.5.2g : Minimum space >= " + LUP_5_5_2 + " um if one of guard-ring < " + LUP_3_W + " um " 
                                            "1. between 5V N+ OD injector which connects to the IO pad and the the PMOS in the internal circuit "
                                            "2. between 5V P+ OD injector which connects to the IO pad and the the NMOS in the internal circuit";
                external2_edge( POST_DRIVER_PINJ_NW_5V_NG, BESIDE_POST_DRIVER_NMOS_PW, < LUP_5_5_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_PINJ_NW_5V_NG, BESIDE_POST_DRIVER_NMOS_PW, < LUP_5_5_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
                external2_edge( POST_DRIVER_PINJ_NW_5V_NG, BESIDE_POST_DRIVER_NMOS_RW, < LUP_5_5_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_PINJ_NW_5V_NG, BESIDE_POST_DRIVER_NMOS_RW, < LUP_5_5_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
                external2_edge( POST_DRIVER_PINJ_NWI_5V_NG, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_5_5_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_PINJ_NWI_5V_NG, BESIDE_POST_DRIVER_NMOS_RWI, < LUP_5_5_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
                external2_edge( POST_DRIVER_NINJ_PW_5V_NG, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_5_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NINJ_PW_5V_NG, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_5_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
                external2_edge( POST_DRIVER_NINJ_RW_5V_NG, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_5_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NINJ_RW_5V_NG, BESIDE_POST_DRIVER_PMOS_NW, < LUP_5_5_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
                external2_edge( POST_DRIVER_NINJ_RWI_5V_NG, BESIDE_POST_DRIVER_PMOS_NWI, < LUP_5_5_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NINJ_RWI_5V_NG, BESIDE_POST_DRIVER_PMOS_NWI, < LUP_5_5_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
                external2_edge( POST_DRIVER_PINJ_NW_5V, BESIDE_POST_DRIVER_NMOS_PW_NG, < LUP_5_5_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_PINJ_NW_5V, BESIDE_POST_DRIVER_NMOS_PW_NG, < LUP_5_5_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
                external2_edge( POST_DRIVER_PINJ_NW_5V, BESIDE_POST_DRIVER_NMOS_RW_NG, < LUP_5_5_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_PINJ_NW_5V, BESIDE_POST_DRIVER_NMOS_RW_NG, < LUP_5_5_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
                external2_edge( POST_DRIVER_PINJ_NWI_5V, BESIDE_POST_DRIVER_NMOS_RWI_NG, < LUP_5_5_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_PINJ_NWI_5V, BESIDE_POST_DRIVER_NMOS_RWI_NG, < LUP_5_5_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
                external2_edge( POST_DRIVER_NINJ_PW_5V, BESIDE_POST_DRIVER_PMOS_NW_NG, < LUP_5_5_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NINJ_PW_5V, BESIDE_POST_DRIVER_PMOS_NW_NG, < LUP_5_5_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
                external2_edge( POST_DRIVER_NINJ_RW_5V, BESIDE_POST_DRIVER_PMOS_NW_NG, < LUP_5_5_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NINJ_RW_5V, BESIDE_POST_DRIVER_PMOS_NW_NG, < LUP_5_5_2, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
                external2_edge( POST_DRIVER_NINJ_RWI_5V, BESIDE_POST_DRIVER_PMOS_NWI_NG, < LUP_5_5_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, relational = { POINT_TOUCH } ); 
                external2_edge( POST_DRIVER_NINJ_RWI_5V, BESIDE_POST_DRIVER_PMOS_NWI_NG, < LUP_5_5_2, connect_sequence = CONNECT_DB, connectivity = DIFFERENT_NET, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER2, relational = { POINT_TOUCH } );    /* REGION */ 
            } /* end of rule : LUP.5.5.2g */
         #endif /* end of #ifdef LP  */ 
      #endif /* end of #ifdef GUIDELINE_LUP  */ 
      gLAYER_686 = PSDC not_outside COI; 
      CO_PACT = COI or gLAYER_686; 
      NPUI = interacting( NSTPI, CO_PACT ); 
      NPUI_SRAM = NPUI inside SRM; 
      NSTP_OS = size_inside_wrapper( NPUI, NWI, distance = LUP_6, increment = NW_S_1 * 0.7 ); 
      NSTP_OS_SRAM = size_inside_wrapper( NPUI_SRAM, NWI, distance = LUP_6_SRAM, increment = NW_S_1 * 0.7 ); 
      gLAYER_688 = interacting( PACTI, COI ); 
      gLAYER_687 = interacting( gLAYER_688, POI ); 
      PACT_CHECK = gLAYER_687 not POI; 
      PACT_CHECK_NON_SRAM = PACT_CHECK not_inside SRM; 
      PACT_CHECK_SRAM = PACT_CHECK inside SRM; 
      gLAYER_689 = NSDC not_outside COI; 
      CO_NACT = COI or gLAYER_689; 
      PPUI = interacting( PSTPI, CO_NACT ); 
      PPUI_SRAM = PPUI inside SRM; 
      PSTP_OS = size_inside_wrapper( PPUI, PWELI, distance = LUP_6, increment = NW_S_1 * 0.7 ); 
      PSTP_OS_SRAM = size_inside_wrapper( PPUI_SRAM, PWELI, distance = LUP_6_SRAM, increment = NW_S_1 * 0.7 ); 
      gLAYER_691 = interacting( NACTI, COI ); 
      gLAYER_690 = interacting( gLAYER_691, POI ); 
      NACT_CHECK = gLAYER_690 not POI; 
      NACT_CHECK_NON_SRAM = NACT_CHECK not_inside SRM; 
      NACT_CHECK_SRAM = NACT_CHECK inside SRM; 
      rLUP_6 @= { @ "LUP.6 : Any point inside NMOS source/drain space to the nearest PW STRAP in the same PW <= " + LUP_6 + " um " 
                            "Any point inside PMOS source/drain space to the nearest NW STRAP in the same NW <= " + LUP_6 + " um " 
                            "In SRAM bit cell region, the rule is relaxed to " + LUP_6_SRAM + " um"; 
          PACT_CHECK_NON_SRAM not NSTP_OS; 
          sLAYER_1150 = NSTP_OS or NSTP_OS_SRAM; 
          PACT_CHECK_SRAM not sLAYER_1150; 
          NACT_CHECK_NON_SRAM not PSTP_OS; 
          sLAYER_1151 = PSTP_OS or PSTP_OS_SRAM; 
          NACT_CHECK_SRAM not sLAYER_1151; 
      } /* end of rule : LUP.6 */
      
      //LUP.10.g is checked by LUP.10__LUP.13 
      //LUP.13.g is checked by LUP.10__LUP.13 
      rLUP_10__LUP_13 @= { @ "LUP.10__LUP.13 : For Area I/O, within " + LUP_10 + " um from OD injector (covered by LUPWDMY_2), " 
                                              "Any point inside NMOS source/drain space to the nearest PW STRAP in the same PW <= " + LUP_13 + " um " 
                                              "Any point inside PMOS source/drain space to the nearest NW STRAP in the same NW <= " + LUP_13 + " um"; 
          TRIGGER_SOURCE = POST_DRIVER_ACT not_outside LUPWDMY_2; 
          sLAYER_1152 = NACT_CHECK not TRIGGER_SOURCE; 
          CORE_LOGIC_NACT = sLAYER_1152 not_inside PTAP_GUARD_RING_HOLE; 
          sLAYER_1153 = PACT_CHECK not TRIGGER_SOURCE; 
          CORE_LOGIC_PACT = sLAYER_1153 not_inside NTAP_GUARD_RING_HOLE; 
          sLAYER_1154 = size( TRIGGER_SOURCE, clip_acute = NONE, corner_extension = RADIAL_INSIDE, distance = LUP_10, radial_sectors = 4 ); 
          NACT_LUP_PRE = CORE_LOGIC_NACT not_outside sLAYER_1154; 
          sLAYER_1155 = size( TRIGGER_SOURCE, clip_acute = NONE, corner_extension = RADIAL_INSIDE, distance = LUP_10, radial_sectors = 4 ); 
          PACT_LUP_PRE = CORE_LOGIC_PACT not_outside sLAYER_1155; 
          sLAYER_1157 = size( size( PACT_LUP_PRE, LUP_10E, clip_acute = NONE ), - LUP_10E, clip_acute = NONE ); 
          sLAYER_1156 = size( sLAYER_1157, clip_acute = NONE, corner_extension = RADIAL_INSIDE, distance = LUP_10E, radial_sectors = 4 ); 
          NACT_LUP = NACT_LUP_PRE not_outside sLAYER_1156; 
          sLAYER_1159 = size( size( NACT_LUP_PRE, LUP_10E, clip_acute = NONE ), - LUP_10E, clip_acute = NONE ); 
          sLAYER_1158 = size( sLAYER_1159, clip_acute = NONE, corner_extension = RADIAL_INSIDE, distance = LUP_10E, radial_sectors = 4 ); 
          PACT_LUP = PACT_LUP_PRE not_outside sLAYER_1158; 
          sPSTP_OS = size_inside_wrapper( PPUI, PWELI, distance = LUP_13, increment = NW_S_1 * 0.7 ); 
          NACT_LUP not sPSTP_OS; 
          sNSTP_OS = size_inside_wrapper( NPUI, NWI, distance = LUP_13, increment = NW_S_1 * 0.7 ); 
          PACT_LUP not sNSTP_OS; 
      } /* end of rule : LUP.10__LUP.13 */
      rLUP_14_G @= { @ "LUP.14.g : For Area I/O, width of picup ring and guard rings for the OD injector >= 0.2";
          AREA_IO_NACT = POST_DRIVER_NACT not_outside LUPWDMY_2; 
          AREA_IO_PACT = POST_DRIVER_PACT not_outside LUPWDMY_2; 
          AREA_IO_NACT not_inside PTAP_GUARD_RING_HOLE; 
          AREA_IO_PACT not_inside NTAP_GUARD_RING_HOLE; 
          sLAYER_1161 = donut_holes( PSTPI, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          sLAYER_1160 = interacting( sLAYER_1161, AREA_IO_PACT ); 
          PTAP_GUARD_RING_2ND = not_interacting( sLAYER_1160, NACT ); 
          sLAYER_1163 = donut_holes( NSTPI, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          sLAYER_1162 = interacting( sLAYER_1163, AREA_IO_NACT ); 
          NTAP_GUARD_RING_2ND = not_interacting( sLAYER_1162, PACT ); 
          AREA_IO_NACT not_inside NTAP_GUARD_RING_2ND; 
          AREA_IO_PACT not_inside PTAP_GUARD_RING_2ND; 
          sLAYER_1164 = interacting( PTAP_GUARD_RING_HOLE, AREA_IO_NACT ); 
          PTAP_GUARD_RING_HOLE_EDGE = PSTPI coincident_outside_edge sLAYER_1164; 
          sLAYER_1165 = interacting( NTAP_GUARD_RING_HOLE, AREA_IO_PACT ); 
          NTAP_GUARD_RING_HOLE_EDGE = NSTPI coincident_outside_edge sLAYER_1165; 
          internal2( PTAP_GUARD_RING_HOLE_EDGE, PSTPI, < LUP_14, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = RELATED_COINCIDENT, width = 0.002 ); 
          internal2( NTAP_GUARD_RING_HOLE_EDGE, NSTPI, < LUP_14, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = RELATED_COINCIDENT, width = 0.002 ); 
          PTAP_GUARD_RING_2ND_EDGE = PSTPI coincident_outside_edge PTAP_GUARD_RING_2ND; 
          NTAP_GUARD_RING_2ND_EDGE = NSTPI coincident_outside_edge NTAP_GUARD_RING_2ND; 
          internal2( PTAP_GUARD_RING_2ND_EDGE, PSTPI, < LUP_14, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = RELATED_COINCIDENT, width = 0.002 ); 
          internal2( NTAP_GUARD_RING_2ND_EDGE, NSTPI, < LUP_14, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = RELATED_COINCIDENT, width = 0.002 ); 
      } /* end of rule : LUP.14.g */
      #ifdef GUIDELINE_ESD 
         gLAYER_697 = interacting( NACTI, POI ); 
         NMOSI = interacting( gLAYER_697, COI ); 
         gLAYER_692 = interacting( NSDC, NMOSI ); 
         NSDC_HVMOS = interacting( gLAYER_692, OD2 ); 
         gLAYER_693 = interacting( NSDC, NMOSI ); 
         NSDC_LVMOS = not_interacting( gLAYER_693, OD2 ); 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSDC_LVMOS }, NSDC }} ); 
         gLAYER_696 = interacting( PACTI, POI ); 
         PMOSI = interacting( gLAYER_696, COI ); 
         gLAYER_694 = interacting( PSDC, PMOSI ); 
         PSDC_HVMOS = interacting( gLAYER_694, OD2 ); 
         gLAYER_695 = interacting( PSDC, PMOSI ); 
         PSDC_LVMOS = not_interacting( gLAYER_695, OD2 ); 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSDC_LVMOS }, PSDC }} ); 
         NSDC_HVMOS_SDI = interacting( NSDC_HVMOS, SDI ); 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSDC_HVMOS_SDI }, NSDC }} ); 
         NSDC_LVMOS_SDI = interacting( NSDC_LVMOS, SDI ); 
         PSDC_HVMOS_SDI = interacting( PSDC_HVMOS, SDI ); 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSDC_HVMOS_SDI }, PSDC }} ); 
         PSDC_LVMOS_SDI = interacting( PSDC_LVMOS, SDI ); 
         HV_GATEC = stamp( HV_GATE, ILP1I, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
         LV_GATEC = stamp( LV_GATE, ILP1I, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
         ESD_PMOS = SDI and PMOSI; 
         ESD_NMOS = SDI and NMOSI; 
         ESD_MOS = ESD_PMOS or ESD_NMOS; 
         ESD_GATE = SDI and GATE; 
         ESD_GATE_FULLY_RPO = ESD_GATE inside RPO; 
         ESD_GATE_PARTIAL_RPO = cutting( ESD_GATE, RPO ); 
         ESD_GATE_RPO = interacting( ESD_GATE, RPO ); 
         ESD_GATE_NORPO = not_interacting( ESD_GATE, RPO ); 
         ESD_GATE_W = and_edge( GATE_W, SDI, false ); 
         ESD_GATE_L = and_edge( GATE_L, SDI, false ); 
         ESD_COOD = COOD and ESD_MOS; 
         gLAYER_699 = interacting( NSDC, CO ); 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ gLAYER_699 }, NSDC }} ); 
         gLAYER_698 = stamp( NSDI, gLAYER_699, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
         ESD_NSD = interacting( gLAYER_698, ESD_GATE ); 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ ESD_NSD }, gLAYER_698 }} ); 
         gLAYER_701 = interacting( PSDC, CO ); 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ gLAYER_701 }, PSDC }} ); 
         gLAYER_700 = stamp( PSDI, gLAYER_701, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
         ESD_PSD = interacting( gLAYER_700, ESD_GATE ); 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ ESD_PSD }, gLAYER_700 }} ); 
         ESD_NSD_STACK = not_interacting( ESD_NSD, CO ); 
         PSTPI_REAL = PSTPI not DIODMY; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSTPI_REAL }, PSTPI }} ); 
         NSTPI_REAL = NSTPI not DIODMY; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NSTPI_REAL }, NSTPI }} ); 
         ESD_NMOS_SOURCE_PRE1 = net_area_ratio( CONNECT_DB, > 0, { "layer1" => ESD_NSD, "layer2" => PSTPI_REAL }, 2, 2, {  }, NAR_SAVE_NET_16, false ); 
         gLAYER_703 = ESD_NMOS_SOURCE_PRE1 or ESD_GATE; 
         gLAYER_702 = gLAYER_703 or ESD_NSD_STACK; 
         ESD_NMOS_SOURCE_PRE2 = interacting( gLAYER_702, ESD_NMOS_SOURCE_PRE1 ); 
         gLAYER_704 = ESD_NSD not ESD_NMOS_SOURCE_PRE2; 
         ESD_NMOS_DRAIN_PRE1 = interacting( gLAYER_704, ESD_NMOS_SOURCE_PRE2 ); 
         gLAYER_706 = ESD_NMOS_DRAIN_PRE1 or ESD_GATE; 
         gLAYER_705 = gLAYER_706 or ESD_NSD_STACK; 
         ESD_NMOS_DRAIN_PRE2 = interacting( gLAYER_705, ESD_NMOS_DRAIN_PRE1 ); 
         gLAYER_707 = ESD_NSD not ESD_NMOS_DRAIN_PRE2; 
         ESD_NMOS_SOURCE_PRE3 = interacting( gLAYER_707, ESD_NMOS_DRAIN_PRE2 ); 
         ESD_NMOS_SOURCE_PRE4 = ESD_NMOS_SOURCE_PRE1 or ESD_NMOS_SOURCE_PRE3; 
         ESD_NMOS_DRAIN_PRE4 = ESD_NSD not ESD_NMOS_SOURCE_PRE4; 
         gLAYER_708 = interacting( ESD_NMOS, ESD_NMOS_SOURCE_PRE4 ); 
         ESD_NMOS_NORMAL = interacting( gLAYER_708, ESD_NMOS_DRAIN_PRE4 ); 
         ESD_NMOS_SPECIAL = ESD_NMOS not ESD_NMOS_NORMAL; 
         gLAYER_710 = interacting( ESD_NSD, ESD_NMOS_SPECIAL ); 
         gLAYER_709 = not_interacting( gLAYER_710, RPO ); 
         gLAYER_711 = interacting( ESD_NMOS_SOURCE_PRE4, ESD_NMOS_NORMAL ); 
         ESD_NMOS_SOURCE = gLAYER_709 or gLAYER_711; 
         gLAYER_712 = ESD_NSD not ESD_NMOS_SOURCE; 
         ESD_NMOS_DRAIN = gLAYER_712 not_inside RPO; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ ESD_NMOS_DRAIN }, ESD_NSD }} ); 
         ESD_PMOS_SOURCE_PRE1 = net_area_ratio( CONNECT_DB, > 0, { "layer1" => ESD_PSD, "layer2" => NSTPI_REAL }, 2, 2, {  }, NAR_SAVE_NET_16, false ); 
         gLAYER_713 = interacting( ESD_GATE, ESD_PMOS_SOURCE_PRE1 ); 
         ESD_PMOS_SOURCE_PRE2 = ESD_PMOS_SOURCE_PRE1 or gLAYER_713; 
         gLAYER_714 = ESD_PSD not ESD_PMOS_SOURCE_PRE2; 
         ESD_PMOS_DRAIN_PRE1 = interacting( gLAYER_714, ESD_PMOS_SOURCE_PRE2 ); 
         gLAYER_715 = interacting( ESD_GATE, ESD_PMOS_DRAIN_PRE1 ); 
         ESD_PMOS_DRAIN_PRE2 = ESD_PMOS_DRAIN_PRE1 or gLAYER_715; 
         gLAYER_716 = ESD_PSD not ESD_PMOS_DRAIN_PRE2; 
         ESD_PMOS_SOURCE_PRE3 = interacting( gLAYER_716, ESD_PMOS_DRAIN_PRE2 ); 
         ESD_PMOS_SOURCE_PRE4 = ESD_PMOS_SOURCE_PRE1 or ESD_PMOS_SOURCE_PRE3; 
         ESD_PMOS_DRAIN_PRE4 = ESD_PSD not ESD_PMOS_SOURCE_PRE4; 
         gLAYER_717 = interacting( ESD_PMOS, ESD_PMOS_SOURCE_PRE4 ); 
         ESD_PMOS_NORMAL = interacting( gLAYER_717, ESD_PMOS_DRAIN_PRE4 ); 
         ESD_PMOS_SPECIAL = ESD_PMOS not ESD_PMOS_NORMAL; 
         gLAYER_719 = interacting( ESD_PSD, ESD_PMOS_SPECIAL ); 
         gLAYER_718 = not_interacting( gLAYER_719, RPO ); 
         gLAYER_720 = interacting( ESD_PMOS_SOURCE_PRE4, ESD_PMOS_NORMAL ); 
         ESD_PMOS_SOURCE = gLAYER_718 or gLAYER_720; 
         gLAYER_721 = ESD_PSD not ESD_PMOS_SOURCE; 
         ESD_PMOS_DRAIN = gLAYER_721 not_inside RPO; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ ESD_PMOS_DRAIN }, ESD_PSD }} ); 
         ESD_MOS_SOURCE = ESD_NMOS_SOURCE or ESD_PMOS_SOURCE; 
         ESD_MOS_DRAIN = ESD_NMOS_DRAIN or ESD_PMOS_DRAIN; 
         ESD_NMOSC = stamp( ESD_NMOS, ESD_NMOS_DRAIN, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
         ESD_PMOSC = stamp( ESD_PMOS, ESD_PMOS_DRAIN, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
         #ifdef FULL_CHIP 
            rESD_WARN_1 @= { @ "ESD.WARN.1 : SDI is  not in whole chip";
                not_interacting( CHIPX, SDI ); 
            } /* end of rule : ESD.WARN.1 */
         #endif /* end of #ifdef FULL_CHIP  */ 
         rESD_WARN_2 @= { @ "ESD.WARN.2 : SDI encloure of ACTIVE >= 0";
             sLAYER_1166 = interacting( DACT, SDI ); 
             sLAYER_1166 not SDI; 
         } /* end of rule : ESD.WARN.2 */
         PSTPIX = PSTPI not DNWI; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PSTPIX }, PSTPI }} ); 
         rESD_1G @= { @ "ESD.1g : Use thin oxide transistor for thin oxide power clamp and thin oxide I/O buffers; use thick oxide transistor for the thick oxide Power Clamp and thick oxide I/O buffers (Figure XXX). DRC will flag the following one condition: (1) ((MOS INTERACT OD2) INTERACT SDI) connected to (MOS NOT INTERACT OD2) When turn off option 'DEFINE_PAD_BY_TEXT', DRC will exclude Drain/Source/Gate connected to {PW STRAP NOT DNW}. When turn on option 'DEFINE_PAD_BY_TEXT', DRC will exclude Drain/Source/Gate connected to VSS net. (For more ESD design Tips, please see the 'Tips for ESD/LU design' section in this chapter.)";
         #ifdef DEFINE_PAD_BY_TEXT 
                NSDC_HVMOS_SDI_PRE = net_select( CONNECT_DB, not_connected_to_any = { GND_M9I_BY_TEXT, GND_M8I_BY_TEXT, GND_M7I_BY_TEXT, GND_M6I_BY_TEXT, GND_M5I_BY_TEXT, GND_M4I_BY_TEXT, GND_M3I_BY_TEXT, GND_M2I_BY_TEXT, GND_M1I_BY_TEXT, GND_API_BY_TEXT }, output_from_layers = { NSDC_HVMOS_SDI } ); 
                CONNECT_DB_ESD_1G = incremental_connect( CONNECT_DB, {{{ NSDC_HVMOS_SDI_PRE }, NSDC_HVMOS_SDI }} ); 
                net_select( CONNECT_DB_ESD_1G, connected_to_any = { NSDC_LVMOS, PSDC_LVMOS, LV_GATEC }, output_from_layers = { NSDC_HVMOS_SDI_PRE }, error_net_output = ALL ); 
                PSDC_HVMOS_SDI_PRE = net_select( CONNECT_DB_ESD_1G, not_connected_to_any = { GND_M9I_BY_TEXT, GND_M8I_BY_TEXT, GND_M7I_BY_TEXT, GND_M6I_BY_TEXT, GND_M5I_BY_TEXT, GND_M4I_BY_TEXT, GND_M3I_BY_TEXT, GND_M2I_BY_TEXT, GND_M1I_BY_TEXT, GND_API_BY_TEXT }, output_from_layers = { PSDC_HVMOS_SDI } ); 
                CONNECT_DB_ESD_1G = incremental_connect( CONNECT_DB_ESD_1G, {{{ PSDC_HVMOS_SDI_PRE }, PSDC_HVMOS_SDI }} ); 
                net_select( CONNECT_DB_ESD_1G, connected_to_any = { NSDC_LVMOS, PSDC_LVMOS, LV_GATEC }, output_from_layers = { PSDC_HVMOS_SDI_PRE }, error_net_output = ALL ); 
         #else /* the reverse of #ifdef DEFINE_PAD_BY_TEXT  */ 
                net_area_ratio( CONNECT_DB, > 0, { "layer1" => NSDC_HVMOS_SDI, "layer2" => NSDC_LVMOS, "layer3" => PSDC_LVMOS, "layer4" => LV_GATEC, "layer5" => PSTPIX }, 5, 5, {  }, NAR_SAVE_NET_17, false ); 
                net_area_ratio( CONNECT_DB, > 0, { "layer1" => PSDC_HVMOS_SDI, "layer2" => NSDC_LVMOS, "layer3" => PSDC_LVMOS, "layer4" => LV_GATEC, "layer5" => PSTPIX }, 5, 5, {  }, NAR_SAVE_NET_17, false ); 
         #endif /* end of #ifdef DEFINE_PAD_BY_TEXT  */ 
         } /* end of rule : ESD.1g */
         rESD_3G @= { @ "ESD.3g : Unit finger width of NMOS and PMOS for I/O buffer and Power Clamp Device  = 15-60";
             length_edge( ESD_GATE_W, < ESD_3G_MIN, CONNECT ); 
             length_edge( ESD_GATE_W, > ESD_3G_MAX, CONNECT ); 
         } /* end of rule : ESD.3g */
         rESD_4G @= { @ "ESD.4g : The OD area of the edge side of I/O buffer and Power Clamp should be Source or Bulk rather than Drain, to avoid an unwanted parasitic bipolar effect or an abnormal discharge path in ESD zapping.";
             EDGE_NSD = interacting( NSDU, ESD_GATE, == 1 ); 
             EDGE_NSD not ESD_NMOS_SOURCE; 
             EDGE_PSD = interacting( PSDU, ESD_GATE, == 1 ); 
             EDGE_PSD not ESD_PMOS_SOURCE; 
         } /* end of rule : ESD.4g */
         rESD_5G @= { @ "ESD.5g : For same type OD of the I/O buffer and Power Clamp should be surrounded by a guard-ring. All other type ODs should be placed outside this guard-ring.";
             ESD_PMOS not_inside NTAP_GUARD_RING_HOLE; 
             ESD_NMOS not_inside PTAP_GUARD_RING_HOLE; 
         } /* end of rule : ESD.5g */
         rESD_6G @= { @ "ESD.6g : Butted STRAP and the STRAP which are between two sources of the N/PMOS in the same I/O buffer and Power Clamp are strictly prohibited.";
             sLAYER_1167 = external1( ESD_NMOSC, < ESD_6G, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
             A = not_interacting( sLAYER_1167, GATE ); 
             interacting( A, PSTPI ); 
             sLAYER_1168 = external1( ESD_PMOSC, < ESD_6G, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = NONE, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
             B = not_interacting( sLAYER_1168, GATE ); 
             interacting( B, NSTPI ); 
         } /* end of rule : ESD.6g */
         rESD_7G @= { @ "ESD.7g : Except the ESD device, 2 separate same type ODs connected to 2 different signal PAD must follow one of the following: 1. The space of 2 same type ODs in the same well. 2. Two same type ODs should be separated by different types of OD. The same type ODs are N+OD and N+OD in the same PW or P-base substrate, or P+OD and P+OD in the same NW or N-base substrate, which conntect to 2 different signal PAD (Please refer to section XXX in detail) >= 2.4";
             sLAYER_1169 = interacting( PACT, PSD_IOPAD ); 
             sPACT_CHECK = sLAYER_1169 not ESD_PMOS; 
             sLAYER_1170 = interacting( sPACT_CHECK, PSD_IOPAD, == 1, connect_sequence = CONNECT_DB, count_by = NET ); 
             PACT_CHECK_CB = stamp( sLAYER_1170, PSD_IOPAD, CONNECT_DB, CONNECT_DB_ESD_7G, include_touch = NONE ); 
             P1 = external1( PACT_CHECK_CB, < ESD_7G, connect_sequence = CONNECT_DB_ESD_7G, connectivity = DIFFERENT_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
             sLAYER_1171 = interacting( sPACT_CHECK, P1 ); 
             PACT_CHECK_NW = stamp( sLAYER_1171, NWELC, CONNECT_DB_ESD_7G, CONNECT_DB_ESD_7G, include_touch = NONE ); 
             P2 = external1( PACT_CHECK_NW, < ESD_7G, connect_sequence = CONNECT_DB_ESD_7G, connectivity = SAME_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
             P3 = P1 and P2; 
             sLAYER_1172 = P3 not NSTPI; 
             interacting( sLAYER_1172, PACT_CHECK_CB, > 1, connect_sequence = CONNECT_DB_ESD_7G, count_by = NET ); 
             interacting( sPACT_CHECK, PSD_IOPAD, > 1, connect_sequence = CONNECT_DB_ESD_7G, count_by = NET ); 
             sLAYER_1173 = interacting( NACT, NSD_IOPAD ); 
             sNACT_CHECK = sLAYER_1173 not ESD_NMOS; 
             sLAYER_1174 = interacting( sNACT_CHECK, NSD_IOPAD, == 1, connect_sequence = CONNECT_DB_ESD_7G, count_by = NET ); 
             NACT_CHECK_CB = stamp( sLAYER_1174, NSD_IOPAD, CONNECT_DB_ESD_7G, CONNECT_DB_ESD_7G, include_touch = NONE ); 
             N1 = external1( NACT_CHECK_CB, < ESD_7G, connect_sequence = CONNECT_DB_ESD_7G, connectivity = DIFFERENT_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
             sLAYER_1175 = interacting( sNACT_CHECK, N1 ); 
             NACT_CHECK_PW = stamp( sLAYER_1175, PWELC, CONNECT_DB_ESD_7G, CONNECT_DB_ESD_7G, include_touch = NONE ); 
             N2 = external1( NACT_CHECK_PW, < ESD_7G, connect_sequence = CONNECT_DB_ESD_7G, connectivity = SAME_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
             N3 = N1 and N2; 
             sLAYER_1176 = N3 not PSTPI; 
             interacting( sLAYER_1176, NACT_CHECK_CB, > 1, connect_sequence = CONNECT_DB_ESD_7G, count_by = NET ); 
             interacting( sNACT_CHECK, NSD_IOPAD, > 1, connect_sequence = CONNECT_DB_ESD_7G, count_by = NET ); 
         } /* end of rule : ESD.7g */
         rESD_12G @= { @ "ESD.12g : It is not recommended to use OD RPO resistor or NW resistor connected to PAD";
             sLAYER_1178 = OD not POLY; 
             sLAYER_1177 = interacting( sLAYER_1178, ODRES_A ); 
             ODRES_TERMINAL = sLAYER_1177 not ODRES_A; 
             ODRES_TERMINALC = stamp( ODRES_TERMINAL, COU, CONNECT_DB, CONNECT_DB_ESD_12G, include_touch = NONE ); 
             net_area_ratio( CONNECT_DB_ESD_12G, > 0, { "layer1" => ODRES_TERMINALC, "layer2" => CBU, "layer3" => CB2U, "layer4" => UBMNU, "layer5" => UBMDU }, 5, 5, {  }, NAR_SAVE_NET_18, false ); 
             net_area_ratio( CONNECT_DB_ESD_12G, > 0, { "layer1" => NWRUT, "layer2" => CBU, "layer3" => CB2U, "layer4" => UBMNU, "layer5" => UBMDU }, 5, 5, {  }, NAR_SAVE_NET_18, false ); 
         } /* end of rule : ESD.12g */
         ESD_PMOS_GATE_W = and_edge( ESD_GATE_W, PP, false ); 
         ESD_NMOS_GATE_W = and_edge( ESD_GATE_W, gNP, false ); 
         gLAYER_722 = edge_size( ESD_PMOS_GATE_W, inside = GRID ); 
         ESD_PMOS_GATE_W_EXP = interacting( gLAYER_722, ESD_PMOS_DRAIN ); 
         gLAYER_723 = edge_size( ESD_NMOS_GATE_W, inside = GRID ); 
         ESD_NMOS_GATE_W_EXP = interacting( gLAYER_723, ESD_NMOS_DRAIN ); 
         ESD_PMOS_GATE_W_EXPC = stamp( ESD_PMOS_GATE_W_EXP, ESD_PMOSC, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
         ESD_NMOS_GATE_W_EXPC = stamp( ESD_NMOS_GATE_W_EXP, ESD_NMOSC, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
         rESD_16G @= { @ "ESD.16g : Total finger width for NMOS in same connection > " + ESD_16G + " " 
                                   "ESD.24g/ESD.36g/ESD.44g/ESD.53g are also checked by ESD.16g";
             net_area_ratio( CONNECT_DB, < ESD_16G, { "layer1" => ESD_NMOS_GATE_W_EXPC }, 0, 0, {  }, NAR_SAVE_NET_19, false ); 
         } /* end of rule : ESD.16g */
         rESD_17G @= { @ "ESD.17g : Total finger width for PMOS in same connection > " + ESD_17G + " " 
                                   "ESD.25g/ESD.45g are also checked by ESD.17g";
             net_area_ratio( CONNECT_DB, < ESD_17G, { "layer1" => ESD_PMOS_GATE_W_EXPC }, 0, 0, {  }, NAR_SAVE_NET_19, false ); 
         } /* end of rule : ESD.17g */
         _33V_ESD_GATE_W = and_edge( ESD_GATE_W, OD_33, false ); 
         _25V_ESD_GATE_W = and_edge( ESD_GATE_W, OD_25, false ); 
         _18V_ESD_GATE_W = and_edge( ESD_GATE_W, OD_18, false ); 
         LV_ESD_GATE_W = or_edge( not_edge( ESD_GATE_W, OD2 ), coincident_inside_edge( ESD_GATE_W, OD2 ) ); 
         rESD_18G @= { @ "ESD.18g : Channel length of 3.3V I/O and Power Clamp >= 0.4 "
                                   "Channel length of 2.5V I/O and Power Clamp >= 0.35 "
                                   "Channel length of 1.8V I/O and Power Clamp >= 0.20 "
                                   "Channel length of 1.0V/1.2V I/O and Power Clamp >= 0.1 "
                                   "ESD.26g/ESD.38g/ESD.46g/ESD.54g are also checked by ESD.18g";
             internal1( _33V_ESD_GATE_W, < ESD_18G_33V, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
             internal1( _25V_ESD_GATE_W, < ESD_18G_25V, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
             internal1( _18V_ESD_GATE_W, < ESD_18G_18V, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
             internal1( LV_ESD_GATE_W, < ESD_18G_10V, extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
         } /* end of rule : ESD.18g */
         gLAYER_724 = interacting( ESD_NMOS, ESD_GATE_PARTIAL_RPO ); 
         REGULARIO_NMOS = not_interacting( gLAYER_724, ESD_GATE_FULLY_RPO ); 
         gLAYER_725 = interacting( ESD_PMOS, ESD_GATE_PARTIAL_RPO ); 
         REGULARIO_PMOS = not_interacting( gLAYER_725, ESD_GATE_FULLY_RPO ); 
         REGULARIO_MOS = REGULARIO_NMOS or REGULARIO_PMOS; 
         REGULARIO_NMOS_DRAIN = ESD_NMOS_DRAIN and REGULARIO_NMOS; 
         REGULARIO_PMOS_DRAIN = ESD_PMOS_DRAIN and REGULARIO_PMOS; 
         REGULARIO_MOS_DRAIN = ESD_MOS_DRAIN and REGULARIO_MOS; 
         REGULARIO_GATE = ESD_GATE and REGULARIO_MOS; 
         rESD_19G @= { @ "ESD.19g : The NMOS and PMOS should have an unsilicided area on the drain side. That is, the RPO mask should block the drain side of the device (except the contact region which should remain silicided). "
                                   "ESD.27g/ESD.39g are also checked by ESD.19g";
             not_interacting( REGULARIO_MOS_DRAIN, RPO ); 
             not_interacting( REGULARIO_MOS, RPO ); 
         } /* end of rule : ESD.19g */
         rESD_20G @= { @ "ESD.20g : Overlap of RPO on the drain side to the poly gate =0.06 "
                                   "ESD.29g/ESD.40g are also checked by ESD.20g";
             X = ESD_GATE_W outside_touching_edge REGULARIO_MOS_DRAIN; 
             A = edge_size( X, inside = ESD_20G ); 
             B = RPO and REGULARIO_GATE; 
             A xor B; 
         } /* end of rule : ESD.20g */
         rESD_21G @= { @ "ESD.21g : Width of the RPO on the drain side for NMOS  >= " + ESD_21G + " " 
                                   "ESD.41g is also checked by ESD.21g";
             A = REGULARIO_NMOS_DRAIN and RPO; 
             internal1( A, < ESD_21G, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
         } /* end of rule : ESD.21g */
         rESD_22G @= { @ "ESD.22g : Width of the RPO on the drain side for PMOS 	>= 1.0 "
                                   "ESD.31g is also checked by ESD.22g";
             A = REGULARIO_PMOS_DRAIN and RPO; 
             internal1( A, < ESD_22G, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
         } /* end of rule : ESD.22g */
         rESD_23G @= { @ "ESD.23g : Space of poly to CO on the source side >= " + ESD_23G + " " 
                                   "ESD.32g/ESD.42g are also checked by ESD.23g";
             A = ESD_GATE_W inside_touching_edge REGULARIO_GATE; 
             external2( ESD_COOD, A, < ESD_23G, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
         } /* end of rule : ESD.23g */
         
         // ESD.24g is checked by ESD.16g
         // ESD.25g is checked by ESD.17g
         // ESD.26g is checked by ESD.18g
         gLAYER_726 = interacting( ESD_NMOS, ESD_GATE_FULLY_RPO ); 
         HV_TOL_IO_NMOS = interacting( gLAYER_726, ESD_GATE_PARTIAL_RPO ); 
         gLAYER_727 = interacting( ESD_NMOS_DRAIN, CO ); 
         HV_TOL_IO_NMOS_DRAIN = gLAYER_727 and HV_TOL_IO_NMOS; 
         HV_TOL_IO_NMOS_SOURCE = ESD_NMOS_SOURCE and HV_TOL_IO_NMOS; 
         gLAYER_730 = HV_TOL_IO_NMOS not HV_TOL_IO_NMOS_DRAIN; 
         gLAYER_729 = gLAYER_730 not HV_TOL_IO_NMOS_SOURCE; 
         gLAYER_728 = gLAYER_729 not ESD_GATE; 
         HV_TOL_IO_NMOS_DRAIN_X = not_interacting( gLAYER_728, CO ); 
         HV_TOL_IO_GATE = ESD_GATE and HV_TOL_IO_NMOS; 
         HV_TOL_IO_GATEA = interacting( HV_TOL_IO_GATE, HV_TOL_IO_NMOS_DRAIN ); 
         gLAYER_731 = not_interacting( HV_TOL_IO_GATE, HV_TOL_IO_NMOS_DRAIN ); 
         HV_TOL_IO_GATEB = interacting( gLAYER_731, HV_TOL_IO_NMOS_DRAIN_X ); 
         rESD_27G @= { @ "ESD.27g : The NMOS and PMOS should have an unsilicided area on the drain side. That is, the RPO mask should block the drain side of the device (except the contact region which should remain silicided).DRC only flag no RPO in this device.";
             not_interacting( HV_TOL_IO_NMOS_DRAIN, RPO ); 
             HV_TOL_IO_NMOS_DRAIN_X not RPO; 
             not_interacting( HV_TOL_IO_NMOS, RPO ); 
         } /* end of rule : ESD.27g */
         rESD_28G @= { @ "ESD.28g : For NMOS, the RPO needs to cover all inactive poly gates(N2) and extend to overlap the N3 gate = 0.06";
             HV_TOL_IO_GATEA not RPO; 
             sLAYER_1179 = ESD_GATE_W inside_touching_edge HV_TOL_IO_GATEB; 
             X = sLAYER_1179 outside_touching_edge HV_TOL_IO_NMOS_DRAIN_X; 
             A = edge_size( X, inside = ESD_28G ); 
             B = RPO and HV_TOL_IO_GATEB; 
             A xor B; 
         } /* end of rule : ESD.28g */
         
         // ESD.29g is checked by ESD.20g
         rESD_30G @= { @ "ESD.30g : Width of the RPO on the drain side for NMOS. >= 1.0";
             A = HV_TOL_IO_NMOS_DRAIN and RPO; 
             internal1( A, < ESD_30G, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
         } /* end of rule : ESD.30g */
         
         // ESD.31g is checked by ESD.22g
         rESD_32G @= { @ "ESD.32g : Space of poly to CO on the source side >= 0.22";
             A = ESD_GATE_W inside_touching_edge HV_TOL_IO_GATE; 
             external2( ESD_COOD, A, < ESD_32G, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
         } /* end of rule : ESD.32g */
         rESD_33G @= { @ "ESD.33g : For NMOS, space of the N2 gate to the N3 gate. = 0.25";
             A = external2( HV_TOL_IO_GATEA, HV_TOL_IO_GATEB, == ESD_33G, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
             HV_TOL_IO_NMOS_DRAIN_X xor A; 
         } /* end of rule : ESD.33g */
         rESD_34G @= { @ "ESD.34g : The NMOS should have ESD3 or ESDIMP";
             sLAYER_1180 = ESD3 or ESDIMP; 
             not_interacting( HV_TOL_IO_NMOS, sLAYER_1180 ); 
         } /* end of rule : ESD.34g */
         
         // ESD.36g is checked by ESD.16g
         NCS_NMOS = not_interacting( ESD_NMOS, RPO ); 
         NCS_NMOS_GATE_W = and_edge( ESD_GATE_W, NCS_NMOS, false ); 
         NCS_NMOS_GATE_W_EXP = edge_size( NCS_NMOS_GATE_W, inside = GRID ); 
         NCS_NMOS_GATE_W_EXPC = stamp( NCS_NMOS_GATE_W_EXP, ESD_NMOSC, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
         NCS_NMOS_GATE = ESD_GATE and NCS_NMOS; 
         rESD_37G @= { @ "ESD.37g : Total finger width for Power Clamp in same connection > 900";
             net_area_ratio( CONNECT_DB, < ESD_37G, { "layer1" => NCS_NMOS_GATE_W_EXPC }, 0, 0, {  }, NAR_SAVE_NET_20, false ); 
         } /* end of rule : ESD.37g */
         
         // ESD.38g is checked by ESD.16g
         // ESD.39g is checked by ESD.19g
         // ESD.40g is checked by ESD.20g
         // ESD.41g is checked by ESD.21g
         // ESD.42g is checked by ESD.23g
         // ESD.44g is checked by ESD.16g 
         // ESD.45g is checked by ESD.17g
         // ESD.46g is checked by ESD.18g
         gLAYER_732 = interacting( ESD_NMOS, RPO ); 
         REGULARIO_TYPE2_NMOS = not_interacting( gLAYER_732, ESD_GATE_RPO ); 
         gLAYER_733 = interacting( ESD_PMOS, RPO ); 
         REGULARIO_TYPE2_PMOS = not_interacting( gLAYER_733, ESD_GATE_RPO ); 
         REGULARIO_TYPE2_MOS = REGULARIO_TYPE2_NMOS or REGULARIO_TYPE2_PMOS; 
         REGULARIO_TYPE2_NMOS_DRAIN = ESD_NMOS_DRAIN and REGULARIO_TYPE2_NMOS; 
         REGULARIO_TYPE2_PMOS_DRAIN = ESD_PMOS_DRAIN and REGULARIO_TYPE2_PMOS; 
         REGULARIO_TYPE2_MOS_DRAIN = ESD_MOS_DRAIN and REGULARIO_TYPE2_MOS; 
         REGULARIO_TYPE2_GATE = ESD_GATE and REGULARIO_TYPE2_MOS; 
         rESD_47G @= { @ "ESD.47g : The NMOS and PMOS should have an unsilicided area on the drain side. That is, the RPO mask should be in the drain side of the device (except the contact region which should remain silicided).";
             not_interacting( REGULARIO_TYPE2_MOS_DRAIN, RPO ); 
         } /* end of rule : ESD.47g */
         rESD_48G @= { @ "ESD.48g : RPO on the drain side space to the poly gate = 0.45";
             X = ESD_GATE_W outside_touching_edge REGULARIO_TYPE2_MOS_DRAIN; 
             A = edge_size( X, outside = ESD_48G ); 
             B = external2( RPO, REGULARIO_TYPE2_GATE, == ESD_48G, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
             A xor B; 
         } /* end of rule : ESD.48g */
         rESD_49G @= { @ "ESD.49g : Width of the RPO on the drain side for NMOS. >= 1.0";
             A = REGULARIO_TYPE2_NMOS_DRAIN and RPO; 
             internal1( A, < ESD_49G, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
         } /* end of rule : ESD.49g */
         rESD_50G @= { @ "ESD.50g : Width of the RPO on the drain side for PMOS. >= 1.0";
             A = REGULARIO_TYPE2_PMOS_DRAIN and RPO; 
             internal1( A, < ESD_50G, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
         } /* end of rule : ESD.50g */
         rESD_51G @= { @ "ESD.51g : Space of poly to CO on the source side  >= 0.22";
             A = ESD_GATE_W inside_touching_edge REGULARIO_TYPE2_GATE; 
             external2( ESD_COOD, A, < ESD_51G, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
         } /* end of rule : ESD.51g */
         rESD_52G @= { @ "ESD.52g : 1.8V regular IO INTERACT OD_25 or OD_33 is not recommended.";
             interacting( REGULARIO_TYPE2_MOS, OD_25 ); 
             interacting( REGULARIO_TYPE2_MOS, OD_33 ); 
         } /* end of rule : ESD.52g */
         
         // ESD.53g is checked by ESD.16g
         // ESD.54g is checked by ESD.18g
         gLAYER_735 = interacting( ESD_NMOS, RPO ); 
         gLAYER_734 = interacting( gLAYER_735, ESD_GATE_FULLY_RPO ); 
         NCS_TYPE2_NMOS = not_interacting( gLAYER_734, ESD_GATE_PARTIAL_RPO ); 
         NCS_TYPE2_NMOS_DRAIN = ESD_NMOS_DRAIN and NCS_TYPE2_NMOS; 
         NCS_TYPE2_NMOS_SOURCE = ESD_NMOS_SOURCE and NCS_TYPE2_NMOS; 
         NCS_TYPE2_NMOS_GATE = ESD_GATE and NCS_TYPE2_NMOS; 
         rESD_55G @= { @ "ESD.55g : The NMOS should have an unsilicided area on the drain/source side. That is, the RPO mask should be in the drain/source side of the device (except the contact region which should remain silicided).";
             not_interacting( NCS_TYPE2_NMOS_DRAIN, RPO ); 
             not_interacting( NCS_TYPE2_NMOS_SOURCE, RPO ); 
         } /* end of rule : ESD.55g */
         rESD_56G @= { @ "ESD.56g : Width of the RPO on the drain side for NMOS >= 1.0";
             A = NCS_TYPE2_NMOS_DRAIN and RPO; 
             internal1( A, < ESD_56G, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
         } /* end of rule : ESD.56g */
         rESD_57G @= { @ "ESD.57g : Space of poly to CO on the source side  >= 0.22";
             A = ESD_GATE_W inside_touching_edge NCS_TYPE2_NMOS_GATE; 
             external2( ESD_COOD, A, < ESD_57G, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, width = 0.002 ); 
         } /* end of rule : ESD.57g */
         gLAYER_738 = not_interacting( NACT, POLY ); 
         gLAYER_737 = gLAYER_738 and SDI; 
         gLAYER_736 = cutting( gLAYER_737, RPO ); 
         NFD = not_interacting( gLAYER_736, RPDMY ); 
         gLAYER_741 = not_interacting( PACT, POLY ); 
         gLAYER_740 = gLAYER_741 and SDI; 
         gLAYER_739 = cutting( gLAYER_740, RPO ); 
         PFD = not_interacting( gLAYER_739, RPDMY ); 
         NFDC = stamp( NFD, NSDC, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
         PFDC = stamp( PFD, PSDC, CONNECT_DB, CONNECT_DB, include_touch = NONE ); 
         NFD_EMITTER = net_select( CONNECT_DB, connected_to_any = { PSTPI }, output_from_layers = { NFDC } ); 
         NFD_COLLECTOR = NFDC not NFD_EMITTER; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ NFD_COLLECTOR }, NFDC }} ); 
         PFD_EMITTER = net_select( CONNECT_DB, connected_to_any = { NSTPI }, output_from_layers = { PFDC } ); 
         PFD_COLLECTOR = PFDC not PFD_EMITTER; 
         CONNECT_DB = incremental_connect( CONNECT_DB, {{{ PFD_COLLECTOR }, PFDC }} ); 
         NFD_STI = external2( NFD_COLLECTOR, NFD_EMITTER, == ESD_60G, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
         PFD_STI = external2( PFD_COLLECTOR, PFD_EMITTER, == ESD_60G, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
         rESD_58G @= { @ "ESD.58g : Total width for NFD in same connection of collector >= " + ESD_58G; 
             A = NFD_COLLECTOR coincident_outside_edge NFD_STI; 
             A1 = edge_size( A, inside = GRID ); 
             AC = stamp( A1, NFD_COLLECTOR, CONNECT_DB, CONNECT_DB_ESD_58G, include_touch = NONE ); 
             net_area_ratio( CONNECT_DB_ESD_58G, < ESD_58G, { "layer1" => AC }, 0, 0, {  }, NAR_SAVE_NET_21, false ); 
         } /* end of rule : ESD.58g */
         rESD_59G @= { @ "ESD.59g : Total width for PFD in same connection of collector >= " + ESD_59G; 
             A = PFD_COLLECTOR coincident_outside_edge PFD_STI; 
             A1 = edge_size( A, inside = GRID ); 
             AC = stamp( A1, PFD_COLLECTOR, CONNECT_DB, CONNECT_DB_ESD_59G, include_touch = NONE ); 
             net_area_ratio( CONNECT_DB_ESD_59G, < ESD_59G, { "layer1" => AC }, 0, 0, {  }, NAR_SAVE_NET_21, false ); 
         } /* end of rule : ESD.59g */
         rESD_60G @= { @ "ESD.60g : STI spacing of the NFD and PFD = " + ESD_60G; 
             not_interacting( NFD_COLLECTOR, NFD_STI, == 2 ); 
             not_interacting( PFD_COLLECTOR, PFD_STI, == 2 ); 
         } /* end of rule : ESD.60g */
         rESD_61G @= { @ "ESD.61g : Unit collector width of NFD and PFD = " + ESD_61G_MIN + " ~ " + ESD_61G_MAX; 
             A = NFD_COLLECTOR coincident_outside_edge NFD_STI; 
             length_edge( A, < ESD_61G_MIN ); 
             length_edge( A, > ESD_61G_MAX ); 
             B = PFD_COLLECTOR coincident_outside_edge PFD_STI; 
             length_edge( B, < ESD_61G_MIN ); 
             length_edge( B, > ESD_61G_MAX ); 
         } /* end of rule : ESD.61g */
         rESD_62G @= { @ "ESD.62g : Unit emitter width of NFD and PFD should be the same as unit collector width";
             sLAYER_1182 = NFD_STI or NFD_EMITTER; 
             sLAYER_1181 = sLAYER_1182 or NFD_COLLECTOR; 
             not_rectangles( sLAYER_1181 );
             sLAYER_1184 = PFD_STI or PFD_EMITTER; 
             sLAYER_1183 = sLAYER_1184 or PFD_COLLECTOR; 
             not_rectangles( sLAYER_1183 );
         } /* end of rule : ESD.62g */
         rESD_63G @= { @ "ESD.63g : Unit emitter length of NFD and PFD >= " + ESD_63G; 
             internal1( NFD_EMITTER, < ESD_63G, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
             internal1( PFD_EMITTER, < ESD_63G, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
         } /* end of rule : ESD.63g */
         rESD_64G @= { @ "ESD.64g : Width of the RPO on the collector side for NFD and PFD >= " + ESD_64G; 
             A = NFD_COLLECTOR coincident_outside_edge NFD_STI; 
             A1 = edge_size( A, inside = ESD_64G ); 
             A1 not RPO; 
             B = PFD_COLLECTOR coincident_outside_edge PFD_STI; 
             B1 = edge_size( B, inside = ESD_64G ); 
             B1 not RPO; 
         } /* end of rule : ESD.64g */
         rESD_65G @= { @ "ESD.65g : Width of the RPO on the emitter side for NFD and PFD = " + ESD_65G; 
             A = NFD_EMITTER coincident_outside_edge NFD_STI; 
             A1 = edge_size( A, inside = ESD_65G ); 
             sLAYER_1185 = RPO and NFD_EMITTER; 
             A1 xor sLAYER_1185; 
             B = PFD_EMITTER coincident_outside_edge PFD_STI; 
             B1 = edge_size( B, inside = ESD_65G ); 
             sLAYER_1186 = RPO and PFD_EMITTER; 
             B1 xor sLAYER_1186; 
         } /* end of rule : ESD.65g */
         rESD_66G @= { @ "ESD.66g : Space of RPO to CO on the collector and emitter side >= " + ESD_66G; 
             sLAYER_1187 = NFD or PFD; 
             A = CO and sLAYER_1187; 
             external2( A, RPO, < ESD_66G, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
         } /* end of rule : ESD.66g */
         rESD_72G @= { @ "ESD.72g : The layer of OD2 is required for 5V protection (NFD and PFD)";
             NFD not OD2; 
             PFD not OD2; 
         } /* end of rule : ESD.72g */
      #endif /* end of #ifdef GUIDELINE_ESD  */ 
      #ifndef DFM_ONLY 
         rESDIMP_W_1 @= { @ "ESDIMP.W.1 : Width >= " + ESDIMP_W_1; 
             internal1( ESDIMP, < ESDIMP_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
         } /* end of rule : ESDIMP.W.1 */
         rESDIMP_S_1 @= { @ "ESDIMP.S.1 : Space >= " + ESDIMP_S_1; 
             external1( ESDIMP, < ESDIMP_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
         } /* end of rule : ESDIMP.S.1 */
         rESDIMP_S_2 @= { @ "ESDIMP.S.2 : Space to ESD3 >= " + ESDIMP_S_2 + " Overlap is prohibited"; 
             external2( ESDIMP, ESD3, < ESDIMP_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
             ESDIMP and ESD3; 
         } /* end of rule : ESDIMP.S.2 */
         rESDIMP_EN_1 @= { @ "ESDIMP.EN.1 : (OD NOT PO) enclosure of ESDIMP >= " + ESDIMP_EN_1 + ". ESDIMP must be fully inside (OD NOT PO)"; 
             sLAYER_1188 = OD not POLY; 
             enclose( ESDIMP, sLAYER_1188, < ESDIMP_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { OUTSIDE, POINT_TOUCH }, width = 0.004 ); 
         } /* end of rule : ESDIMP.EN.1 */
         rESDIMP_A_1 @= { @ "ESDIMP.A.1 : Area >= " + ESDIMP_A_1; 
             area( ESDIMP, < ESDIMP_A_1 ); 
         } /* end of rule : ESDIMP.A.1 */
         rESDIMP_A_2 @= { @ "ESDIMP.A.2 : Enclosed area >= " + ESDIMP_A_2; 
             INT1 = donut_holes( ESDIMP, area = < ( ( ( ESDIMP_A_2 + ( ESDIMP_S_1 * ESDIMP_S_1 * 3.142 ) ) / ( 2 * ESDIMP_S_1 ) ) * ( ( ESDIMP_A_2 + ( ESDIMP_S_1 * ESDIMP_S_1 * 3.142 ) ) / ( 2 * 0.14 ) ) / 3.141 ), outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
             INT2 = INT1 not ESDIMP; 
             area( INT2, < ESDIMP_A_2 ); 
         } /* end of rule : ESDIMP.A.2 */
         rESDIMP_R_1 @= { @ "ESDIMP.R.1 : ESDIMP MUST BE FULLY INSIDE N+ACTVE";
             ESDIMP not NACT; 
         } /* end of rule : ESDIMP.R.1 */
      #endif /* end of #ifndef DFM_ONLY  */ 
      #ifndef DFM 
         
         //ESDIMP.EN.1.R is checked by ESDIMP.EN.1:R
         rESDIMP_EN_1_R @= { @ "ESDIMP.EN.1:R : (OD NOT PO) enclosure of ESDIMP >= " + ESDIMP_EN_1 + ". ESDIMP must be fully inside (OD NOT PO)"; 
         
         
         
         
         
          
         //Y XOR Z
             sLAYER_1189 = OD not POLY; 
             enclose( ESDIMP, sLAYER_1189, < ESDIMP_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { OUTSIDE, POINT_TOUCH }, width = 0.004 ); 
             sLAYER_1191 = OD not POLY; 
             sLAYER_1190 = enclosing( sLAYER_1191, ESDIMP ); 
             X = sLAYER_1190 not ESDIMP; 
             contains( X, { 0.405, 0.405 }, FORTY_FIVE ); 
         } /* end of rule : ESDIMP.EN.1:R */
         
         //ESDIMP.R.2.RU is uncheckable
      #endif /* end of #ifndef DFM  */ 
      
      //SRAM CHECKS
      //===========
      rSRAM_W_1 @= { @ "SRAM.W.1 : SRM width (interact with OD) >= " + SRAM_W_1 + " um"; 
          sLAYER_1192 = internal1( SRM, < SRAM_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          interacting( sLAYER_1192, ODI ); 
      } /* end of rule : SRAM.W.1 */
      rSRAM_S_1 @= { @ "SRAM.S.1 : SRM space (interact with OD) >= " + SRAM_S_1 + " um"; 
          sLAYER_1193 = external1( SRM, < SRAM_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          interacting( sLAYER_1193, ODI ); 
      } /* end of rule : SRAM.S.1 */
      rSRAM_S_2 @= { @ "SRAM.S.2 : SRM space to {GATE not interact with SRM} >= " + SRAM_S_2 + " um"; 
          A = POI and ODI; 
          B = not_interacting( A, SRM ); 
          external2( B, SRM, < SRAM_S_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : SRAM.S.2 */
      rSRAM_EN_1 @= { @ "SRAM.EN.1 : SRM enclosusre of GATE >= " + SRAM_EN_1 + " um"; 
          A = POI and ODI; 
          enclose( A, SRM, < SRAM_EN_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : SRAM.EN.1 */
      rSRAM_EX_1 @= { @ "SRAM.EX.1 : SRM Extension on NWEL (interact with OD). Extension = 0 is allowed. >= " + SRAM_EX_1 + " um"; 
          sLAYER_1194 = enclose( NWI, SRM, < SRAM_EX_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = ( 0, 90 ), look_thru = NOT_CONTAINED, relational = { POINT_TOUCH } ); 
          interacting( sLAYER_1194, ODI ); 
      } /* end of rule : SRAM.EX.1 */
      rSRAM_O_1 @= { @ "SRAM.O.1 : SRM Overlap of NWEL (interact with OD) >= " + SRAM_O_1 + " um"; 
          sLAYER_1196 = SRM and NWI; 
          sLAYER_1195 = internal1( sLAYER_1196, < SRAM_O_1, extension = NONE, intersecting = {  }, intersection_angle = < 90, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          interacting( sLAYER_1195, ODI ); 
      } /* end of rule : SRAM.O.1 */
      rSRAM_R_12 @= { @ "SRAM.R.12 : SRMDMY_4(186;4) overlap SRAMDMY_0(186;0) is not allowed.";
          SRAMDMY_PERI and SRAMDMY; 
      } /* end of rule : SRAM.R.12 */
      rSRAM_R_13 @= { @ "SRAM.R.13 : SRM must fully cover GATE.";
          sLAYER_1197 = POI and ODI; 
          A = interacting( sLAYER_1197, SRM ); 
          A not SRM; 
      } /* end of rule : SRAM.R.13 */
      
      // SRAM.R.14 is not necessary to check
      #ifdef HALF_NODE 
         rSRAM_R_15 @= { @ "SRAM.R.15 : CO_11 (30;11) is a must for CO mask tape-out "
                                       "1.if CO_11 exists, it must cover CO "
                                       "2.CO_11 must be 0.09 um x 0.09 um "
                                       "3.CO_11 must be exactly the same as CO "
                                       "4.CO_11 must be fully covered by SRM(50;0) and SRAMDMY(186;0) "
                                       "5.CO_11 is must on square OD contact if CO.S.3 is rule pushed in SRAM. "
                                       "6.CO_11 is not allowed on square OD contact if CO.S.3 is not rule pushed in SRAM.";
             sLAYER_1198 = interacting( COI, SRAMDMY ); 
             A = interacting( sLAYER_1198, SRM ); 
             B = rectangles( A, sides = { == CO_W_1, == CO_W_1 } ); 
             not_interacting( CO_PUSH, B ); 
             C = interacting( A, CO_PUSH ); 
             C xor CO_PUSH; 
             D = interacting( B, ODI ); 
             E = external2( D, POI, < CO_S_3, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
             not_outside_touching( E, CO_PUSH ); 
             sLAYER_1199 = CO_PUSH and ODI; 
             not_outside_touching( sLAYER_1199, E ); 
         } /* end of rule : SRAM.R.15 */
      #else /* the reverse of #ifdef HALF_NODE  */ 
         rSRAM_R_15 @= { @ "SRAM.R.15 : CO_11 (30;11) is a must for CO mask tape-out "
                                       "1.if CO_11 exists, it must cover CO "
                                       "2.CO_11 must be 0.09 um x 0.09 um "
                                       "3.CO_11 must be exactly the same as CO "
                                       "4.CO_11 must be fully covered by SRM(50;0) and SRAMDMY(186;0)";
             sLAYER_1200 = interacting( COI, SRAMDMY ); 
             A = interacting( sLAYER_1200, SRM ); 
             B = rectangles( A, sides = { == CO_W_1, == CO_W_1 } ); 
             not_interacting( CO_PUSH, B ); 
             C = interacting( A, CO_PUSH ); 
             C xor CO_PUSH; 
         } /* end of rule : SRAM.R.15 */
      #endif /* end of #ifdef HALF_NODE  */ 
      rSRAM_R_17 @= { @ "SRAM.R.17 : SRAMDMY(186;0) must fully cover OD,CO,VIA1";
          cutting( ODI, SRAMDMY ); 
          cutting( COI, SRAMDMY ); 
          cutting( VIA1I, SRAMDMY ); 
      } /* end of rule : SRAM.R.17 */
      rSRAM_WARN_1 @= { @ "SRAM.WARN.1 : Warning: It is important to add different redundancies according to different memory density, "
                                        "if the accumulated SRAM density is greater than 8Mb bits, please refer to T-000-CL-RP-002, "
                                        "DRC only flags the total BTC counts inside 0.525um2, 0.62um2, 0.499um2, 0.974um2 and 1.158um2 cell in full chip > " + SRAM_WARN_1; 
                sLAYER_1343_prop_layer = initialize_property( CHIP_SRAM, { "ANT_RATIO" } ); 
          net_area_ratio_with_accumulate( CONNECT_DB, > SRAM_WARN_1, sLAYER_1343_prop_layer, sLAYER_1343_prop_layer_unused, { "layer1" => SRAM_BTC_ALL_CELL }, {  }, NARACC_SAVE_NET_22 ); 
      } /* end of rule : SRAM.WARN.1 */
      #ifdef HALF_NODE 
         rSRAM_R_18 @= { @ "SRAM.R.18 : SRAMDMY (186;0) must fully cover SRAMDMY_1(186;1)";
             SRAMDMY_1 not SRAMDMY; 
             sLAYER_1201 = SRAMDMY and SRM; 
             not_enclosing( sLAYER_1201, SRAMDMY_1 ); 
         } /* end of rule : SRAM.R.18 */
      #endif /* end of #ifdef HALF_NODE  */ 
      rSRAM_A_1 @= { @ "SRAM.A.1 : Enclosed area of Donut-type OD (Enclosed area of OD > 0) interact with poly in SRM region >= " + SRAM_A_1; 
          SRAM_OD = ODI not_outside SRM; 
          SRAM_OD_HOLE = donut_holes( SRAM_OD, holes = INNER, outer_boundary_point_touch = CLOSED_OUTER_BOUNDARY ); 
          sLAYER_1202 = POI and SRAM_OD; 
          SRAM_OD_HOLE_CHECK = outside_touching( SRAM_OD_HOLE, sLAYER_1202 ); 
          area( SRAM_OD_HOLE_CHECK, < SRAM_A_1 ); 
      } /* end of rule : SRAM.A.1 */
      rNW_S_1_SRM_SRAMDMY @= { @ "NW.S.1:SRM_SRAMDMY : Spacing between NW along the boundary of SRM and SRAMDMY";
          A = size( SRAM_EXCLUDE, clip_acute = NONE, distance = ( NW_S_1 + GRID ) ); 
          B = size( SRAM_EXCLUDE, clip_acute = NONE, distance = - ( NW_S_1 + GRID ) ); 
          C = A not B; 
          D = NWI not_outside C; 
          E = external1( D, < NW_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          cutting( E, SRAM_EXCLUDE ); 
          outside_touching( E, SRAM_EXCLUDE ); 
      } /* end of rule : NW.S.1:SRM_SRAMDMY */
      rOD_S_1_SRM_SRAMDMY @= { @ "OD.S.1:SRM_SRAMDMY : Spacing between OD along the boundary of SRM and SRAMDMY";
          A = size( SRAM_EXCLUDE, clip_acute = NONE, distance = ( OD_S_1 + GRID ) ); 
          B = size( SRAM_EXCLUDE, clip_acute = NONE, distance = - ( OD_S_1 + GRID ) ); 
          C = A not B; 
          D = ODI not_outside C; 
          E = external1( D, < OD_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          cutting( E, SRAM_EXCLUDE ); 
          outside_touching( E, SRAM_EXCLUDE ); 
      } /* end of rule : OD.S.1:SRM_SRAMDMY */
      rPO_S_1_SRM_SRAMDMY @= { @ "PO.S.1:SRM_SRAMDMY : Spacing between POLY along the boundary of SRM and SRAMDMY";
          A = size( SRAM_EXCLUDE, clip_acute = NONE, distance = ( PO_S_1 + GRID ) ); 
          B = size( SRAM_EXCLUDE, clip_acute = NONE, distance = - ( PO_S_1 + GRID ) ); 
          C = A not B; 
          D = POI not_outside C; 
          E = external1( D, < PO_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          cutting( E, SRAM_EXCLUDE ); 
          outside_touching( E, SRAM_EXCLUDE ); 
      } /* end of rule : PO.S.1:SRM_SRAMDMY */
      rNP_S_1_SRM_SRAMDMY @= { @ "NP.S.1:SRM_SRAMDMY : Spacing between NP along the boundary of SRM and SRAMDMY";
          A = size( SRAM_EXCLUDE, clip_acute = NONE, distance = ( NP_S_1 + GRID ) ); 
          B = size( SRAM_EXCLUDE, clip_acute = NONE, distance = - ( NP_S_1 + GRID ) ); 
          C = A not B; 
          D = NPI not_outside C; 
          E = external1( D, < NP_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          cutting( E, SRAM_EXCLUDE ); 
          outside_touching( E, SRAM_EXCLUDE ); 
      } /* end of rule : NP.S.1:SRM_SRAMDMY */
      rPP_S_1_SRM_SRAMDMY @= { @ "PP.S.1:SRM_SRAMDMY : Spacing between PP along the boundary of SRM and SRAMDMY";
          A = size( SRAM_EXCLUDE, clip_acute = NONE, distance = ( PP_S_1 + GRID ) ); 
          B = size( SRAM_EXCLUDE, clip_acute = NONE, distance = - ( PP_S_1 + GRID ) ); 
          C = A not B; 
          D = PPI not_outside C; 
          E = external1( D, < PP_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          cutting( E, SRAM_EXCLUDE ); 
          outside_touching( E, SRAM_EXCLUDE ); 
      } /* end of rule : PP.S.1:SRM_SRAMDMY */
      rCO_S_1_SRM_SRAMDMY @= { @ "CO.S.1:SRM_SRAMDMY : Spacing between CO along the boundary of SRM and SRAMDMY";
          A = size( SRAM_EXCLUDE, clip_acute = NONE, distance = ( CO_S_1 + GRID ) ); 
          B = size( SRAM_EXCLUDE, clip_acute = NONE, distance = - ( CO_S_1 + GRID ) ); 
          C = A not B; 
          D = COI not_outside C; 
          E = external1( D, < CO_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          cutting( E, SRAM_EXCLUDE ); 
          outside_touching( E, SRAM_EXCLUDE ); 
      } /* end of rule : CO.S.1:SRM_SRAMDMY */
      rM1_S_1_SRM_SRAMDMY @= { @ "M1.S.1:SRM_SRAMDMY : Spacing between M1 along the boundary of SRM and SRAMDMY";
          A = size( SRAM_EXCLUDE, clip_acute = NONE, distance = ( M1_S_1 + GRID ) ); 
          B = size( SRAM_EXCLUDE, clip_acute = NONE, distance = - ( M1_S_1 + GRID ) ); 
          C = A not B; 
          D = M1I not_outside C; 
          E = external1( D, < M1_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          cutting( E, SRAM_EXCLUDE ); 
          outside_touching( E, SRAM_EXCLUDE ); 
      } /* end of rule : M1.S.1:SRM_SRAMDMY */
      rVIA1_S_1_SRM_SRAMDMY @= { @ "VIA1.S.1:SRM_SRAMDMY : Spacing between VIA1 along the boundary of SRM and SRAMDMY";
          A = size( SRAM_EXCLUDE, clip_acute = NONE, distance = ( VIA1_S_1 + GRID ) ); 
          B = size( SRAM_EXCLUDE, clip_acute = NONE, distance = - ( VIA1_S_1 + GRID ) ); 
          C = A not B; 
          D = VIA1I not_outside C; 
          E = external1( D, < VIA1_S_1, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
          cutting( E, SRAM_EXCLUDE ); 
          outside_touching( E, SRAM_EXCLUDE ); 
      } /* end of rule : VIA1.S.1:SRM_SRAMDMY */
      CO_PERI_4 = CO_PERI not_outside SRAMDMY_4; 
      CO_PERI_5 = CO_PERI not_outside SRAMDMY_5; 
      NPOD_PERI = OD_PERI and NPI; 
      PPOD_PERI = OD_PERI and PPI; 
      NSTP_PERI = NPOD_PERI and NWI; 
      PSTP_PERI = PPOD_PERI not NWI; 
      STP_PERI = NSTP_PERI or PSTP_PERI; 
      NACT_PERI = NPOD_PERI not NWI; 
      PACT_PERI = PPOD_PERI and NWI; 
      DACT_PERI = NACT_PERI or PACT_PERI; 
      ACT_PERI = interacting( DACT_PERI, POI ); 
      SD_PERI = ACT_PERI not POI; 
      rWLD_R_1 @= { @ "WLD.R.1 : CO to PO space inside SRAMDMY (186;4) >= 0.05";
          external2( CO_PERI_4, POI, < WLD_R_1, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : WLD.R.1 */
      rWLD_R_2 @= { @ "WLD.R.2 : CO to PO space inside SRAMDMY (186;5) >= 0.043";
          external2( CO_PERI_5, POI, < WLD_R_2, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : WLD.R.2 */
      rWLD_R_3 @= { @ "WLD.R.3 : CO space on the same OD [inside SRAMDMY (186;4 & 186;5)] >= 0.14";
          external1( COOD_PERI, < WLD_R_3, connect_sequence = CONNECT_DB, connectivity = SAME_NET, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : WLD.R.3 */
      rWLD_R_6 @= { @ "WLD.R.6 : SRAMDMY (186;4 & 186;5) edge cut CO is not allowed";
          cutting( CO_PERI, SRAMDMY_4 ); 
          cutting( CO_PERI, SRAMDMY_5 ); 
      } /* end of rule : WLD.R.6 */
      rWLD_R_7 @= { @ "WLD.R.7 : SRMDMY (186;0) upsized 200 um must cover SRMDMY (186;4,5)";
          S = size( SRAMDMY, clip_acute = NONE, distance = WLD_R_7 ); 
          SRAMDMY_4 not S; 
          SRAMDMY_5 not S; 
      } /* end of rule : WLD.R.7 */
      
      // Analog Checks
      //==============
      POS14M_POCELLIN = copy( aLAYER_148 ); 
      POS14M_POCELLOUT = copy( aLAYER_149 ); 
      POS14M_POCELL = POS14M_POCELLIN and POS14M_POCELLOUT; 
      POS14M_POMARKER = POI and RRULEANALOG; 
      gLAYER_748 = POS14M_POCELL or POS14M_POMARKER; 
      gLAYER_747 = gLAYER_748 not SRAM_EXCLUDE; 
      gLAYER_746 = gLAYER_747 outside BLOCK; 
      POS14M_PO = gLAYER_746 not EXCLUDERRULEANALOG; 
      gLAYER_749 = GATE_NP and POS14M_PO; 
      POS14M_GATE = gLAYER_749 not OD2; 
      gLAYER_750 = NWEL or NTN; 
      POS14M_NW = OD2 or gLAYER_750; 
      rPO_S_14M @= { @ "PO.S.14m : Gate space to ( OD2 OR (NW OR NT_N) ) in Core NMOS >= 1.0um";
          external2( POS14M_GATE, POS14M_NW, < 1.0, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : PO.S.14m */
      POEN1M_POCELLIN = copy( aLAYER_148 ); 
      POEN1M_POCELLOUT = copy( aLAYER_149 ); 
      POEN1M_POCELL = POEN1M_POCELLIN and POEN1M_POCELLOUT; 
      POEN1M_POMARKER = POI and RRULEANALOG; 
      gLAYER_753 = POEN1M_POCELL or POEN1M_POMARKER; 
      gLAYER_752 = gLAYER_753 not SRAM_EXCLUDE; 
      gLAYER_751 = gLAYER_752 outside BLOCK; 
      POEN1M_PO = gLAYER_751 not EXCLUDERRULEANALOG; 
      gLAYER_754 = GATE_PP and POEN1M_PO; 
      POEN1M_GATE = gLAYER_754 not OD2; 
      gLAYER_755 = NWEL not OD_33; 
      POEN1M_NW = gLAYER_755 not NTN; 
      rPO_EN_1M @= { @ "PO.EN.1m : 1.0V or 1.2V PMOS gate enclosure by ((NW NOT OD2) NOT NT_N) for 3.3V IO process >= 1.0 um "
                                  "1.0V or 1.2V PMOS gate enclosure by (NW NOT NT_N) for 1.8V or 2.5V IO process >= 1.0 um";
          enclose( POEN1M_GATE, POEN1M_NW, < 1.0, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : PO.EN.1m */
      POEN2M_POCELLIN = copy( aLAYER_148 ); 
      POEN2M_POCELLOUT = copy( aLAYER_149 ); 
      POEN2M_POCELL = POEN2M_POCELLIN and POEN2M_POCELLOUT; 
      POEN2M_POMARKER = POI and RRULEANALOG; 
      gLAYER_758 = POEN2M_POCELL or POEN2M_POMARKER; 
      gLAYER_757 = gLAYER_758 not SRAM_EXCLUDE; 
      gLAYER_756 = gLAYER_757 outside BLOCK; 
      POEN2M_PO = gLAYER_756 not EXCLUDERRULEANALOG; 
      gLAYER_759 = GATE_NP and POEN2M_PO; 
      POEN2M_GATE = gLAYER_759 and OD2; 
      gLAYER_760 = NWEL or NTN; 
      POEN2M_NW = OD2 not gLAYER_760; 
      rPO_EN_2M @= { @ "PO.EN.2m : Gate enclosure by ( OD2 NOT (NW OR NT_N) ) in IO NMOS >= 2.0um";
          enclose( POEN2M_GATE, POEN2M_NW, < 2.0, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : PO.EN.2m */
      POEN3M_POCELLIN = copy( aLAYER_148 ); 
      POEN3M_POCELLOUT = copy( aLAYER_149 ); 
      POEN3M_POCELL = POEN3M_POCELLIN and POEN3M_POCELLOUT; 
      POEN3M_POMARKER = POI and RRULEANALOG; 
      gLAYER_763 = POEN3M_POCELL or POEN3M_POMARKER; 
      gLAYER_762 = gLAYER_763 not SRAM_EXCLUDE; 
      gLAYER_761 = gLAYER_762 outside BLOCK; 
      POEN3M_PO = gLAYER_761 not EXCLUDERRULEANALOG; 
      POEN3M_GATE = GATE_PP and POEN3M_PO; 
      POEN3M_GATE33 = POEN3M_GATE and OD_33; 
      gLAYER_764 = OD_25 or OD_18; 
      POEN3M_GATE1825 = POEN3M_GATE and gLAYER_764; 
      POEN3M_NW = NWEL not NTN; 
      POEN3M_NW33 = POEN3M_NW and OD_33; 
      rPO_EN_3M @= { @ "PO.EN.3m : 3.3V PMOS gate enclosure by ((NW AND OD2) NOT NT_N) >= 1.5 um "
                                  "1.8V or 2.5V PMOS gate enclosure by (NW NOT NT_N) >= 1.5 um";
          enclose( POEN3M_GATE1825, POEN3M_NW, < 1.5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          enclose( POEN3M_GATE33, POEN3M_NW33, < 1.5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : PO.EN.3m */
      rBJT_R_1 @= { @ "BJT.R.1 : RPO needs to cover 0.3um on EM OD edge from OD and STI sides";
          sLAYER_1203 = size( EMOD, clip_acute = NONE, distance = 0.3 ); 
          sLAYER_1204 = size( EMOD, clip_acute = NONE, distance = - 0.3 ); 
          X = sLAYER_1203 not sLAYER_1204; 
          Y = interacting( RPO, EMOD ); 
          X xor Y; 
      } /* end of rule : BJT.R.1 */
      rBJT_R_8 @= { @ "BJT.R.8 : {RH OR BJTDMY} enclosure of  Emitter OD >=0.13";
          A = RH or BJTDMY; 
          enclose( EMOD, A, < 0.13, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          EMOD not A; 
      } /* end of rule : BJT.R.8 */
      RES2M_ODCELLIN = copy( aLAYER_150 ); 
      RES2M_ODCELLOUT = copy( aLAYER_151 ); 
      RES2M_ODCELL = RES2M_ODCELLIN and RES2M_ODCELLOUT; 
      RES2M_ODMARKER = ODI and RRULEANALOG; 
      gLAYER_767 = RES2M_ODCELL or RES2M_ODMARKER; 
      gLAYER_766 = gLAYER_767 not SRAM_EXCLUDE; 
      gLAYER_765 = gLAYER_766 outside BLOCK; 
      RES2M_OD = gLAYER_765 not EXCLUDERRULEANALOG; 
      RES2M_POCELLIN = copy( aLAYER_148 ); 
      RES2M_POCELLOUT = copy( aLAYER_149 ); 
      RES2M_POCELL = RES2M_POCELLIN and RES2M_POCELLOUT; 
      RES2M_POMARKER = POI and RRULEANALOG; 
      gLAYER_770 = RES2M_POCELL or RES2M_POMARKER; 
      gLAYER_769 = gLAYER_770 not SRAM_EXCLUDE; 
      gLAYER_768 = gLAYER_769 outside BLOCK; 
      RES2M_PO = gLAYER_768 not EXCLUDERRULEANALOG; 
      RES2M_ODRES = ODRES and RES2M_OD; 
      RES2M_PORES = PORESG and RES2M_PO; 
      
      //RES.2m is checked by RES.2m:OD and RES.2m:PO
      rRES_2M_OD @= { @ "RES.2m:OD : Width >= 0.4um and length >= 0.4um for unsilicided OD resistor";
          internal1( RES2M_ODRES, < 0.4, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          RES_L = and_edge( RES2M_ODRES, RPO, false ); 
          X = length_edge( RES_L, < 0.4, CONNECT ); 
          CHECK_RES = RES2M_ODRES touching X; 
          RES_E = CHECK_RES coincident_inside_edge RPO; 
          A = edge_size( RES_E, inside = GRID ); 
          B = size_inside_wrapper( A, RES2M_ODRES, distance = ( 0.2 - GRID * 2 ), increment = OD_S_1 * 0.7 ); 
          C = CHECK_RES not B; 
          not_interacting( CHECK_RES, C ); 
          D = internal1( C, < ( GRID * 2 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
          Y = interacting( CHECK_RES, D ); 
          Y not_inside DIODMY; 
      } /* end of rule : RES.2m:OD */
      rRES_2M_PO @= { @ "RES.2m:PO : Width >= 0.4um and length >= 0.4um for unsilicided PO resistor";
          internal1( RES2M_PORES, < 0.4, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          RES_L = and_edge( RES2M_PORES, RPO, false ); 
          X = length_edge( RES_L, < 0.4, CONNECT ); 
          CHECK_RES = RES2M_PORES touching X; 
          RES_E = CHECK_RES coincident_inside_edge RPO; 
          A = edge_size( RES_E, inside = GRID ); 
          B = size_inside_wrapper( A, RES2M_PORES, distance = ( 0.2 - GRID * 2 ), increment = PO_S_1 * 0.7 ); 
          C = CHECK_RES not B; 
          not_interacting( CHECK_RES, C ); 
          D = internal1( C, < ( GRID * 2 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
          interacting( CHECK_RES, D ); 
      } /* end of rule : RES.2m:PO */
      NWRODR1M_NWCELLIN = copy( aLAYER_152 ); 
      NWRODR1M_NWCELLOUT = copy( aLAYER_153 ); 
      NWRODR1M_NWCELL = NWRODR1M_NWCELLIN and NWRODR1M_NWCELLOUT; 
      NWRODR1M_NWMARKER = NWI and RRULEANALOG; 
      gLAYER_773 = NWRODR1M_NWCELL or NWRODR1M_NWMARKER; 
      gLAYER_772 = gLAYER_773 not_inside SRAM_EXCLUDE; 
      gLAYER_771 = gLAYER_772 outside BLOCK; 
      NWRODR1M_NW = gLAYER_771 not EXCLUDERRULEANALOG; 
      gLAYER_774 = NWRODR1M_NW and NWRES; 
      NWRODR1M_NWRES = gLAYER_774 and NWDMY; 
      rNWROD_R_1M @= { @ "NWROD.R.1m : Width >= 1.8um and length >= 20um for NW resistor with OD";
          internal1( NWRODR1M_NWRES, < 1.8, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          RES_L = NWRODR1M_NWRES coincident_inside_edge NWRODR1M_NW; 
          X = length_edge( RES_L, < 20.0, CONNECT ); 
          CHECK_RES = NWRODR1M_NWRES touching X; 
          RES_E = CHECK_RES coincident_inside_edge NWDMY; 
          A = edge_size( RES_E, inside = GRID ); 
          B = size_inside_wrapper( A, NWRODR1M_NWRES, distance = ( 10 - GRID * 2 ), increment = NW_S_1 * 0.7 ); 
          C = CHECK_RES not B; 
          not_interacting( CHECK_RES, C ); 
          D = internal1( C, < ( GRID * 2 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
          interacting( CHECK_RES, D ); 
      } /* end of rule : NWROD.R.1m */
      NWRSTIR1M_NWCELLIN = copy( aLAYER_152 ); 
      NWRSTIR1M_NWCELLOUT = copy( aLAYER_153 ); 
      NWRSTIR1M_NWCELL = NWRSTIR1M_NWCELLIN and NWRSTIR1M_NWCELLOUT; 
      NWRSTIR1M_NWMARKER = NWI and RRULEANALOG; 
      gLAYER_777 = NWRSTIR1M_NWCELL or NWRSTIR1M_NWMARKER; 
      gLAYER_776 = gLAYER_777 not_inside SRAM_EXCLUDE; 
      gLAYER_775 = gLAYER_776 outside BLOCK; 
      NWRSTIR1M_NW = gLAYER_775 not EXCLUDERRULEANALOG; 
      gLAYER_778 = NWRSTIR1M_NW and NWRES_STI; 
      NWRSTIR1M_NWRES = gLAYER_778 and NWDMY; 
      rNWRSTI_R_1M @= { @ "NWRSTI.R.1m : Width >= 1.8um and length >= 20um for NW resistor under STI";
          internal1( NWRSTIR1M_NWRES, < 1.8, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          RES_L = NWRSTIR1M_NWRES coincident_inside_edge NWRSTIR1M_NW; 
          X = length_edge( RES_L, < 20.0, CONNECT ); 
          CHECK_RES = NWRSTIR1M_NWRES touching X; 
          RES_E = CHECK_RES coincident_inside_edge NWDMY; 
          A = edge_size( RES_E, inside = GRID ); 
          B = size_inside_wrapper( A, NWRSTIR1M_NWRES, distance = ( 10 - GRID * 2 ), increment = NW_S_1 * 0.7 ); 
          C = CHECK_RES not B; 
          not_interacting( CHECK_RES, C ); 
          D = internal1( C, < ( GRID * 2 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
          interacting( CHECK_RES, D ); 
      } /* end of rule : NWRSTI.R.1m */
      ANR46MG_POICELLIN = copy( aLAYER_148 ); 
      ANR46MG_POICELLOUT = copy( aLAYER_149 ); 
      ANR46MG_POICELL = ANR46MG_POICELLIN and ANR46MG_POICELLOUT; 
      ANR46MG_POIMARKER = POI and RRULEANALOG; 
      gLAYER_781 = ANR46MG_POICELL or ANR46MG_POIMARKER; 
      gLAYER_780 = gLAYER_781 not SRAM_EXCLUDE; 
      gLAYER_779 = gLAYER_780 outside BLOCK; 
      ANR46MG_POI = gLAYER_779 not EXCLUDERRULEANALOG; 
      gLAYER_782 = interacting( ANR46MG_POI, OD ); 
      ANR46MG_POLY_PAIR_CHECK = interacting( gLAYER_782, MATCHING ); 
      ANR46MG_POLY_PAIR_CHECK_G_M1 = ANR46MG_POLY_PAIR_CHECK inside M1X; 
      ANR46MG_POLY_PAIR_CHECK_B_M1 = cutting( ANR46MG_POLY_PAIR_CHECK, M1X ); 
      ANR46MG_POLY_PAIR_CHECK_O_M1 = ANR46MG_POLY_PAIR_CHECK outside M1X; 
      
      //AN.R.46m is checked by AN.R.46:M1
      rAN_R_46_M1 @= { @ "AN.R.46:M1 : In MATCHING layer, one of differential pair covered by M1 layer but without all fully covered is not allowed";
          interacting( MATCHINGI, ANR46MG_POLY_PAIR_CHECK_B_M1 ); 
          sLAYER_1205 = interacting( MATCHINGI, ANR46MG_POLY_PAIR_CHECK_G_M1 ); 
          interacting( sLAYER_1205, ANR46MG_POLY_PAIR_CHECK_O_M1 ); 
      } /* end of rule : AN.R.46:M1 */
   #endif /* end of #ifdef FRONT_END  */ 
#else /* the reverse of #ifndef DFM_ONLY  */ 
   #ifndef DFM 
      rDFM_OPTION_ERROR1 @= { @ "DFM_OPTION:ERROR1 : If DFM_ONLY option is enabled, DFM option should be enabled,too.";
          copy( CHIPX ); 
      } /* end of rule : DFM_OPTION:ERROR1 */
   #endif /* end of #ifndef DFM  */ 
#endif /* end of #ifndef DFM_ONLY  */ 
#ifdef DFM                                /* start DFM check */ 
   #ifdef Recommended 
      
      // End of recommended DFM rules    
   #endif /* end of #ifdef Recommended  */ 
   #ifdef Analog 
      
      // End of Analog DFM rules 
   #endif /* end of #ifdef Analog  */ 
   
   // PO.S.2.R is checked by RR:AR:SP:PO.S.2
   #ifdef _POS2_ 
      #ifdef GP 
         POS2_ODCELLIN = copy( aLAYER_154 ); 
         POS2_ODCELLOUT = copy( aLAYER_155 ); 
         POS2_ODCELL = POS2_ODCELLIN and POS2_ODCELLOUT; 
         POS2_ODMARKER = ODI and RRULEREQUIRED; 
         gLAYER_785 = POS2_ODCELL or POS2_ODMARKER; 
         gLAYER_784 = gLAYER_785 not SRAM_EXCLUDE; 
         gLAYER_783 = gLAYER_784 outside BLOCK; 
         POS2_OD = gLAYER_783 not EXCLUDERRULEREQUIRED; 
         POS2_GATE_W = and_edge( POLY, POS2_OD, false ); 
         rRR_AR_SP_PO_S_2 @= { @ "RR:AR:SP:PO.S.2 : Recommended gate space in the same OD in GP process >= 0.2";
             external1( POS2_GATE_W, < 0.2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT ); 
         } /* end of rule : RR:AR:SP:PO.S.2 */
      #else /* the reverse of #ifdef GP  */ 
         #ifdef LP 
            POS2_ODCELLIN = copy( aLAYER_156 ); 
            POS2_ODCELLOUT = copy( aLAYER_157 ); 
            POS2_ODCELL = POS2_ODCELLIN and POS2_ODCELLOUT; 
            POS2_ODMARKER = ODI and RRULEREQUIRED; 
            gLAYER_788 = POS2_ODCELL or POS2_ODMARKER; 
            gLAYER_787 = gLAYER_788 not SRAM_EXCLUDE; 
            gLAYER_786 = gLAYER_787 outside BLOCK; 
            POS2_OD = gLAYER_786 not EXCLUDERRULEREQUIRED; 
            POS2_GATE_W = and_edge( POLY, POS2_OD, false ); 
            rRR_AR_SP_PO_S_2 @= { @ "RR:AR:SP:PO.S.2 : Recommended gate space in the same OD in LP process >= 0.2";
                external1( POS2_GATE_W, < 0.2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT ); 
            } /* end of rule : RR:AR:SP:PO.S.2 */
         #else /* the reverse of #ifdef LP  */ 
            #ifdef LPG 
               POS2_ODCELLIN = copy( aLAYER_158 ); 
               POS2_ODCELLOUT = copy( aLAYER_159 ); 
               POS2_ODCELL = POS2_ODCELLIN and POS2_ODCELLOUT; 
               POS2_ODMARKER = ODI and RRULEREQUIRED; 
               gLAYER_791 = POS2_ODCELL or POS2_ODMARKER; 
               gLAYER_790 = gLAYER_791 not SRAM_EXCLUDE; 
               gLAYER_789 = gLAYER_790 outside BLOCK; 
               POS2_OD = gLAYER_789 not EXCLUDERRULEREQUIRED; 
               gLAYER_792 = and_edge( POLY, POS2_OD, false ); 
               POS2_GATE_W = or_edge( not_edge( gLAYER_792, DCO ), coincident_inside_edge( gLAYER_792, DCO ) ); 
               rRR_AR_SP_PO_S_2 @= { @ "RR:AR:SP:PO.S.2 : Recommended gate space in the same OD in LP process >= 0.2";
                   external1( POS2_GATE_W, < 0.2, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT ); 
               } /* end of rule : RR:AR:SP:PO.S.2 */
            #endif /* end of #ifdef LPG  */ 
         #endif /* end of #ifdef LP  */ 
      #endif /* end of #ifdef GP  */ 
   #endif /* end of #ifdef _POS2_  */ 
   #ifdef _POEX2_ 
      POEX2_ODCELLIN = copy( aLAYER_160 ); 
      POEX2_ODCELLOUT = copy( aLAYER_161 ); 
      POEX2_ODCELL = POEX2_ODCELLIN and POEX2_ODCELLOUT; 
      POEX2_ODMARKER = ODI and RRULEREQUIRED; 
      gLAYER_795 = POEX2_ODCELL or POEX2_ODMARKER; 
      gLAYER_794 = gLAYER_795 not SRAM_EXCLUDE; 
      gLAYER_793 = gLAYER_794 outside BLOCK; 
      POEX2_OD = gLAYER_793 not EXCLUDERRULEREQUIRED; 
      
      // PO.EX.2.R is checked by RR:AR:SP:PO.EX.2
      rRR_AR_SP_PO_EX_2 @= { @ "RR:AR:SP:PO.EX.2 : Recommended OD extension on PO >= 0.18 um";
          sLAYER_1206 = enclose( POLY, POEX2_OD, < 0.18, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 89.5, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, relational = { POINT_TOUCH }, width = 0.004 ); 
          sLAYER_1206 not_inside LOGO; 
      } /* end of rule : RR:AR:SP:PO.EX.2 */
   #endif /* end of #ifdef _POEX2_  */ 
   GATEW2CHECK = length_edge( GATE_W, >= 0.15 ); 
   GATE2CHECK = GATE touching GATEW2CHECK; 
   #ifdef _POS5_ 
      POS5_POCELLIN = copy( aLAYER_162 ); 
      POS5_POCELLOUT = copy( aLAYER_163 ); 
      POS5_POCELL = POS5_POCELLIN and POS5_POCELLOUT; 
      POS5_POMARKER = POI and RRULEREQUIRED; 
      gLAYER_798 = POS5_POCELL or POS5_POMARKER; 
      gLAYER_797 = gLAYER_798 not SRAM_EXCLUDE; 
      gLAYER_796 = gLAYER_797 outside BLOCK; 
      POS5_PO = gLAYER_796 not EXCLUDERRULEREQUIRED; 
      gLAYER_799 = GATE_W coincident_inside_edge POS5_PO; 
      POS5_GATEW = gLAYER_799 coincident_inside_edge GATE2CHECK; 
      gLAYER_1213 = extend_edge( POS5_GATEW, start = OD_S_1, end = OD_S_1 ); 
      POS5_GATEWEXP = edge_size( gLAYER_1213, inside = GRID ); 
      POS5_GATEWEXE = POS5_PO coincident_inside_edge POS5_GATEWEXP; 
      POS5B_A = external2( POS5_GATEWEXE, ODI, < 0.1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
      POS5B_B = edge_size( POS5_GATEW, outside = 0.1 ); 
      POS5B_C = POS5B_B and OD; 
      POS5B_D = POS5B_C outside_touching_edge POS5B_A; 
      POS5B_E = edge_size( POS5B_D, outside = 0.21 ); 
      POS5B_F = edge_size( POS5B_D, outside = 0.005 ); 
      POS5B_G = POS5B_E and OD; 
      POS5B_H = interacting( POS5B_G, POS5B_F ); 
      POS5B_I = POS5B_H not_touching_edge POS5B_F; 
      POS5B_J = and_edge( POS5B_I, OD, false ); 
      
      // PO.S.5.R is checked by RR:AR:SP:PO.S.5
      rRR_AR_SP_PO_S_5 @= { @ "RR:AR:SP:PO.S.5 : Space to L-shape OD when PO and OD are in the same MOS [channel width (W) >= 0.15 um ] >= 0.10 "
                                                "or Max L-leg length when PO and OD are in the same MOS [channel width (W) >= 0.15 um & J<0.1 ] <= 0.21";
          POS5B_H touching POS5B_J; 
      } /* end of rule : RR:AR:SP:PO.S.5 */
   #endif /* end of #ifdef _POS5_  */ 
   #ifdef _POS14_ 
      POS14_POCELLIN = copy( aLAYER_164 ); 
      POS14_POCELLOUT = copy( aLAYER_165 ); 
      POS14_POCELL = POS14_POCELLIN and POS14_POCELLOUT; 
      POS14_POMARKER = POI and RRULERECOMMENDED; 
      gLAYER_802 = POS14_POCELL or POS14_POMARKER; 
      gLAYER_801 = gLAYER_802 not SRAM_EXCLUDE; 
      gLAYER_800 = gLAYER_801 outside BLOCK; 
      POS14_PO = gLAYER_800 not EXCLUDERRULERECOMMENDED; 
      gLAYER_803 = GATE_NP and POS14_PO; 
      POS14_GATE = gLAYER_803 not OD2; 
      gLAYER_804 = NWEL or NTN; 
      POS14_NW = OD2 or gLAYER_804; 
      
      // PO.S.14.R is checked by RR:AR:SP:PO.S.14
      rRR_AR_SP_PO_S_14 @= { @ "RR:AR:SP:PO.S.14 : Recommmended 1.0V or 1.2V NMOS gate space to (OD2 OR (NW OR NT_N))  >= 1.0 um";
          external2( POS14_GATE, POS14_NW, < 1.0, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : RR:AR:SP:PO.S.14 */
   #endif /* end of #ifdef _POS14_  */ 
   #ifdef _POEN1_ 
      POEN1_POCELLIN = copy( aLAYER_166 ); 
      POEN1_POCELLOUT = copy( aLAYER_167 ); 
      POEN1_POCELL = POEN1_POCELLIN and POEN1_POCELLOUT; 
      POEN1_POMARKER = POI and RRULERECOMMENDED; 
      gLAYER_807 = POEN1_POCELL or POEN1_POMARKER; 
      gLAYER_806 = gLAYER_807 not SRAM_EXCLUDE; 
      gLAYER_805 = gLAYER_806 outside BLOCK; 
      POEN1_PO = gLAYER_805 not EXCLUDERRULERECOMMENDED; 
      gLAYER_808 = GATE_PP and POEN1_PO; 
      POEN1_GATE = gLAYER_808 not OD2; 
      gLAYER_809 = NWEL not OD_33; 
      POEN1_NW = gLAYER_809 not NTN; 
      
      // PO.EN.1.R is checked by RR:RE:SP:PO.EN.1
      rRR_RE_SP_PO_EN_1 @= { @ "RR:RE:SP:PO.EN.1 : Recommmended 1.0V or 1.2V PMOS gate enclosure by ((NW NOT OD2) NOT NT_N) for 3.3V IO process >= 1.0 um "
                                                  "Recommmended 1.0V or 1.2V PMOS gate enclosure by (NW NOT NT_N) for 1.8V or 2.5V IO process >= 1.0 um";
          enclose( POEN1_GATE, POEN1_NW, < 1.0, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : RR:RE:SP:PO.EN.1 */
   #endif /* end of #ifdef _POEN1_  */ 
   #ifdef _POEN2_ 
      POEN2_POCELLIN = copy( aLAYER_168 ); 
      POEN2_POCELLOUT = copy( aLAYER_169 ); 
      POEN2_POCELL = POEN2_POCELLIN and POEN2_POCELLOUT; 
      POEN2_POMARKER = POI and RRULERECOMMENDED; 
      gLAYER_812 = POEN2_POCELL or POEN2_POMARKER; 
      gLAYER_811 = gLAYER_812 not SRAM_EXCLUDE; 
      gLAYER_810 = gLAYER_811 outside BLOCK; 
      POEN2_PO = gLAYER_810 not EXCLUDERRULERECOMMENDED; 
      gLAYER_813 = GATE_NP and POEN2_PO; 
      POEN2_GATE = gLAYER_813 and OD2; 
      gLAYER_814 = NWEL or NTN; 
      POEN2_NW = OD2 not gLAYER_814; 
      
      // PO.EN.2.R is checked by RR:RE:SP:PO.EN.2
      rRR_RE_SP_PO_EN_2 @= { @ "RR:RE:SP:PO.EN.2 : Recommmended 2.5V NMOS gate enclosure by (OD2 NOT (NW OR NT_N)) >= 2.0 um";
          enclose( POEN2_GATE, POEN2_NW, < 2.0, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : RR:RE:SP:PO.EN.2 */
   #endif /* end of #ifdef _POEN2_  */ 
   #ifdef _POEN3_ 
      POEN3_POCELLIN = copy( aLAYER_170 ); 
      POEN3_POCELLOUT = copy( aLAYER_171 ); 
      POEN3_POCELL = POEN3_POCELLIN and POEN3_POCELLOUT; 
      POEN3_POMARKER = POI and RRULERECOMMENDED; 
      gLAYER_817 = POEN3_POCELL or POEN3_POMARKER; 
      gLAYER_816 = gLAYER_817 not SRAM_EXCLUDE; 
      gLAYER_815 = gLAYER_816 outside BLOCK; 
      POEN3_PO = gLAYER_815 not EXCLUDERRULERECOMMENDED; 
      POEN3_GATE = GATE_PP and POEN3_PO; 
      POEN3_GATE33 = POEN3_GATE and OD_33; 
      gLAYER_818 = OD_18 or OD_25; 
      POEN3_GATE1825 = POEN3_GATE and gLAYER_818; 
      POEN3_NW = NWEL not NTN; 
      POEN3_NW33 = POEN3_NW and OD_33; 
      
      // PO.EN.3.R is checked by RR:AR:SP:PO.EN.3
      rRR_AR_SP_PO_EN_3 @= { @ "RR:AR:SP:PO.EN.3 : Recommmended 3.3V PMOS gate enclosure by ((NW AND OD2) NOT NT_N) >= 1.5 um "
                                                  "Recommmended 1.8V or 2.5V PMOS gate enclosure by (NW NOT NT_N) >= 1.5 um";
          enclose( POEN3_GATE1825, POEN3_NW, < 1.5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          enclose( POEN3_GATE33, POEN3_NW33, < 1.5, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : RR:AR:SP:PO.EN.3 */
   #endif /* end of #ifdef _POEN3_  */ 
   #ifdef _OPCR1_ 
      OPCR1_PPCELLIN = copy( aLAYER_172 ); 
      OPCR1_PPCELLOUT = copy( aLAYER_173 ); 
      OPCR1_PPCELL = OPCR1_PPCELLIN and OPCR1_PPCELLOUT; 
      OPCR1_PPMARKER = PPI and RRULERECOMMENDED; 
      gLAYER_821 = OPCR1_PPCELL or OPCR1_PPMARKER; 
      gLAYER_820 = gLAYER_821 not_inside SRAM_EXCLUDE; 
      gLAYER_819 = gLAYER_820 outside BLOCK; 
      OPCR1_PP = gLAYER_819 not EXCLUDERRULERECOMMENDED; 
      OPCR1_PP_45ANGLE = angle_edge( OPCR1_PP, == 45 ); 
      
      // OPC.R.1.R is checked by RR:RE:S:OPC.R.1:PP
      rRR_RE_S_OPC_R_1_PP @= { @ "RR:RE:S:OPC.R.1:PP : Recommended 45-degree edge length >= 0.27 um for OPC friendly layout";
          sLAYER_1207 = length_edge( OPCR1_PP_45ANGLE, < 0.27 ); 
          or_edge( not_edge( sLAYER_1207, SRAM_EXCLUDE ), coincident_inside_edge( sLAYER_1207, SRAM_EXCLUDE ) ); 
      } /* end of rule : RR:RE:S:OPC.R.1:PP */
      OPCR1_NPCELLIN = copy( aLAYER_174 ); 
      OPCR1_NPCELLOUT = copy( aLAYER_175 ); 
      OPCR1_NPCELL = OPCR1_NPCELLIN and OPCR1_NPCELLOUT; 
      OPCR1_NPMARKER = NPI and RRULERECOMMENDED; 
      gLAYER_824 = OPCR1_NPCELL or OPCR1_NPMARKER; 
      gLAYER_823 = gLAYER_824 not_inside SRAM_EXCLUDE; 
      gLAYER_822 = gLAYER_823 outside BLOCK; 
      OPCR1_NP = gLAYER_822 not EXCLUDERRULERECOMMENDED; 
      OPCR1_NP_45ANGLE = angle_edge( OPCR1_NP, == 45 ); 
      
      // OPC.R.1.R is checked by RR:RE:S:OPC.R.1:NP 
      rRR_RE_S_OPC_R_1_NP @= { @ "RR:RE:S:OPC.R.1:NP : Recommended 45-degree edge length >= 0.27 um for OPC friendly layout";
          sLAYER_1208 = length_edge( OPCR1_NP_45ANGLE, < 0.27 ); 
          or_edge( not_edge( sLAYER_1208, SRAM_EXCLUDE ), coincident_inside_edge( sLAYER_1208, SRAM_EXCLUDE ) ); 
      } /* end of rule : RR:RE:S:OPC.R.1:NP */
      OPCR1_VTHNCELLIN = copy( aLAYER_176 ); 
      OPCR1_VTHNCELLOUT = copy( aLAYER_177 ); 
      OPCR1_VTHNCELL = OPCR1_VTHNCELLIN and OPCR1_VTHNCELLOUT; 
      OPCR1_VTHNMARKER = VTH_NI and RRULERECOMMENDED; 
      gLAYER_827 = OPCR1_VTHNCELL or OPCR1_VTHNMARKER; 
      gLAYER_826 = gLAYER_827 not_inside SRAM_EXCLUDE; 
      gLAYER_825 = gLAYER_826 outside BLOCK; 
      OPCR1_VTHN = gLAYER_825 not EXCLUDERRULERECOMMENDED; 
      OPCR1_VTHN_45ANGLE = angle_edge( OPCR1_VTHN, == 45 ); 
      
      // OPC.R.1.R is checked by RR:RE:S:OPC.R.1:VTHN
      rRR_RE_S_OPC_R_1_VTHN @= { @ "RR:RE:S:OPC.R.1:VTHN : Recommended 45-degree edge length >= 0.27 um for OPC friendly layout";
          sLAYER_1209 = length_edge( OPCR1_VTHN_45ANGLE, < 0.27 ); 
          or_edge( not_edge( sLAYER_1209, SRAM_EXCLUDE ), coincident_inside_edge( sLAYER_1209, SRAM_EXCLUDE ) ); 
      } /* end of rule : RR:RE:S:OPC.R.1:VTHN */
      OPCR1_VTHPCELLIN = copy( aLAYER_178 ); 
      OPCR1_VTHPCELLOUT = copy( aLAYER_179 ); 
      OPCR1_VTHPCELL = OPCR1_VTHPCELLIN and OPCR1_VTHPCELLOUT; 
      OPCR1_VTHPMARKER = VTH_PI and RRULERECOMMENDED; 
      gLAYER_830 = OPCR1_VTHPCELL or OPCR1_VTHPMARKER; 
      gLAYER_829 = gLAYER_830 not_inside SRAM_EXCLUDE; 
      gLAYER_828 = gLAYER_829 outside BLOCK; 
      OPCR1_VTHP = gLAYER_828 not EXCLUDERRULERECOMMENDED; 
      OPCR1_VTHP_45ANGLE = angle_edge( OPCR1_VTHP, == 45 ); 
      
      // OPC.R.1.R is checked by RR:RE:S:OPC.R.1:VTHP
      rRR_RE_S_OPC_R_1_VTHP @= { @ "RR:RE:S:OPC.R.1:VTHP : Recommended 45-degree edge length >= 0.27 um for OPC friendly layout";
          sLAYER_1210 = length_edge( OPCR1_VTHP_45ANGLE, < 0.27 ); 
          or_edge( not_edge( sLAYER_1210, SRAM_EXCLUDE ), coincident_inside_edge( sLAYER_1210, SRAM_EXCLUDE ) ); 
      } /* end of rule : RR:RE:S:OPC.R.1:VTHP */
      OPCR1_VTLNCELLIN = copy( aLAYER_180 ); 
      OPCR1_VTLNCELLOUT = copy( aLAYER_181 ); 
      OPCR1_VTLNCELL = OPCR1_VTLNCELLIN and OPCR1_VTLNCELLOUT; 
      OPCR1_VTLNMARKER = VTL_NI and RRULERECOMMENDED; 
      gLAYER_833 = OPCR1_VTLNCELL or OPCR1_VTLNMARKER; 
      gLAYER_832 = gLAYER_833 not_inside SRAM_EXCLUDE; 
      gLAYER_831 = gLAYER_832 outside BLOCK; 
      OPCR1_VTLN = gLAYER_831 not EXCLUDERRULERECOMMENDED; 
      OPCR1_VTLN_45ANGLE = angle_edge( OPCR1_VTLN, == 45 ); 
      
      // OPC.R.1.R is checked by RR:RE:S:OPC.R.1:VTLN
      rRR_RE_S_OPC_R_1_VTLN @= { @ "RR:RE:S:OPC.R.1:VTLN : Recommended 45-degree edge length >= 0.27 um for OPC friendly layout";
          sLAYER_1211 = length_edge( OPCR1_VTLN_45ANGLE, < 0.27 ); 
          or_edge( not_edge( sLAYER_1211, SRAM_EXCLUDE ), coincident_inside_edge( sLAYER_1211, SRAM_EXCLUDE ) ); 
      } /* end of rule : RR:RE:S:OPC.R.1:VTLN */
      OPCR1_VTLPCELLIN = copy( aLAYER_182 ); 
      OPCR1_VTLPCELLOUT = copy( aLAYER_183 ); 
      OPCR1_VTLPCELL = OPCR1_VTLPCELLIN and OPCR1_VTLPCELLOUT; 
      OPCR1_VTLPMARKER = VTL_PI and RRULERECOMMENDED; 
      gLAYER_836 = OPCR1_VTLPCELL or OPCR1_VTLPMARKER; 
      gLAYER_835 = gLAYER_836 not_inside SRAM_EXCLUDE; 
      gLAYER_834 = gLAYER_835 outside BLOCK; 
      OPCR1_VTLP = gLAYER_834 not EXCLUDERRULERECOMMENDED; 
      OPCR1_VTLP_45ANGLE = angle_edge( OPCR1_VTLP, == 45 ); 
      
      // OPC.R.1.R is checked by RR:RE:S:OPC.R.1:VTLP
      rRR_RE_S_OPC_R_1_VTLP @= { @ "RR:RE:S:OPC.R.1:VTLP : Recommended 45-degree edge length >= 0.27 um for OPC friendly layout";
          sLAYER_1212 = length_edge( OPCR1_VTLP_45ANGLE, < 0.27 ); 
          or_edge( not_edge( sLAYER_1212, SRAM_EXCLUDE ), coincident_inside_edge( sLAYER_1212, SRAM_EXCLUDE ) ); 
      } /* end of rule : RR:RE:S:OPC.R.1:VTLP */
      OPCR1_ODCELLIN = copy( aLAYER_184 ); 
      OPCR1_ODCELLOUT = copy( aLAYER_185 ); 
      OPCR1_ODCELL = OPCR1_ODCELLIN and OPCR1_ODCELLOUT; 
      OPCR1_ODMARKER = ODI and RRULERECOMMENDED; 
      gLAYER_839 = OPCR1_ODCELL or OPCR1_ODMARKER; 
      gLAYER_838 = gLAYER_839 not_inside SRAM_EXCLUDE; 
      gLAYER_837 = gLAYER_838 outside BLOCK; 
      OPCR1_OD = gLAYER_837 not EXCLUDERRULERECOMMENDED; 
      OPCR1_OD_45ANGLE = angle_edge( OPCR1_OD, == 45 ); 
      
      // OPC.R.1.R is checked by RR:RE:S:OPC.R.1:OD
      rRR_RE_S_OPC_R_1_OD @= { @ "RR:RE:S:OPC.R.1:OD : Recommended 45-degree edge length >= 0.27um";
          sLAYER_1213 = length_edge( OPCR1_OD_45ANGLE, < 0.27 ); 
          or_edge( not_edge( sLAYER_1213, SRAM_EXCLUDE ), coincident_inside_edge( sLAYER_1213, SRAM_EXCLUDE ) ); 
      } /* end of rule : RR:RE:S:OPC.R.1:OD */
      OPCR1_POCELLIN = copy( aLAYER_186 ); 
      OPCR1_POCELLOUT = copy( aLAYER_187 ); 
      OPCR1_POCELL = OPCR1_POCELLIN and OPCR1_POCELLOUT; 
      OPCR1_POMARKER = POI and RRULERECOMMENDED; 
      gLAYER_842 = OPCR1_POCELL or OPCR1_POMARKER; 
      gLAYER_841 = gLAYER_842 not_inside SRAM_EXCLUDE; 
      gLAYER_840 = gLAYER_841 outside BLOCK; 
      OPCR1_PO = gLAYER_840 not EXCLUDERRULERECOMMENDED; 
      OPCR1_PO_45ANGLE = angle_edge( OPCR1_PO, == 45 ); 
      
      // OPC.R.1.R is checked by RR:RE:S:OPC.R.1:PO
      rRR_RE_S_OPC_R_1_PO @= { @ "RR:RE:S:OPC.R.1:PO : Recommended 45-degree edge length >= 0.27um";
          sLAYER_1214 = length_edge( OPCR1_PO_45ANGLE, < 0.27 ); 
          or_edge( not_edge( sLAYER_1214, SRAM_EXCLUDE ), coincident_inside_edge( sLAYER_1214, SRAM_EXCLUDE ) ); 
      } /* end of rule : RR:RE:S:OPC.R.1:PO */
      OPCR1_M1CELLIN = copy( aLAYER_188 ); 
      OPCR1_M1CELLOUT = copy( aLAYER_189 ); 
      OPCR1_M1CELL = OPCR1_M1CELLIN and OPCR1_M1CELLOUT; 
      OPCR1_M1MARKER = M1I and RRULERECOMMENDED; 
      gLAYER_845 = OPCR1_M1CELL or OPCR1_M1MARKER; 
      gLAYER_844 = gLAYER_845 not_inside SRAM_EXCLUDE; 
      gLAYER_843 = gLAYER_844 not_inside BLOCK; 
      OPCR1_M1 = gLAYER_843 not EXCLUDERRULERECOMMENDED; 
      OPCR1_M1_45ANGLE = angle_edge( OPCR1_M1, == 45 ); 
      
      // OPC.R.1.R is checked by RR:RE:S:OPC.R.1:M1
      rRR_RE_S_OPC_R_1_M1 @= { @ "RR:RE:S:OPC.R.1:M1 : Recommended 45-degree edge length >= 0.27um";
          sLAYER_1215 = length_edge( OPCR1_M1_45ANGLE, < 0.27 ); 
          or_edge( not_edge( sLAYER_1215, SRAM_EXCLUDE ), coincident_inside_edge( sLAYER_1215, SRAM_EXCLUDE ) ); 
      } /* end of rule : RR:RE:S:OPC.R.1:M1 */
      OPCR1_M2CELLIN = copy( aLAYER_190 ); 
      OPCR1_M2CELLOUT = copy( aLAYER_191 ); 
      OPCR1_M2CELL = OPCR1_M2CELLIN and OPCR1_M2CELLOUT; 
      OPCR1_M2MARKER = M2I and RRULERECOMMENDED; 
      gLAYER_847 = OPCR1_M2CELL or OPCR1_M2MARKER; 
      gLAYER_846 = gLAYER_847 not_inside BLOCK; 
      OPCR1_M2 = gLAYER_846 not EXCLUDERRULERECOMMENDED; 
      OPCR1_M2_45ANGLE = angle_edge( OPCR1_M2, == 45 ); 
      
      // OPC.R.1.R is checked by RR:RE:S:OPC.R.1:M2
      rRR_RE_S_OPC_R_1_M2 @= { @ "RR:RE:S:OPC.R.1:M2 : Recommended 45-degree edge length >= 0.27um";
          length_edge( OPCR1_M2_45ANGLE, < 0.27 ); 
      } /* end of rule : RR:RE:S:OPC.R.1:M2 */
      OPCR1_M3CELLIN = copy( aLAYER_192 ); 
      OPCR1_M3CELLOUT = copy( aLAYER_193 ); 
      OPCR1_M3CELL = OPCR1_M3CELLIN and OPCR1_M3CELLOUT; 
      OPCR1_M3MARKER = M3I and RRULERECOMMENDED; 
      gLAYER_849 = OPCR1_M3CELL or OPCR1_M3MARKER; 
      gLAYER_848 = gLAYER_849 not_inside BLOCK; 
      OPCR1_M3 = gLAYER_848 not EXCLUDERRULERECOMMENDED; 
      OPCR1_M3_45ANGLE = angle_edge( OPCR1_M3, == 45 ); 
      
      // OPC.R.1.R is checked by RR:RE:S:OPC.R.1:M3
      rRR_RE_S_OPC_R_1_M3 @= { @ "RR:RE:S:OPC.R.1:M3 : Recommended 45-degree edge length >= 0.27um";
          length_edge( OPCR1_M3_45ANGLE, < 0.27 ); 
      } /* end of rule : RR:RE:S:OPC.R.1:M3 */
      OPCR1_M4CELLIN = copy( aLAYER_194 ); 
      OPCR1_M4CELLOUT = copy( aLAYER_195 ); 
      OPCR1_M4CELL = OPCR1_M4CELLIN and OPCR1_M4CELLOUT; 
      OPCR1_M4MARKER = M4I and RRULERECOMMENDED; 
      gLAYER_851 = OPCR1_M4CELL or OPCR1_M4MARKER; 
      gLAYER_850 = gLAYER_851 not_inside BLOCK; 
      OPCR1_M4 = gLAYER_850 not EXCLUDERRULERECOMMENDED; 
      OPCR1_M4_45ANGLE = angle_edge( OPCR1_M4, == 45 ); 
      
      // OPC.R.1.R is checked by RR:RE:S:OPC.R.1:M4
      rRR_RE_S_OPC_R_1_M4 @= { @ "RR:RE:S:OPC.R.1:M4 : Recommended 45-degree edge length >= 0.27um";
          length_edge( OPCR1_M4_45ANGLE, < 0.27 ); 
      } /* end of rule : RR:RE:S:OPC.R.1:M4 */
      OPCR1_M5CELLIN = copy( aLAYER_196 ); 
      OPCR1_M5CELLOUT = copy( aLAYER_197 ); 
      OPCR1_M5CELL = OPCR1_M5CELLIN and OPCR1_M5CELLOUT; 
      OPCR1_M5MARKER = M5I and RRULERECOMMENDED; 
      gLAYER_853 = OPCR1_M5CELL or OPCR1_M5MARKER; 
      gLAYER_852 = gLAYER_853 not_inside BLOCK; 
      OPCR1_M5 = gLAYER_852 not EXCLUDERRULERECOMMENDED; 
      OPCR1_M5_45ANGLE = angle_edge( OPCR1_M5, == 45 ); 
      
      // OPC.R.1.R is checked by RR:RE:S:OPC.R.1:M5
      rRR_RE_S_OPC_R_1_M5 @= { @ "RR:RE:S:OPC.R.1:M5 : Recommended 45-degree edge length >= 0.27um";
          length_edge( OPCR1_M5_45ANGLE, < 0.27 ); 
      } /* end of rule : RR:RE:S:OPC.R.1:M5 */
      OPCR1_M6CELLIN = copy( aLAYER_198 ); 
      OPCR1_M6CELLOUT = copy( aLAYER_199 ); 
      OPCR1_M6CELL = OPCR1_M6CELLIN and OPCR1_M6CELLOUT; 
      OPCR1_M6MARKER = M6I and RRULERECOMMENDED; 
      gLAYER_855 = OPCR1_M6CELL or OPCR1_M6MARKER; 
      gLAYER_854 = gLAYER_855 not_inside BLOCK; 
      OPCR1_M6 = gLAYER_854 not EXCLUDERRULERECOMMENDED; 
      OPCR1_M6_45ANGLE = angle_edge( OPCR1_M6, == 45 ); 
      
      // OPC.R.1.R is checked by RR:RE:S:OPC.R.1:M6
      rRR_RE_S_OPC_R_1_M6 @= { @ "RR:RE:S:OPC.R.1:M6 : Recommended 45-degree edge length >= 0.27um";
          length_edge( OPCR1_M6_45ANGLE, < 0.27 ); 
      } /* end of rule : RR:RE:S:OPC.R.1:M6 */
      OPCR1_M7CELLIN = copy( aLAYER_200 ); 
      OPCR1_M7CELLOUT = copy( aLAYER_201 ); 
      OPCR1_M7CELL = OPCR1_M7CELLIN and OPCR1_M7CELLOUT; 
      OPCR1_M7MARKER = M7I and RRULERECOMMENDED; 
      gLAYER_857 = OPCR1_M7CELL or OPCR1_M7MARKER; 
      gLAYER_856 = gLAYER_857 not_inside BLOCK; 
      OPCR1_M7 = gLAYER_856 not EXCLUDERRULERECOMMENDED; 
      OPCR1_M7_45ANGLE = angle_edge( OPCR1_M7, == 45 ); 
      
      // OPC.R.1.R is checked by RR:RE:S:OPC.R.1:M7
      rRR_RE_S_OPC_R_1_M7 @= { @ "RR:RE:S:OPC.R.1:M7 : Recommended 45-degree edge length >= 0.27um";
          length_edge( OPCR1_M7_45ANGLE, < 0.27 ); 
      } /* end of rule : RR:RE:S:OPC.R.1:M7 */
   #endif /* end of #ifdef _OPCR1_  */ 
   #ifdef _ODS6_ 
      ODS6_ODCELLIN = copy( aLAYER_202 ); 
      ODS6_ODCELLOUT = copy( aLAYER_203 ); 
      ODS6_ODCELL = ODS6_ODCELLIN and ODS6_ODCELLOUT; 
      ODS6_ODMARKER = ODI and RRULERECOMMENDED; 
      gLAYER_860 = ODS6_ODCELL or ODS6_ODMARKER; 
      gLAYER_859 = gLAYER_860 not SRAM_EXCLUDE; 
      gLAYER_858 = gLAYER_859 outside BLOCK; 
      ODS6_OD = gLAYER_858 not EXCLUDERRULERECOMMENDED; 
      gLAYER_861 = not_interacting( ODI, SEALRING ); 
      ODS6AREA = area( gLAYER_861, > BIG_AREA ); 
      
      // OD.S.6.R is checked by RR:RE:S:OD.S.6
      rRR_RE_S_OD_S_6 @= { @ "RR:RE:S:OD.S.6 : Space to large OD [OD area > " + BIG_AREA + "] >= " + OD_S_6_R + " um"; 
          sLAYER_1216 = external2( ODS6AREA, ODI, < OD_S_6_R, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, membership = DIFFERENT_POLYGON, relational = { POINT_TOUCH }, width = 0.002 ); 
          interacting( sLAYER_1216, ODS6_OD ); 
      } /* end of rule : RR:RE:S:OD.S.6 */
   #endif /* end of #ifdef _ODS6_  */ 
   #ifdef _DNWEN1_ 
      DNWEN1_DNWCELLIN = copy( aLAYER_204 ); 
      DNWEN1_DNWCELLOUT = copy( aLAYER_205 ); 
      DNWEN1_DNWCELL = DNWEN1_DNWCELLIN and DNWEN1_DNWCELLOUT; 
      DNWEN1_DNWMARKER = DNWI and RRULERECOMMENDED; 
      gLAYER_864 = DNWEN1_DNWCELL or DNWEN1_DNWMARKER; 
      gLAYER_863 = gLAYER_864 not_inside SRAM_EXCLUDE; 
      gLAYER_862 = gLAYER_863 outside BLOCK; 
      DNWEN1_DNW = gLAYER_862 not EXCLUDERRULERECOMMENDED; 
      
      // DNW.EN.1.R is checked by RR:RE:S:DNW.EN.1
      rRR_RE_S_DNW_EN_1 @= { @ "RR:RE:S:DNW.EN.1 : Enclosure by NW >= 1.0um for better noise isolation.";
          enclose( DNWEN1_DNW, NWEL, < 1.0, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          not_edge( DNWEN1_DNW, NWEL, coincident = false ); 
      } /* end of rule : RR:RE:S:DNW.EN.1 */
   #endif /* end of #ifdef _DNWEN1_  */ 
   #ifdef _POS11_ 
      POS11_POCELLIN = copy( aLAYER_206 ); 
      POS11_POCELLOUT = copy( aLAYER_207 ); 
      POS11_POCELL = POS11_POCELLIN and POS11_POCELLOUT; 
      POS11_POMARKER = POI and RRULERECOMMENDED; 
      gLAYER_867 = POS11_POCELL or POS11_POMARKER; 
      gLAYER_866 = gLAYER_867 not SRAM_EXCLUDE; 
      gLAYER_865 = gLAYER_866 outside BLOCK; 
      POS11_PO = gLAYER_865 not EXCLUDERRULERECOMMENDED; 
      POS11_ODCELLIN = copy( aLAYER_208 ); 
      POS11_ODCELLOUT = copy( aLAYER_209 ); 
      POS11_ODCELL = POS11_ODCELLIN and POS11_ODCELLOUT; 
      POS11_ODMARKER = ODI and RRULERECOMMENDED; 
      gLAYER_870 = POS11_ODCELL or POS11_ODMARKER; 
      gLAYER_869 = gLAYER_870 not SRAM_EXCLUDE; 
      gLAYER_868 = gLAYER_869 outside BLOCK; 
      POS11_OD = gLAYER_868 not EXCLUDERRULERECOMMENDED; 
      POS11_GATE = POS11_PO and POS11_OD; 
      POS11_GATEW = POS11_PO coincident_inside_edge POS11_GATE; 
      POS11_CHECK = internal1_edge( POS11_GATEW, <= 0.08, extension = NONE, intersecting = {  }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
      POS11_CHIP = size( gCHIP, clip_acute = NONE, distance = - ( 1.0 - GRID ) ); 
      gLAYER_871 = and_edge( POS11_CHECK, POS11_CHIP, false ); 
      POS11_EDGE1 = POS11_CHECK touching_edge gLAYER_871; 
      POS11_EXPD = edge_size( POS11_EDGE1, outside = 1.0 ); 
      POS11_ALL = interacting( ALL_POLY, POS11_EXPD ); 
      POS11_EXT = external2_edge( POS11_CHECK, POS11_ALL, < 1.0, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = COINCIDENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
      
      // PO.S.11.R is checked by RR:RE:S:PO.S.11
      rRR_RE_S_PO_S_11 @= { @ "RR:RE:S:PO.S.11 : Recommended gate space to {PO OR DPO} (for channel length <= 0.08 um)  < 1.0um";
          POS11_EDGE1 not_coincident_inside_edge POS11_EXT; 
      } /* end of rule : RR:RE:S:PO.S.11 */
   #endif /* end of #ifdef _POS11_  */ 
   #ifdef _POS13_ 
      POS13_POCELLIN = copy( aLAYER_210 ); 
      POS13_POCELLOUT = copy( aLAYER_211 ); 
      POS13_POCELL = POS13_POCELLIN and POS13_POCELLOUT; 
      POS13_POMARKER = POI and RRULERECOMMENDED; 
      gLAYER_874 = POS13_POCELL or POS13_POMARKER; 
      gLAYER_873 = gLAYER_874 not SRAM_EXCLUDE; 
      gLAYER_872 = gLAYER_873 outside BLOCK; 
      POS13_PO = gLAYER_872 not EXCLUDERRULERECOMMENDED; 
      POS13_ODCELLIN = copy( aLAYER_212 ); 
      POS13_ODCELLOUT = copy( aLAYER_213 ); 
      POS13_ODCELL = POS13_ODCELLIN and POS13_ODCELLOUT; 
      POS13_ODMARKER = ODI and RRULERECOMMENDED; 
      gLAYER_877 = POS13_ODCELL or POS13_ODMARKER; 
      gLAYER_876 = gLAYER_877 not SRAM_EXCLUDE; 
      gLAYER_875 = gLAYER_876 outside BLOCK; 
      POS13_OD = gLAYER_875 not EXCLUDERRULERECOMMENDED; 
      POS13_GATE = POS13_PO and POS13_OD; 
      POS13_GATEW = POS13_PO coincident_inside_edge POS13_GATE; 
      POS13_CHECK = internal1_edge( POS13_GATEW, == 0.06, extension = NONE, intersecting = {  }, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
      POS13_BAD19 = external2( POS13_CHECK, ALL_POLY, < 0.19, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
      POS13_EXT27 = external2_edge( POS13_CHECK, ALL_POLY, <= 0.27, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
      POS13_LEFT27 = POS13_CHECK not_coincident_inside_edge POS13_EXT27; 
      POS13_BAD295 = external2( POS13_LEFT27, ALL_POLY, < 0.295, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
      POS13_EXT39 = external2_edge( POS13_CHECK, ALL_POLY, <= 0.39, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
      POS13_LEFT39 = POS13_CHECK not_coincident_inside_edge POS13_EXT39; 
      POS13_BAD455 = external2( POS13_LEFT39, ALL_POLY, < 0.455, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
      POS13_EXT94 = external2_edge( POS13_CHECK, ALL_POLY, <= 0.94, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, look_thru = COINCIDENT, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
      POS13_LEFT94 = POS13_CHECK not_coincident_inside_edge POS13_EXT94; 
      
      // PO.S.13.R is checked by RR:RE:S:PO.S.13
      rRR_RE_S_PO_S_13 @= { @ "RR:RE:S:PO.S.13 : Recommended gate to poly spacing range (for channel length = 0.06um ) =0.19~0.27/0.295~0.39/0.455~0.94";
          sLAYER_1217 = POS13_BAD19 or POS13_BAD295; 
          sLAYER_1217 or POS13_BAD455; 
          copy_edge( POS13_LEFT94 ); 
      } /* end of rule : RR:RE:S:PO.S.13 */
   #endif /* end of #ifdef _POS13_  */ 
   #ifdef _NWRODS3_ 
      NWRODS3_NWCELLIN = copy( aLAYER_214 ); 
      NWRODS3_NWCELLOUT = copy( aLAYER_215 ); 
      NWRODS3_NWCELL = NWRODS3_NWCELLIN and NWRODS3_NWCELLOUT; 
      NWRODS3_NWMARKER = NWI and RRULERECOMMENDED; 
      gLAYER_880 = NWRODS3_NWCELL or NWRODS3_NWMARKER; 
      gLAYER_879 = gLAYER_880 not_inside SRAM_EXCLUDE; 
      gLAYER_878 = gLAYER_879 outside BLOCK; 
      NWRODS3_NW = gLAYER_878 not EXCLUDERRULERECOMMENDED; 
      
      // NWROD.S.3.R is checked by RR:RE:P:NWROD.S.3
      rRR_RE_P_NWROD_S_3 @= { @ "RR:RE:P:NWROD.S.3 : RPO space to CO in NWEL resistor within OD for SPICE model accuracy == 0.3 um";
          sLAYER_1218 = NWRES and NWRODS3_NW; 
          A = and_edge( RPO, sLAYER_1218, false ); 
          B = edge_size( A, outside = 0.3 ); 
          B and COWR; 
          not_interacting( B, COWR ); 
      } /* end of rule : RR:RE:P:NWROD.S.3 */
   #endif /* end of #ifdef _NWRODS3_  */ 
   #ifdef _NWRODR1_ 
      NWRODR1_NWCELLIN = copy( aLAYER_216 ); 
      NWRODR1_NWCELLOUT = copy( aLAYER_217 ); 
      NWRODR1_NWCELL = NWRODR1_NWCELLIN and NWRODR1_NWCELLOUT; 
      NWRODR1_NWMARKER = NWI and RRULERECOMMENDED; 
      gLAYER_883 = NWRODR1_NWCELL or NWRODR1_NWMARKER; 
      gLAYER_882 = gLAYER_883 not_inside SRAM_EXCLUDE; 
      gLAYER_881 = gLAYER_882 outside BLOCK; 
      NWRODR1_NW = gLAYER_881 not EXCLUDERRULERECOMMENDED; 
      gLAYER_884 = NWRODR1_NW and NWRES; 
      NWRODR1_NWRES = gLAYER_884 and NWDMY; 
      
      // NWROD.R.1.R is checked by RR:RE:P:NWROD.R.1
      rRR_RE_P_NWROD_R_1 @= { @ "RR:RE:P:NWROD.R.1 : Recommended length >= 20um for NW resistor with OD, for SPICE model accuracy";
          RES_L = NWRODR1_NWRES coincident_inside_edge NWRODR1_NW; 
          X = length_edge( RES_L, < 20.0, CONNECT ); 
          CHECK_RES = NWRODR1_NWRES touching X; 
          RES_E = CHECK_RES coincident_inside_edge NWDMY; 
          A = edge_size( RES_E, inside = GRID ); 
          B = size_inside_wrapper( A, NWRODR1_NWRES, distance = ( 10 - GRID * 2 ), increment = NW_S_1 * 0.7 ); 
          C = CHECK_RES not B; 
          not_interacting( CHECK_RES, C ); 
          D = internal1( C, < ( GRID * 2 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
          interacting( CHECK_RES, D ); 
      } /* end of rule : RR:RE:P:NWROD.R.1 */
   #endif /* end of #ifdef _NWRODR1_  */ 
   #ifdef _NWRSTIEN2_ 
      NWRSTIEN2_NWCELLIN = copy( aLAYER_218 ); 
      NWRSTIEN2_NWCELLOUT = copy( aLAYER_219 ); 
      NWRSTIEN2_NWCELL = NWRSTIEN2_NWCELLIN and NWRSTIEN2_NWCELLOUT; 
      NWRSTIEN2_NWMARKER = NWI and RRULERECOMMENDED; 
      gLAYER_887 = NWRSTIEN2_NWCELL or NWRSTIEN2_NWMARKER; 
      gLAYER_886 = gLAYER_887 not_inside SRAM_EXCLUDE; 
      gLAYER_885 = gLAYER_886 outside BLOCK; 
      NWRSTIEN2_NW = gLAYER_885 not EXCLUDERRULERECOMMENDED; 
      
      // NWRSTI.EN.2.R is checked by RR:RE:P:NWRSTI.EN.2
      rRR_RE_P_NWRSTI_EN_2 @= { @ "RR:RE:P:NWRSTI.EN.2 : OD enclosure of CO in NWEL resistor under STI for SPICE model accuracy == 0.3 um";
          sLAYER_1219 = NWRES_STI and NWRSTIEN2_NW; 
          A = and_edge( OD, sLAYER_1219, false ); 
          B = edge_size( A, inside = 0.3 ); 
          not_interacting( B, COWR_STI ); 
      } /* end of rule : RR:RE:P:NWRSTI.EN.2 */
   #endif /* end of #ifdef _NWRSTIEN2_  */ 
   #ifdef _NWRSTIR1_ 
      NWRSTIR1_NWCELLIN = copy( aLAYER_220 ); 
      NWRSTIR1_NWCELLOUT = copy( aLAYER_221 ); 
      NWRSTIR1_NWCELL = NWRSTIR1_NWCELLIN and NWRSTIR1_NWCELLOUT; 
      NWRSTIR1_NWMARKER = NWI and RRULERECOMMENDED; 
      gLAYER_890 = NWRSTIR1_NWCELL or NWRSTIR1_NWMARKER; 
      gLAYER_889 = gLAYER_890 not_inside SRAM_EXCLUDE; 
      gLAYER_888 = gLAYER_889 outside BLOCK; 
      NWRSTIR1_NW = gLAYER_888 not EXCLUDERRULERECOMMENDED; 
      gLAYER_891 = NWRSTIR1_NW and NWRES_STI; 
      NWRSTIR1_NWRES = gLAYER_891 and NWDMY; 
      
      // NWRSTI.R.1.R is checked by RR:RE:P:NWRSTI.R.1
      rRR_RE_P_NWRSTI_R_1 @= { @ "RR:RE:P:NWRSTI.R.1 : Recommended length >= 20um for NW resistor under STI, for SPICE model accuracy";
          RES_L = NWRSTIR1_NWRES coincident_inside_edge NWRSTIR1_NW; 
          X = length_edge( RES_L, < 20.0, CONNECT ); 
          CHECK_RES = NWRSTIR1_NWRES touching X; 
          RES_E = CHECK_RES coincident_inside_edge NWDMY; 
          A = edge_size( RES_E, inside = GRID ); 
          B = size_inside_wrapper( A, NWRSTIR1_NWRES, distance = ( 10 - GRID * 2 ), increment = NW_S_1 * 0.7 ); 
          C = CHECK_RES not B; 
          not_interacting( CHECK_RES, C ); 
          D = internal1( C, < ( GRID * 2 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
          interacting( CHECK_RES, D ); 
      } /* end of rule : RR:RE:P:NWRSTI.R.1 */
   #endif /* end of #ifdef _NWRSTIR1_  */    /* _NWRSTIR1_ */ 
   #ifdef _ODW2_ 
      ODW2_ODCELLIN = copy( aLAYER_222 ); 
      ODW2_ODCELLOUT = copy( aLAYER_223 ); 
      ODW2_ODCELL = ODW2_ODCELLIN and ODW2_ODCELLOUT; 
      ODW2_ODMARKER = ODI and RRULERECOMMENDED; 
      gLAYER_894 = ODW2_ODCELL or ODW2_ODMARKER; 
      gLAYER_893 = gLAYER_894 not SRAM_EXCLUDE; 
      gLAYER_892 = gLAYER_893 outside BLOCK; 
      ODW2_OD = gLAYER_892 not EXCLUDERRULERECOMMENDED; 
      ODW2_POCELLIN = copy( aLAYER_224 ); 
      ODW2_POCELLOUT = copy( aLAYER_225 ); 
      ODW2_POCELL = ODW2_POCELLIN and ODW2_POCELLOUT; 
      ODW2_POMARKER = POI and RRULERECOMMENDED; 
      gLAYER_897 = ODW2_POCELL or ODW2_POMARKER; 
      gLAYER_896 = gLAYER_897 not SRAM_EXCLUDE; 
      gLAYER_895 = gLAYER_896 outside BLOCK; 
      ODW2_PO = gLAYER_895 not EXCLUDERRULERECOMMENDED; 
      gLAYER_898 = and_edge( ODW2_PO, ODW2_OD, false ); 
      ODW2_GATE_W = or_edge( not_edge( gLAYER_898, OD2 ), coincident_inside_edge( gLAYER_898, OD2 ) ); 
      
      // OD.W.2.R is checked by RR:RE:P:OD.W.2
      rRR_RE_P_OD_W_2 @= { @ "RR:RE:P:OD.W.2 : Recommended Width of MOS (<= 1.2V) >= 0.15 um";
          length_edge( ODW2_GATE_W, < 0.15 ); 
      } /* end of rule : RR:RE:P:OD.W.2 */
   #endif /* end of #ifdef _ODW2_  */ 
   #ifdef _POS4_1_ 
      POS4_1_ODCELLIN = copy( aLAYER_226 ); 
      POS4_1_ODCELLOUT = copy( aLAYER_227 ); 
      POS4_1_ODCELL = POS4_1_ODCELLIN and POS4_1_ODCELLOUT; 
      POS4_1_ODMARKER = ODI and RRULERECOMMENDED; 
      gLAYER_901 = POS4_1_ODCELL or POS4_1_ODMARKER; 
      gLAYER_900 = gLAYER_901 not SRAM_EXCLUDE; 
      gLAYER_899 = gLAYER_900 outside BLOCK; 
      POS4_1_OD = gLAYER_899 not EXCLUDERRULERECOMMENDED; 
      POS4_1_GATE = POLY and POS4_1_OD; 
      
      // PO.S.4.1.R is checked by RR:RE:P:PO.S.4.1
      rRR_RE_P_PO_S_4_1 @= { @ "RR:RE:P:PO.S.4.1 : Recommended gate space when the area enclosed by L-shape OD and L-shape PO < 0.0196 for PO/OD rounding effect >= 0.2";
          sLAYER_1221 = external1( POS4_1_GATE, < 0.2, corner_configuration = CORNER_TO_CORNER, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT ); 
          sLAYER_1220 = interacting( sLAYER_1221, ODI, == 1 ); 
          interacting( sLAYER_1220, POI, == 1 ); 
      } /* end of rule : RR:RE:P:PO.S.4.1 */
   #endif /* end of #ifdef _POS4_1_  */ 
   
   // RES.2.R is checked by RR:RE:P:RES.2:OD and RR:RE:P:RES.2:PO
   #ifdef _RES2_ 
      RES2_POCELLIN = copy( aLAYER_228 ); 
      RES2_POCELLOUT = copy( aLAYER_229 ); 
      RES2_POCELL = RES2_POCELLIN and RES2_POCELLOUT; 
      RES2_POMARKER = POI and RRULERECOMMENDED; 
      gLAYER_904 = RES2_POCELL or RES2_POMARKER; 
      gLAYER_903 = gLAYER_904 not SRAM_EXCLUDE; 
      gLAYER_902 = gLAYER_903 outside BLOCK; 
      RES2_PO = gLAYER_902 not EXCLUDERRULERECOMMENDED; 
      RES2_ODCELLIN = copy( aLAYER_230 ); 
      RES2_ODCELLOUT = copy( aLAYER_231 ); 
      RES2_ODCELL = RES2_ODCELLIN and RES2_ODCELLOUT; 
      RES2_ODMARKER = ODI and RRULERECOMMENDED; 
      gLAYER_907 = RES2_ODCELL or RES2_ODMARKER; 
      gLAYER_906 = gLAYER_907 not SRAM_EXCLUDE; 
      gLAYER_905 = gLAYER_906 outside BLOCK; 
      RES2_OD = gLAYER_905 not EXCLUDERRULERECOMMENDED; 
      RES2_ODRES = ODRES and RES2_OD; 
      RES2_PORES = PORESG and RES2_PO; 
      rRR_RE_P_RES_2_OD @= { @ "RR:RE:P:RES.2:OD : Recommended width >= 0.4um and length >= 0.4um for unsilicided OD resistor";
          internal1( RES2_ODRES, < 0.4, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          RES_L = and_edge( RES2_ODRES, RPO, false ); 
          X = length_edge( RES_L, < 0.4, CONNECT ); 
          CHECK_RES = RES2_ODRES touching X; 
          RES_E = CHECK_RES coincident_inside_edge RPO; 
          A = edge_size( RES_E, inside = GRID ); 
          B = size_inside_wrapper( A, RES2_ODRES, distance = ( 0.4 / 2 - GRID * 2 ), increment = OD_S_1 * 0.7 ); 
          C = CHECK_RES not B; 
          not_interacting( CHECK_RES, C ); 
          D = internal1( C, < ( GRID * 2 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
          Y = interacting( CHECK_RES, D ); 
          Y not_inside DIODMY; 
      } /* end of rule : RR:RE:P:RES.2:OD */
      rRR_RE_P_RES_2_PO @= { @ "RR:RE:P:RES.2:PO : Recommended width >= 0.4um and length >= 0.4um for unsilicided PO resistor";
          internal1( RES2_PORES, < 0.4, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, relational = { POINT_TOUCH } ); 
          RES_L = and_edge( RES2_PORES, RPO, false ); 
          X = length_edge( RES_L, < 0.4, CONNECT ); 
          CHECK_RES = RES2_PORES touching X; 
          RES_E = CHECK_RES coincident_inside_edge RPO; 
          A = edge_size( RES_E, inside = GRID ); 
          B = size_inside_wrapper( A, RES2_PORES, distance = ( 0.4 / 2 - GRID * 2 ), increment = PO_S_1 * 0.7 ); 
          C = CHECK_RES not B; 
          not_interacting( CHECK_RES, C ); 
          D = internal1( C, < ( GRID * 2 ), extension = RADIAL, intersecting = {  }, intersection_angle = < 90 ); 
          interacting( CHECK_RES, D ); 
      } /* end of rule : RR:RE:P:RES.2:PO */
   #endif /* end of #ifdef _RES2_  */ 
   #ifdef _RES8_ 
      RES8_ODCELLIN = copy( aLAYER_232 ); 
      RES8_ODCELLOUT = copy( aLAYER_233 ); 
      RES8_ODCELL = RES8_ODCELLIN and RES8_ODCELLOUT; 
      RES8_ODMARKER = ODI and RRULERECOMMENDED; 
      gLAYER_910 = RES8_ODCELL or RES8_ODMARKER; 
      gLAYER_909 = gLAYER_910 not SRAM_EXCLUDE; 
      gLAYER_908 = gLAYER_909 outside BLOCK; 
      RES8_OD = gLAYER_908 not EXCLUDERRULERECOMMENDED; 
      RES8_GATE = GATE and RES8_OD; 
      
      // RES.8.R is checked by RR:RE:P:RES.8
      rRR_RE_P_RES_8 @= { @ "RR:RE:P:RES.8 : RH space to Gate >= 0.185um in source or drain direction for unsilicided OD resistor in the s/d of MOS.";
          RH_RES = RH not_outside AYRE; 
          external2( RH_RES, RES8_GATE, < 0.185, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
          RH_RES and RES8_GATE; 
          RES8_GATE inside RH;            /* RH can not fully cover GATE */ 
      } /* end of rule : RR:RE:P:RES.8 */
   #endif /* end of #ifdef _RES8_  */ 
   #ifdef _RES9_ 
      RES9_RHCELLIN = copy( aLAYER_234 ); 
      RES9_RHCELLOUT = copy( aLAYER_235 ); 
      RES9_RHCELL = RES9_RHCELLIN and RES9_RHCELLOUT; 
      RES9_RHMARKER = RH and RRULERECOMMENDED; 
      gLAYER_913 = RES9_RHCELL or RES9_RHMARKER; 
      gLAYER_912 = gLAYER_913 not SRAM_EXCLUDE; 
      gLAYER_911 = gLAYER_912 outside BLOCK; 
      RES9_RH = gLAYER_911 not EXCLUDERRULERECOMMENDED; 
      
      // RES.9.R is checked by RR:RE:P:RES.9
      rRR_RE_P_RES_9 @= { @ "RR:RE:P:RES.9 : RH enclosure of unsilicided OD/PO resistor >= 0.13um.";
          enclose( AYRE, RES9_RH, < 0.13, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : RR:RE:P:RES.9 */
   #endif /* end of #ifdef _RES9_  */ 
   #ifdef _COEN1_ 
      COEN1_COCELLIN = copy( aLAYER_236 ); 
      COEN1_COCELLOUT = copy( aLAYER_237 ); 
      COEN1_COCELL = COEN1_COCELLIN and COEN1_COCELLOUT; 
      COEN1_COMARKER = COI and RRULERECOMMENDED; 
      gLAYER_916 = COEN1_COCELL or COEN1_COMARKER; 
      gLAYER_915 = gLAYER_916 not SRAM_EXCLUDE; 
      gLAYER_914 = gLAYER_915 outside BLOCK; 
      COEN1_CO = gLAYER_914 not EXCLUDERRULERECOMMENDED; 
      
      // CO.EN.1.R is checked by RR:RE:SP:CO.EN.1
      rRR_RE_SP_CO_EN_1 @= { @ "RR:RE:SP:CO.EN.1 : Recommended enclosure by OD >= " + CO_EN_1_R; 
          enclose( COEN1_CO, OD, < CO_EN_1_R, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, width = 0.004 ); 
      } /* end of rule : RR:RE:SP:CO.EN.1 */
   #endif /* end of #ifdef _COEN1_  */ 
   #ifdef _COEN3_ 
      COEN3_COCELLIN = copy( aLAYER_238 ); 
      COEN3_COCELLOUT = copy( aLAYER_239 ); 
      COEN3_COCELL = COEN3_COCELLIN and COEN3_COCELLOUT; 
      COEN3_COMARKER = COI and RRULERECOMMENDED; 
      gLAYER_919 = COEN3_COCELL or COEN3_COMARKER; 
      gLAYER_918 = gLAYER_919 not SRAM_EXCLUDE; 
      gLAYER_917 = gLAYER_918 outside BLOCK; 
      COEN3_CO = gLAYER_917 not EXCLUDERRULERECOMMENDED; 
      
      // CO.EN.3.R is checked by RR:RE:SP:CO.EN.3
      rRR_RE_SP_CO_EN_3 @= { @ "RR:RE:SP:CO.EN.3 : Recommended enclosure by PO [at least two opposite sides] >= 0.06";
          X = not_enclosed_by( COEN3_CO, POLY, distances = { { { CO_EN_2, RADIAL }, { 0.06, NONE }, { CO_EN_2, RADIAL }, { 0.06, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          Y = enclose_edge( X, POLY, < 0.06, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_CONTAINED, output_layer = LAYER1, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC ); 
          Z = X touching_edge Y; 
          internal1_error( Z, < CO_W_1, extension = RADIAL, intersecting = {  }, intersection_angle = == 90, orientation = { } );    /* adjacent narrow sides */ 
      } /* end of rule : RR:RE:SP:CO.EN.3 */
   #endif /* end of #ifdef _COEN3_  */ 
   #ifdef _COS3_ 
      COS3_COCELLIN = copy( aLAYER_240 ); 
      COS3_COCELLOUT = copy( aLAYER_241 ); 
      COS3_COCELL = COS3_COCELLIN and COS3_COCELLOUT; 
      COS3_COMARKER = COI and RRULERECOMMENDED; 
      gLAYER_922 = COS3_COCELL or COS3_COMARKER; 
      gLAYER_921 = gLAYER_922 not SRAM_EXCLUDE; 
      gLAYER_920 = gLAYER_921 outside BLOCK; 
      COS3_CO = gLAYER_920 not EXCLUDERRULERECOMMENDED; 
      
      // CO.S.3.R is checked by RR:RE:FSD:CO.S.3
      rRR_RE_FSD_CO_S_3 @= { @ "RR:RE:FSD:CO.S.3 : Recommended CO space to GATE >= 0.065";
          external2( COS3_CO, GATE, < 0.065, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, relational = { POINT_TOUCH }, width = 0.002 ); 
      } /* end of rule : RR:RE:FSD:CO.S.3 */
   #endif /* end of #ifdef _COS3_  */ 
   #ifdef _ODS1_ 
      ODS1_ODCELLIN = copy( aLAYER_242 ); 
      ODS1_ODCELLOUT = copy( aLAYER_243 ); 
      ODS1_ODCELL = ODS1_ODCELLIN and ODS1_ODCELLOUT; 
      ODS1_ODMARKER = ODI and RRULERECOMMENDED; 
      gLAYER_925 = ODS1_ODCELL or ODS1_ODMARKER; 
      gLAYER_924 = gLAYER_925 not SRAM_EXCLUDE; 
      gLAYER_923 = gLAYER_924 outside BLOCK; 
      ODS1_OD = gLAYER_923 not EXCLUDERRULERECOMMENDED; 
      
      // OD.S.1.R is checked by RR:RE:D:OD.S.1
      rRR_RE_D_OD_S_1 @= { @ "RR:RE:D:OD.S.1 : Recommended OD space >= " + OD_S_1_R + " um"; 
          external1( ODS1_OD, < OD_S_1_R, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : RR:RE:D:OD.S.1 */
   #endif /* end of #ifdef _ODS1_  */ 
   #ifdef _POS1_ 
      POS1_POCELLIN = copy( aLAYER_244 ); 
      POS1_POCELLOUT = copy( aLAYER_245 ); 
      POS1_POCELL = POS1_POCELLIN and POS1_POCELLOUT; 
      POS1_POMARKER = POI and RRULERECOMMENDED; 
      gLAYER_928 = POS1_POCELL or POS1_POMARKER; 
      gLAYER_927 = gLAYER_928 not SRAM_EXCLUDE; 
      gLAYER_926 = gLAYER_927 outside BLOCK; 
      POS1_PO = gLAYER_926 not EXCLUDERRULERECOMMENDED; 
      POS1ERR = external1_edge( POS1_PO, < 0.15, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT ); 
      POS1ERRLONG = POS1ERR not_touching_edge GATE;    /* exclude gate space checking */ 
      
      // PO.S.1.R is checked by RR:RE:D:PO.S.1
      rRR_RE_D_PO_S_1 @= { @ "RR:RE:D:PO.S.1 : Recommended PO interconnect space >= 0.15um, to reduce short possibility";
          external1( POS1ERRLONG, < 0.15, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT ); 
      } /* end of rule : RR:RE:D:PO.S.1 */
   #endif /* end of #ifdef _POS1_  */ 
   #ifdef _M1S1_ 
      M1S1_M1CELLIN = copy( aLAYER_246 ); 
      M1S1_M1CELLOUT = copy( aLAYER_247 ); 
      M1S1_M1CELL = M1S1_M1CELLIN and M1S1_M1CELLOUT; 
      M1S1_M1MARKER = M1I and RRULERECOMMENDED; 
      gLAYER_931 = M1S1_M1CELL or M1S1_M1MARKER; 
      gLAYER_930 = gLAYER_931 not SRAM_EXCLUDE; 
      gLAYER_929 = gLAYER_930 outside BLOCK; 
      M1S1_M1 = gLAYER_929 not EXCLUDERRULERECOMMENDED; 
      
      // M1.S.1.R is checked by RR:RE:D:M1.S.1
      rRR_RE_D_M1_S_1 @= { @ "RR:RE:D:M1.S.1 : Recommended M1 space >= 0.12um";
          external1( M1S1_M1, < 0.12, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : RR:RE:D:M1.S.1 */
   #endif /* end of #ifdef _M1S1_  */ 
   
   // M1.EN.0.R is checked by related rules (M1.EN.1.R and M1.EN.2.R)
   // M1.EN.1.R and M1.EN.2.R are checked by RR:RE:FP:M1.EN.1__M1.EN.2
   #ifdef _M1EN1_M1EN2_ 
      M1EN1_M1EN2_COCELLIN = copy( aLAYER_248 ); 
      M1EN1_M1EN2_COCELLOUT = copy( aLAYER_249 ); 
      M1EN1_M1EN2_COCELL = M1EN1_M1EN2_COCELLIN and M1EN1_M1EN2_COCELLOUT; 
      M1EN1_M1EN2_COMARKER = COI and RRULERECOMMENDED; 
      gLAYER_934 = M1EN1_M1EN2_COCELL or M1EN1_M1EN2_COMARKER; 
      gLAYER_933 = gLAYER_934 not_inside SRAM_EXCLUDE; 
      gLAYER_932 = gLAYER_933 outside BLOCK; 
      M1EN1_M1EN2_CO = gLAYER_932 not EXCLUDERRULERECOMMENDED; 
      rRR_RE_FP_M1_EN_1__M1_EN_2 @= { @ "RR:RE:FP:M1.EN.1__M1.EN.2 : Enclosure of CO at least two opposite sides 0.06 um/Enclosure of CO 0.04 um";
          A = not_enclosed_by( M1EN1_M1EN2_CO, M1S, distances = { { { 0, RADIAL }, { 0.06, NONE }, { 0, RADIAL }, { 0.06, NONE } } }, intersecting_failures = { ACUTE } ); 
          sLAYER_1222 = enclose( A, M1S, < 0.04, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
          sLAYER_1222 not_inside SRAM_EXCLUDE; 
      } /* end of rule : RR:RE:FP:M1.EN.1__M1.EN.2 */
   #endif /* end of #ifdef _M1EN1_M1EN2_  */ 
   #ifdef _M1S7_ 
      M1S7_M1CELLIN = copy( aLAYER_250 ); 
      M1S7_M1CELLOUT = copy( aLAYER_251 ); 
      M1S7_M1CELL = M1S7_M1CELLIN and M1S7_M1CELLOUT; 
      M1S7_M1MARKER = M1I and RRULERECOMMENDED; 
      gLAYER_936 = M1S7_M1CELL or M1S7_M1MARKER; 
      gLAYER_935 = gLAYER_936 not BLOCK; 
      M1S7_M1 = gLAYER_935 not EXCLUDERRULERECOMMENDED; 
      M1S7_DM1CELLIN = copy( aLAYER_252 ); 
      M1S7_DM1CELLOUT = copy( aLAYER_253 ); 
      M1S7_DM1CELL = M1S7_DM1CELLIN and M1S7_DM1CELLOUT; 
      M1S7_DM1MARKER = DUM1 and RRULERECOMMENDED; 
      gLAYER_938 = M1S7_DM1CELL or M1S7_DM1MARKER; 
      gLAYER_937 = gLAYER_938 not BLOCK; 
      M1S7_DM1 = gLAYER_937 not EXCLUDERRULERECOMMENDED; 
      M1S7_M1X = M1S7_M1 or M1S7_DM1; 
      M1S7_NOT_M1X = gCHIP not M1X; 
      M1S7_BIGAREA = area( M1S7_NOT_M1X, > BIG_AREA ); 
      gLAYER_939 = external2( M1S7_BIGAREA, M1S7_NOT_M1X, < 0.35, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, membership = DIFFERENT_POLYGON, relational = { POINT_TOUCH }, width = 0.002 ); 
      M1S7_ERROR = gLAYER_939 not_outside M1S7_M1X; 
      
      // M1.S.7.R is checked by RR:RE:S:M1.S.7
      rRR_RE_S_M1_S_7 @= { @ "RR:RE:S:M1.S.7 : Space between two non-M1 regions 0.35 [ one area > " + BIG_AREA + " ]"; 
          copy( M1S7_ERROR ); 
      } /* end of rule : RR:RE:S:M1.S.7 */
   #endif /* end of #ifdef _M1S7_  */ 
   #ifdef _VIA1EN1_VIA1EN2_ 
      VIA1EN1_VIA1EN2_VIA1CELLIN = copy( aLAYER_254 ); 
      VIA1EN1_VIA1EN2_VIA1CELLOUT = copy( aLAYER_255 ); 
      VIA1EN1_VIA1EN2_VIA1CELL = VIA1EN1_VIA1EN2_VIA1CELLIN and VIA1EN1_VIA1EN2_VIA1CELLOUT; 
      VIA1EN1_VIA1EN2_VIA1MARKER = VIA1I and RRULERECOMMENDED; 
      gLAYER_942 = VIA1EN1_VIA1EN2_VIA1CELL or VIA1EN1_VIA1EN2_VIA1MARKER; 
      gLAYER_941 = gLAYER_942 not SRAM_EXCLUDE; 
      gLAYER_940 = gLAYER_941 outside BLOCK; 
      VIA1EN1_VIA1EN2_VIA1 = gLAYER_940 not EXCLUDERRULERECOMMENDED; 
      
      // VIA1.EN.0.R is checked by related rules (VIA1.EN.1.R and VIA1.EN.2.R)
      // VIA1.EN.1.R and VIA1.EN.2.R are checked by RR:RE:FP:VIA1.EN.1__VIA1.EN.2
      rRR_RE_FP_VIA1_EN_1__VIA1_EN_2 @= { @ "RR:RE:FP:VIA1.EN.1__VIA1.EN.2 : Enclosure of VIA1 at least two opposite sides 0.07 um/Enclosure of VIA1 0.04 um";
          A = not_enclosed_by( VIA1EN1_VIA1EN2_VIA1, M1I, distances = { { { 0, RADIAL }, { 0.07, NONE }, { 0, RADIAL }, { 0.07, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          enclose( A, M1I, < 0.04, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : RR:RE:FP:VIA1.EN.1__VIA1.EN.2 */
   #endif /* end of #ifdef _VIA1EN1_VIA1EN2_  */ 
   #ifdef _M2EN1_M2EN2_ 
      M2EN1_M2EN2_VIA1CELLIN = copy( aLAYER_256 ); 
      M2EN1_M2EN2_VIA1CELLOUT = copy( aLAYER_257 ); 
      M2EN1_M2EN2_VIA1CELL = M2EN1_M2EN2_VIA1CELLIN and M2EN1_M2EN2_VIA1CELLOUT; 
      M2EN1_M2EN2_VIA1MARKER = VIA1I and RRULERECOMMENDED; 
      gLAYER_945 = M2EN1_M2EN2_VIA1CELL or M2EN1_M2EN2_VIA1MARKER; 
      gLAYER_944 = gLAYER_945 not SRAM_EXCLUDE; 
      gLAYER_943 = gLAYER_944 outside BLOCK; 
      M2EN1_M2EN2_VIA1 = gLAYER_943 not EXCLUDERRULERECOMMENDED; 
      
      // M2.EN.0.R is checked by related rules (M2.EN.1.R and M2.EN.2.R)
      // M2.EN.1.R and M2.EN.2.R are checked by RR:RE:FP:M2.EN.1__M2.EN.2
      rRR_RE_FP_M2_EN_1__M2_EN_2 @= { @ "RR:RE:FP:M2.EN.1__M2.EN.2 : Enclosure of VIA1 at least two opposite sides 0.07 um/Enclosure of VIA1 0.04 um";
          A = not_enclosed_by( M2EN1_M2EN2_VIA1, M2, distances = { { { 0, RADIAL }, { 0.07, NONE }, { 0, RADIAL }, { 0.07, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          enclose( A, M2, < 0.04, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : RR:RE:FP:M2.EN.1__M2.EN.2 */
   #endif /* end of #ifdef _M2EN1_M2EN2_  */ 
   #ifdef _M2S1_ 
      M2S1_M2CELLIN = copy( aLAYER_258 ); 
      M2S1_M2CELLOUT = copy( aLAYER_259 ); 
      M2S1_M2CELL = M2S1_M2CELLIN and M2S1_M2CELLOUT; 
      M2S1_M2MARKER = M2I and RRULERECOMMENDED; 
      gLAYER_947 = M2S1_M2CELL or M2S1_M2MARKER; 
      gLAYER_946 = gLAYER_947 not BLOCK; 
      M2S1_M2 = gLAYER_946 not EXCLUDERRULERECOMMENDED; 
      
      // M2.S.1.R is checked by RR:RE:D:M2.S.1
      rRR_RE_D_M2_S_1 @= { @ "RR:RE:D:M2.S.1 : Recommended M2 space >= 0.13um";
          external1( M2S1_M2, < 0.13, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : RR:RE:D:M2.S.1 */
   #endif /* end of #ifdef _M2S1_  */ 
   #ifdef _M2S7_ 
      M2S7_M2CELLIN = copy( aLAYER_260 ); 
      M2S7_M2CELLOUT = copy( aLAYER_261 ); 
      M2S7_M2CELL = M2S7_M2CELLIN and M2S7_M2CELLOUT; 
      M2S7_M2MARKER = M2I and RRULERECOMMENDED; 
      gLAYER_949 = M2S7_M2CELL or M2S7_M2MARKER; 
      gLAYER_948 = gLAYER_949 not BLOCK; 
      M2S7_M2 = gLAYER_948 not EXCLUDERRULERECOMMENDED; 
      M2S7_DM2CELLIN = copy( aLAYER_262 ); 
      M2S7_DM2CELLOUT = copy( aLAYER_263 ); 
      M2S7_DM2CELL = M2S7_DM2CELLIN and M2S7_DM2CELLOUT; 
      M2S7_DM2MARKER = DUM2 and RRULERECOMMENDED; 
      gLAYER_951 = M2S7_DM2CELL or M2S7_DM2MARKER; 
      gLAYER_950 = gLAYER_951 not BLOCK; 
      M2S7_DM2 = gLAYER_950 not EXCLUDERRULERECOMMENDED; 
      M2S7_M2X = M2S7_M2 or M2S7_DM2; 
      M2S7_NOT_M2X = gCHIP not M2X; 
      M2S7_BIGAREA = area( M2S7_NOT_M2X, > BIG_AREA ); 
      gLAYER_952 = external2( M2S7_BIGAREA, M2S7_NOT_M2X, < 0.35, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, membership = DIFFERENT_POLYGON, relational = { POINT_TOUCH }, width = 0.002 ); 
      M2S7_ERROR = gLAYER_952 not_outside M2S7_M2X; 
      
      // M2.S.7.R is checked by RR:RE:S:M2.S.7 
      rRR_RE_S_M2_S_7 @= { @ "RR:RE:S:M2.S.7 : Space between two non-M2 regions 0.35 [ one area > " + BIG_AREA + " ]"; 
          copy( M2S7_ERROR ); 
      } /* end of rule : RR:RE:S:M2.S.7 */
   #endif /* end of #ifdef _M2S7_  */ 
   #ifdef _VIA2EN1_VIA2EN2_ 
      VIA2EN1_VIA2EN2_VIA2CELLIN = copy( aLAYER_264 ); 
      VIA2EN1_VIA2EN2_VIA2CELLOUT = copy( aLAYER_265 ); 
      VIA2EN1_VIA2EN2_VIA2CELL = VIA2EN1_VIA2EN2_VIA2CELLIN and VIA2EN1_VIA2EN2_VIA2CELLOUT; 
      VIA2EN1_VIA2EN2_VIA2MARKER = VIA2I and RRULERECOMMENDED; 
      gLAYER_955 = VIA2EN1_VIA2EN2_VIA2CELL or VIA2EN1_VIA2EN2_VIA2MARKER; 
      gLAYER_954 = gLAYER_955 not SRAM_EXCLUDE; 
      gLAYER_953 = gLAYER_954 outside BLOCK; 
      VIA2EN1_VIA2EN2_VIA2 = gLAYER_953 not EXCLUDERRULERECOMMENDED; 
      
      // VIA2.EN.0.R is checked by related rules (VIA2.EN.1.R and VIA2.EN.2.R)
      // VIA2.EN.1.R and VIA2.EN.2.R are checked by RR:RE:FP:VIA2.EN.1__VIA2.EN.2
      rRR_RE_FP_VIA2_EN_1__VIA2_EN_2 @= { @ "RR:RE:FP:VIA2.EN.1__VIA2.EN.2 : Enclosure of VIA2 at least two opposite sides 0.07 um/Enclosure of VIA2 0.04 um";
          A = not_enclosed_by( VIA2EN1_VIA2EN2_VIA2, M2I, distances = { { { 0, RADIAL }, { 0.07, NONE }, { 0, RADIAL }, { 0.07, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          enclose( A, M2I, < 0.04, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : RR:RE:FP:VIA2.EN.1__VIA2.EN.2 */
   #endif /* end of #ifdef _VIA2EN1_VIA2EN2_  */ 
   #ifdef _M3EN1_M3EN2_ 
      M3EN1_M3EN2_VIA2CELLIN = copy( aLAYER_266 ); 
      M3EN1_M3EN2_VIA2CELLOUT = copy( aLAYER_267 ); 
      M3EN1_M3EN2_VIA2CELL = M3EN1_M3EN2_VIA2CELLIN and M3EN1_M3EN2_VIA2CELLOUT; 
      M3EN1_M3EN2_VIA2MARKER = VIA2I and RRULERECOMMENDED; 
      gLAYER_958 = M3EN1_M3EN2_VIA2CELL or M3EN1_M3EN2_VIA2MARKER; 
      gLAYER_957 = gLAYER_958 not SRAM_EXCLUDE; 
      gLAYER_956 = gLAYER_957 outside BLOCK; 
      M3EN1_M3EN2_VIA2 = gLAYER_956 not EXCLUDERRULERECOMMENDED; 
      
      // M3.EN.0.R is checked by related rules (M3.EN.1.R and M3.EN.2.R)
      // M3.EN.1.R and M3.EN.2.R are checked by RR:RE:FP:M3.EN.1__M3.EN.2
      rRR_RE_FP_M3_EN_1__M3_EN_2 @= { @ "RR:RE:FP:M3.EN.1__M3.EN.2 : Enclosure of VIA2 at least two opposite sides 0.07 um/Enclosure of VIA2 0.04 um";
          A = not_enclosed_by( M3EN1_M3EN2_VIA2, M3, distances = { { { 0, RADIAL }, { 0.07, NONE }, { 0, RADIAL }, { 0.07, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          enclose( A, M3, < 0.04, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : RR:RE:FP:M3.EN.1__M3.EN.2 */
   #endif /* end of #ifdef _M3EN1_M3EN2_  */ 
   #ifdef _M3S1_ 
      M3S1_M3CELLIN = copy( aLAYER_268 ); 
      M3S1_M3CELLOUT = copy( aLAYER_269 ); 
      M3S1_M3CELL = M3S1_M3CELLIN and M3S1_M3CELLOUT; 
      M3S1_M3MARKER = M3I and RRULERECOMMENDED; 
      gLAYER_960 = M3S1_M3CELL or M3S1_M3MARKER; 
      gLAYER_959 = gLAYER_960 not BLOCK; 
      M3S1_M3 = gLAYER_959 not EXCLUDERRULERECOMMENDED; 
      
      // M3.S.1.R is checked by RR:RE:D:M3.S.1
      rRR_RE_D_M3_S_1 @= { @ "RR:RE:D:M3.S.1 : Recommended M3 space >= 0.13um";
          external1( M3S1_M3, < 0.13, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : RR:RE:D:M3.S.1 */
   #endif /* end of #ifdef _M3S1_  */ 
   #ifdef _M3S7_ 
      M3S7_M3CELLIN = copy( aLAYER_270 ); 
      M3S7_M3CELLOUT = copy( aLAYER_271 ); 
      M3S7_M3CELL = M3S7_M3CELLIN and M3S7_M3CELLOUT; 
      M3S7_M3MARKER = M3I and RRULERECOMMENDED; 
      gLAYER_962 = M3S7_M3CELL or M3S7_M3MARKER; 
      gLAYER_961 = gLAYER_962 not BLOCK; 
      M3S7_M3 = gLAYER_961 not EXCLUDERRULERECOMMENDED; 
      M3S7_DM3CELLIN = copy( aLAYER_272 ); 
      M3S7_DM3CELLOUT = copy( aLAYER_273 ); 
      M3S7_DM3CELL = M3S7_DM3CELLIN and M3S7_DM3CELLOUT; 
      M3S7_DM3MARKER = DUM3 and RRULERECOMMENDED; 
      gLAYER_964 = M3S7_DM3CELL or M3S7_DM3MARKER; 
      gLAYER_963 = gLAYER_964 not BLOCK; 
      M3S7_DM3 = gLAYER_963 not EXCLUDERRULERECOMMENDED; 
      M3S7_M3X = M3S7_M3 or M3S7_DM3; 
      M3S7_NOT_M3X = gCHIP not M3X; 
      M3S7_BIGAREA = area( M3S7_NOT_M3X, > BIG_AREA ); 
      gLAYER_965 = external2( M3S7_BIGAREA, M3S7_NOT_M3X, < 0.35, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, membership = DIFFERENT_POLYGON, relational = { POINT_TOUCH }, width = 0.002 ); 
      M3S7_ERROR = gLAYER_965 not_outside M3S7_M3X; 
      
      // M3.S.7.R is checked by RR:RE:S:M3.S.7 
      rRR_RE_S_M3_S_7 @= { @ "RR:RE:S:M3.S.7 : Space between two non-M3 regions 0.35 [ one area > " + BIG_AREA + " ]"; 
          copy( M3S7_ERROR ); 
      } /* end of rule : RR:RE:S:M3.S.7 */
   #endif /* end of #ifdef _M3S7_  */ 
   #ifdef _VIA3EN1_VIA3EN2_ 
      VIA3EN1_VIA3EN2_VIA3CELLIN = copy( aLAYER_274 ); 
      VIA3EN1_VIA3EN2_VIA3CELLOUT = copy( aLAYER_275 ); 
      VIA3EN1_VIA3EN2_VIA3CELL = VIA3EN1_VIA3EN2_VIA3CELLIN and VIA3EN1_VIA3EN2_VIA3CELLOUT; 
      VIA3EN1_VIA3EN2_VIA3MARKER = VIA3I and RRULERECOMMENDED; 
      gLAYER_967 = VIA3EN1_VIA3EN2_VIA3CELL or VIA3EN1_VIA3EN2_VIA3MARKER; 
      gLAYER_966 = gLAYER_967 not BLOCK; 
      VIA3EN1_VIA3EN2_VIA3 = gLAYER_966 not EXCLUDERRULERECOMMENDED; 
      
      // VIA3.EN.0.R is checked by related rules (VIA3.EN.1.R and VIA3.EN.2.R)
      // VIA3.EN.1.R and VIA3.EN.2.R are checked by RR:RE:FP:VIA3.EN.1__VIA3.EN.2
      rRR_RE_FP_VIA3_EN_1__VIA3_EN_2 @= { @ "RR:RE:FP:VIA3.EN.1__VIA3.EN.2 : Enclosure of VIA3 at least two opposite sides 0.07 um/Enclosure of VIA3 0.04 um";
          A = not_enclosed_by( VIA3EN1_VIA3EN2_VIA3, M3I, distances = { { { 0, RADIAL }, { 0.07, NONE }, { 0, RADIAL }, { 0.07, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          enclose( A, M3I, < 0.04, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : RR:RE:FP:VIA3.EN.1__VIA3.EN.2 */
   #endif /* end of #ifdef _VIA3EN1_VIA3EN2_  */ 
   #ifdef _M4EN1_M4EN2_ 
      M4EN1_M4EN2_VIA3CELLIN = copy( aLAYER_276 ); 
      M4EN1_M4EN2_VIA3CELLOUT = copy( aLAYER_277 ); 
      M4EN1_M4EN2_VIA3CELL = M4EN1_M4EN2_VIA3CELLIN and M4EN1_M4EN2_VIA3CELLOUT; 
      M4EN1_M4EN2_VIA3MARKER = VIA3I and RRULERECOMMENDED; 
      gLAYER_969 = M4EN1_M4EN2_VIA3CELL or M4EN1_M4EN2_VIA3MARKER; 
      gLAYER_968 = gLAYER_969 not BLOCK; 
      M4EN1_M4EN2_VIA3 = gLAYER_968 not EXCLUDERRULERECOMMENDED; 
      
      // M4.EN.0.R is checked by related rules (M4.EN.1.R and M4.EN.2.R)
      // M4.EN.1.R and M4.EN.2.R are checked by RR:RE:FP:M4.EN.1__M4.EN.2
      rRR_RE_FP_M4_EN_1__M4_EN_2 @= { @ "RR:RE:FP:M4.EN.1__M4.EN.2 : Enclosure of VIA3 at least two opposite sides 0.07 um/Enclosure of VIA3 0.04 um";
          A = not_enclosed_by( M4EN1_M4EN2_VIA3, M4, distances = { { { 0, RADIAL }, { 0.07, NONE }, { 0, RADIAL }, { 0.07, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          enclose( A, M4, < 0.04, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : RR:RE:FP:M4.EN.1__M4.EN.2 */
   #endif /* end of #ifdef _M4EN1_M4EN2_  */ 
   #ifdef _M4S1_ 
      M4S1_M4CELLIN = copy( aLAYER_278 ); 
      M4S1_M4CELLOUT = copy( aLAYER_279 ); 
      M4S1_M4CELL = M4S1_M4CELLIN and M4S1_M4CELLOUT; 
      M4S1_M4MARKER = M4I and RRULERECOMMENDED; 
      gLAYER_971 = M4S1_M4CELL or M4S1_M4MARKER; 
      gLAYER_970 = gLAYER_971 not BLOCK; 
      M4S1_M4 = gLAYER_970 not EXCLUDERRULERECOMMENDED; 
      
      // M4.S.1.R is checked by RR:RE:D:M4.S.1
      rRR_RE_D_M4_S_1 @= { @ "RR:RE:D:M4.S.1 : Recommended M4 space >= 0.13um";
          external1( M4S1_M4, < 0.13, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : RR:RE:D:M4.S.1 */
   #endif /* end of #ifdef _M4S1_  */ 
   #ifdef _M4S7_ 
      M4S7_M4CELLIN = copy( aLAYER_280 ); 
      M4S7_M4CELLOUT = copy( aLAYER_281 ); 
      M4S7_M4CELL = M4S7_M4CELLIN and M4S7_M4CELLOUT; 
      M4S7_M4MARKER = M4I and RRULERECOMMENDED; 
      gLAYER_973 = M4S7_M4CELL or M4S7_M4MARKER; 
      gLAYER_972 = gLAYER_973 not BLOCK; 
      M4S7_M4 = gLAYER_972 not EXCLUDERRULERECOMMENDED; 
      M4S7_DM4CELLIN = copy( aLAYER_282 ); 
      M4S7_DM4CELLOUT = copy( aLAYER_283 ); 
      M4S7_DM4CELL = M4S7_DM4CELLIN and M4S7_DM4CELLOUT; 
      M4S7_DM4MARKER = DUM4 and RRULERECOMMENDED; 
      gLAYER_975 = M4S7_DM4CELL or M4S7_DM4MARKER; 
      gLAYER_974 = gLAYER_975 not BLOCK; 
      M4S7_DM4 = gLAYER_974 not EXCLUDERRULERECOMMENDED; 
      M4S7_M4X = M4S7_M4 or M4S7_DM4; 
      M4S7_NOT_M4X = gCHIP not M4X; 
      M4S7_BIGAREA = area( M4S7_NOT_M4X, > BIG_AREA ); 
      gLAYER_976 = external2( M4S7_BIGAREA, M4S7_NOT_M4X, < 0.35, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, membership = DIFFERENT_POLYGON, relational = { POINT_TOUCH }, width = 0.002 ); 
      M4S7_ERROR = gLAYER_976 not_outside M4S7_M4X; 
      
      // M4.S.7.R is checked by RR:RE:S:M4.S.7 
      rRR_RE_S_M4_S_7 @= { @ "RR:RE:S:M4.S.7 : Space between two non-M4 regions 0.35 [ one area > " + BIG_AREA + " ]"; 
          copy( M4S7_ERROR ); 
      } /* end of rule : RR:RE:S:M4.S.7 */
   #endif /* end of #ifdef _M4S7_  */ 
   #ifdef _VIA4EN1_VIA4EN2_ 
      VIA4EN1_VIA4EN2_VIA4CELLIN = copy( aLAYER_284 ); 
      VIA4EN1_VIA4EN2_VIA4CELLOUT = copy( aLAYER_285 ); 
      VIA4EN1_VIA4EN2_VIA4CELL = VIA4EN1_VIA4EN2_VIA4CELLIN and VIA4EN1_VIA4EN2_VIA4CELLOUT; 
      VIA4EN1_VIA4EN2_VIA4MARKER = VIA4I and RRULERECOMMENDED; 
      gLAYER_978 = VIA4EN1_VIA4EN2_VIA4CELL or VIA4EN1_VIA4EN2_VIA4MARKER; 
      gLAYER_977 = gLAYER_978 not BLOCK; 
      VIA4EN1_VIA4EN2_VIA4 = gLAYER_977 not EXCLUDERRULERECOMMENDED; 
      
      // VIA4.EN.0.R is checked by related rules (VIA4.EN.1.R and VIA4.EN.2.R)
      // VIA4.EN.1.R and VIA4.EN.2.R are checked by RR:RE:FP:VIA4.EN.1__VIA4.EN.2
      rRR_RE_FP_VIA4_EN_1__VIA4_EN_2 @= { @ "RR:RE:FP:VIA4.EN.1__VIA4.EN.2 : Enclosure of VIA4 at least two opposite sides 0.07 um/Enclosure of VIA4 0.04 um";
          A = not_enclosed_by( VIA4EN1_VIA4EN2_VIA4, M4I, distances = { { { 0, RADIAL }, { 0.07, NONE }, { 0, RADIAL }, { 0.07, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          enclose( A, M4I, < 0.04, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : RR:RE:FP:VIA4.EN.1__VIA4.EN.2 */
   #endif /* end of #ifdef _VIA4EN1_VIA4EN2_  */ 
   #ifdef _M5EN1_M5EN2_ 
      M5EN1_M5EN2_VIA4CELLIN = copy( aLAYER_286 ); 
      M5EN1_M5EN2_VIA4CELLOUT = copy( aLAYER_287 ); 
      M5EN1_M5EN2_VIA4CELL = M5EN1_M5EN2_VIA4CELLIN and M5EN1_M5EN2_VIA4CELLOUT; 
      M5EN1_M5EN2_VIA4MARKER = VIA4I and RRULERECOMMENDED; 
      gLAYER_980 = M5EN1_M5EN2_VIA4CELL or M5EN1_M5EN2_VIA4MARKER; 
      gLAYER_979 = gLAYER_980 not BLOCK; 
      M5EN1_M5EN2_VIA4 = gLAYER_979 not EXCLUDERRULERECOMMENDED; 
      
      // M5.EN.0.R is checked by related rules (M5.EN.1.R and M5.EN.2.R)
      // M5.EN.1.R and M5.EN.2.R are checked by RR:RE:FP:M5.EN.1__M5.EN.2
      rRR_RE_FP_M5_EN_1__M5_EN_2 @= { @ "RR:RE:FP:M5.EN.1__M5.EN.2 : Enclosure of VIA4 at least two opposite sides 0.07 um/Enclosure of VIA4 0.04 um";
          A = not_enclosed_by( M5EN1_M5EN2_VIA4, M5, distances = { { { 0, RADIAL }, { 0.07, NONE }, { 0, RADIAL }, { 0.07, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          enclose( A, M5, < 0.04, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : RR:RE:FP:M5.EN.1__M5.EN.2 */
   #endif /* end of #ifdef _M5EN1_M5EN2_  */ 
   #ifdef _M5S1_ 
      M5S1_M5CELLIN = copy( aLAYER_288 ); 
      M5S1_M5CELLOUT = copy( aLAYER_289 ); 
      M5S1_M5CELL = M5S1_M5CELLIN and M5S1_M5CELLOUT; 
      M5S1_M5MARKER = M5I and RRULERECOMMENDED; 
      gLAYER_982 = M5S1_M5CELL or M5S1_M5MARKER; 
      gLAYER_981 = gLAYER_982 not BLOCK; 
      M5S1_M5 = gLAYER_981 not EXCLUDERRULERECOMMENDED; 
      
      // M5.S.1.R is checked by RR:RE:D:M5.S.1
      rRR_RE_D_M5_S_1 @= { @ "RR:RE:D:M5.S.1 : Recommended M5 space >= 0.13um";
          external1( M5S1_M5, < 0.13, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : RR:RE:D:M5.S.1 */
   #endif /* end of #ifdef _M5S1_  */ 
   #ifdef _M5S7_ 
      M5S7_M5CELLIN = copy( aLAYER_290 ); 
      M5S7_M5CELLOUT = copy( aLAYER_291 ); 
      M5S7_M5CELL = M5S7_M5CELLIN and M5S7_M5CELLOUT; 
      M5S7_M5MARKER = M5I and RRULERECOMMENDED; 
      gLAYER_984 = M5S7_M5CELL or M5S7_M5MARKER; 
      gLAYER_983 = gLAYER_984 not BLOCK; 
      M5S7_M5 = gLAYER_983 not EXCLUDERRULERECOMMENDED; 
      M5S7_DM5CELLIN = copy( aLAYER_292 ); 
      M5S7_DM5CELLOUT = copy( aLAYER_293 ); 
      M5S7_DM5CELL = M5S7_DM5CELLIN and M5S7_DM5CELLOUT; 
      M5S7_DM5MARKER = DUM5 and RRULERECOMMENDED; 
      gLAYER_986 = M5S7_DM5CELL or M5S7_DM5MARKER; 
      gLAYER_985 = gLAYER_986 not BLOCK; 
      M5S7_DM5 = gLAYER_985 not EXCLUDERRULERECOMMENDED; 
      M5S7_M5X = M5S7_M5 or M5S7_DM5; 
      M5S7_NOT_M5X = gCHIP not M5X; 
      M5S7_BIGAREA = area( M5S7_NOT_M5X, > BIG_AREA ); 
      gLAYER_987 = external2( M5S7_BIGAREA, M5S7_NOT_M5X, < 0.35, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, membership = DIFFERENT_POLYGON, relational = { POINT_TOUCH }, width = 0.002 ); 
      M5S7_ERROR = gLAYER_987 not_outside M5S7_M5X; 
      
      // M5.S.7.R is checked by RR:RE:S:M5.S.7 
      rRR_RE_S_M5_S_7 @= { @ "RR:RE:S:M5.S.7 : Space between two non-M5 regions 0.35 [ one area > " + BIG_AREA + " ]"; 
          copy( M5S7_ERROR ); 
      } /* end of rule : RR:RE:S:M5.S.7 */
   #endif /* end of #ifdef _M5S7_  */ 
   #ifdef _VIA5EN1_VIA5EN2_ 
      VIA5EN1_VIA5EN2_VIA5CELLIN = copy( aLAYER_294 ); 
      VIA5EN1_VIA5EN2_VIA5CELLOUT = copy( aLAYER_295 ); 
      VIA5EN1_VIA5EN2_VIA5CELL = VIA5EN1_VIA5EN2_VIA5CELLIN and VIA5EN1_VIA5EN2_VIA5CELLOUT; 
      VIA5EN1_VIA5EN2_VIA5MARKER = VIA5I and RRULERECOMMENDED; 
      gLAYER_989 = VIA5EN1_VIA5EN2_VIA5CELL or VIA5EN1_VIA5EN2_VIA5MARKER; 
      gLAYER_988 = gLAYER_989 not BLOCK; 
      VIA5EN1_VIA5EN2_VIA5 = gLAYER_988 not EXCLUDERRULERECOMMENDED; 
      
      // VIA5.EN.0.R is checked by related rules (VIA5.EN.1.R and VIA5.EN.2.R)
      // VIA5.EN.1.R and VIA5.EN.2.R are checked by RR:RE:FP:VIA5.EN.1__VIA5.EN.2
      rRR_RE_FP_VIA5_EN_1__VIA5_EN_2 @= { @ "RR:RE:FP:VIA5.EN.1__VIA5.EN.2 : Enclosure of VIA5 at least two opposite sides 0.07 um/Enclosure of VIA5 0.04 um";
          A = not_enclosed_by( VIA5EN1_VIA5EN2_VIA5, M5I, distances = { { { 0, RADIAL }, { 0.07, NONE }, { 0, RADIAL }, { 0.07, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          enclose( A, M5I, < 0.04, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : RR:RE:FP:VIA5.EN.1__VIA5.EN.2 */
   #endif /* end of #ifdef _VIA5EN1_VIA5EN2_  */ 
   #ifdef _M6EN1_M6EN2_ 
      M6EN1_M6EN2_VIA5CELLIN = copy( aLAYER_296 ); 
      M6EN1_M6EN2_VIA5CELLOUT = copy( aLAYER_297 ); 
      M6EN1_M6EN2_VIA5CELL = M6EN1_M6EN2_VIA5CELLIN and M6EN1_M6EN2_VIA5CELLOUT; 
      M6EN1_M6EN2_VIA5MARKER = VIA5I and RRULERECOMMENDED; 
      gLAYER_991 = M6EN1_M6EN2_VIA5CELL or M6EN1_M6EN2_VIA5MARKER; 
      gLAYER_990 = gLAYER_991 not BLOCK; 
      M6EN1_M6EN2_VIA5 = gLAYER_990 not EXCLUDERRULERECOMMENDED; 
      
      // M6.EN.0.R is checked by related rules (M6.EN.1.R and M6.EN.2.R)
      // M6.EN.1.R and M6.EN.2.R are checked by RR:RE:FP:M6.EN.1__M6.EN.2
      rRR_RE_FP_M6_EN_1__M6_EN_2 @= { @ "RR:RE:FP:M6.EN.1__M6.EN.2 : Enclosure of VIA5 at least two opposite sides 0.07 um/Enclosure of VIA5 0.04 um";
          A = not_enclosed_by( M6EN1_M6EN2_VIA5, M6, distances = { { { 0, RADIAL }, { 0.07, NONE }, { 0, RADIAL }, { 0.07, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          enclose( A, M6, < 0.04, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : RR:RE:FP:M6.EN.1__M6.EN.2 */
   #endif /* end of #ifdef _M6EN1_M6EN2_  */ 
   #ifdef _M6S1_ 
      M6S1_M6CELLIN = copy( aLAYER_298 ); 
      M6S1_M6CELLOUT = copy( aLAYER_299 ); 
      M6S1_M6CELL = M6S1_M6CELLIN and M6S1_M6CELLOUT; 
      M6S1_M6MARKER = M6I and RRULERECOMMENDED; 
      gLAYER_993 = M6S1_M6CELL or M6S1_M6MARKER; 
      gLAYER_992 = gLAYER_993 not BLOCK; 
      M6S1_M6 = gLAYER_992 not EXCLUDERRULERECOMMENDED; 
      
      // M6.S.1.R is checked by RR:RE:D:M6.S.1
      rRR_RE_D_M6_S_1 @= { @ "RR:RE:D:M6.S.1 : Recommended M6 space >= 0.13um";
          external1( M6S1_M6, < 0.13, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : RR:RE:D:M6.S.1 */
   #endif /* end of #ifdef _M6S1_  */ 
   #ifdef _M6S7_ 
      M6S7_M6CELLIN = copy( aLAYER_300 ); 
      M6S7_M6CELLOUT = copy( aLAYER_301 ); 
      M6S7_M6CELL = M6S7_M6CELLIN and M6S7_M6CELLOUT; 
      M6S7_M6MARKER = M6I and RRULERECOMMENDED; 
      gLAYER_995 = M6S7_M6CELL or M6S7_M6MARKER; 
      gLAYER_994 = gLAYER_995 not BLOCK; 
      M6S7_M6 = gLAYER_994 not EXCLUDERRULERECOMMENDED; 
      M6S7_DM6CELLIN = copy( aLAYER_302 ); 
      M6S7_DM6CELLOUT = copy( aLAYER_303 ); 
      M6S7_DM6CELL = M6S7_DM6CELLIN and M6S7_DM6CELLOUT; 
      M6S7_DM6MARKER = DUM6 and RRULERECOMMENDED; 
      gLAYER_997 = M6S7_DM6CELL or M6S7_DM6MARKER; 
      gLAYER_996 = gLAYER_997 not BLOCK; 
      M6S7_DM6 = gLAYER_996 not EXCLUDERRULERECOMMENDED; 
      M6S7_M6X = M6S7_M6 or M6S7_DM6; 
      M6S7_NOT_M6X = gCHIP not M6X; 
      M6S7_BIGAREA = area( M6S7_NOT_M6X, > BIG_AREA ); 
      gLAYER_998 = external2( M6S7_BIGAREA, M6S7_NOT_M6X, < 0.35, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, membership = DIFFERENT_POLYGON, relational = { POINT_TOUCH }, width = 0.002 ); 
      M6S7_ERROR = gLAYER_998 not_outside M6S7_M6X; 
      
      // M6.S.7.R is checked by RR:RE:S:M6.S.7 
      rRR_RE_S_M6_S_7 @= { @ "RR:RE:S:M6.S.7 : Space between two non-M6 regions 0.35 [ one area > " + BIG_AREA + " ]"; 
          copy( M6S7_ERROR ); 
      } /* end of rule : RR:RE:S:M6.S.7 */
   #endif /* end of #ifdef _M6S7_  */ 
   #ifdef _VIA6EN1_VIA6EN2_ 
      VIA6EN1_VIA6EN2_VIA6CELLIN = copy( aLAYER_304 ); 
      VIA6EN1_VIA6EN2_VIA6CELLOUT = copy( aLAYER_305 ); 
      VIA6EN1_VIA6EN2_VIA6CELL = VIA6EN1_VIA6EN2_VIA6CELLIN and VIA6EN1_VIA6EN2_VIA6CELLOUT; 
      VIA6EN1_VIA6EN2_VIA6MARKER = VIA6I and RRULERECOMMENDED; 
      gLAYER_1000 = VIA6EN1_VIA6EN2_VIA6CELL or VIA6EN1_VIA6EN2_VIA6MARKER; 
      gLAYER_999 = gLAYER_1000 not BLOCK; 
      VIA6EN1_VIA6EN2_VIA6 = gLAYER_999 not EXCLUDERRULERECOMMENDED; 
      
      // VIA6.EN.0.R is checked by related rules (VIA6.EN.1.R and VIA6.EN.2.R)
      // VIA6.EN.1.R and VIA6.EN.2.R are checked by RR:RE:FP:VIA6.EN.1__VIA6.EN.2
      rRR_RE_FP_VIA6_EN_1__VIA6_EN_2 @= { @ "RR:RE:FP:VIA6.EN.1__VIA6.EN.2 : Enclosure of VIA6 at least two opposite sides 0.07 um/Enclosure of VIA6 0.04 um";
          A = not_enclosed_by( VIA6EN1_VIA6EN2_VIA6, M6I, distances = { { { 0, RADIAL }, { 0.07, NONE }, { 0, RADIAL }, { 0.07, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          enclose( A, M6I, < 0.04, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : RR:RE:FP:VIA6.EN.1__VIA6.EN.2 */
   #endif /* end of #ifdef _VIA6EN1_VIA6EN2_  */ 
   #ifdef _M7EN1_M7EN2_ 
      M7EN1_M7EN2_VIA6CELLIN = copy( aLAYER_306 ); 
      M7EN1_M7EN2_VIA6CELLOUT = copy( aLAYER_307 ); 
      M7EN1_M7EN2_VIA6CELL = M7EN1_M7EN2_VIA6CELLIN and M7EN1_M7EN2_VIA6CELLOUT; 
      M7EN1_M7EN2_VIA6MARKER = VIA6I and RRULERECOMMENDED; 
      gLAYER_1002 = M7EN1_M7EN2_VIA6CELL or M7EN1_M7EN2_VIA6MARKER; 
      gLAYER_1001 = gLAYER_1002 not BLOCK; 
      M7EN1_M7EN2_VIA6 = gLAYER_1001 not EXCLUDERRULERECOMMENDED; 
      
      // M7.EN.0.R is checked by related rules (M7.EN.1.R and M7.EN.2.R)
      // M7.EN.1.R and M7.EN.2.R are checked by RR:RE:FP:M7.EN.1__M7.EN.2
      rRR_RE_FP_M7_EN_1__M7_EN_2 @= { @ "RR:RE:FP:M7.EN.1__M7.EN.2 : Enclosure of VIA6 at least two opposite sides 0.07 um/Enclosure of VIA6 0.04 um";
          A = not_enclosed_by( M7EN1_M7EN2_VIA6, M7, distances = { { { 0, RADIAL }, { 0.07, NONE }, { 0, RADIAL }, { 0.07, NONE } } }, intersecting_failures = { ACUTE, POINT_TOUCH, TOUCH } ); 
          enclose( A, M7, < 0.04, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = INSIDE, look_thru = NOT_CONTAINED, relational = { POINT_TOUCH }, width = 0.004 ); 
      } /* end of rule : RR:RE:FP:M7.EN.1__M7.EN.2 */
   #endif /* end of #ifdef _M7EN1_M7EN2_  */ 
   #ifdef _M7S1_ 
      M7S1_M7CELLIN = copy( aLAYER_308 ); 
      M7S1_M7CELLOUT = copy( aLAYER_309 ); 
      M7S1_M7CELL = M7S1_M7CELLIN and M7S1_M7CELLOUT; 
      M7S1_M7MARKER = M7I and RRULERECOMMENDED; 
      gLAYER_1004 = M7S1_M7CELL or M7S1_M7MARKER; 
      gLAYER_1003 = gLAYER_1004 not BLOCK; 
      M7S1_M7 = gLAYER_1003 not EXCLUDERRULERECOMMENDED; 
      
      // M7.S.1.R is checked by RR:RE:D:M7.S.1
      rRR_RE_D_M7_S_1 @= { @ "RR:RE:D:M7.S.1 : Recommended M7 space >= 0.13um";
          external1( M7S1_M7, < 0.13, extension = RADIAL, intersecting = {  }, intersection_angle = < 90, look_thru = NOT_ADJACENT, relational = { POINT_TOUCH } ); 
      } /* end of rule : RR:RE:D:M7.S.1 */
   #endif /* end of #ifdef _M7S1_  */ 
   #ifdef _M7S7_ 
      M7S7_M7CELLIN = copy( aLAYER_310 ); 
      M7S7_M7CELLOUT = copy( aLAYER_311 ); 
      M7S7_M7CELL = M7S7_M7CELLIN and M7S7_M7CELLOUT; 
      M7S7_M7MARKER = M7I and RRULERECOMMENDED; 
      gLAYER_1006 = M7S7_M7CELL or M7S7_M7MARKER; 
      gLAYER_1005 = gLAYER_1006 not BLOCK; 
      M7S7_M7 = gLAYER_1005 not EXCLUDERRULERECOMMENDED; 
      M7S7_DM7CELLIN = copy( aLAYER_312 ); 
      M7S7_DM7CELLOUT = copy( aLAYER_313 ); 
      M7S7_DM7CELL = M7S7_DM7CELLIN and M7S7_DM7CELLOUT; 
      M7S7_DM7MARKER = DUM7 and RRULERECOMMENDED; 
      gLAYER_1008 = M7S7_DM7CELL or M7S7_DM7MARKER; 
      gLAYER_1007 = gLAYER_1008 not BLOCK; 
      M7S7_DM7 = gLAYER_1007 not EXCLUDERRULERECOMMENDED; 
      M7S7_M7X = M7S7_M7 or M7S7_DM7; 
      M7S7_NOT_M7X = gCHIP not M7X; 
      M7S7_BIGAREA = area( M7S7_NOT_M7X, > BIG_AREA ); 
      gLAYER_1009 = external2( M7S7_BIGAREA, M7S7_NOT_M7X, < 0.35, extension = RADIAL, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, membership = DIFFERENT_POLYGON, relational = { POINT_TOUCH }, width = 0.002 ); 
      M7S7_ERROR = gLAYER_1009 not_outside M7S7_M7X; 
      
      // M7.S.7.R is checked by RR:RE:S:M7.S.7 
      rRR_RE_S_M7_S_7 @= { @ "RR:RE:S:M7.S.7 : Space between two non-M7 regions 0.35 [ one area > " + BIG_AREA + " ]"; 
          copy( M7S7_ERROR ); 
      } /* end of rule : RR:RE:S:M7.S.7 */
   #endif /* end of #ifdef _M7S7_  */ 
   #ifdef _VIAxR8_ 
      VIA_EXD_STACK = copy( SEALRINGI ); 
      gLAYER_1012 = M1I and M2I; 
      gLAYER_1011 = interacting( gLAYER_1012, VIA1, > 1 ); 
      gLAYER_1010 = interacting( VIA1, gLAYER_1011 ); 
      SINGLE_VIA1 = VIA1 not gLAYER_1010; 
      gLAYER_1015 = M2I and M3I; 
      gLAYER_1014 = interacting( gLAYER_1015, VIA2, > 1 ); 
      gLAYER_1013 = interacting( VIA2, gLAYER_1014 ); 
      SINGLE_VIA2 = VIA2 not gLAYER_1013; 
      gLAYER_1018 = M3I and M4I; 
      gLAYER_1017 = interacting( gLAYER_1018, VIA3, > 1 ); 
      gLAYER_1016 = interacting( VIA3, gLAYER_1017 ); 
      SINGLE_VIA3 = VIA3 not gLAYER_1016; 
      gLAYER_1021 = M4I and M5I; 
      gLAYER_1020 = interacting( gLAYER_1021, VIA4, > 1 ); 
      gLAYER_1019 = interacting( VIA4, gLAYER_1020 ); 
      SINGLE_VIA4 = VIA4 not gLAYER_1019; 
      gLAYER_1024 = M5I and M6I; 
      gLAYER_1023 = interacting( gLAYER_1024, VIA5, > 1 ); 
      gLAYER_1022 = interacting( VIA5, gLAYER_1023 ); 
      SINGLE_VIA5 = VIA5 not gLAYER_1022; 
      gLAYER_1026 = SINGLE_VIA5 and SINGLE_VIA4; 
      gLAYER_1025 = gLAYER_1026 and SINGLE_VIA3; 
      STACK_V2V5 = gLAYER_1025 and SINGLE_VIA2; 
      VIAXR8_V2CELLIN = copy( aLAYER_314 ); 
      VIAXR8_V2CELLOUT = copy( aLAYER_315 ); 
      VIAXR8_V2CELL = VIAXR8_V2CELLIN and VIAXR8_V2CELLOUT; 
      VIAXR8_V2MARKER = VIA2I and RRULERECOMMENDED; 
      gLAYER_1028 = VIAXR8_V2CELL or VIAXR8_V2MARKER; 
      gLAYER_1027 = gLAYER_1028 not BLOCK; 
      VIAXR8_V2 = gLAYER_1027 not EXCLUDERRULERECOMMENDED; 
      VIAXR8_STACK_V2V5 = STACK_V2V5 and VIAXR8_V2; 
      
      // VIAx.R.8.R is checked by RR:RE:S:VIAx.R.8:V1V5
      rRR_RE_S_VIAX_R_8_V1V5 @= { @ "RR:RE:S:VIAx.R.8:V1V5 : Max. 4 stacked Vias are allowed when only one via for each VIA layer. (VIA1~VIA5 is not allowed)";
          sLAYER_1223 = VIAXR8_STACK_V2V5 and SINGLE_VIA1; 
          sLAYER_1223 not VIA_EXD_STACK; 
      } /* end of rule : RR:RE:S:VIAx.R.8:V1V5 */
      gLAYER_1031 = M6I and M7I; 
      gLAYER_1030 = interacting( gLAYER_1031, VIA6, > 1 ); 
      gLAYER_1029 = interacting( VIA6, gLAYER_1030 ); 
      SINGLE_VIA6 = VIA6 not gLAYER_1029; 
      
      // VIAx.R.8.R is checked by RR:RE:S:VIAx.R.8:V2V6
      rRR_RE_S_VIAX_R_8_V2V6 @= { @ "RR:RE:S:VIAx.R.8:V2V6 : Max. 4 stacked Vias are allowed when only one via for each VIA layer.(VIA2~VIA6 is not allowed)";
          sLAYER_1224 = VIAXR8_STACK_V2V5 and SINGLE_VIA6; 
          sLAYER_1224 not VIA_EXD_STACK; 
      } /* end of rule : RR:RE:S:VIAx.R.8:V2V6 */
   #endif /* end of #ifdef _VIAxR8_  */ 
   #ifdef FULL_CHIP 
      #ifdef _DTCDDN1_ 
         
         // DTCD.DN.1.R is checked by RR:RE:S:DTCD.DN.1
         rRR_RE_S_DTCD_DN_1 @= { @ "RR:RE:S:DTCD.DN.1 : Density of Dummy TCD (2mmx2mm is one unit) >= 80 %";
         _den_con = == 4000000;
         _den_polygon_area_clip = false;
         _den_print = false;
         _den_print_only = false;
             ALL_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = CHIPX, layer_hash = { "layer1" => gCHIP }, delta_window = { 2000, 2000 }, delta_x = 2000, delta_y = 2000, window_function = den_save_window_23 ); 
             VAR_137 = density_statistics_file( file = "DTCD.DN.1.NO_TCDDMY" ); 
         _den_con = == 0;
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             BAD_WIN = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = ALL_WIN, layer_hash = { "layer1" => TCDDMY }, delta_window = { 2000, 2000 }, delta_x = 2000, delta_y = 2000, statistics_files = { VAR_137 }, window_function = den_save_window_4 ); 
             GOOD_WIN = ALL_WIN not BAD_WIN; 
             VAR_138 = density_statistics_file( file = "DTCD.DN.1.density" ); 
         _den_con = < 0.8;
         _den_polygon_area_clip = false;
         #ifdef ICV_REPORT_DENSITY
         _den_print = true;
         #else
         _den_print = false;
         #endif
         _den_print_only = false;
             ERR = density( output_type = CLIPPED_DELTA_WINDOW, window_layer = ALL_WIN, layer_hash = { "layer1" => GOOD_WIN }, statistics_files = { VAR_138 }, window_function = den_save_window_4 ); 
             sLAYER_1225 = ERR and BAD_WIN; 
             copy( sLAYER_1225 );
         } /* end of rule : RR:RE:S:DTCD.DN.1 */
      #endif /* end of #ifdef _DTCDDN1_  */ 
   #endif /* end of #ifdef FULL_CHIP  */ 
   #ifdef _OPCR2_ 
      OPCR2_PPCELLIN = copy( aLAYER_316 ); 
      OPCR2_PPCELLOUT = copy( aLAYER_317 ); 
      OPCR2_PPCELL = OPCR2_PPCELLIN and OPCR2_PPCELLOUT; 
      OPCR2_PPMARKER = PPI and RRULEGUIDELINE; 
      gLAYER_1034 = OPCR2_PPCELL or OPCR2_PPMARKER; 
      gLAYER_1033 = gLAYER_1034 not_inside SRAM_EXCLUDE; 
      gLAYER_1032 = gLAYER_1033 outside BLOCK; 
      OPCR2_PP = gLAYER_1032 not EXCLUDERRULEGUIDELINE; 
      
      // OPC.R.2g is checked by RR:GL:S:OPC.R.2:PP
      rRR_GL_S_OPC_R_2_PP @= { @ "RR:GL:S:OPC.R.2:PP : Recommended edge length >= 1/2 minimum width for OPC friendly layout";
          sLAYER_1227 = length_edge( PP, < ( PP_W_1 / 2 ) ); 
          sLAYER_1226 = sLAYER_1227 inside_touching_edge OPCR2_PP; 
          or_edge( not_edge( sLAYER_1226, SRAM_EXCLUDE ), coincident_inside_edge( sLAYER_1226, SRAM_EXCLUDE ) ); 
      } /* end of rule : RR:GL:S:OPC.R.2:PP */
      OPCR2_NPCELLIN = copy( aLAYER_318 ); 
      OPCR2_NPCELLOUT = copy( aLAYER_319 ); 
      OPCR2_NPCELL = OPCR2_NPCELLIN and OPCR2_NPCELLOUT; 
      OPCR2_NPMARKER = NPI and RRULEGUIDELINE; 
      gLAYER_1037 = OPCR2_NPCELL or OPCR2_NPMARKER; 
      gLAYER_1036 = gLAYER_1037 not_inside SRAM_EXCLUDE; 
      gLAYER_1035 = gLAYER_1036 outside BLOCK; 
      OPCR2_NP = gLAYER_1035 not EXCLUDERRULEGUIDELINE; 
      
      // OPC.R.2g is checked by RR:GL:S:OPC.R.2:NP
      rRR_GL_S_OPC_R_2_NP @= { @ "RR:GL:S:OPC.R.2:NP : Recommended edge length >= 1/2 minimum width for OPC friendly layout";
          sLAYER_1229 = length_edge( gNP, < ( NP_W_1 / 2 ) ); 
          sLAYER_1228 = sLAYER_1229 inside_touching_edge OPCR2_NP; 
          or_edge( not_edge( sLAYER_1228, SRAM_EXCLUDE ), coincident_inside_edge( sLAYER_1228, SRAM_EXCLUDE ) ); 
      } /* end of rule : RR:GL:S:OPC.R.2:NP */
      OPCR2_VTHNCELLIN = copy( aLAYER_320 ); 
      OPCR2_VTHNCELLOUT = copy( aLAYER_321 ); 
      OPCR2_VTHNCELL = OPCR2_VTHNCELLIN and OPCR2_VTHNCELLOUT; 
      OPCR2_VTHNMARKER = VTH_NI and RRULEGUIDELINE; 
      gLAYER_1040 = OPCR2_VTHNCELL or OPCR2_VTHNMARKER; 
      gLAYER_1039 = gLAYER_1040 not_inside SRAM_EXCLUDE; 
      gLAYER_1038 = gLAYER_1039 outside BLOCK; 
      OPCR2_VTHN = gLAYER_1038 not EXCLUDERRULEGUIDELINE; 
      
      // OPC.R.2g is checked by RR:GL:S:OPC.R.2:VTHN
      rRR_GL_S_OPC_R_2_VTHN @= { @ "RR:GL:S:OPC.R.2:VTHN : Recommended edge length >= 1/2 minimum width for OPC friendly layout";
          sLAYER_1231 = length_edge( VTHNS, < ( VTH_N_W_1 / 2 ) ); 
          sLAYER_1230 = sLAYER_1231 inside_touching_edge OPCR2_VTHN; 
          or_edge( not_edge( sLAYER_1230, SRAM_EXCLUDE ), coincident_inside_edge( sLAYER_1230, SRAM_EXCLUDE ) ); 
      } /* end of rule : RR:GL:S:OPC.R.2:VTHN */
      OPCR2_VTHPCELLIN = copy( aLAYER_322 ); 
      OPCR2_VTHPCELLOUT = copy( aLAYER_323 ); 
      OPCR2_VTHPCELL = OPCR2_VTHPCELLIN and OPCR2_VTHPCELLOUT; 
      OPCR2_VTHPMARKER = VTH_PI and RRULEGUIDELINE; 
      gLAYER_1043 = OPCR2_VTHPCELL or OPCR2_VTHPMARKER; 
      gLAYER_1042 = gLAYER_1043 not_inside SRAM_EXCLUDE; 
      gLAYER_1041 = gLAYER_1042 outside BLOCK; 
      OPCR2_VTHP = gLAYER_1041 not EXCLUDERRULEGUIDELINE; 
      
      // OPC.R.2g is checked by RR:GL:S:OPC.R.2:VTHP
      rRR_GL_S_OPC_R_2_VTHP @= { @ "RR:GL:S:OPC.R.2:VTHP : Recommended edge length >= 1/2 minimum width for OPC friendly layout";
          sLAYER_1233 = length_edge( VTHPS, < ( VTH_P_W_1 / 2 ) ); 
          sLAYER_1232 = sLAYER_1233 inside_touching_edge OPCR2_VTHP; 
          or_edge( not_edge( sLAYER_1232, SRAM_EXCLUDE ), coincident_inside_edge( sLAYER_1232, SRAM_EXCLUDE ) ); 
      } /* end of rule : RR:GL:S:OPC.R.2:VTHP */
      OPCR2_VTLNCELLIN = copy( aLAYER_324 ); 
      OPCR2_VTLNCELLOUT = copy( aLAYER_325 ); 
      OPCR2_VTLNCELL = OPCR2_VTLNCELLIN and OPCR2_VTLNCELLOUT; 
      OPCR2_VTLNMARKER = VTL_NI and RRULEGUIDELINE; 
      gLAYER_1046 = OPCR2_VTLNCELL or OPCR2_VTLNMARKER; 
      gLAYER_1045 = gLAYER_1046 not_inside SRAM_EXCLUDE; 
      gLAYER_1044 = gLAYER_1045 outside BLOCK; 
      OPCR2_VTLN = gLAYER_1044 not EXCLUDERRULEGUIDELINE; 
      
      // OPC.R.2g is checked by RR:GL:S:OPC.R.2:VTLN
      rRR_GL_S_OPC_R_2_VTLN @= { @ "RR:GL:S:OPC.R.2:VTLN : Recommended edge length >= 1/2 minimum width for OPC friendly layout";
          sLAYER_1235 = length_edge( VTLNS, < ( VTL_N_W_1 / 2 ) ); 
          sLAYER_1234 = sLAYER_1235 inside_touching_edge OPCR2_VTLN; 
          or_edge( not_edge( sLAYER_1234, SRAM_EXCLUDE ), coincident_inside_edge( sLAYER_1234, SRAM_EXCLUDE ) ); 
      } /* end of rule : RR:GL:S:OPC.R.2:VTLN */
      OPCR2_VTLPCELLIN = copy( aLAYER_326 ); 
      OPCR2_VTLPCELLOUT = copy( aLAYER_327 ); 
      OPCR2_VTLPCELL = OPCR2_VTLPCELLIN and OPCR2_VTLPCELLOUT; 
      OPCR2_VTLPMARKER = VTL_PI and RRULEGUIDELINE; 
      gLAYER_1049 = OPCR2_VTLPCELL or OPCR2_VTLPMARKER; 
      gLAYER_1048 = gLAYER_1049 not_inside SRAM_EXCLUDE; 
      gLAYER_1047 = gLAYER_1048 outside BLOCK; 
      OPCR2_VTLP = gLAYER_1047 not EXCLUDERRULEGUIDELINE; 
      
      // OPC.R.2g is checked by RR:GL:S:OPC.R.2:VTLP
      rRR_GL_S_OPC_R_2_VTLP @= { @ "RR:GL:S:OPC.R.2:VTLP : Recommended edge length >= 1/2 minimum width for OPC friendly layout";
          sLAYER_1237 = length_edge( VTLPS, < ( VTL_P_W_1 / 2 ) ); 
          sLAYER_1236 = sLAYER_1237 inside_touching_edge OPCR2_VTLP; 
          or_edge( not_edge( sLAYER_1236, SRAM_EXCLUDE ), coincident_inside_edge( sLAYER_1236, SRAM_EXCLUDE ) ); 
      } /* end of rule : RR:GL:S:OPC.R.2:VTLP */
      OPCR2_ODCELLIN = copy( aLAYER_328 ); 
      OPCR2_ODCELLOUT = copy( aLAYER_329 ); 
      OPCR2_ODCELL = OPCR2_ODCELLIN and OPCR2_ODCELLOUT; 
      OPCR2_ODMARKER = ODI and RRULEGUIDELINE; 
      gLAYER_1052 = OPCR2_ODCELL or OPCR2_ODMARKER; 
      gLAYER_1051 = gLAYER_1052 not_inside SRAM_EXCLUDE; 
      gLAYER_1050 = gLAYER_1051 outside BLOCK; 
      OPCR2_OD = gLAYER_1050 not EXCLUDERRULEGUIDELINE; 
      
      // OPC.R.2g is checked by RR:GL:S:OPC.R.2:OD
      rRR_GL_S_OPC_R_2_OD @= { @ "RR:GL:S:OPC.R.2:OD : Recommended edge length >= 1/2 minimum width for OPC friendly layout";
          sLAYER_1239 = length_edge( ODS, < ( OD_W_1 / 2 ) ); 
          sLAYER_1238 = sLAYER_1239 inside_touching_edge OPCR2_OD; 
          or_edge( not_edge( sLAYER_1238, SRAM_EXCLUDE ), coincident_inside_edge( sLAYER_1238, SRAM_EXCLUDE ) ); 
      } /* end of rule : RR:GL:S:OPC.R.2:OD */
      OPCR2_POCELLIN = copy( aLAYER_330 ); 
      OPCR2_POCELLOUT = copy( aLAYER_331 ); 
      OPCR2_POCELL = OPCR2_POCELLIN and OPCR2_POCELLOUT; 
      OPCR2_POMARKER = POI and RRULEGUIDELINE; 
      gLAYER_1055 = OPCR2_POCELL or OPCR2_POMARKER; 
      gLAYER_1054 = gLAYER_1055 not_inside SRAM_EXCLUDE; 
      gLAYER_1053 = gLAYER_1054 outside BLOCK; 
      OPCR2_PO = gLAYER_1053 not EXCLUDERRULEGUIDELINE; 
      
      // OPC.R.2g is checked by RR:GL:S:OPC.R.2:PO
      rRR_GL_S_OPC_R_2_PO @= { @ "RR:GL:S:OPC.R.2:PO : Recommended edge length >= 1/2 minimum width for OPC friendly layout";
          sLAYER_1241 = length_edge( POLYS, < ( PO_W_1 / 2 ) ); 
          sLAYER_1240 = sLAYER_1241 inside_touching_edge OPCR2_PO; 
          or_edge( not_edge( sLAYER_1240, SRAM_EXCLUDE ), coincident_inside_edge( sLAYER_1240, SRAM_EXCLUDE ) ); 
      } /* end of rule : RR:GL:S:OPC.R.2:PO */
      OPCR2_M1CELLIN = copy( aLAYER_332 ); 
      OPCR2_M1CELLOUT = copy( aLAYER_333 ); 
      OPCR2_M1CELL = OPCR2_M1CELLIN and OPCR2_M1CELLOUT; 
      OPCR2_M1MARKER = M1I and RRULEGUIDELINE; 
      gLAYER_1058 = OPCR2_M1CELL or OPCR2_M1MARKER; 
      gLAYER_1057 = gLAYER_1058 not_inside SRAM_EXCLUDE; 
      gLAYER_1056 = gLAYER_1057 outside BLOCK; 
      OPCR2_M1 = gLAYER_1056 not EXCLUDERRULEGUIDELINE; 
      
      // OPC.R.2g is checked by RR:GL:S:OPC.R.2:M1
      rRR_GL_S_OPC_R_2_M1 @= { @ "RR:GL:S:OPC.R.2:M1 : Recommended edge length >= 1/2 minimum width for OPC friendly layout";
          sLAYER_1243 = length_edge( M1S, < ( M1_W_1 / 2 ) ); 
          sLAYER_1242 = sLAYER_1243 inside_touching_edge OPCR2_M1; 
          or_edge( not_edge( sLAYER_1242, SRAM_EXCLUDE ), coincident_inside_edge( sLAYER_1242, SRAM_EXCLUDE ) ); 
      } /* end of rule : RR:GL:S:OPC.R.2:M1 */
      OPCR2_M2CELLIN = copy( aLAYER_334 ); 
      OPCR2_M2CELLOUT = copy( aLAYER_335 ); 
      OPCR2_M2CELL = OPCR2_M2CELLIN and OPCR2_M2CELLOUT; 
      OPCR2_M2MARKER = M2I and RRULEGUIDELINE; 
      gLAYER_1060 = OPCR2_M2CELL or OPCR2_M2MARKER; 
      gLAYER_1059 = gLAYER_1060 not BLOCK; 
      OPCR2_M2 = gLAYER_1059 not EXCLUDERRULEGUIDELINE; 
      
      // OPC.R.2g is checked by RR:GL:S:OPC.R.2:M2
      rRR_GL_S_OPC_R_2_M2 @= { @ "RR:GL:S:OPC.R.2:M2 : Recommended edge length >= 1/2 minimum width for OPC friendly layout";
          sLAYER_1244 = length_edge( M2, < ( M2_W_1 / 2 ) ); 
          sLAYER_1244 inside_touching_edge OPCR2_M2; 
      } /* end of rule : RR:GL:S:OPC.R.2:M2 */
      OPCR2_M3CELLIN = copy( aLAYER_336 ); 
      OPCR2_M3CELLOUT = copy( aLAYER_337 ); 
      OPCR2_M3CELL = OPCR2_M3CELLIN and OPCR2_M3CELLOUT; 
      OPCR2_M3MARKER = M3I and RRULEGUIDELINE; 
      gLAYER_1062 = OPCR2_M3CELL or OPCR2_M3MARKER; 
      gLAYER_1061 = gLAYER_1062 not BLOCK; 
      OPCR2_M3 = gLAYER_1061 not EXCLUDERRULEGUIDELINE; 
      
      // OPC.R.2g is checked by RR:GL:S:OPC.R.2:M3
      rRR_GL_S_OPC_R_2_M3 @= { @ "RR:GL:S:OPC.R.2:M3 : Recommended edge length >= 1/2 minimum width for OPC friendly layout";
          sLAYER_1245 = length_edge( M3, < ( M3_W_1 / 2 ) ); 
          sLAYER_1245 inside_touching_edge OPCR2_M3; 
      } /* end of rule : RR:GL:S:OPC.R.2:M3 */
      OPCR2_M4CELLIN = copy( aLAYER_338 ); 
      OPCR2_M4CELLOUT = copy( aLAYER_339 ); 
      OPCR2_M4CELL = OPCR2_M4CELLIN and OPCR2_M4CELLOUT; 
      OPCR2_M4MARKER = M4I and RRULEGUIDELINE; 
      gLAYER_1064 = OPCR2_M4CELL or OPCR2_M4MARKER; 
      gLAYER_1063 = gLAYER_1064 not BLOCK; 
      OPCR2_M4 = gLAYER_1063 not EXCLUDERRULEGUIDELINE; 
      
      // OPC.R.2g is checked by RR:GL:S:OPC.R.2:M4
      rRR_GL_S_OPC_R_2_M4 @= { @ "RR:GL:S:OPC.R.2:M4 : Recommended edge length >= 1/2 minimum width for OPC friendly layout";
          sLAYER_1246 = length_edge( M4, < ( M4_W_1 / 2 ) ); 
          sLAYER_1246 inside_touching_edge OPCR2_M4; 
      } /* end of rule : RR:GL:S:OPC.R.2:M4 */
      OPCR2_M5CELLIN = copy( aLAYER_340 ); 
      OPCR2_M5CELLOUT = copy( aLAYER_341 ); 
      OPCR2_M5CELL = OPCR2_M5CELLIN and OPCR2_M5CELLOUT; 
      OPCR2_M5MARKER = M5I and RRULEGUIDELINE; 
      gLAYER_1066 = OPCR2_M5CELL or OPCR2_M5MARKER; 
      gLAYER_1065 = gLAYER_1066 not BLOCK; 
      OPCR2_M5 = gLAYER_1065 not EXCLUDERRULEGUIDELINE; 
      
      // OPC.R.2g is checked by RR:GL:S:OPC.R.2:M5
      rRR_GL_S_OPC_R_2_M5 @= { @ "RR:GL:S:OPC.R.2:M5 : Recommended edge length >= 1/2 minimum width for OPC friendly layout";
          sLAYER_1247 = length_edge( M5, < ( M5_W_1 / 2 ) ); 
          sLAYER_1247 inside_touching_edge OPCR2_M5; 
      } /* end of rule : RR:GL:S:OPC.R.2:M5 */
      OPCR2_M6CELLIN = copy( aLAYER_342 ); 
      OPCR2_M6CELLOUT = copy( aLAYER_343 ); 
      OPCR2_M6CELL = OPCR2_M6CELLIN and OPCR2_M6CELLOUT; 
      OPCR2_M6MARKER = M6I and RRULEGUIDELINE; 
      gLAYER_1068 = OPCR2_M6CELL or OPCR2_M6MARKER; 
      gLAYER_1067 = gLAYER_1068 not BLOCK; 
      OPCR2_M6 = gLAYER_1067 not EXCLUDERRULEGUIDELINE; 
      
      // OPC.R.2g is checked by RR:GL:S:OPC.R.2:M6
      rRR_GL_S_OPC_R_2_M6 @= { @ "RR:GL:S:OPC.R.2:M6 : Recommended edge length >= 1/2 minimum width for OPC friendly layout";
          sLAYER_1248 = length_edge( M6, < ( M6_W_1 / 2 ) ); 
          sLAYER_1248 inside_touching_edge OPCR2_M6; 
      } /* end of rule : RR:GL:S:OPC.R.2:M6 */
      OPCR2_M7CELLIN = copy( aLAYER_344 ); 
      OPCR2_M7CELLOUT = copy( aLAYER_345 ); 
      OPCR2_M7CELL = OPCR2_M7CELLIN and OPCR2_M7CELLOUT; 
      OPCR2_M7MARKER = M7I and RRULEGUIDELINE; 
      gLAYER_1070 = OPCR2_M7CELL or OPCR2_M7MARKER; 
      gLAYER_1069 = gLAYER_1070 not BLOCK; 
      OPCR2_M7 = gLAYER_1069 not EXCLUDERRULEGUIDELINE; 
      
      // OPC.R.2g is checked by RR:GL:S:OPC.R.2:M7
      rRR_GL_S_OPC_R_2_M7 @= { @ "RR:GL:S:OPC.R.2:M7 : Recommended edge length >= 1/2 minimum width for OPC friendly layout";
          sLAYER_1249 = length_edge( M7, < ( M7_W_1 / 2 ) ); 
          sLAYER_1249 inside_touching_edge OPCR2_M7; 
      } /* end of rule : RR:GL:S:OPC.R.2:M7 */
   #endif /* end of #ifdef _OPCR2_  */ 
   #ifdef _NWR1_ 
      NWR1_NWCELLIN = copy( aLAYER_346 ); 
      NWR1_NWCELLOUT = copy( aLAYER_347 ); 
      NWR1_NWCELL = NWR1_NWCELLIN and NWR1_NWCELLOUT; 
      NWR1_NWMARKER = NWI and RRULEGUIDELINE; 
      gLAYER_1073 = NWR1_NWCELL or NWR1_NWMARKER; 
      gLAYER_1072 = gLAYER_1073 not_inside SRAM_EXCLUDE; 
      gLAYER_1071 = gLAYER_1072 outside BLOCK; 
      NWR1_NW = gLAYER_1071 not EXCLUDERRULEGUIDELINE; 
      
      // NW.R.1g is checked by RR:GL:SP:NW.R.1
      rRR_GL_SP_NW_R_1 @= { @ "RR:GL:SP:NW.R.1 : Recommended not to use floating well";
          sLAYER_1253 = interacting( NPODI, COI ); 
          sLAYER_1252 = NWI outside sLAYER_1253; 
          sLAYER_1251 = sLAYER_1252 not LOGO; 
          sLAYER_1250 = sLAYER_1251 not_inside SRAM_EXCLUDE; 
          interacting( sLAYER_1250, NWR1_NW ); 
          sLAYER_1256 = interacting( PPODI, COI ); 
          sLAYER_1255 = PWELI outside sLAYER_1256; 
          sLAYER_1254 = sLAYER_1255 not_inside SRAM_EXCLUDE; 
          interacting( sLAYER_1254, NWR1_NW ); 
      } /* end of rule : RR:GL:SP:NW.R.1 */
   #endif /* end of #ifdef _NWR1_  */ 
   #ifdef _DNWR6_ 
      DNWR6_DNWCELLIN = copy( aLAYER_348 ); 
      DNWR6_DNWCELLOUT = copy( aLAYER_349 ); 
      DNWR6_DNWCELL = DNWR6_DNWCELLIN and DNWR6_DNWCELLOUT; 
      DNWR6_DNWMARKER = DNWI and RRULEGUIDELINE; 
      gLAYER_1076 = DNWR6_DNWCELL or DNWR6_DNWMARKER; 
      gLAYER_1075 = gLAYER_1076 not_inside SRAM_EXCLUDE; 
      gLAYER_1074 = gLAYER_1075 outside BLOCK; 
      DNWR6_DNW = gLAYER_1074 not EXCLUDERRULEGUIDELINE; 
      
      // DNW.R.6g is checked by RR:GL:SP:DNW.R.6
      rRR_GL_SP_DNW_R_6 @= { @ "RR:GL:SP:DNW.R.6 : Recommended not to use floating RW";
          sLAYER_1259 = interacting( PPODI, COI ); 
          sLAYER_1258 = RWI outside sLAYER_1259; 
          sLAYER_1257 = sLAYER_1258 not_inside SRAM_EXCLUDE; 
          interacting( sLAYER_1257, DNWR6_DNW ); 
      } /* end of rule : RR:GL:SP:DNW.R.6 */
   #endif /* end of #ifdef _DNWR6_  */ 
   #ifdef _NWRODR3_NWRSTIR3_ 
      NWRODR3_NWDMYCELLIN = copy( aLAYER_350 ); 
      NWRODR3_NWDMYCELLOUT = copy( aLAYER_351 ); 
      NWRODR3_NWDMYCELL = NWRODR3_NWDMYCELLIN and NWRODR3_NWDMYCELLOUT; 
      NWRODR3_NWDMYMARKER = NWDMY and RRULEGUIDELINE; 
      gLAYER_1079 = NWRODR3_NWDMYCELL or NWRODR3_NWDMYMARKER; 
      gLAYER_1078 = gLAYER_1079 not_inside SRAM_EXCLUDE; 
      gLAYER_1077 = gLAYER_1078 outside BLOCK; 
      NWRODR3_NWDMY = gLAYER_1077 not EXCLUDERRULEGUIDELINE; 
      
      // NWROD.R.3g is checked by RR:GL:P:NWROD.R.3__NWRSTI.R.3
      // NWRSTI.R.3g is checked by RR:GL:P:NWROD.R.3__NWRSTI.R.3
      rRR_GL_P_NWROD_R_3__NWRSTI_R_3 @= { @ "RR:GL:P:NWROD.R.3__NWRSTI.R.3 : Recommended to use rectangle shape resistor";
          sLAYER_1260 = interacting( NWDMY, NWRODR3_NWDMY ); 
          NWRES_BODY = RNWEL and sLAYER_1260; 
          not_rectangles( NWRES_BODY, orientation = ORTHOGONAL ); 
      } /* end of rule : RR:GL:P:NWROD.R.3__NWRSTI.R.3 */
   #endif /* end of #ifdef _NWRODR3_NWRSTIR3_  */ 
   #ifdef _COS6_ 
      COS6_ODCELLIN = copy( aLAYER_352 ); 
      COS6_ODCELLOUT = copy( aLAYER_353 ); 
      COS6_ODCELL = COS6_ODCELLIN and COS6_ODCELLOUT; 
      COS6_ODMARKER = ODI and RRULEGUIDELINE; 
      gLAYER_1082 = COS6_ODCELL or COS6_ODMARKER; 
      gLAYER_1081 = gLAYER_1082 not_inside SRAM_EXCLUDE; 
      gLAYER_1080 = gLAYER_1081 outside BLOCK; 
      COS6_OD = gLAYER_1080 not EXCLUDERRULEGUIDELINE; 
      
      // CO.S.6g is checked by RR:GL:P:CO.S.6
      rRR_GL_P_CO_S_6 @= { @ "RR:GL:P:CO.S.6 : Recommended to put contacts at both source side and butted well pickup.";
          sLAYER_1261 = BUTT_PSTP or BUTT_NSTP; 
          BUTT_SOUR = interacting( SD, sLAYER_1261 ); 
          sLAYER_1262 = interacting( BUTT_PSTP, COS6_OD ); 
          not_interacting( sLAYER_1262, COI ); 
          sLAYER_1263 = interacting( BUTT_NSTP, COS6_OD ); 
          not_interacting( sLAYER_1263, COI ); 
          sLAYER_1264 = interacting( BUTT_SOUR, COS6_OD ); 
          not_interacting( sLAYER_1264, COI ); 
      } /* end of rule : RR:GL:P:CO.S.6 */
   #endif /* end of #ifdef _COS6_  */ 
   #ifdef _COR5_ 
      COR5_COCELLIN = copy( aLAYER_354 ); 
      COR5_COCELLOUT = copy( aLAYER_355 ); 
      COR5_COCELL = COR5_COCELLIN and COR5_COCELLOUT; 
      COR5_COMARKER = COI and RRULEGUIDELINE; 
      gLAYER_1085 = COR5_COCELL or COR5_COMARKER; 
      gLAYER_1084 = gLAYER_1085 not_inside SRAM_EXCLUDE; 
      gLAYER_1083 = gLAYER_1084 outside BLOCK; 
      COR5_CO = gLAYER_1083 not EXCLUDERRULEGUIDELINE; 
      
      // CO.R.5g is checked by RR:GL:FDP:CO.R.5
      rRR_GL_FDP_CO_R_5 @= { @ "RR:GL:FDP:CO.R.5 : Recommended to use redundant CO to avoid high Rc whenever layout allows.";
          sLAYER_1266 = FPO1 and M1; 
          sLAYER_1265 = interacting( sLAYER_1266, COR5_CO, == 1 ); 
          sLAYER_1265 and COR5_CO; 
          sLAYER_1268 = SD and M1; 
          sLAYER_1267 = interacting( sLAYER_1268, COR5_CO, == 1 ); 
          sLAYER_1267 and COR5_CO; 
          sLAYER_1270 = DSTP and M1; 
          sLAYER_1269 = interacting( sLAYER_1270, COR5_CO, == 1 ); 
          sLAYER_1269 and COR5_CO; 
      } /* end of rule : RR:GL:FDP:CO.R.5 */
   #endif /* end of #ifdef _COR5_  */ 
   #ifdef _VIA1R9_ 
      VIA1R9_VIA1CELLIN = copy( aLAYER_356 ); 
      VIA1R9_VIA1CELLOUT = copy( aLAYER_357 ); 
      VIA1R9_VIA1CELL = VIA1R9_VIA1CELLIN and VIA1R9_VIA1CELLOUT; 
      VIA1R9_VIA1MARKER = VIA1I and RRULEGUIDELINE; 
      gLAYER_1088 = VIA1R9_VIA1CELL or VIA1R9_VIA1MARKER; 
      gLAYER_1087 = gLAYER_1088 not SRAM_EXCLUDE; 
      gLAYER_1086 = gLAYER_1087 outside BLOCK; 
      VIA1R9_VIA1 = gLAYER_1086 not EXCLUDERRULEGUIDELINE; 
      
      // VIA1.R.9g is checked by RR:GL:FDP:VIA1.R.9
      rRR_GL_FDP_VIA1_R_9 @= { @ "RR:GL:FDP:VIA1.R.9 : Recommended to use redundant VIAs to avoid high Rc whenever layout allows.";
          sLAYER_1272 = M1 and M2; 
          sLAYER_1271 = interacting( sLAYER_1272, VIA1R9_VIA1, == 1 ); 
          sLAYER_1271 and VIA1R9_VIA1; 
      } /* end of rule : RR:GL:FDP:VIA1.R.9 */
   #endif /* end of #ifdef _VIA1R9_  */ 
   #ifdef _VIA2R9_ 
      VIA2R9_VIA2CELLIN = copy( aLAYER_358 ); 
      VIA2R9_VIA2CELLOUT = copy( aLAYER_359 ); 
      VIA2R9_VIA2CELL = VIA2R9_VIA2CELLIN and VIA2R9_VIA2CELLOUT; 
      VIA2R9_VIA2MARKER = VIA2I and RRULEGUIDELINE; 
      gLAYER_1091 = VIA2R9_VIA2CELL or VIA2R9_VIA2MARKER; 
      gLAYER_1090 = gLAYER_1091 not SRAM_EXCLUDE; 
      gLAYER_1089 = gLAYER_1090 outside BLOCK; 
      VIA2R9_VIA2 = gLAYER_1089 not EXCLUDERRULEGUIDELINE; 
      
      // VIA2.R.9g is checked by RR:GL:FDP:VIA2.R.9
      rRR_GL_FDP_VIA2_R_9 @= { @ "RR:GL:FDP:VIA2.R.9 : Recommended to use redundant VIAs to avoid high Rc whenever layout allows.";
          sLAYER_1274 = M2 and M3; 
          sLAYER_1273 = interacting( sLAYER_1274, VIA2R9_VIA2, == 1 ); 
          sLAYER_1273 and VIA2R9_VIA2; 
      } /* end of rule : RR:GL:FDP:VIA2.R.9 */
   #endif /* end of #ifdef _VIA2R9_  */ 
   #ifdef _VIA3R9_ 
      VIA3R9_VIA3CELLIN = copy( aLAYER_360 ); 
      VIA3R9_VIA3CELLOUT = copy( aLAYER_361 ); 
      VIA3R9_VIA3CELL = VIA3R9_VIA3CELLIN and VIA3R9_VIA3CELLOUT; 
      VIA3R9_VIA3MARKER = VIA3I and RRULEGUIDELINE; 
      gLAYER_1093 = VIA3R9_VIA3CELL or VIA3R9_VIA3MARKER; 
      gLAYER_1092 = gLAYER_1093 not BLOCK; 
      VIA3R9_VIA3 = gLAYER_1092 not EXCLUDERRULEGUIDELINE; 
      
      // VIA3.R.9g is checked by RR:GL:FDP:VIA3.R.9
      rRR_GL_FDP_VIA3_R_9 @= { @ "RR:GL:FDP:VIA3.R.9 : Recommended to use redundant VIAs to avoid high Rc whenever layout allows.";
          sLAYER_1276 = M3 and M4; 
          sLAYER_1275 = interacting( sLAYER_1276, VIA3R9_VIA3, == 1 ); 
          sLAYER_1275 and VIA3R9_VIA3; 
      } /* end of rule : RR:GL:FDP:VIA3.R.9 */
   #endif /* end of #ifdef _VIA3R9_  */ 
   #ifdef _VIA4R9_ 
      VIA4R9_VIA4CELLIN = copy( aLAYER_362 ); 
      VIA4R9_VIA4CELLOUT = copy( aLAYER_363 ); 
      VIA4R9_VIA4CELL = VIA4R9_VIA4CELLIN and VIA4R9_VIA4CELLOUT; 
      VIA4R9_VIA4MARKER = VIA4I and RRULEGUIDELINE; 
      gLAYER_1095 = VIA4R9_VIA4CELL or VIA4R9_VIA4MARKER; 
      gLAYER_1094 = gLAYER_1095 not BLOCK; 
      VIA4R9_VIA4 = gLAYER_1094 not EXCLUDERRULEGUIDELINE; 
      
      // VIA4.R.9g is checked by RR:GL:FDP:VIA4.R.9
      rRR_GL_FDP_VIA4_R_9 @= { @ "RR:GL:FDP:VIA4.R.9 : Recommended to use redundant VIAs to avoid high Rc whenever layout allows.";
          sLAYER_1278 = M4 and M5; 
          sLAYER_1277 = interacting( sLAYER_1278, VIA4R9_VIA4, == 1 ); 
          sLAYER_1277 and VIA4R9_VIA4; 
      } /* end of rule : RR:GL:FDP:VIA4.R.9 */
   #endif /* end of #ifdef _VIA4R9_  */ 
   #ifdef _VIA5R9_ 
      VIA5R9_VIA5CELLIN = copy( aLAYER_364 ); 
      VIA5R9_VIA5CELLOUT = copy( aLAYER_365 ); 
      VIA5R9_VIA5CELL = VIA5R9_VIA5CELLIN and VIA5R9_VIA5CELLOUT; 
      VIA5R9_VIA5MARKER = VIA5I and RRULEGUIDELINE; 
      gLAYER_1097 = VIA5R9_VIA5CELL or VIA5R9_VIA5MARKER; 
      gLAYER_1096 = gLAYER_1097 not BLOCK; 
      VIA5R9_VIA5 = gLAYER_1096 not EXCLUDERRULEGUIDELINE; 
      
      // VIA5.R.9g is checked by RR:GL:FDP:VIA5.R.9
      rRR_GL_FDP_VIA5_R_9 @= { @ "RR:GL:FDP:VIA5.R.9 : Recommended to use redundant VIAs to avoid high Rc whenever layout allows.";
          sLAYER_1280 = M5 and M6; 
          sLAYER_1279 = interacting( sLAYER_1280, VIA5R9_VIA5, == 1 ); 
          sLAYER_1279 and VIA5R9_VIA5; 
      } /* end of rule : RR:GL:FDP:VIA5.R.9 */
   #endif /* end of #ifdef _VIA5R9_  */ 
   #ifdef _VIA6R9_ 
      VIA6R9_VIA6CELLIN = copy( aLAYER_366 ); 
      VIA6R9_VIA6CELLOUT = copy( aLAYER_367 ); 
      VIA6R9_VIA6CELL = VIA6R9_VIA6CELLIN and VIA6R9_VIA6CELLOUT; 
      VIA6R9_VIA6MARKER = VIA6I and RRULEGUIDELINE; 
      gLAYER_1099 = VIA6R9_VIA6CELL or VIA6R9_VIA6MARKER; 
      gLAYER_1098 = gLAYER_1099 not BLOCK; 
      VIA6R9_VIA6 = gLAYER_1098 not EXCLUDERRULEGUIDELINE; 
      
      // VIA6.R.9g is checked by RR:GL:FDP:VIA6.R.9
      rRR_GL_FDP_VIA6_R_9 @= { @ "RR:GL:FDP:VIA6.R.9 : Recommended to use redundant VIAs to avoid high Rc whenever layout allows.";
          sLAYER_1282 = M6 and M7; 
          sLAYER_1281 = interacting( sLAYER_1282, VIA6R9_VIA6, == 1 ); 
          sLAYER_1281 and VIA6R9_VIA6; 
      } /* end of rule : RR:GL:FDP:VIA6.R.9 */
   #endif /* end of #ifdef _VIA6R9_  */ 
   #ifdef _VIA7R5_ 
      #ifdef MIXED_SCHEME 
         VIA7R5_VIA7_OLDCELLIN = copy( aLAYER_368 ); 
         VIA7R5_VIA7_OLDCELLOUT = copy( aLAYER_369 ); 
         VIA7R5_VIA7_OLDCELL = VIA7R5_VIA7_OLDCELLIN and VIA7R5_VIA7_OLDCELLOUT; 
         VIA7R5_VIA7_OLDMARKER = VIA7_OLD and RRULEGUIDELINE; 
         gLAYER_1101 = VIA7R5_VIA7_OLDCELL or VIA7R5_VIA7_OLDMARKER; 
         gLAYER_1100 = gLAYER_1101 not BLOCK; 
         VIA7R5_VIA7_OLD = gLAYER_1100 not EXCLUDERRULEGUIDELINE; 
         VIA7R5_VIA7_NEWCELLIN = copy( aLAYER_370 ); 
         VIA7R5_VIA7_NEWCELLOUT = copy( aLAYER_371 ); 
         VIA7R5_VIA7_NEWCELL = VIA7R5_VIA7_NEWCELLIN and VIA7R5_VIA7_NEWCELLOUT; 
         VIA7R5_VIA7_NEWMARKER = VIA7_NEW and RRULEGUIDELINE; 
         gLAYER_1103 = VIA7R5_VIA7_NEWCELL or VIA7R5_VIA7_NEWMARKER; 
         gLAYER_1102 = gLAYER_1103 not BLOCK; 
         VIA7R5_VIA7_NEW = gLAYER_1102 not EXCLUDERRULEGUIDELINE; 
         VIA7R5_VIA7 = VIA7R5_VIA7_OLD or VIA7R5_VIA7_NEW; 
      #else /* the reverse of #ifdef MIXED_SCHEME  */ 
         VIA7R5_VIA7CELLIN = copy( aLAYER_372 ); 
         VIA7R5_VIA7CELLOUT = copy( aLAYER_373 ); 
         VIA7R5_VIA7CELL = VIA7R5_VIA7CELLIN and VIA7R5_VIA7CELLOUT; 
         VIA7R5_VIA7MARKER = VIA7_NEW and RRULEGUIDELINE; 
         gLAYER_1105 = VIA7R5_VIA7CELL or VIA7R5_VIA7MARKER; 
         gLAYER_1104 = gLAYER_1105 not BLOCK; 
         VIA7R5_VIA7 = gLAYER_1104 not EXCLUDERRULEGUIDELINE; 
      #endif /* end of #ifdef MIXED_SCHEME  */ 
      
      // VIA7.R.5g is checked by RR:GL:FDP:VIA7.R.5
      rRR_GL_FDP_VIA7_R_5 @= { @ "RR:GL:FDP:VIA7.R.5 : Recommended to use redundant VIAs to avoid high Rc whenever layout allows.";
          sLAYER_1284 = M7 and M8; 
          sLAYER_1283 = interacting( sLAYER_1284, VIA7R5_VIA7, == 1 ); 
          sLAYER_1283 and VIA7R5_VIA7; 
      } /* end of rule : RR:GL:FDP:VIA7.R.5 */
   #endif /* end of #ifdef _VIA7R5_  */ 
   #ifdef _VIA8R5_ 
      #ifdef MIXED_SCHEME 
         VIA8R5_VIA8_OLDCELLIN = copy( aLAYER_374 ); 
         VIA8R5_VIA8_OLDCELLOUT = copy( aLAYER_375 ); 
         VIA8R5_VIA8_OLDCELL = VIA8R5_VIA8_OLDCELLIN and VIA8R5_VIA8_OLDCELLOUT; 
         VIA8R5_VIA8_OLDMARKER = VIA8_OLD and RRULEGUIDELINE; 
         gLAYER_1107 = VIA8R5_VIA8_OLDCELL or VIA8R5_VIA8_OLDMARKER; 
         gLAYER_1106 = gLAYER_1107 not BLOCK; 
         VIA8R5_VIA8_OLD = gLAYER_1106 not EXCLUDERRULEGUIDELINE; 
         VIA8R5_VIA8_NEWCELLIN = copy( aLAYER_376 ); 
         VIA8R5_VIA8_NEWCELLOUT = copy( aLAYER_377 ); 
         VIA8R5_VIA8_NEWCELL = VIA8R5_VIA8_NEWCELLIN and VIA8R5_VIA8_NEWCELLOUT; 
         VIA8R5_VIA8_NEWMARKER = VIA8_NEW and RRULEGUIDELINE; 
         gLAYER_1109 = VIA8R5_VIA8_NEWCELL or VIA8R5_VIA8_NEWMARKER; 
         gLAYER_1108 = gLAYER_1109 not BLOCK; 
         VIA8R5_VIA8_NEW = gLAYER_1108 not EXCLUDERRULEGUIDELINE; 
         VIA8R5_VIA8 = VIA8R5_VIA8_OLD or VIA8R5_VIA8_NEW; 
      #else /* the reverse of #ifdef MIXED_SCHEME  */ 
         VIA8R5_VIA8CELLIN = copy( aLAYER_378 ); 
         VIA8R5_VIA8CELLOUT = copy( aLAYER_379 ); 
         VIA8R5_VIA8CELL = VIA8R5_VIA8CELLIN and VIA8R5_VIA8CELLOUT; 
         VIA8R5_VIA8MARKER = VIA8_NEW and RRULEGUIDELINE; 
         gLAYER_1111 = VIA8R5_VIA8CELL or VIA8R5_VIA8MARKER; 
         gLAYER_1110 = gLAYER_1111 not BLOCK; 
         VIA8R5_VIA8 = gLAYER_1110 not EXCLUDERRULEGUIDELINE; 
      #endif /* end of #ifdef MIXED_SCHEME  */ 
      
      // VIA8.R.5g is checked by RR:GL:FDP:VIA8.R.5
      rRR_GL_FDP_VIA8_R_5 @= { @ "RR:GL:FDP:VIA8.R.5 : Recommended to use redundant VIAs to avoid high Rc whenever layout allows.";
          sLAYER_1286 = M8 and M9; 
          sLAYER_1285 = interacting( sLAYER_1286, VIA8R5_VIA8, == 1 ); 
          sLAYER_1285 and VIA8R5_VIA8; 
      } /* end of rule : RR:GL:FDP:VIA8.R.5 */
   #endif /* end of #ifdef _VIA8R5_  */ 
   #ifdef _POS5m_ 
      POS5M_POCELLIN = copy( aLAYER_380 ); 
      POS5M_POCELLOUT = copy( aLAYER_381 ); 
      POS5M_POCELL = POS5M_POCELLIN and POS5M_POCELLOUT; 
      POS5M_POMARKER = POI and RRULEANALOG; 
      gLAYER_1114 = POS5M_POCELL or POS5M_POMARKER; 
      gLAYER_1113 = gLAYER_1114 not SRAM_EXCLUDE; 
      gLAYER_1112 = gLAYER_1113 outside BLOCK; 
      POS5M_PO = gLAYER_1112 not EXCLUDERRULEANALOG; 
      POS5M_GATEW = GATE_W coincident_inside_edge POS5M_PO; 
      gLAYER_1214 = extend_edge( POS5M_GATEW, start = OD_S_1, end = OD_S_1 ); 
      POS5M_GATEWEXP = edge_size( gLAYER_1214, inside = GRID ); 
      POS5M_GATEWEXE = POS5M_PO coincident_inside_edge POS5M_GATEWEXP; 
      rRR_AN_PO_S_5M @= { @ "RR:AN:PO.S.5m : Space to L-shape OD when PO and OD are in the same MOS  >= 0.20 um";
          external2( POS5M_GATEWEXE, ODI, < 0.2, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
      } /* end of rule : RR:AN:PO.S.5m */
   #endif /* end of #ifdef _POS5m_  */ 
   #ifdef _POS6m_ 
      POS6M_ODCELLIN = copy( aLAYER_382 ); 
      POS6M_ODCELLOUT = copy( aLAYER_383 ); 
      POS6M_ODCELL = POS6M_ODCELLIN and POS6M_ODCELLOUT; 
      POS6M_ODMARKER = ODI and RRULEANALOG; 
      gLAYER_1117 = POS6M_ODCELL or POS6M_ODMARKER; 
      gLAYER_1116 = gLAYER_1117 not SRAM_EXCLUDE; 
      gLAYER_1115 = gLAYER_1116 outside BLOCK; 
      POS6M_OD = gLAYER_1115 not EXCLUDERRULEANALOG; 
      POS6M_GATEL = GATE_L coincident_inside_edge POS6M_OD; 
      gLAYER_1215 = extend_edge( POS6M_GATEL, start = PO_S_1, end = PO_S_1 ); 
      POS6M_GATELEXP = edge_size( gLAYER_1215, inside = GRID ); 
      gLAYER_1118 = POS6M_OD coincident_inside_edge POS6M_GATELEXP; 
      POS6M_GATELEXE = gLAYER_1118 inside_touching_edge POS6M_GATEL; 
      rRR_AN_PO_S_6M @= { @ "RR:AN:PO.S.6m : L-shape PO Space to OD when PO and OD are in the same MOS  >= 0.10 um";
          external2( POS6M_GATELEXE, POI, < 0.1, extension = NONE, extension_look_past = POINT_TO_POINT, intersecting = {  }, intersection_angle = < 90, line_touch_shape = BOTH, look_thru = COINCIDENT, projection_filter = MUTUAL_NON_ORTHOGONAL, projection_mode = ASYMMETRIC, width = 0.002 ); 
      } /* end of rule : RR:AN:PO.S.6m */
   #endif /* end of #ifdef _POS6m_  */ 
   #ifdef _RES5m_ 
      RES5_POCELLIN = copy( aLAYER_384 ); 
      RES5_POCELLOUT = copy( aLAYER_385 ); 
      RES5_POCELL = RES5_POCELLIN and RES5_POCELLOUT; 
      RES5_POMARKER = POI and RRULEANALOG; 
      gLAYER_1121 = RES5_POCELL or RES5_POMARKER; 
      gLAYER_1120 = gLAYER_1121 not SRAM_EXCLUDE; 
      gLAYER_1119 = gLAYER_1120 outside BLOCK; 
      RES5_PO = gLAYER_1119 not EXCLUDERRULEANALOG; 
      RES5_ODCELLIN = copy( aLAYER_386 ); 
      RES5_ODCELLOUT = copy( aLAYER_387 ); 
      RES5_ODCELL = RES5_ODCELLIN and RES5_ODCELLOUT; 
      RES5_ODMARKER = ODI and RRULEANALOG; 
      gLAYER_1124 = RES5_ODCELL or RES5_ODMARKER; 
      gLAYER_1123 = gLAYER_1124 not SRAM_EXCLUDE; 
      gLAYER_1122 = gLAYER_1123 outside BLOCK; 
      RES5_OD = gLAYER_1122 not EXCLUDERRULEANALOG; 
      
      // RES.5.R is checked by RR:AN:RES.5m:OD and RR:AN:RES.5m:PO
      rRR_AN_RES_5M_OD @= { @ "RR:AN:RES.5m:OD : CO space to unsilicided OD resistor should be equal to 0.22um";
          sLAYER_1287 = interacting( RES5_OD, GATE ); 
          ODR_GATE = sLAYER_1287 and ODRES; 
          ODR_TRM = size_inside_wrapper( ODR_GATE, OD, distance = 0.22, increment = OD_S_1 ); 
          not_outside_touching( ODR_TRM, CO ); 
          sLAYER_1288 = not_interacting( RES5_OD, GATE ); 
          ODR_NOT_GATE = sLAYER_1288 and ODRES; 
          ODR_TER = RPO coincident_inside_edge ODR_NOT_GATE; 
          ODR_TER_EX = edge_size( ODR_TER, outside = 0.22 ); 
          not_outside_touching( ODR_TER_EX, CO ); 
      } /* end of rule : RR:AN:RES.5m:OD */
      rRR_AN_RES_5M_PO @= { @ "RR:AN:RES.5m:PO : CO space to unsilicided PO resistor should be equal to 0.22um";
          sLAYER_1289 = interacting( RES5_PO, GATE ); 
          POR_GATE = sLAYER_1289 and PORESG; 
          POR_TRM = size_inside_wrapper( POR_GATE, POLY, distance = 0.22, increment = PO_S_1 ); 
          not_outside_touching( POR_TRM, CO ); 
          sLAYER_1290 = not_interacting( RES5_PO, GATE ); 
          POR_NOT_GATE = sLAYER_1290 and PORESG; 
          POR_TER = RPO coincident_inside_edge POR_NOT_GATE; 
          POR_TER_EX = edge_size( POR_TER, outside = 0.22 ); 
          not_outside_touching( POR_TER_EX, CO ); 
      } /* end of rule : RR:AN:RES.5m:PO */
   #endif /* end of #ifdef _RES5m_  */ 
   #ifdef _BJTR2_ 
      
      // BJT.R.2.R is checked by RR:AN:BJT.R.2
      rRR_AN_BJT_R_2 @= { @ "RR:AN:BJT.R.2 : OD( Emitter size ) si 2x2, 5x5, 10x10";
          X = not_rectangles( EMOD, sides = { == 2.0, == 2.0 } ); 
          Y = not_rectangles( X, sides = { == 5.0, == 5.0 } ); 
          not_rectangles( Y, sides = { == 10.0, == 10.0 } ); 
      } /* end of rule : RR:AN:BJT.R.2 */
   #endif /* end of #ifdef _BJTR2_  */ 
   
   //FPAD.R.1m.RU is uncheckable
   #ifdef _ANR17_ 
      ANR17MG_POCELLIN = copy( aLAYER_388 ); 
      ANR17MG_POCELLOUT = copy( aLAYER_389 ); 
      ANR17MG_POCELL = ANR17MG_POCELLIN and ANR17MG_POCELLOUT; 
      ANR17MG_POMARKER = POI and RRULEANALOG; 
      gLAYER_1127 = ANR17MG_POCELL or ANR17MG_POMARKER; 
      gLAYER_1126 = gLAYER_1127 not SRAM_EXCLUDE; 
      gLAYER_1125 = gLAYER_1126 outside BLOCK; 
      ANR17MG_PO = gLAYER_1125 not EXCLUDERRULEANALOG; 
      ANR17MG_PORES = ANR17MG_PO and PORES; 
      
      // AN.R.17mg is checked by RR:AN:AN.R.17mg
      rRR_AN_AN_R_17MG @= { @ "RR:AN:AN.R.17mg : PO resistor on NW for better noise immunity; P+ PO resistor is recommended";
          ANR17MG_PORES not NWEL; 
          ANR17MG_PORES not PP; 
      } /* end of rule : RR:AN:AN.R.17mg */
   #endif /* end of #ifdef _ANR17_  */ 
   #ifdef _ANR20_ 
      ANR20MG_VARCELLIN = copy( aLAYER_390 ); 
      ANR20MG_VARCELLOUT = copy( aLAYER_391 ); 
      ANR20MG_VARCELL = ANR20MG_VARCELLIN and ANR20MG_VARCELLOUT; 
      ANR20MG_VARMARKER = VARI and RRULEANALOG; 
      gLAYER_1129 = ANR20MG_VARCELL or ANR20MG_VARMARKER; 
      gLAYER_1128 = gLAYER_1129 not BLOCK; 
      ANR20MG_VAR = gLAYER_1128 not EXCLUDERRULEANALOG; 
      ANR20MG_VAROD = ANR20MG_VAR and OD; 
      
      // AN.R.20mg is checked by RR:AN:AN.R.20mg
      rRR_AN_AN_R_20MG @= { @ "RR:AN:AN.R.20mg : Use OD2 MOS varactor is recommended.";
          ANR20MG_VAROD not OD2; 
      } /* end of rule : RR:AN:AN.R.20mg */
   #endif /* end of #ifdef _ANR20_  */ 
   #ifdef _ANR47_ 
      ANR47_POICELLIN = copy( aLAYER_392 ); 
      ANR47_POICELLOUT = copy( aLAYER_393 ); 
      ANR47_POICELL = ANR47_POICELLIN and ANR47_POICELLOUT; 
      ANR47_POIMARKER = POI and RRULEANALOG; 
      gLAYER_1132 = ANR47_POICELL or ANR47_POIMARKER; 
      gLAYER_1131 = gLAYER_1132 not SRAM_EXCLUDE; 
      gLAYER_1130 = gLAYER_1131 outside BLOCK; 
      ANR47_POI = gLAYER_1130 not EXCLUDERRULEANALOG; 
      gLAYER_1133 = interacting( ANR47_POI, OD ); 
      ANR47_POLY_PAIR_CHECK = interacting( gLAYER_1133, MATCHINGI ); 
      ANR47_POLY_PAIR_CHECK_G_M2 = ANR47_POLY_PAIR_CHECK inside M2; 
      ANR47_POLY_PAIR_CHECK_B_M2 = cutting( ANR47_POLY_PAIR_CHECK, M2 ); 
      ANR47_POLY_PAIR_CHECK_O_M2 = ANR47_POLY_PAIR_CHECK outside M2; 
      
      //AN.R.47m.R is checked by RR:AN:AN.R.47:M2
      rRR_AN_AN_R_47_M2 @= { @ "RR:AN:AN.R.47:M2 : In MATCHING layer, one of differential pair covered by M2 layer but without all fully covered is not allowed";
          interacting( MATCHINGI, ANR47_POLY_PAIR_CHECK_B_M2 ); 
          sLAYER_1291 = interacting( MATCHINGI, ANR47_POLY_PAIR_CHECK_G_M2 ); 
          interacting( sLAYER_1291, ANR47_POLY_PAIR_CHECK_O_M2 ); 
      } /* end of rule : RR:AN:AN.R.47:M2 */
      ANR47_POLY_PAIR_CHECK_G_M3 = ANR47_POLY_PAIR_CHECK inside M3; 
      ANR47_POLY_PAIR_CHECK_B_M3 = cutting( ANR47_POLY_PAIR_CHECK, M3 ); 
      ANR47_POLY_PAIR_CHECK_O_M3 = ANR47_POLY_PAIR_CHECK outside M3; 
      
      //AN.R.47m.R is checked by RR:AN:AN.R.47:M3
      rRR_AN_AN_R_47_M3 @= { @ "RR:AN:AN.R.47:M3 : In MATCHING layer, one of differential pair covered by M3 layer but without all fully covered is not allowed";
          interacting( MATCHINGI, ANR47_POLY_PAIR_CHECK_B_M3 ); 
          sLAYER_1292 = interacting( MATCHINGI, ANR47_POLY_PAIR_CHECK_G_M3 ); 
          interacting( sLAYER_1292, ANR47_POLY_PAIR_CHECK_O_M3 ); 
      } /* end of rule : RR:AN:AN.R.47:M3 */
      ANR47_POLY_PAIR_CHECK_G_M4 = ANR47_POLY_PAIR_CHECK inside M4; 
      ANR47_POLY_PAIR_CHECK_B_M4 = cutting( ANR47_POLY_PAIR_CHECK, M4 ); 
      ANR47_POLY_PAIR_CHECK_O_M4 = ANR47_POLY_PAIR_CHECK outside M4; 
      
      //AN.R.47m.R is checked by RR:AN:AN.R.47:M4
      rRR_AN_AN_R_47_M4 @= { @ "RR:AN:AN.R.47:M4 : In MATCHING layer, one of differential pair covered by M4 layer but without all fully covered is not allowed";
          interacting( MATCHINGI, ANR47_POLY_PAIR_CHECK_B_M4 ); 
          sLAYER_1293 = interacting( MATCHINGI, ANR47_POLY_PAIR_CHECK_G_M4 ); 
          interacting( sLAYER_1293, ANR47_POLY_PAIR_CHECK_O_M4 ); 
      } /* end of rule : RR:AN:AN.R.47:M4 */
      ANR47_POLY_PAIR_CHECK_G_M5 = ANR47_POLY_PAIR_CHECK inside M5; 
      ANR47_POLY_PAIR_CHECK_B_M5 = cutting( ANR47_POLY_PAIR_CHECK, M5 ); 
      ANR47_POLY_PAIR_CHECK_O_M5 = ANR47_POLY_PAIR_CHECK outside M5; 
      
      //AN.R.47m.R is checked by RR:AN:AN.R.47:M5
      rRR_AN_AN_R_47_M5 @= { @ "RR:AN:AN.R.47:M5 : In MATCHING layer, one of differential pair covered by M5 layer but without all fully covered is not allowed";
          interacting( MATCHINGI, ANR47_POLY_PAIR_CHECK_B_M5 ); 
          sLAYER_1294 = interacting( MATCHINGI, ANR47_POLY_PAIR_CHECK_G_M5 ); 
          interacting( sLAYER_1294, ANR47_POLY_PAIR_CHECK_O_M5 ); 
      } /* end of rule : RR:AN:AN.R.47:M5 */
      ANR47_POLY_PAIR_CHECK_G_M6 = ANR47_POLY_PAIR_CHECK inside M6; 
      ANR47_POLY_PAIR_CHECK_B_M6 = cutting( ANR47_POLY_PAIR_CHECK, M6 ); 
      ANR47_POLY_PAIR_CHECK_O_M6 = ANR47_POLY_PAIR_CHECK outside M6; 
      
      //AN.R.47m.R is checked by RR:AN:AN.R.47:M6
      rRR_AN_AN_R_47_M6 @= { @ "RR:AN:AN.R.47:M6 : In MATCHING layer, one of differential pair covered by M6 layer but without all fully covered is not allowed";
          interacting( MATCHINGI, ANR47_POLY_PAIR_CHECK_B_M6 ); 
          sLAYER_1295 = interacting( MATCHINGI, ANR47_POLY_PAIR_CHECK_G_M6 ); 
          interacting( sLAYER_1295, ANR47_POLY_PAIR_CHECK_O_M6 ); 
      } /* end of rule : RR:AN:AN.R.47:M6 */
      ANR47_POLY_PAIR_CHECK_G_M7 = ANR47_POLY_PAIR_CHECK inside M7; 
      ANR47_POLY_PAIR_CHECK_B_M7 = cutting( ANR47_POLY_PAIR_CHECK, M7 ); 
      ANR47_POLY_PAIR_CHECK_O_M7 = ANR47_POLY_PAIR_CHECK outside M7; 
      
      //AN.R.47m.R is checked by RR:AN:AN.R.47:M7
      rRR_AN_AN_R_47_M7 @= { @ "RR:AN:AN.R.47:M7 : In MATCHING layer, one of differential pair covered by M7 layer but without all fully covered is not allowed";
          interacting( MATCHINGI, ANR47_POLY_PAIR_CHECK_B_M7 ); 
          sLAYER_1296 = interacting( MATCHINGI, ANR47_POLY_PAIR_CHECK_G_M7 ); 
          interacting( sLAYER_1296, ANR47_POLY_PAIR_CHECK_O_M7 ); 
      } /* end of rule : RR:AN:AN.R.47:M7 */
      ANR47_POLY_PAIR_CHECK_G_M8 = ANR47_POLY_PAIR_CHECK inside M8; 
      ANR47_POLY_PAIR_CHECK_B_M8 = cutting( ANR47_POLY_PAIR_CHECK, M8 ); 
      ANR47_POLY_PAIR_CHECK_O_M8 = ANR47_POLY_PAIR_CHECK outside M8; 
      
      //AN.R.47m.R is checked by RR:AN:AN.R.47:M8
      rRR_AN_AN_R_47_M8 @= { @ "RR:AN:AN.R.47:M8 : In MATCHING layer, one of differential pair covered by M8 layer but without all fully covered is not allowed";
          interacting( MATCHINGI, ANR47_POLY_PAIR_CHECK_B_M8 ); 
          sLAYER_1297 = interacting( MATCHINGI, ANR47_POLY_PAIR_CHECK_G_M8 ); 
          interacting( sLAYER_1297, ANR47_POLY_PAIR_CHECK_O_M8 ); 
      } /* end of rule : RR:AN:AN.R.47:M8 */
      ANR47_POLY_PAIR_CHECK_G_M9 = ANR47_POLY_PAIR_CHECK inside M9; 
      ANR47_POLY_PAIR_CHECK_B_M9 = cutting( ANR47_POLY_PAIR_CHECK, M9 ); 
      ANR47_POLY_PAIR_CHECK_O_M9 = ANR47_POLY_PAIR_CHECK outside M9; 
      
      //AN.R.47m.R is checked by RR:AN:AN.R.47:M9
      rRR_AN_AN_R_47_M9 @= { @ "RR:AN:AN.R.47:M9 : In MATCHING layer, one of differential pair covered by M9 layer but without all fully covered is not allowed";
          interacting( MATCHINGI, ANR47_POLY_PAIR_CHECK_B_M9 ); 
          sLAYER_1298 = interacting( MATCHINGI, ANR47_POLY_PAIR_CHECK_G_M9 ); 
          interacting( sLAYER_1298, ANR47_POLY_PAIR_CHECK_O_M9 ); 
      } /* end of rule : RR:AN:AN.R.47:M9 */
   #endif /* end of #ifdef _ANR47_  */ 
#endif /* end of #ifdef DFM  */ 
rDRM_R_1 @= { @ "DRM.R.1 : DRM.R.1 is a warining message to remind the users to check the related DRMs. Please refer to DRM.R.1 in the DRM for the details.";
    copy( CHIPX ); 
} /* end of rule : DRM.R.1 */


#pragma ICV patch_insert patch_checks

